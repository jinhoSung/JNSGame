<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ììœ¨ì£¼í–‰ ë ˆì´ì‹± (Shop & Firebase)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // ğŸŒŸ ìˆ˜ì •: getDocì„ firebase-firestore.jsì—ì„œ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •
        import { getFirestore, doc, setDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        
        // setLogLevel('Debug'); // ë””ë²„ê¹… ì‹œ ì£¼ì„ í•´ì œ

        // --- Firebase Globals Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        if (firebaseConfig) {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);

            // Export Firestore functions to window for use in the Babel script
            window.firebaseApp = app;
            window.firebaseAuth = auth;
            window.firestoreDB = db;
            window.doc = doc;      
            window.setDoc = setDoc;    
            window.onSnapshot = onSnapshot;  
            window.getDoc = getDoc; // getDocì€ ì´ì œ window.getDocìœ¼ë¡œ ë‚´ë³´ë‚´ì§‘ë‹ˆë‹¤.
            
            window.firebaseInitialized = false;

            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth failed:", error);
                    }
                }
                if (user && !window.firebaseInitialized) {
                    window.firebaseInitialized = true;
                    // Trigger custom event to notify React app that Firebase is ready
                    window.dispatchEvent(new CustomEvent('firebase-ready'));
                }
            });
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #f1f5f9; font-family: sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        /* ì»¤ìŠ¤í…€ Tailwind í´ë˜ìŠ¤: w-[40%]ë¥¼ ì •í™•íˆ ë§ì¶¥ë‹ˆë‹¤. */
        .lg-w-40-percent { width: 40%; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = window.React; 

        // --- Icon Components (Inline SVG) ---
        const Play = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>);
        const Pause = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>);
        const RotateCcw = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>);
        const Plus = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>);
        const Trash2 = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>);
        const Cpu = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x="9" y="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>);
        const Activity = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>);
        const Trophy = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 21h8m-4-9v9m-8-2.5a6 6 0 0 1 12 0v2.5"></path><path d="M16 3h-8"></path><path d="M7 3v7a5 5 0 0 0 10 0V3"></path><path d="M19 6h2a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-2"></path><path d="M5 6H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h2"></path></svg>);
        const Hash = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>);
        const Radar = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z"></path><path d="M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path><line x1="12" y1="2" x2="12" y2="4"></line><line x1="12" y1="20" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="6.34" y2="6.34"></line><line x1="17.66" y1="17.66" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="4" y2="12"></line><line x1="20" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="6.34" y2="17.66"></line><line x1="17.66" y1="6.34" x2="19.07" y2="4.93"></line></svg>);
        const Timer = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="10" y1="2" x2="14" y2="2"></line><line x1="12" y1="14" x2="15" y2="11"></line><circle cx="12" cy="14" r="8"></circle></svg>);
        const Flag = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>);
        const MapIcon = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>);
        const Volume2 = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>);
        const VolumeX = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>);
        const ShoppingCart = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>);
        const Wrench = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-3.76 3.76a1 1 0 0 0-1.4 0l-1.6-1.6a1 1 0 0 0 0-1.4l3.77-3.77a6 6 0 0 1 7.94-7.94l-3.76-3.76z"></path><path d="M21.5 2L17 6.5"></path><path d="M19.4 12.6l-2.6 2.6"></path><path d="M12.6 19.4l-2.6 2.6"></path><path d="M16 16l-1.4 1.4"></path><path d="M14 10l-1.4 1.4"></path><path d="M6 6L2 2"></path></svg>);
        const DollarSign = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>);
        const Save = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>);
        const Folder = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 8.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2z"></path></svg>);
        const Car = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 17h2a1 1 0 0 0 0-2h-2"></path><path d="M5 17H3a1 1 0 0 1 0-2h2"></path><path d="M21 14V8a2 2 0 0 0-2-2h-1c-1 0-4 1-4 1s-3-1-4-1H5a2 2 0 0 0-2 2v6"></path><path d="M8 10h.01"></path><path d="M16 10h.01"></path><path d="M7 21h10"></path><path d="M12 14v7"></path><path d="M10 14h4"></path></svg>);


        // --- Constants & Config ---
        const TRACK_WIDTH = 800;
        const TRACK_HEIGHT = 600;
        const FPS = 60;
        const CAR_SIZE = { width: 24, height: 14 };
        const MAP_SCALE = 1.0; 
        const MAX_SKID_MARKS = 50; 
        const TOTAL_LAPS = 3;

        // Detection Radius Config
        const CHECKPOINT_RADIUS_NORMAL = 120; 

        // Track Aesthetics
        const TRACK_AESTHETICS = {
            border: 90, 
            curb: 80,   
            asphalt: 70 
        };

        // ğŸŒŸ ì§€í˜•ë³„ ìƒ‰ìƒ ë° ë¬¼ë¦¬ íŠ¹ì„± ì •ì˜ (Ice, Gravel, Water)
        const TERRAIN_PROPERTIES = {
            asphalt: { trackColor: '#334155', groundColor: '#4ade80', frictionFactor: 1.0, turnFactor: 1.0, skidColor: 'rgba(20, 20, 20, 0.3)' },
            ice: { trackColor: '#80cedd', groundColor: '#f8fafc', frictionFactor: 0.3, turnFactor: 1.0, skidColor: 'rgba(173, 216, 230, 0.6)' }, // ë§¤ìš° ë¯¸ë„ëŸ¬ì›€
            gravel: { trackColor: '#8b5e3c', groundColor: '#b4a595', frictionFactor: 0.85, turnFactor: 0.7, skidColor: 'rgba(139, 69, 19, 0.6)' }, // ì¡°í–¥ ì–´ë ¤ì›€, ë§ˆì°° ê°ì†Œ
            water: { trackColor: '#1e3a8a', groundColor: '#3b82f6', frictionFactor: 0.6, turnFactor: 0.8, skidColor: 'rgba(0, 191, 255, 0.6)' } // ê°ì† ë° ì¡°í–¥ ì–´ë ¤ì›€
        };

        const SENSOR_LABELS = {
            0: 'ì¢Œì¸¡ ì„¼ì„œ', 1: 'ì „ë°© ì¢Œì¸¡', 2: 'ì „ë°© ì„¼ì„œ', 3: 'ì „ë°© ìš°ì¸¡', 4: 'ìš°ì¸¡ ì„¼ì„œ'
        };

        const OPERATOR_OPTIONS = [
            { value: '<', label: 'ì‘ë‹¤ë©´ (<)' }, { value: '>', label: 'í¬ë‹¤ë©´ (>)' }, 
            { value: '<=', label: 'ê°™ê±°ë‚˜ ì‘ë‹¤ë©´ (<=)' }, { value: '>=', label: 'ê°™ê±°ë‚˜ í¬ë‹¤ë©´ (>=)' }, 
            { value: '==', label: 'ê°™ë‹¤ë©´ (==)' }, { value: '!=', label: 'ê°™ì§€ ì•Šë‹¤ë©´ (!=)' },
        ];
        
        const FLOW_OPTIONS = [
            { value: 'IF', label: 'ë§Œì•½ (IF)', color: 'border-blue-500' },
            { value: 'ELSE_IF', label: 'ì•„ë‹ˆë©´ ë§Œì•½ (ELSE IF)', color: 'border-indigo-500' },
            { value: 'ELSE', label: 'ì•„ë‹ˆë©´ (ELSE)', color: 'border-purple-500' },
        ];

        // ğŸŒŸ ê¸°ë³¸ ë¡œì§ ë¸”ë¡ (ì‚¬ìš©ì ì´ˆê¸° ë¡œì§)
        const INITIAL_BLOCKS = [
            { id: 1, flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 80, action: 'BRAKE_100' },
            { id: 2, flowType: 'ELSE_IF', sensor: 0, operator: '>', valueType: 'sensor', value: 4, action: 'RIGHT' },
            { id: 3, flowType: 'ELSE_IF', sensor: 4, operator: '>', valueType: 'sensor', value: 0, action: 'LEFT' },
            { id: 4, flowType: 'ELSE', sensor: 2, operator: '>', valueType: 'number', value: 0, action: 'ACCEL_100' },
        ];

        // --- ğŸŒŸ ìºë¦­í„°/ì°¨ëŸ‰ íƒ€ì… ì •ì˜ ---
        const VEHICLE_TYPES = [
            { id: 'car', name: 'ììœ¨ì£¼í–‰ ìë™ì°¨', emoji: 'ğŸš—', trailType: 'skid' },
            { id: 'dragon', name: 'ë¶ˆ ë¿œëŠ” ë“œë˜ê³¤', emoji: 'ğŸ‰', trailType: 'dust' },
            { id: 'horse', name: 'ê²½ì£¼ë§ˆ', emoji: 'ğŸ', trailType: 'dust' },
            { id: 'rocket', name: 'ë¡œì¼“ ì°¨ëŸ‰', emoji: 'ğŸš€', trailType: 'skid' },
            { id: 'ufo', name: 'ë¯¸í™•ì¸ ë¹„í–‰ë¬¼ì²´', emoji: 'ğŸ›¸', trailType: 'none' }, 
        ];


        // --- íŒŒì¸  ë° ì°¨ëŸ‰ ë°ì´í„° (êµ¬ë§¤ ì‹œìŠ¤í…œ) ---
        const PART_TYPES = [
            { id: 'engine', name: 'ì—”ì§„', unit: 'ê°€ì†ë ¥ (Accel)' },
            { id: 'gearbox', name: 'ë³€ì†ê¸°', unit: 'ìµœê³ ì†ë„ (Max Speed)' },
            { id: 'tire', name: 'íƒ€ì´ì–´', unit: 'ë§ˆì°°ë ¥ (Friction)' },
            { id: 'steering', name: 'ìŠ¤í‹°ì–´ë§', unit: 'ì¡°í–¥ ì†ë„ (Turn Speed)' },
            { id: 'downforce', name: 'ë‹¤ìš´í¬ìŠ¤ ìœ™', unit: 'ì ‘ì§€ë ¥ (Grip)' },
            { id: 'sensor', name: 'ì„¼ì„œ ëª¨ë“ˆ', unit: 'ì„¼ì„œ ë²”ìœ„ (Range)' },
        ];
        
        // ğŸŒŸ í‹°ì–´ í™•ì¥: 0ë¶€í„° 5ê¹Œì§€ ì´ 6ë‹¨ê³„. ì¦ê°€í­ ê°ì†Œ.
        const PART_STATS = {
            // Tier 0 (Base stats derived from C01)
            '0': { 
                acceleration: 0.70, maxSpeedMod: 9.0, friction: 0.930, turnSpeed: 0.080, gripFactor: 0.050, sensorRange: 150
            },
            // Tier 1
            '1': {
                acceleration: 0.78, maxSpeedMod: 10.0, friction: 0.935, turnSpeed: 0.090, gripFactor: 0.070, sensorRange: 175, price: 1000
            },
            // Tier 2
            '2': {
                acceleration: 0.86, maxSpeedMod: 11.0, friction: 0.940, turnSpeed: 0.100, gripFactor: 0.090, sensorRange: 200, price: 2000
            },
            // Tier 3
            '3': {
                acceleration: 0.95, maxSpeedMod: 12.5, friction: 0.945, turnSpeed: 0.115, gripFactor: 0.120, sensorRange: 230, price: 3500
            },
            // Tier 4
            '4': {
                acceleration: 1.05, maxSpeedMod: 14.0, friction: 0.950, turnSpeed: 0.130, gripFactor: 0.150, sensorRange: 270, price: 5500
            },
            // Tier 5 (MAX TIER)
            '5': {
                acceleration: 1.20, maxSpeedMod: 16.0, friction: 0.955, turnSpeed: 0.150, gripFactor: 0.200, sensorRange: 320, price: 8000
            }
        };

        const CAR_CHASSIS = [
            { id: 'C01', name: 'ê¸°ë³¸ ëª¨ë¸ (Blue)', price: 0, color: '#3b82f6', baseAccel: 0.7, baseGrip: 0.05, maxSpeedBonus: 0 },
            { id: 'C02', name: 'ìŠ¤í¬íŠ¸ ê²½ëŸ‰ (Red)', price: 10000, color: '#ef4444', baseAccel: 0.8, baseGrip: 0.08, maxSpeedBonus: 1 },
            { id: 'C03', name: 'í•˜ì´ ê·¸ë¦½ (Green)', price: 25000, color: '#10b981', baseAccel: 0.75, baseGrip: 0.12, maxSpeedBonus: 0 },
        ];

        // --- ğŸŒŸ íŠ¸ë™ ë ˆì´ì•„ì›ƒ ì¬ì„¤ê³„ (30ê°œ, ì§€í˜• íƒ€ì… í†µí•© ë° ì½˜ì…‰íŠ¸ ê°•í™”) ---
        const TRACK_LAYOUTS = [
            // ì´ˆê¸‰ (1-10) - ì•„ìŠ¤íŒ”íŠ¸ ê¸°ë³¸
            { id: 'simple_square', name: '1. ì‹¬í”Œ ìŠ¤í€˜ì–´ (ì…ë¬¸)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'oval', name: '2. ìŠ¤í”¼ë“œ ì˜¤ë²Œ (ì…ë¬¸)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 300 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 50, y: 300 }, { x: 100, y: 50 }], terrainType: 'asphalt' },
            { id: 'smooth_curve', name: '3. ìŠ¤ë¬´ìŠ¤ ì½”ë„ˆ (ì´ˆê¸‰)', points: [{ x: 400, y: 50 }, { x: 700, y: 100 }, { x: 750, y: 300 }, { x: 700, y: 500 }, { x: 400, y: 550 }, { x: 100, y: 500 }, { x: 50, y: 300 }, { x: 100, y: 100 }], terrainType: 'asphalt' },
            { id: 'mini_technical', name: '4. ë¯¸ë‹ˆ í…Œí¬ë‹ˆì»¬ (ì´ˆê¸‰)', points: [{ x: 350, y: 50 }, { x: 500, y: 50 }, { x: 700, y: 100 }, { x: 750, y: 200 }, { x: 700, y: 400 }, { x: 500, y: 500 }, { x: 300, y: 450 }, { x: 50, y: 300 }, { x: 100, y: 100 }, { x: 200, y: 50 }], terrainType: 'asphalt' },
            { id: 'long_straight', name: '5. ë¡± ìŠ¤íŠ¸ë ˆì´íŠ¸ (ì´ˆê¸‰)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'u_turn_basic', name: '6. ìœ í„´ ê¸°ë³¸ (ì´ˆê¸‰)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 300 }, { x: 500, y: 550 }, { x: 300, y: 550 }, { x: 100, y: 300 }, { x: 100, y: 50 }], terrainType: 'asphalt' },
            { id: 'pentagon', name: '7. íœíƒ€ê³¤ ì±Œë¦°ì§€ (ì¤‘ê¸‰)', points: [{ x: 400, y: 50 }, { x: 600, y: 80 }, { x: 750, y: 300 }, { x: 500, y: 550 }, { x: 150, y: 520 }, { x: 50, y: 300 }, { x: 200, y: 80 }], terrainType: 'asphalt' },
            { id: 'hairpin_mix', name: '8. í—¤ì–´í•€ ë¯¹ìŠ¤ (ì¤‘ê¸‰)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 350 }, { x: 600, y: 550 }, { x: 400, y: 400 }, { x: 200, y: 550 }, { x: 50, y: 350 }, { x: 50, y: 150 }], terrainType: 'asphalt' },
            { id: 's_and_straights', name: '9. Sì ë° ì§ì„  (ì¤‘ê¸‰)', points: [{ x: 400, y: 50 }, { x: 750, y: 100 }, { x: 550, y: 250 }, { x: 750, y: 400 }, { x: 400, y: 550 }, { x: 50, y: 400 }, { x: 250, y: 250 }, { x: 50, y: 100 }], terrainType: 'asphalt' },
            { id: 'wide_curve_long', name: '10. ì™€ì´ë“œ ì»¤ë¸Œ ë¡± (ì¤‘ê¸‰)', points: [{ x: 400, y: 50 }, { x: 750, y: 100 }, { x: 700, y: 400 }, { x: 400, y: 550 }, { x: 100, y: 400 }, { x: 50, y: 100 }], terrainType: 'asphalt' },
            
            // ì¤‘ìƒê¸‰ (11-15) - ì§€í˜• ë„ì… (Ice, Gravel)
            { id: 'ice_zigzag', name: '11. ì•„ì´ìŠ¤ ì§€ê·¸ì¬ê·¸ (ì–¼ìŒ)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 250 }, { x: 250, y: 350 }, { x: 700, y: 450 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 100, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_reverse', name: '12. ê±°ì¹œ í…Œí¬ë‹ˆì»¬ (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 600, y: 150 }, { x: 750, y: 300 }, { x: 600, y: 450 }, { x: 400, y: 550 }, { x: 200, y: 450 }, { x: 50, y: 300 }, { x: 200, y: 150 }], terrainType: 'gravel' },
            { id: 'water_coastline', name: '13. ìŠµì§€ í•´ì•ˆì„  (ë¬¼)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 700, y: 300 }, { x: 750, y: 500 }, { x: 500, y: 550 }, { x: 50, y: 500 }, { x: 50, y: 300 }, { x: 100, y: 100 }], terrainType: 'water' },
            { id: 'ice_spiral', name: '14. Cì ì•„ì´ìŠ¤ ìŠ¤íŒŒì´ëŸ´ (ì–¼ìŒ)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 450 }, { x: 400, y: 550 }, { x: 100, y: 450 }, { x: 100, y: 100 }, { x: 250, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_long_s', name: '15. ë¡± S ì»¤ë¸Œ (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 750, y: 150 }, { x: 500, y: 250 }, { x: 750, y: 450 }, { x: 400, y: 550 }, { x: 50, y: 450 }, { x: 300, y: 250 }, { x: 50, y: 150 }], terrainType: 'gravel' },
            
            // ìƒê¸‰ (16-25) - ê¸¸ì´ì™€ ë³µì¡ì„± ì¦ê°€
            { id: 'water_slalom', name: '16. ì›Œí„° ìŠ¬ë¼ë¡¬ (ë¬¼)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 700, y: 200 }, { x: 750, y: 350 }, { x: 600, y: 500 }, { x: 400, y: 550 }, { x: 200, y: 500 }, { x: 50, y: 350 }, { x: 100, y: 200 }, { x: 50, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_grand', name: '17. ê·¸ëœë“œ íˆ¬ì–´ (ì•„ìŠ¤íŒ”íŠ¸)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 200 }, { x: 650, y: 300 }, { x: 750, y: 450 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 300 }, { x: 50, y: 200 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'ice_oval_ext', name: '18. ìµìŠ¤í…ë””ë“œ ì˜¤ë²Œ (ì–¼ìŒ)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 300 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 50, y: 300 }, { x: 50, y: 50 }, { x: 250, y: 50 }], terrainType: 'ice' },
            { id: 'gravel_triple', name: '19. íŠ¸ë¦¬í”Œ ì»¤ë¸Œ (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 750, y: 150 }, { x: 600, y: 300 }, { x: 750, y: 450 }, { x: 400, y: 550 }, { x: 50, y: 450 }, { x: 200, y: 300 }, { x: 50, y: 150 }], terrainType: 'gravel' },
            { id: 'water_wave', name: '20. ì›¨ì´ë¸Œ íŠ¸ë™ (ë¬¼)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 650, y: 200 }, { x: 750, y: 350 }, { x: 600, y: 500 }, { x: 200, y: 550 }, { x: 150, y: 400 }, { x: 200, y: 200 }, { x: 50, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_snake', name: '21. ìŠ¤ë„¤ì´í¬ ì¤‘í˜• (ì•„ìŠ¤íŒ”íŠ¸)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 250 }, { x: 600, y: 400 }, { x: 750, y: 550 }, { x: 250, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 250 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'ice_complex', name: '22. ì•„ì´ìŠ¤ í”¼ê²¨ (ì–¼ìŒ)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 250 }, { x: 500, y: 350 }, { x: 700, y: 450 }, { x: 500, y: 550 }, { x: 100, y: 500 }, { x: 300, y: 400 }, { x: 100, y: 250 }, { x: 300, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_tri', name: '23. ì‚¼ê° ì„œí‚· (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 750, y: 250 }, { x: 500, y: 550 }, { x: 50, y: 250 }, { x: 250, y: 150 }], terrainType: 'gravel' },
            { id: 'water_coffin', name: '24. ì½”í•€ ë ˆì´ìŠ¤ (ë¬¼)', points: [{ x: 400, y: 50 }, { x: 600, y: 50 }, { x: 750, y: 300 }, { x: 600, y: 550 }, { x: 200, y: 550 }, { x: 50, y: 300 }, { x: 200, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_spiral', name: '25. ìŠ¤íŒŒì´ëŸ´ ì•„ì›ƒ (ì•„ìŠ¤íŒ”íŠ¸)', points: [{ x: 400, y: 50 }, { x: 500, y: 100 }, { x: 700, y: 150 }, { x: 750, y: 300 }, { x: 500, y: 450 }, { x: 200, y: 550 }, { x: 50, y: 300 }, { x: 250, y: 150 }], terrainType: 'asphalt' },
            
            // ìµœìƒê¸‰ (26-30) - ê·¹í•œì˜ ë‚œì´ë„
            { id: 'ice_mega', name: '26. ì•„ì´ìŠ¤ ë©”ê°€ ì±Œë¦°ì§€ (ì–¼ìŒ)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 650, y: 200 }, { x: 750, y: 300 }, { x: 650, y: 400 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 300 }, { x: 50, y: 200 }, { x: 150, y: 100 }, { x: 400, y: 250 }], terrainType: 'ice' },
            { id: 'gravel_long_tech', name: '27. ë¡± í…Œí¬ë‹ˆì»¬ (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 150 }, { x: 700, y: 300 }, { x: 750, y: 450 }, { x: 500, y: 550 }, { x: 250, y: 500 }, { x: 50, y: 400 }, { x: 150, y: 250 }, { x: 50, y: 100 }, { x: 250, y: 150 }, { x: 550, y: 150 }], terrainType: 'gravel' },
            { id: 'water_quad', name: '28. ì¿¼ë“œ í—¤ì–´í•€ (ë¬¼)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 200 }, { x: 600, y: 300 }, { x: 750, y: 400 }, { x: 600, y: 550 }, { x: 400, y: 550 }, { x: 200, y: 550 }, { x: 50, y: 400 }, { x: 200, y: 300 }, { x: 50, y: 200 }, { x: 100, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_ultimate', name: '29. ì–¼í‹°ë°‹ ìŠ¤í”¼ë“œ (ì•„ìŠ¤íŒ”íŠ¸)', points: [{ x: 400, y: 50 }, { x: 650, y: 50 }, { x: 750, y: 200 }, { x: 700, y: 400 }, { x: 750, y: 550 }, { x: 400, y: 550 }, { x: 50, y: 550 }, { x: 100, y: 400 }, { x: 50, y: 200 }, { x: 150, y: 50 }, { x: 400, y: 150 }], terrainType: 'asphalt' },
            { id: 'gravel_marathon', name: '30. ë§ˆë¼í†¤ ì„œí‚· (ìê°ˆ)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 150 }, { x: 650, y: 250 }, { x: 750, y: 350 }, { x: 700, y: 450 }, { x: 750, y: 550 }, { x: 400, y: 500 }, { x: 50, y: 550 }, { x: 150, y: 450 }, { x: 50, y: 350 }, { x: 150, y: 250 }, { x: 50, y: 150 }, { x: 200, y: 50 }, { x: 400, y: 150 }], terrainType: 'gravel' }
        ];


        // --- Core Physics Calculation ---
        const getPhysicsConstants = (userParts, currentChassisId) => {
            const currentChassis = CAR_CHASSIS.find(c => c.id === currentChassisId);
            
            // Tier 0 is the base for all parts, so we merge it with the chassis base.
            const baseStats = {
                // Max speed (Gearbox) includes chassis bonus
                maxSpeed: PART_STATS[userParts.gearbox].maxSpeedMod + currentChassis.maxSpeedBonus, 
                // Friction (Tire)
                friction: PART_STATS[userParts.tire].friction,
                // Turn Speed (Steering)
                turnSpeed: PART_STATS[userParts.steering].turnSpeed,
                // Grip (Downforce)
                gripFactor: PART_STATS[userParts.downforce].gripFactor, 
                // Sensor Range (Sensor)
                sensorRange: PART_STATS[userParts.sensor].sensorRange,
                // Acceleration (Engine)
                acceleration: PART_STATS[userParts.engine].acceleration,
            };
            
            return baseStats;
        };


        // --- Firestore Utilities ---
        const APP_ID = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const USER_DATA_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/gameData/config`;
        // ë¡œì§ ì„¤ì •ì„ ìœ„í•œ ìƒˆë¡œìš´ ê²½ë¡œ
        const LOGIC_CONFIG_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/logicConfigs/slots`;
        // AI ë‚œì´ë„ ì ì‘ ì €ì¥ì„ ìœ„í•œ ê²½ë¡œ
        const AI_DIFFICULTY_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/aiDifficulty/stats`;

        const getUserId = () => window.firebaseAuth?.currentUser?.uid || 'anonymous';
        const getFirestoreDB = () => window.firestoreDB;

        const getDefaultUserData = (userId) => ({
            userId: userId,
            dollars: 5000, // Initial cash for testing
            currentChassis: CAR_CHASSIS[0].id,
            parts: {
                engine: 0, gearbox: 0, tire: 0, steering: 0, downforce: 0, sensor: 0
            },
            lapHistory: []
        });

        const getDefaultLogicData = () => {
            const defaultSlotName = (index) => `ìŠ¬ë¡¯ ${index + 1} (ê¸°ë³¸)`;
            const defaultSlots = [...Array(5)].map((_, index) => ({
                name: defaultSlotName(index),
                blocks: index === 0 ? INITIAL_BLOCKS : [],
            }));
            return {
                slots: defaultSlots,
                activeSlotIndex: 0,
            };
        };

        // ğŸŒŸ AI ë‚œì´ë„ ë°ì´í„° ë¡œë”©
        const loadAIDifficultyData = (setAIDifficultyStats, setAIReady) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;
            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, AI_DIFFICULTY_PATH(userId)); 

            const unsubscribe = window.onSnapshot(docRef, async (docSnap) => { // async ì¶”ê°€
                try {
                    if (docSnap.exists()) {
                        // winStreakMap: { 'trackId': winStreakCount }
                        setAIDifficultyStats(docSnap.data().winStreakMap || {});
                    } else {
                        await window.setDoc(docRef, { winStreakMap: {} }); // await ì¶”ê°€
                        setAIDifficultyStats({});
                    }
                    setAIReady(true); // ğŸŒŸ ë¡œë”© ì™„ë£Œ ì‹ í˜¸ ì „ì†¡
                } catch (error) {
                    console.error("Error listening to AI Difficulty:", error);
                    setAIReady(true); // ì˜¤ë¥˜ê°€ ë‚˜ë”ë¼ë„ ë¡œë”© ì™„ë£Œ ì‹ í˜¸ ì „ì†¡ (ë©ˆì¶¤ ë°©ì§€)
                }
            }, (error) => {
                console.error("Error setting up AI Difficulty listener:", error);
                setAIReady(true);
            });
            return unsubscribe;
        };
        
        // ğŸŒŸ AI ë‚œì´ë„ ì ì‘ ì €ì¥
        const saveAIDifficultyData = async (trackId, didWin) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, AI_DIFFICULTY_PATH(userId));
                
                const docSnap = await window.getDoc(docRef);
                const data = docSnap.exists() ? docSnap.data().winStreakMap || {} : {};
                
                const currentStreak = data[trackId] || 0;
                let newStreak;

                if (didWin) {
                    newStreak = currentStreak + 1;
                } else {
                    newStreak = Math.max(0, currentStreak - 1); // íŒ¨ë°° ì‹œ ê°ì†Œ (ìµœì†Œ 0)
                }

                data[trackId] = newStreak;

                await window.setDoc(docRef, { winStreakMap: data }, { merge: true });
                console.log(`AI Difficulty for ${trackId} updated. New Win Streak: ${newStreak}`);

            } catch (error) {
                console.error("Error saving AI Difficulty:", error);
            }
        };


        const loadUserData = (setUserData, setAuthReady) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;

            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, USER_DATA_PATH(userId)); 
            setAuthReady(true); 

            const unsubscribe = window.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    setUserData(docSnap.data());
                } else {
                    const defaultData = getDefaultUserData(userId);
                    window.setDoc(docRef, defaultData); 
                    setUserData(defaultData);
                }
            }, (error) => {
                console.error("Error listening to User Data:", error);
                setAuthReady(true);
            });

            return unsubscribe;
        };
        
        const loadLogicData = (setLogicSlots, setActiveSlotIndex, setLogicReady) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;

            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, LOGIC_CONFIG_PATH(userId)); 

            const unsubscribe = window.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    setLogicSlots(data.slots || getDefaultLogicData().slots);
                    setActiveSlotIndex(data.activeSlotIndex || 0);
                } else {
                    const defaultData = getDefaultLogicData();
                    window.setDoc(docRef, defaultData); 
                    setLogicSlots(defaultData.slots);
                    setActiveSlotIndex(defaultData.activeSlotIndex);
                }
                setLogicReady(true);
            }, (error) => {
                console.error("Error listening to Logic Config:", error);
                setLogicReady(true);
            });

            return unsubscribe;
        };

        const saveUserData = async (newUserData) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, USER_DATA_PATH(userId));
                await window.setDoc(docRef, newUserData, { merge: true });
            } catch (error) {
                console.error("Error saving user data:", error);
            }
        };

        const saveLogicData = async (logicData) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, LOGIC_CONFIG_PATH(userId));
                await window.setDoc(docRef, logicData, { merge: true });
            } catch (error) {
                console.error("Error saving logic data:", error);
            }
        };


        // --- Shop Helper Function ---
        const getPartStatKey = (partId) => {
            switch(partId) {
                case 'engine': return 'acceleration';
                case 'gearbox': return 'maxSpeedMod';
                case 'tire': return 'friction';
                case 'steering': return 'turnSpeed';
                case 'downforce': return 'gripFactor';
                case 'sensor': return 'sensorRange';
                default: return '';
            }
        };

        // ğŸŒŸ ìµœëŒ€ í‹°ì–´ í™•ì¸ í•¨ìˆ˜
        const MAX_TIER = 5;


        const App = () => {
            // --- App State ---
            const [currentScreen, setCurrentScreen] = useState('race');
            const [isPlaying, setIsPlaying] = useState(false);
            const [blocks, setBlocks] = useState(INITIAL_BLOCKS);
            const [gameState, setGameState] = useState('idle');
            const [winner, setWinner] = useState(null);
            const [sensorReadings, setSensorReadings] = useState([0, 0, 0, 0, 0]);
            const [currentTrackIdx, setCurrentTrackIdx] = useState(0);
            const [isMuted, setIsMuted] = useState(false);
            const [authReady, setAuthReady] = useState(false);
            
            // --- User Data State ---
            const [userData, setUserData] = useState(getDefaultUserData('initial'));
            const [physics, setPhysics] = useState(getPhysicsConstants(getDefaultUserData('initial').parts, CAR_CHASSIS[0].id));

            // --- Logic Slot State ---
            const [logicSlots, setLogicSlots] = useState(getDefaultLogicData().slots);
            const [activeSlotIndex, setActiveSlotIndex] = useState(getDefaultLogicData().activeSlotIndex);
            const [logicReady, setLogicReady] = useState(false);
            
            // ğŸŒŸ AI ë‚œì´ë„ ìƒíƒœ
            const [aiDifficultyStats, setAIDifficultyStats] = useState({});
            const [aiReady, setAIReady] = useState(false); // ğŸŒŸ AI ë¡œë”© ìƒíƒœ ì¶”ê°€

            // ğŸŒŸ ìºë¦­í„° ì„ íƒ ìƒíƒœ
            const [currentVehicleId, setCurrentVehicleId] = useState(VEHICLE_TYPES[0].id);

            const [userStats, setUserStats] = useState({ 
                laps: 0, 
                currentLapTime: 0, 
                lastLapTime: 0,
                totalTime: 0,
                lapHistory: []
            });

            // --- Time/Game Refs ---
            const canvasRef = useRef(null);
            const cars = useRef([]);
            const requestRef = useRef();
            const startTimeRef = useRef(0);
            const currentSkidSegmentId = useRef(0); 

            // --- Audio Refs (Simplified for brevity) ---
            const audioCtxRef = useRef(null);
            const engineOscRef = useRef(null);
            const engineGainRef = useRef(null);
            const skidOscRef = useRef(null);
            const skidGainRef = useRef(null);
            const skidFilterRef = useRef(null);
            
            // Helper to get current vehicle info
            const currentVehicle = VEHICLE_TYPES.find(v => v.id === currentVehicleId) || VEHICLE_TYPES[0];

            const initAudio = useCallback(() => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume();
                }
            }, []);

            const playTone = useCallback((freq, type, duration, vol = 0.1) => {
                if (isMuted || !audioCtxRef.current) return;
                const osc = audioCtxRef.current.createOscillator();
                const gain = audioCtxRef.current.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
                gain.gain.setValueAtTime(vol, audioCtxRef.current.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtxRef.current.destination);
                osc.start();
                osc.stop(audioCtxRef.current.currentTime + duration);
            }, [isMuted]);

            const playClickSound = useCallback(() => {
                initAudio(); 
                playTone(600, 'sine', 0.1, 0.025);
            }, [initAudio, playTone]);
            
            const playLapSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current) return;
                playTone(880, 'sine', 0.1, 0.05);
                setTimeout(() => playTone(1760, 'sine', 0.2, 0.05), 100);
            }, [isMuted, playTone]);

            const playWinSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current) return;
                const notes = [523.25, 659.25, 783.99, 1046.50]; 
                notes.forEach((note, i) => {
                    setTimeout(() => playTone(note, 'square', 0.2, 0.05), i * 150);
                });
            }, [isMuted, playTone]);

            const startEngineSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current || engineOscRef.current) return;
                const osc = audioCtxRef.current.createOscillator();
                const gain = audioCtxRef.current.createGain();
                osc.type = 'sawtooth'; 
                osc.frequency.value = 100; 
                gain.gain.value = 0.001; 
                osc.connect(gain);
                gain.connect(audioCtxRef.current.destination);
                osc.start();
                engineOscRef.current = osc;
                engineGainRef.current = gain;
            }, [isMuted]);

            const stopEngineSound = useCallback(() => {
                if (engineOscRef.current) {
                    try { engineOscRef.current.stop(); engineOscRef.current.disconnect(); } catch (e) {} 
                    engineOscRef.current = null;
                }
                if (engineGainRef.current) {
                    engineGainRef.current.disconnect();
                    engineGainRef.current = null;
                }
            }, []);

            const updateEnginePitch = useCallback((speed) => {
                if (engineOscRef.current && engineGainRef.current && !isMuted && audioCtxRef.current) {
                    const absSpeed = Math.abs(speed);
                    const pitch = 100 + absSpeed * 30; 
                    engineOscRef.current.frequency.setTargetAtTime(pitch, audioCtxRef.current.currentTime, 0.1);

                    const baseVol = 0.05;
                    const speedRatio = Math.min(absSpeed / physics.maxSpeed, 1.0);
                    const volFactor = 0.1 + speedRatio * 0.9;
                    const volume = baseVol * volFactor;

                    engineGainRef.current.gain.setTargetAtTime(volume, audioCtxCtx.current.currentTime, 0.05);
                }
            }, [isMuted, physics.maxSpeed]);

            const updateSkidSound = useCallback((driftIntensity) => {
                if (!audioCtxRef.current || isMuted || currentVehicle.trailType !== 'skid') return;

                if (driftIntensity > 0.15) { 
                    if (!skidOscRef.current) {
                        const bufferSize = audioCtxRef.current.sampleRate * 2;
                        const buffer = audioCtxRef.current.createBuffer(1, bufferSize, audioCtxRef.current.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }

                        const noise = audioCtxRef.current.createBufferSource();
                        noise.buffer = buffer;
                        noise.loop = true;
                        
                        const gain = audioCtxRef.current.createGain();
                        const filter = audioCtxRef.current.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 1200; 
                        filter.Q.value = 5; 

                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioCtxRef.current.destination);
                        
                        noise.start();
                        skidOscRef.current = noise;
                        skidGainRef.current = gain;
                        skidFilterRef.current = filter;
                    }
                    
                    const vol = Math.min(driftIntensity * 0.8, 0.15); 
                    skidGainRef.current.gain.setTargetAtTime(vol, audioCtxRef.current.currentTime, 0.1);
                    
                    const minPitch = 1000;
                    const maxPitch = 2500;
                    const randomFactor = (Math.random() * 0.2 + 0.9); 
                    const targetPitch = Math.min(minPitch + driftIntensity * (maxPitch - minPitch) * 2 * randomFactor, maxPitch); 
                    skidFilterRef.current.frequency.setTargetAtTime(targetPitch, audioCtxRef.current.currentTime, 0.05);

                } else {
                    if (skidGainRef.current) {
                        skidGainRef.current.gain.setTargetAtTime(0, audioCtxRef.current.currentTime, 0.1);
                    }
                }
            }, [isMuted, currentVehicle.trailType]);

            const stopSkidSound = useCallback(() => {
                if (skidOscRef.current) {
                    try { skidOscRef.current.stop(); skidOscRef.current.disconnect(); } catch (e) {} 
                    skidOscRef.current = null;
                }
                if (skidGainRef.current) {
                    skidGainRef.current.disconnect();
                    skidGainRef.current = null;
                }
            }, []);


            // --- Helpers ---
            const dist = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

            const scalePoint = (p) => ({
                // ğŸŒŸ MAP_SCALEì´ 1.0ì´ë¯€ë¡œ ìŠ¤ì¼€ì¼ë§ì€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                x: (p.x - TRACK_WIDTH / 2) * MAP_SCALE + TRACK_WIDTH / 2,
                y: (p.y - TRACK_HEIGHT / 2) * MAP_SCALE + TRACK_HEIGHT / 2
            });

            const getCurrentTrackPoints = useCallback(() => TRACK_LAYOUTS[currentTrackIdx].points.map(scalePoint), [currentTrackIdx]);

            const getStartAngle = useCallback(() => {
                const points = getCurrentTrackPoints();
                const p1 = points[0];
                const p2 = points[1];
                return Math.atan2(p2.y - p1.y, p2.x - p1.x);
            }, [getCurrentTrackPoints]);

            const distToSegment = (x, y, x1, y1, x2, y2) => {
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                return dist(x, y, xx, yy);
            };

            const isOffTrack = (x, y) => {
                const points = getCurrentTrackPoints();
                let minDist = Infinity;
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];
                    const d = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (d < minDist) minDist = d;
                }
                return minDist > (TRACK_AESTHETICS.curb / 2) + 3; 
            };

            // ğŸŒŸ íŠ¸ë™ì˜ ì§€í˜• ì†ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ ë¬¼ë¦¬ íŒ©í„° ê³„ì‚°
            const getTrackPhysicsFactors = (currentTrackIdx) => {
                const currentTrack = TRACK_LAYOUTS[currentTrackIdx];
                const type = currentTrack.terrainType || 'asphalt';
                const props = TERRAIN_PROPERTIES[type];
                
                return { 
                    friction: props.frictionFactor, 
                    turnSpeed: props.turnFactor,
                    trackColor: props.trackColor,
                    groundColor: props.groundColor,
                    skidColor: props.skidColor
                };
            };


            const castRays = (car, range) => {
                const readings = [];
                const angles = [-60, -30, 0, 30, 60]; 
                
                angles.forEach(offset => {
                    const rayAngle = car.angle + (offset * Math.PI / 180);
                    let distance = 0;
                    let step = 2;
                    let maxDist = range;
                    let rx = car.x;
                    let ry = car.y;

                    while (distance < maxDist) {
                        rx += Math.cos(rayAngle) * step;
                        ry += Math.sin(rayAngle) * step;
                        distance += step;
                        if (isOffTrack(rx, ry)) break;
                    }
                    readings.push(Math.min(distance, maxDist));
                });
                return readings;
            };

            // --- Game Loop Logic ---

            const updateCarPhysics = (car, inputs, timestamp) => {
                if (car.finished) return;

                // ğŸŒŸ íŠ¸ë™ ì§€í˜• ë¬¼ë¦¬ íŒ©í„° ë¡œë“œ
                const trackFactors = getTrackPhysicsFactors(currentTrackIdx);

                // Use current user's physics or default AI physics
                const aiBaseStats = PART_STATS['0'];

                const carPhysics = car.isAI ? { 
                    acceleration: aiBaseStats.acceleration,
                    maxSpeed: aiBaseStats.maxSpeedMod,
                    friction: aiBaseStats.friction,
                    turnSpeed: aiBaseStats.turnSpeed,
                    gripFactor: aiBaseStats.gripFactor,
                    sensorRange: aiBaseStats.sensorRange
                } : physics;

                // ğŸŒŸ íŠ¸ë™ ì§€í˜• íŒ©í„° ì ìš© (ë¬¼ë¦¬ ë³´ì •)
                carPhysics.friction *= trackFactors.friction;
                carPhysics.turnSpeed *= trackFactors.turnSpeed;
                carPhysics.gripFactor *= trackFactors.friction; // ë§ˆì°°ì´ ì¤„ë©´ ê·¸ë¦½ë„ ì¤„ì–´ ë¯¸ë„ëŸ¬ì§ ì¦ê°€
                
                // Steering
                if (Math.abs(car.speed) > 0.5) {
                    car.angle += inputs.steer * carPhysics.turnSpeed * (car.speed > 0 ? 1 : -1);
                }

                if (typeof car.moveAngle === 'undefined') car.moveAngle = car.angle;
                if (typeof car.skidMarks === 'undefined') car.skidMarks = [];
                if (typeof car.currentSkidId === 'undefined') car.currentSkidId = 0;
                if (typeof car.isDrifting === 'undefined') car.isDrifting = false;

                // Physics: Drift 
                const speedRatio = Math.abs(car.speed) / carPhysics.maxSpeed;
                const grip = carPhysics.gripFactor + (1.0 - speedRatio) * (1 - carPhysics.gripFactor); 

                let angleDiff = car.angle - car.moveAngle;
                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                car.moveAngle += angleDiff * grip;

                // Acceleration & Friction
                car.speed += inputs.throttle * carPhysics.acceleration;
                car.speed *= carPhysics.friction;

                // Tire Scrub & Skid Logic
                const driftIntensity = Math.abs(angleDiff);
                const driftThreshold = 0.15; 
                
                const nowDrifting = driftIntensity > driftThreshold && Math.abs(car.speed) > 3;
                
                if (nowDrifting) {
                    if (!car.isDrifting) {
                        currentSkidSegmentId.current += 1;
                        car.currentSkidId = currentSkidSegmentId.current;
                        car.isDrifting = true;
                    }

                    // Scrub speed
                    car.speed *= (1 - driftIntensity * 0.02); 
                    
                    // Add Skid Marks/Dust Trail
                    if (car.trailType !== 'none') {
                        const rearX = car.x - Math.cos(car.angle) * 10;
                        const rearY = car.y - Math.sin(car.angle) * 10;
                        const perp = car.angle + Math.PI/2;
                        const lx = rearX + Math.cos(perp) * 6;
                        const ly = rearY + Math.sin(perp) * 6;
                        const rx = rearX - Math.cos(perp) * 6;
                        const ry = rearY - Math.sin(perp) * 6;

                        // ğŸŒŸ ìŠ¤í‚¤ë“œ ë§ˆí¬ ìƒ‰ìƒì„ íŠ¸ë™ ì§€í˜•ì— ë§ê²Œ ì‚¬ìš©
                        car.skidMarks.push({ lx, ly, rx, ry, alpha: 0.3, segmentId: car.currentSkidId, trailType: car.trailType, skidColor: trackFactors.skidColor });
                        
                        if (car.skidMarks.length > MAX_SKID_MARKS) car.skidMarks.shift(); 
                    }
                } else {
                    car.isDrifting = false;
                }

                if (car.id === 'user' && !isMuted) {
                    updateSkidSound(nowDrifting ? driftIntensity : 0);
                }

                if (car.speed > carPhysics.maxSpeed) car.speed = carPhysics.maxSpeed;
                if (car.speed < -carPhysics.maxSpeed / 2) car.speed = -carPhysics.maxSpeed / 2;

                // Move
                car.x += Math.cos(car.moveAngle) * car.speed;
                car.y += Math.sin(car.moveAngle) * car.speed;

                if (isOffTrack(car.x, car.y)) {
                    car.speed *= 0.5; 
                }
                
                // ğŸŒŸ ì‚¬ìš©ì ì°¨ëŸ‰ 180ë„ ë°©í–¥ ë³´ì • ë¡œì§
                if (car.id === 'user' && Math.abs(car.speed) > 1.0) {
                    const points = getCurrentTrackPoints();
                    const nextCp = points[(car.lastCP + 1) % points.length];
                    
                    const directionToCp = Math.atan2(nextCp.y - car.y, nextCp.x - car.x);
                    let angleDiffToTarget = directionToCp - car.moveAngle;
                    while (angleDiffToTarget <= -Math.PI) angleDiffToTarget += Math.PI * 2;
                    while (angleDiffToTarget > Math.PI) angleDiffToTarget -= Math.PI * 2;
                    
                    // 135ë„ (3*PI/4) ì´ìƒ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì£¼í–‰í•˜ëŠ”ì§€ í™•ì¸
                    if (Math.abs(angleDiffToTarget) > (3 * Math.PI / 4)) {
                        car.wrongDirectionFrames = (car.wrongDirectionFrames || 0) + 1;
                    } else {
                        car.wrongDirectionFrames = 0;
                    }

                    // 120 í”„ë ˆì„ (2ì´ˆ) ì´ìƒ ì˜ëª» ì£¼í–‰í–ˆì„ ê²½ìš° ë³´ì •
                    if (car.wrongDirectionFrames > 120) {
                        const resetCp = points[car.lastCP];
                        const resetNextCp = points[(car.lastCP + 1) % points.length];

                        // ì˜¬ë°”ë¥¸ ë°©í–¥ ê³„ì‚°
                        const correctAngle = Math.atan2(resetNextCp.y - resetCp.y, resetNextCp.x - resetCp.x);
                        
                        // ë§ˆì§€ë§‰ ì²´í¬í¬ì¸íŠ¸ ìœ„ì¹˜ë¡œ ë¦¬ì…‹
                        car.x = resetCp.x;
                        car.y = resetCp.y;
                        car.angle = correctAngle;
                        car.moveAngle = correctAngle;
                        car.speed = 0;
                        car.wrongDirectionFrames = 0;
                        
                        console.log("Auto-correction: Wrong direction detected. User car reset.");
                        // ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ì„ ì£¼ëŠ” UI í”¼ë“œë°±ì„ ì¶”ê°€í•  ìˆ˜ ìˆì§€ë§Œ, í˜„ì¬ëŠ” ì½˜ì†” ë¡œê·¸ë¡œ ëŒ€ì²´
                    }
                }


                // Checkpoint
                const points = getCurrentTrackPoints();
                const nextCpIdx = (car.lastCP + 1) % points.length;
                const nextCp = points[nextCpIdx];
                
                let isCheckpointReached = false;

                if (nextCpIdx === 0) {
                    // Rectangular detection for Start Line
                    const p0 = points[0];
                    const p1 = points[1]; 
                    const trackAngle = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                    const dx = car.x - p0.x;
                    const dy = car.y - p0.y;
                    const localX = dx * Math.cos(-trackAngle) - dy * Math.sin(-trackAngle);
                    const localY = dx * Math.sin(-trackAngle) + dy * Math.cos(-trackAngle);
                    
                    if (Math.abs(localX) < 20 && Math.abs(localY) < (TRACK_AESTHETICS.asphalt / 2 + 5)) { 
                        isCheckpointReached = true;
                    }
                } else {
                    if (dist(car.x, car.y, nextCp.x, nextCp.y) < CHECKPOINT_RADIUS_NORMAL) {
                        isCheckpointReached = true;
                    }
                }

                if (isCheckpointReached) {
                    car.lastCP = nextCpIdx;
                    
                    if (nextCpIdx === 0) {
                        car.laps++;
                        if (!car.isAI) playLapSound();

                        const now = timestamp;
                        const lapTime = (now - car.lapStartTime) / 1000;
                        car.lastLapTime = lapTime;
                        car.lapStartTime = now; 
                        
                        if (car.id === 'user') {
                            if (!car.lapHistory) car.lapHistory.push(0); // ì²« ë©íƒ€ì„ì€ 0 (ë¬´ì‹œë¨)
                            car.lapHistory.push(lapTime);
                        }

                        if (car.laps >= TOTAL_LAPS) {
                            car.finished = true;
                            car.finishTime = (now - startTimeRef.current) / 1000;
                            
                            if (!winner) {
                                setWinner(car.id);
                                setGameState('finished');
                                setIsPlaying(false);
                                
                                // ğŸ’° ë³´ìƒ ê³„ì‚° ë° ì§€ê¸‰ ë¡œì§ ìˆ˜ì •
                                if (car.id === 'user') {
                                    playWinSound();
                                    giveReward(car.finishTime, true, currentTrackIdx); // User wins
                                    saveAIDifficultyData(TRACK_LAYOUTS[currentTrackIdx].id, true); // ğŸŒŸ AI ë‚œì´ë„ ìƒìŠ¹
                                } else {
                                    const userCar = cars.current.find(c => c.id === 'user');
                                    giveReward(userCar ? userCar.finishTime : 0, false, currentTrackIdx); // User lost (participation)
                                    saveAIDifficultyData(TRACK_LAYOUTS[currentTrackIdx].id, false); // ğŸŒŸ AI ë‚œì´ë„ í•˜ë½
                                }
                                
                                stopEngineSound();
                                stopSkidSound();
                            }
                        }
                    }
                }
            };
            
            // ğŸ’° ë³´ìƒ ê³„ì‚° ë¡œì§ ìˆ˜ì • (ë‚œì´ë„ ë° ê¸°ë³¸ ìƒê¸ˆ ì¡°ì •)
            const giveReward = (finishTime, didWin, trackIndex) => {
                const totalTracks = TRACK_LAYOUTS.length;
                // ë‚œì´ë„ì— ë”°ë¥¸ ê¸°ë³¸ ìƒê¸ˆ (ìµœëŒ€ 3000)
                const trackDifficultyRatio = trackIndex / (totalTracks - 1);
                const baseReward = Math.round(500 + trackDifficultyRatio * 2500); 
                const bonusPerSecond = 8; // ì‹œê°„ ë³´ë„ˆìŠ¤ íŒ©í„° ì¡°ì •
                let reward = 0;
                
                if (didWin) {
                    const timeBonus = Math.max(0, 500 - finishTime * bonusPerSecond); // ìµœëŒ€ ì‹œê°„ ë³´ë„ˆìŠ¤ ì¡°ì •
                    reward = baseReward + timeBonus; 
                } else {
                    reward = 300; // ì°¸ì—¬ ìƒê¸ˆ ì¡°ì •
                }

                const actualReward = Math.max(0, Math.round(reward)); 

                const newDollars = userData.dollars + actualReward;
                saveUserData({...userData, dollars: newDollars});
                console.log(`Reward awarded: ${actualReward} dollars. New balance: ${newDollars}`);
                alert(`ê²°ê³¼: ${didWin ? 'ìš°ìŠ¹' : 'íŒ¨ë°°'}! íšë“ ìƒê¸ˆ: $${actualReward.toLocaleString()}`); // UI í”¼ë“œë°± ì¶”ê°€
            };

            const evaluateCondition = (block, currentReadings) => {
                if (block.flowType === 'ELSE') return false; 
                
                const leftValue = currentReadings[block.sensor];
                let rightValue = block.valueType === 'sensor' ? currentReadings[block.value] : block.value;

                if (block.operator === '<') return leftValue < rightValue;
                if (block.operator === '>') return leftValue > rightValue;
                if (block.operator === '<=') return leftValue <= rightValue;
                if (block.operator === '>=') return leftValue >= rightValue;
                if (block.operator === '==') return leftValue === rightValue;
                if (block.operator === '!=') return leftValue !== rightValue;
                
                return false;
            }
            
            // ğŸ’¡ applyAction ë¡œì§ ì—…ë°ì´íŠ¸
            const applyAction = (block, steerOutputs) => {
                    switch(block.action) {
                        case 'LEFT': steerOutputs.turnLeft = true; break;
                        case 'RIGHT': steerOutputs.turnRight = true; break;
                        
                        // ê°€ì† ë‹¨ê³„ë³„ ì„¤ì •
                        case 'ACCEL_100': steerOutputs.gas = 1.0; break;
                        case 'ACCEL_75': steerOutputs.gas = 0.75; break;
                        case 'ACCEL_50': steerOutputs.gas = 0.5; break;

                        // ê°ì† ë‹¨ê³„ë³„ ì„¤ì •
                        case 'BRAKE_100': steerOutputs.brake = 1.0; break;
                        case 'BRAKE_75': steerOutputs.brake = 0.75; break;
                        case 'BRAKE_50': steerOutputs.brake = 0.5; break;
                        
                        default: 
                            if (block.action.startsWith('ACCEL')) steerOutputs.gas = 1.0;
                            if (block.action.startsWith('BRAKE')) steerOutputs.brake = 1.0;
                            break;
                    }
            }

            // ğŸ’¡ ë¡œì§ ë¸”ë¡ ë°°ì—´ì„ ì¸ìˆ˜ë¡œ ë°›ëŠ” ê³µí†µ ì…ë ¥ ê³„ì‚° í•¨ìˆ˜
            const getCarInputs = (carLogicBlocks, currentReadings) => {
                const steerOutputs = { turnLeft: false, turnRight: false, gas: 0, brake: 0 };
                let steer = 0;
                let throttle = 0;
                let matchedInChain = false; 

                for (let i = 0; i < carLogicBlocks.length; i++) {
                    const block = carLogicBlocks[i];
                    
                    let conditionMet = evaluateCondition(block, currentReadings);
                    
                    const isStartOfChain = block.flowType === 'IF';
                    const isElseIf = block.flowType === 'ELSE_IF';
                    const isElse = block.flowType === 'ELSE';

                    if (isStartOfChain) {
                        matchedInChain = false;
                        if (conditionMet) {
                            applyAction(block, steerOutputs);
                            matchedInChain = true; 
                        }
                    } else if (isElseIf) {
                        if (!matchedInChain && conditionMet) {
                            applyAction(block, steerOutputs);
                            matchedInChain = true; 
                        }
                    } else if (isElse) {
                        if (!matchedInChain) {
                            applyAction(block, steerOutputs);
                        }
                    } 
                }
                
                if (steerOutputs.turnLeft) steer -= 1;
                if (steerOutputs.turnRight) steer += 1;
                
                // ê°€ì†/ê°ì† ê°’ì„ ìµœì¢… throttleì— ë°˜ì˜
                throttle += steerOutputs.gas;
                throttle -= steerOutputs.brake;

                // throttle ê°’ì€ -1.0ì—ì„œ 1.0 ì‚¬ì´ê°€ ë©ë‹ˆë‹¤.
                return { steer, throttle: Math.max(-1.0, Math.min(1.0, throttle)) };
            };
            
            // ğŸŒŸ AI ê²½ë¡œ ê¸°ë°˜ ì…ë ¥ (ë‚œì´ë„ ë° ì ì‘ í¸ì°¨ ì ìš©)
            const getAIPathInputs = (car, currentTrackIdx) => {
                const trackId = TRACK_LAYOUTS[currentTrackIdx].id;
                const winStreak = aiDifficultyStats[trackId] || 0;

                const totalTracks = TRACK_LAYOUTS.length;
                // íŠ¸ë™ ë‚œì´ë„ íŒ©í„°: 0.1 (ì‰¬ì›€) ~ 1.0 (ì–´ë ¤ì›€)
                const baseDifficultyFactor = totalTracks > 1 ? (0.1 + (0.9 * (currentTrackIdx / (totalTracks - 1)))) : 1.0;
                
                // ğŸŒŸ ì ì‘ ë‚œì´ë„ íŒ©í„°: 0 ~ 0.2ê¹Œì§€ ì¶”ê°€ ë‚œì´ë„ ë¶€ì—¬ (ìµœëŒ€ 10ì—°ìŠ¹ ì‹œ 0.2)
                const adaptationFactor = Math.min(winStreak * 0.02, 0.2); 
                
                // ìµœì¢… ë‚œì´ë„ íŒ©í„° (1.0 ì´ˆê³¼ ê°€ëŠ¥)
                const finalDifficultyFactor = baseDifficultyFactor + adaptationFactor;

                // 1. ëª©í‘œ ì²´í¬í¬ì¸íŠ¸ ê³„ì‚°
                const points = getCurrentTrackPoints();
                const targetIdx = (car.lastCP + 1) % points.length;
                const target = points[targetIdx];
                
                const desiredAngle = Math.atan2(target.y - car.y, target.x - car.x);
                let diff = desiredAngle - car.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                // 2. ì¡°í–¥ ê³„ì‚° (ë‚œì´ë„ì™€ ëœë¤ì„± ì ìš©)
                let steer = 0;
                
                // ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ë” ê³µê²©ì ì´ê³  ì •í™•í•˜ê²Œ ì¡°í–¥
                const AGGRESSION_FACTOR = 0.5 + 0.5 * finalDifficultyFactor; 
                
                // AI ë¶€ì •í™•ì„± (ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ë…¸ì´ì¦ˆ ê°ì†Œ)
                const noiseRange = 0.05 * (1.0 - Math.min(finalDifficultyFactor, 1.0)); // ë…¸ì´ì¦ˆëŠ” 1.0ê¹Œì§€ë§Œ ê°ì†Œ
                const noise = (Math.random() - 0.5) * noiseRange; 

                // ì¡°í–¥ ë¯¼ê°ë„ (ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ì¤‘ì•™ìœ¼ë¡œ ë” ë¹ ë¥´ê²Œ ë³µê·€)
                const steeringThreshold = 0.1 * (1.0 - AGGRESSION_FACTOR); 

                if (diff > steeringThreshold) steer = 1;
                if (diff < -steeringThreshold) steer = -1;
                
                steer *= AGGRESSION_FACTOR;
                steer += noise;

                // 3. ê°€ì†/ê°ì† ê³„ì‚°
                let throttle = 1.0;
                // AI ìµœëŒ€ ì†ë„ ì œí•œ (ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ë¹ ë¥´ê²Œ)
                const MAX_SPEED_CAP = 0.7 + 0.3 * finalDifficultyFactor; 
                
                // ì½”ë„ˆ ê°ì†: ê°ë„ ì°¨ì´ê°€ í¬ë©´ ê°ì†
                if (Math.abs(diff) > 0.3) throttle = 0.5; 
                
                // í˜„ì¬ ì†ë„ê°€ ìµœëŒ€ ì†ë„ì— ê°€ê¹Œìš°ë©´ ê°€ì†ë„ë¥¼ ì¤„ì„
                if (Math.abs(car.speed) > car.maxSpeed * MAX_SPEED_CAP) throttle = 0.5; 
                
                // AI ê°œë³„ í¸ì°¨ (AIë§ˆë‹¤ ì•½ê°„ì”© ë‹¤ë¦„)
                const variance = (parseInt(car.id.slice(-1)) || 0) * 0.03;

                return { steer: Math.max(-1, Math.min(1, steer)), throttle: Math.max(0.1, throttle - variance) };
            };


            const update = (timestamp) => {
                if (gameState === 'finished') return;
                
                if (startTimeRef.current === 0) {
                    startTimeRef.current = timestamp;
                    cars.current.forEach(c => c.lapStartTime = timestamp);
                }

                const currentTotalTime = (timestamp - startTimeRef.current) / 1000;
                
                const userCar = cars.current[0];
                
                // DRAWING GUARD: Only run physics if cars are initialized
                if (!userCar || cars.current.length === 0) {
                     if (!isPlaying) draw(); 
                     return;
                }

                // 1. ì‚¬ìš©ì ì°¨ëŸ‰ ì—…ë°ì´íŠ¸
                const readings = castRays(userCar, physics.sensorRange);
                setSensorReadings(readings);
                
                // ì‚¬ìš©ìê°€ í˜„ì¬ í¸ì§‘ ì¤‘ì¸ blocks ìƒíƒœë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
                const userInputs = getCarInputs(blocks, readings); 
                updateCarPhysics(userCar, userInputs, timestamp);
                
                if (!isMuted && gameState === 'running') {
                    updateEnginePitch(userCar.speed);
                }

                // 2. AI ì°¨ëŸ‰ ì—…ë°ì´íŠ¸ (ê²½ë¡œ ê¸°ë°˜ AI)
                
                cars.current.slice(1).forEach(car => {
                    const aiInputs = getAIPathInputs(car, currentTrackIdx); 
                    
                    // AIì˜ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ (ë‚´ë¶€ì ìœ¼ë¡œ car.isAIë¥¼ ë³´ê³  ê¸°ë³¸ ìŠ¤íƒ¯ ì‚¬ìš©)
                    updateCarPhysics(car, aiInputs, timestamp);
                });

                setUserStats(prev => {
                    const userCar = cars.current[0] || {}; 
                    return ({
                        ...prev,
                        laps: userCar.laps || 0,
                        currentLapTime: (timestamp - userCar.lapStartTime) / 1000 || 0,
                        lastLapTime: userCar.lastLapTime || 0,
                        totalTime: userCar.finished ? userCar.finishTime : currentTotalTime,
                        lapHistory: userCar.lapHistory || [] 
                    });
                });

                draw();
                if (isPlaying) {
                    requestRef.current = requestAnimationFrame(update);
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // ğŸŒŸ í˜„ì¬ íŠ¸ë™ì˜ ì§€í˜• ì†ì„±ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
                const trackFactors = getTrackPhysicsFactors(currentTrackIdx);
                
                // Clear (ì”ë”” ìƒ‰ìƒ)
                ctx.fillStyle = trackFactors.groundColor;
                ctx.fillRect(0, 0, TRACK_WIDTH, TRACK_HEIGHT);

                const points = getCurrentTrackPoints();
                
                // DRAWING GUARD: Draw only background if cars are not yet initialized (should be temporary)
                if (cars.current.length === 0) {
                    return;
                }
                
                // Draw Track
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Outer Border (ë ˆë“œ ë¼ì¸)
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = TRACK_AESTHETICS.border;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.stroke();

                // Curb (í°ìƒ‰ ë¼ì¸)
                ctx.strokeStyle = '#f8fafc';
                ctx.lineWidth = TRACK_AESTHETICS.curb;
                ctx.stroke();

                // Asphalt (íŠ¸ë™ ì§€í˜• ìƒ‰ìƒ)
                ctx.strokeStyle = trackFactors.trackColor; 
                ctx.lineWidth = TRACK_AESTHETICS.asphalt;
                ctx.stroke();

                // Draw Skid Marks / Trails
                cars.current.forEach(car => {
                    if (car.skidMarks && car.skidMarks.length > 1 && car.trailType !== 'none') {
                        ctx.lineWidth = 4;
                        
                        let trailColor = car.skidMarks[0].skidColor; // ğŸŒŸ íŠ¸ë™ ì§€í˜• ìƒ‰ìƒ ì‚¬ìš©
                        if (car.trailType === 'dust') {
                            trailColor = `rgba(200, 180, 100, 0.5)`; // Sand/Dust color
                        }
                        
                        ctx.strokeStyle = trailColor; 
                        
                        for(let i=0; i<car.skidMarks.length-1; i++) {
                            const p1 = car.skidMarks[i];
                            const p2 = car.skidMarks[i+1];
                            if (p1.segmentId === p2.segmentId) {
                                ctx.beginPath(); ctx.moveTo(p1.lx, p1.ly); ctx.lineTo(p2.lx, p2.ly); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(p1.rx, p1.ry); ctx.lineTo(p2.rx, p2.ry); ctx.stroke();
                            }
                        }
                    }
                });

                // Center Line (Dashed)
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Start Line (Checkered)
                const startAngle = getStartAngle();
                ctx.save();
                ctx.translate(points[0].x, points[0].y);
                ctx.rotate(startAngle); 
                
                const lineHalfHeight = TRACK_AESTHETICS.asphalt / 2 + 10;
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, -lineHalfHeight, 20, lineHalfHeight * 2); 
                
                ctx.fillStyle = '#000';
                for(let i=0; i<8; i++) {
                    for(let j=0; j<2; j++) {
                        if((i+j)%2===0) ctx.fillRect(-10 + j*10, -lineHalfHeight + i*(lineHalfHeight*2/8), 10, lineHalfHeight*2/8);
                    }
                }
                ctx.restore();

                // Draw Cars
                cars.current.forEach(car => {
                    const carInfo = CAR_CHASSIS.find(c => c.id === car.chassisId) || CAR_CHASSIS[0];

                    // 1. Draw Body / Character (Rotated context)
                    ctx.save();
                    ctx.translate(car.x, car.y);
                    ctx.rotate(car.angle);

                    if (car.vehicleType === 'car' || car.vehicleType === 'rocket') {
                        // Draw Car (Existing Logic)
                        ctx.fillStyle = car.color;
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillRect(-CAR_SIZE.width/2, -CAR_SIZE.height/2, CAR_SIZE.width, CAR_SIZE.height);
                        
                        // Windshield/Cabin (Design detail)
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(2, -5, 6, 10);
                        
                        // Simple Wing (for Downforce visual)
                        ctx.fillStyle = '#334155';
                        ctx.fillRect(-CAR_SIZE.width/2 - 2, -5, 3, 10); 
                    } else {
                        // Draw Character (Emoji)
                        ctx.font = '24px sans-serif'; 
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(car.emoji, 0, 0); 
                    }
                    
                    ctx.restore();

                    // 2. Draw Speed Text (Global coords)
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px sans-serif'; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);
                    ctx.fillText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);

                    if (!car.isAI) {
                        const readings = castRays(car, physics.sensorRange);
                        const angles = [-60, -30, 0, 30, 60];
                        readings.forEach((r, i) => {
                           ctx.save();
                           ctx.translate(car.x, car.y);
                           ctx.rotate(car.angle + (angles[i] * Math.PI / 180));
                           const grad = ctx.createLinearGradient(0, 0, r, 0);
                           grad.addColorStop(0, 'rgba(255, 255, 0, 0.5)');
                           grad.addColorStop(1, 'rgba(255, 0, 0, 0.8)');
                           ctx.fillStyle = grad;
                           ctx.fillRect(0, -1, r, 2);
                           ctx.fillStyle = 'red';
                           ctx.beginPath();
                           ctx.arc(r, 0, 3, 0, Math.PI * 2);
                           ctx.fill();
                           ctx.restore();
                        });
                    }
                });
            };

            // --- Game Control Functions ---

            const resetGame = useCallback(() => {
                setIsPlaying(false);
                setGameState('idle');
                setWinner(null);
                stopEngineSound();
                stopSkidSound();
                startTimeRef.current = 0;
                setUserStats({ laps: 0, currentLapTime: 0, lastLapTime: 0, totalTime: 0, lapHistory: [] });
                currentSkidSegmentId.current = 0;

                const points = getCurrentTrackPoints();
                const startPoint = points[0];
                const startAngle = Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x);
                
                const px = Math.cos(startAngle + Math.PI/2);
                const py = Math.sin(startAngle + Math.PI/2);
                const dx = Math.cos(startAngle);
                const dy = Math.sin(startAngle);

                const spawnX = startPoint.x - dx * 40;
                const spawnY = startPoint.y - dy * 40;
                
                const userChassis = CAR_CHASSIS.find(c => c.id === userData.currentChassis) || CAR_CHASSIS[0]; 
                const aiChassis = CAR_CHASSIS[0]; // AI always uses base chassis (C01)
                const userLogicBlocks = logicSlots[activeSlotIndex].blocks; 
                
                const userVehicle = VEHICLE_TYPES.find(v => v.id === currentVehicleId) || VEHICLE_TYPES[0]; // ğŸŒŸ ì‚¬ìš©ì ì„ íƒ ìºë¦­í„°

                // AI ìºë¦­í„°ëŠ” ê³ ì • (ì‹œê°ì  ì¼ê´€ì„±ì„ ìœ„í•´ AIëŠ” ê¸°ë³¸ ì°¨ëŸ‰ìœ¼ë¡œ ìœ ì§€)
                const aiVehicle = VEHICLE_TYPES[0]; 

                // ğŸŒŸ cars.currentì— ì°¨ëŸ‰ ê°ì²´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
                cars.current = [
                    // Player Car
                    { id: 'user', x: spawnX + px * 20, y: spawnY + py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: userChassis.color, chassisId: userChassis.id, isAI: false, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, lapHistory: [], skidMarks: [], isDrifting: false, currentSkidId: 0, logicBlocks: userLogicBlocks, vehicleType: userVehicle.id, emoji: userVehicle.emoji, trailType: userVehicle.trailType },
                    // AI Cars (ê²½ë¡œ ê¸°ë°˜ AI, ëª¨ë‘ C01 ì„€ì‹œ, ê¸°ë³¸ ì°¨ëŸ‰ íƒ€ì…)
                    { id: 'ai1', x: spawnX - px * 20, y: spawnY - py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#ef4444', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                    { id: 'ai2', x: spawnX - dx * 40 - px * 10, y: spawnY - dy * 40 + py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#f59e0b', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                    { id: 'ai3', x: spawnX - dx * 40 + px * 10, y: spawnY - dy * 40 - py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#8b5cf6', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                ];
                draw(); // ì´ˆê¸°í™” í›„ ì¦‰ì‹œ ê·¸ë¦¬ê¸°
            }, [currentTrackIdx, getCurrentTrackPoints, userData, stopEngineSound, stopSkidSound, logicSlots, activeSlotIndex, currentVehicleId]);
            
            const togglePlay = async () => {
                initAudio(); 
                if (currentScreen !== 'race') return;

                if (gameState === 'finished' || gameState === 'idle') { 
                    resetGame(); // ê²Œì„ ì‹œì‘ ì „ ì°¨ëŸ‰ ì´ˆê¸°í™” ë° ê·¸ë¦¬ê¸°
                }
                
                const nextIsPlaying = !isPlaying;
                
                if (nextIsPlaying) {
                    setGameState('running');
                    
                    if (startTimeRef.current === 0) {
                        startTimeRef.current = performance.now();
                        cars.current.forEach(c => c.lapStartTime = startTimeRef.current);
                    }
                    if (!isMuted) startEngineSound();
                } else {
                    setGameState('idle');
                    stopEngineSound();
                    stopSkidSound();
                }
                
                setIsPlaying(nextIsPlaying);
                playClickSound();
            };
            
            // --- Logic Slot Handlers ---

            // **ì£¼ì˜: window.confirm ëŒ€ì‹  alert ì‚¬ìš©**
            const handleSaveSlot = (index) => {
                const newSlots = logicSlots.map((slot, i) => 
                    i === index ? { ...slot, blocks: blocks } : slot
                );
                setLogicSlots(newSlots);
                saveLogicData({ slots: newSlots, activeSlotIndex: index });
                playClickSound();
                alert(`ìŠ¬ë¡¯ ${index + 1} (${newSlots[index].name})ì— í˜„ì¬ ë¡œì§ì„ ì €ì¥í–ˆìŠµë‹ˆë‹¤!`);
                setActiveSlotIndex(index);
            };

            const handleLoadSlot = (index) => {
                if (index === activeSlotIndex) return; // ì´ë¯¸ ë¡œë“œë¨
                
                const slotToLoad = logicSlots[index];
                if (slotToLoad) {
                    setBlocks(slotToLoad.blocks || []);
                    setActiveSlotIndex(index);
                    saveLogicData({ slots: logicSlots, activeSlotIndex: index }); // Save active index
                    playClickSound();
                    resetGame(); // Reset game to apply new blocks immediately
                }
            };

            const handleUpdateSlotName = (index, newName) => {
                const safeName = newName.trim().substring(0, 15) || `ìŠ¬ë¡¯ ${index + 1}`; // 15ì ì œí•œ
                const newSlots = logicSlots.map((slot, i) => 
                    i === index ? { ...slot, name: safeName } : slot
                );
                setLogicSlots(newSlots);
                saveLogicData({ slots: newSlots, activeSlotIndex });
                playClickSound();
            };

            // --- React Hooks ---

            useEffect(() => {
                if (isPlaying) {
                    requestRef.current = requestAnimationFrame(update);
                } else {
                    cancelAnimationFrame(requestRef.current);
                    draw();
                    stopEngineSound(); 
                    stopSkidSound();
                }
                return () => {
                    cancelAnimationFrame(requestRef.current);
                    stopEngineSound();
                    stopSkidSound();
                };
            }, [isPlaying, blocks, gameState, physics]);

            // Initial Game/Auth Setup (Load User Data)
            useEffect(() => {
                const handleFirebaseReady = () => {
                    // loadUserDataëŠ” authReadyë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
                    const unsubscribeUser = loadUserData(setUserData, setAuthReady); 
                    
                    // authReadyê°€ ì„¤ì •ëœ í›„ Logicê³¼ AI ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.
                    // ì´ useEffectëŠ” authReadyê°€ ì„¤ì •ë˜ìë§ˆì ì‹¤í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
                    const unsubscribeLogic = loadLogicData(setLogicSlots, setActiveSlotIndex, setLogicReady);
                    const unsubscribeAI = loadAIDifficultyData(setAIDifficultyStats, setAIReady);
                    
                    return () => { 
                        if (unsubscribeUser) unsubscribeUser(); 
                        if (unsubscribeLogic) unsubscribeLogic();
                        if (unsubscribeAI) unsubscribeAI();
                    };
                };

                if (window.firebaseInitialized) {
                    return handleFirebaseReady();
                } else {
                    window.addEventListener('firebase-ready', handleFirebaseReady);
                    return () => window.removeEventListener('firebase-ready', handleFirebaseReady);
                }
            }, []);
            
            // Sync blocks with loaded logic slots on initial load or active slot change
            useEffect(() => {
                if (logicReady) {
                    const activeSlot = logicSlots[activeSlotIndex];
                    if (activeSlot) {
                         // blocksê°€ í˜„ì¬ í™œì„± ìŠ¬ë¡¯ì˜ ë‚´ìš©ê³¼ ë‹¤ë¥¼ ê²½ìš°ë§Œ ì—…ë°ì´íŠ¸ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
                         if (JSON.stringify(blocks) !== JSON.stringify(activeSlot.blocks)) {
                             setBlocks(activeSlot.blocks || []);
                         }
                    }
                }
            }, [logicReady, activeSlotIndex]);


            // Initial reset when Auth & Logic & AI are ready
            useEffect(() => {
                if (authReady && logicReady && aiReady) { // ğŸŒŸ aiReady ì¶”ê°€
                    resetGame(); 
                }
            }, [authReady, logicReady, aiReady]); // ğŸŒŸ aiReady ì¶”ê°€

            // Reset when track or chassis changes (if game is idle)
            useEffect(() => {
                if (authReady && logicReady && aiReady && gameState === 'idle') { // ğŸŒŸ aiReady ì¶”ê°€
                    resetGame();
                }
            }, [currentTrackIdx, userData.currentChassis, currentVehicleId]);
            
            // ğŸŒŸ [ì¶”ê°€ëœ useEffect] í™”ë©´ ì „í™˜ ì‹œ ì´ˆê¸°í™” ì²˜ë¦¬
            useEffect(() => {
                // ëª¨ë“  ë°ì´í„° ë¡œë”©ì´ ì™„ë£Œë˜ê³  (authReady, logicReady, aiReady),
                // í˜„ì¬ í™”ë©´ì´ 'race'ë¡œ ì„¤ì •ë˜ì—ˆì„ ë•Œë§Œ ì‹¤í–‰
                if (authReady && logicReady && aiReady && currentScreen === 'race') {
                    // ê²Œì„ ìƒíƒœê°€ 'running'ì´ ì•„ë‹ ë•Œ (ì¦‰, ìƒˆë¡œ ì‹œì‘í•˜ê±°ë‚˜ ë©ˆì·„ì„ ë•Œ)
                    if (gameState === 'idle' || gameState === 'finished') {
                        resetGame();
                    }
                }
            }, [currentScreen, authReady, logicReady, aiReady]); // currentScreen ë³€ê²½ì„ ì˜ì¡´ì„±ìœ¼ë¡œ ì¶”ê°€


            // Update physics constants when user data or parts change
            useEffect(() => {
                if (authReady) {
                    const newPhysics = getPhysicsConstants(userData.parts, userData.currentChassis);
                    setPhysics(newPhysics);
                    // ğŸŒŸ ë¶€í’ˆ ë³€ê²½ í›„ ìº”ë²„ìŠ¤ì— ì¦‰ì‹œ ë°˜ì˜ë˜ë„ë¡ ì¬ì„¤ì •
                    if(gameState === 'idle') {
                        resetGame();
                    }
                }
            }, [userData.parts, userData.currentChassis, authReady]);


            // --- Block Logic Handlers (Unchanged) ---
            const addBlock = () => {
                const newBlock = { id: Date.now(), flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 50, action: 'BRAKE_100' };
                setBlocks([...blocks, newBlock]);
                playClickSound();
            };

            const updateBlock = (id, field, value) => {
                // ë¸”ë¡ ìˆ˜ì • ì‹œ active slotì˜ blocksì™€ ë‹¤ë¥´ë©´ active indexë¥¼ -1ë¡œ ì„¤ì •í•˜ì—¬ 'ìˆ˜ì •ë¨' ìƒíƒœë¥¼ í‘œì‹œí•  ìˆ˜ë„ ìˆì§€ë§Œ,
                // ì—¬ê¸°ì„œëŠ” ë³µì¡ì„±ì„ ì¤„ì´ê¸° ìœ„í•´ í˜„ì¬ blocks ìƒíƒœë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
                setBlocks(blocks.map(b => b.id === id ? { ...b, [field]: value } : b));
            };

            const removeBlock = (id) => {
                setBlocks(blocks.filter(b => b.id !== id));
                playClickSound();
            };

            const toggleValueType = (id) => {
                setBlocks(blocks.map(b => {
                    if (b.id === id) {
                        const newType = b.valueType === 'number' ? 'sensor' : 'number';
                        const newValue = newType === 'number' ? 50 : 0; 
                        return { ...b, valueType: newType, value: newValue };
                    }
                    return b;
                }));
                playClickSound();
            };

            const toggleMute = () => {
                setIsMuted(!isMuted);
                playClickSound();
            }

            const fmtTime = (s) => s.toFixed(2) + 's';
            
            // --- Shop/Garage Logic (Upgraded Tiers) ---
            const purchasePart = (partId, currentTier) => {
                const nextTier = currentTier + 1;
                
                // ğŸŒŸ ìµœëŒ€ í‹°ì–´ ì²´í¬ ë¡œì§ ìˆ˜ì •
                if (currentTier >= MAX_TIER) {
                   console.error("ìµœê³  ë“±ê¸‰ì…ë‹ˆë‹¤!");
                   return;
                } 
                
                const nextStats = PART_STATS[nextTier];
                
                if (userData.dollars < nextStats.price) {
                    console.error("ë‹¬ëŸ¬ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); 
                    return;
                }

                const newDollars = userData.dollars - nextStats.price;
                const newParts = { ...userData.parts, [partId]: nextTier };
                saveUserData({ ...userData, dollars: newDollars, parts: newParts });
                playClickSound();
                alert(`${PART_TYPES.find(p=>p.id===partId).name} Tier ${nextTier} êµ¬ë§¤ ì™„ë£Œ!`);
            };
            
            const purchaseChassis = (chassisId, price) => {
                if (userData.currentChassis === chassisId) {
                    saveUserData({ ...userData, currentChassis: chassisId });
                    playClickSound();
                    console.log(`${CAR_CHASSIS.find(c=>c.id===chassisId).name}ìœ¼ë¡œ êµì²´ ì™„ë£Œ!`);
                    return;
                }
                if (userData.dollars < price) {
                    console.error("ë‹¬ëŸ¬ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!");
                    return;
                }
                
                const chassis = CAR_CHASSIS.find(c => c.id === chassisId);
                const newDollars = userData.dollars - price;
                saveUserData({ ...userData, dollars: newDollars, currentChassis: chassisId });
                playClickSound();
                console.log(`${chassis.name} êµ¬ë§¤ ë° ì¥ì°© ì™„ë£Œ!`);
            };

            // --- UI Components ---
            
            const ShopScreen = () => {
                const currentChassis = CAR_CHASSIS.find(c => c.id === userData.currentChassis) || CAR_CHASSIS[0];

                return (
                    <div className="p-4 lg:p-8 overflow-y-auto no-scrollbar max-w-4xl mx-auto h-full text-slate-200">
                        <h1 className="text-3xl font-extrabold text-yellow-400 mb-6 flex items-center gap-3 border-b border-slate-700 pb-2">
                            <ShoppingCart size={30} /> ìƒì  (Shop)
                        </h1>
                        <div className="flex justify-between items-center mb-6 p-3 bg-slate-700 rounded-lg shadow-inner">
                            <span className="text-lg font-semibold flex items-center gap-2"><DollarSign size={20} /> í˜„ì¬ ì”ì•¡:</span>
                            <span className="text-3xl font-mono text-green-400">${userData.dollars.toLocaleString()}</span>
                        </div>

                        {/* --- íŒŒì¸  ì—…ê·¸ë ˆì´ë“œ ì„¹ì…˜ --- */}
                        <h2 className="text-2xl font-bold text-blue-400 mt-8 mb-4">íŒŒì¸  ì—…ê·¸ë ˆì´ë“œ (Parts Upgrade)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {PART_TYPES.map(part => {
                                const currentTier = userData.parts[part.id];
                                const nextTier = currentTier + 1;
                                const currentStats = PART_STATS[currentTier];
                                const nextStats = PART_STATS[nextTier];
                                
                                const statKey = getPartStatKey(part.id);

                                const currentVal = currentStats ? currentStats[statKey] : 0; 
                                const nextVal = nextStats ? nextStats[statKey] : null;
                                
                                // ğŸŒŸ MAX TIER ë¡œì§ ìˆ˜ì •
                                const isMaxTier = currentTier >= MAX_TIER;
                                const precision = (part.id === 'tire' || part.id === 'downforce' || part.id === 'steering') ? 3 : 2;

                                return (
                                    <div key={part.id} className="bg-slate-700 p-4 rounded-lg shadow-lg border-l-4 border-slate-600 hover:border-blue-500 transition">
                                        <h3 className="text-xl font-bold mb-2 uppercase">{part.name}</h3>
                                        <div className="text-sm text-slate-400 mb-3">{part.unit} í–¥ìƒ</div>
                                        
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-sm">í˜„ì¬ ë“±ê¸‰:</span>
                                            <span className={`font-bold text-lg ${currentTier === MAX_TIER ? 'text-yellow-500' : 'text-slate-200'}`}>Tier {currentTier} / {MAX_TIER}</span>
                                        </div>

                                        <div className="flex justify-between items-center mb-4">
                                            <span className="text-sm">í˜„ì¬ ì„±ëŠ¥:</span>
                                            <span className="font-mono text-base text-blue-300">{currentVal.toFixed(precision)}</span>
                                        </div>

                                        <div className="border-t border-slate-600 pt-3">
                                            {isMaxTier ? (
                                                <span className="text-lg font-bold text-green-500">MAX TIER ë‹¬ì„±</span>
                                            ) : (
                                                <div className="flex flex-col gap-2">
                                                    <div className="flex justify-between text-sm text-slate-400">
                                                        <span>ë‹¤ìŒ ë“±ê¸‰ (T{nextTier}):</span>
                                                        <span className="font-mono text-yellow-300">+{nextVal !== null ? (nextVal - currentVal).toFixed(precision) : 'N/A'}</span>
                                                    </div>
                                                    <button
                                                        onClick={() => purchasePart(part.id, currentTier)}
                                                        className="w-full py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-500 transition disabled:bg-slate-500"
                                                        disabled={userData.dollars < nextStats.price}
                                                    >
                                                        ${nextStats.price.toLocaleString()} êµ¬ë§¤
                                                    </button>
                                                    {userData.dollars < nextStats.price && <span className="text-red-400 text-xs text-center">ì”ì•¡ ë¶€ì¡±</span>}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {/* --- ì°¨ëŸ‰ ì„€ì‹œ ì„¹ì…˜ --- */}
                        <h2 className="text-2xl font-bold text-blue-400 mt-10 mb-4">ì°¨ëŸ‰ ì„€ì‹œ (Chassis)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {CAR_CHASSIS.map(chassis => {
                                const isOwned = userData.currentChassis === chassis.id;
                                const isPurchased = chassis.id !== 'C01' && userData.dollars >= chassis.price;

                                return (
                                    <div key={chassis.id} className={`bg-slate-700 p-4 rounded-lg shadow-lg border-l-4 ${isOwned ? 'border-yellow-500' : 'border-slate-600'} hover:border-yellow-500 transition`}>
                                        <div className="w-full h-10 flex justify-center items-center mb-2">
                                            <div className="w-16 h-8 rounded-md shadow-xl" style={{ backgroundColor: chassis.color }}></div>
                                        </div>
                                        <h3 className="text-xl font-bold mb-1 text-center">{chassis.name}</h3>
                                        <div className="text-xs text-slate-400 text-center mb-3">{chassis.id}</div>
                                        
                                        <ul className="text-sm space-y-1 mb-4 border-t border-slate-600 pt-2">
                                            <li className="flex justify-between">ê°€ì† ê¸°ë°˜: <span>{chassis.baseAccel}</span></li>
                                            <li className="flex justify-between">ì ‘ì§€ ê¸°ë°˜: <span>{chassis.baseGrip}</span></li>
                                            <li className="flex justify-between">ìµœê³  ì†ë„ ë³´ë„ˆìŠ¤: <span>+{chassis.maxSpeedBonus}</span></li>
                                        </ul>

                                        <button
                                            onClick={() => purchaseChassis(chassis.id, chassis.price)}
                                            className={`w-full py-2 font-bold rounded-lg transition disabled:bg-slate-500 ${isOwned ? 'bg-yellow-500 text-slate-900' : (chassis.id === 'C01' || isPurchased ? 'bg-green-600 text-white' : 'bg-slate-600 text-slate-300')}`}
                                            disabled={!isOwned && chassis.id !== 'C01' && userData.dollars < chassis.price}
                                        >
                                            {isOwned ? 'í˜„ì¬ ì¥ì°©ë¨' : (chassis.id === 'C01' ? 'ê¸°ë³¸ ì¥ì°©' : (userData.dollars >= chassis.price ? `êµ¬ë§¤ ë° ì¥ì°© ($${chassis.price.toLocaleString()})` : 'ì”ì•¡ ë¶€ì¡±'))}
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            // --- Main App Render ---
            
            if (!authReady || !logicReady || !aiReady) { // ğŸŒŸ aiReady ì¡°ê±´ ì¶”ê°€
                return <div className="flex h-screen items-center justify-center text-xl text-blue-400">ë°ì´í„° ë¡œë”© ì¤‘...</div>;
            }

            return (
                <div className="flex flex-col-reverse lg:flex-row h-screen bg-slate-900 text-slate-100 overflow-hidden font-sans">
                    
                    {/* --- Sidebar: Coding Area / Shop / Garage (Width: 40% on LG, Height: 70% on mobile) --- */}
                    <div className="w-full lg:w-[40%] h-[70%] lg:h-full flex flex-col border-t lg:border-t-0 lg:border-r border-slate-700 bg-slate-800 shadow-xl z-20">
                        
                        {/* Tab Navigation */}
                        <div className="flex justify-between items-center p-2 bg-slate-900 border-b border-slate-700">
                            <div className="flex gap-2">
                                <button 
                                    onClick={() => { setCurrentScreen('race'); playClickSound(); }} 
                                    className={`px-3 py-1.5 rounded-t-lg font-bold text-sm lg:text-base transition ${currentScreen === 'race' ? 'bg-slate-800 text-blue-400' : 'text-slate-400 hover:bg-slate-700'}`}>
                                    <Cpu size={18} className="inline-block mr-1" /> ë¡œì§ ì—ë””í„°
                                </button>
                                <button 
                                    onClick={() => { setCurrentScreen('shop'); playClickSound(); }} 
                                    className={`px-3 py-1.5 rounded-t-lg font-bold text-sm lg:text-base transition ${currentScreen === 'shop' ? 'bg-slate-800 text-yellow-400' : 'text-slate-400 hover:bg-slate-700'}`}>
                                    <ShoppingCart size={18} className="inline-block mr-1" /> ìƒì 
                                </button>
                            </div>
                            {currentScreen === 'shop' && (
                                    <div className="flex items-center gap-2 text-sm lg:text-base font-semibold text-green-400">
                                        <DollarSign size={16} /> ${userData.dollars.toLocaleString()}
                                    </div>
                            )}
                        </div>

                        {/* --- Logic Editor Screen --- */}
                        {currentScreen === 'race' && (
                            <React.Fragment>
                                {/* ë¡œì§ ìŠ¬ë¡¯ ê´€ë¦¬ UI (Padding Reduced, Text Smaller) */}
                                <div className="p-2 lg:p-3 bg-slate-900 border-b border-slate-700 space-y-2 lg:space-y-3">
                                    <h3 className="text-xs lg:text-sm font-bold text-slate-400 flex items-center gap-2">
                                        <Folder size={14} /> ë¡œì§ ìŠ¬ë¡¯ (5ê°œ)
                                    </h3>
                                    <div className="grid grid-cols-5 gap-1 lg:gap-2">
                                        {logicSlots.map((slot, index) => (
                                            <div key={index} className="flex flex-col gap-1 items-stretch">
                                                <input 
                                                    type="text"
                                                    value={slot.name}
                                                    onChange={(e) => handleUpdateSlotName(index, e.target.value)}
                                                    className={`bg-slate-700 text-[10px] lg:text-xs text-center px-1 py-0.5 rounded-t-lg border-b-2 outline-none transition ${index === activeSlotIndex ? 'border-yellow-500 text-yellow-300 font-bold' : 'border-slate-600 text-slate-300'}`}
                                                    placeholder={`ìŠ¬ë¡¯ ${index + 1}`}
                                                    maxLength={15}
                                                />
                                                <div className="flex gap-1 justify-stretch">
                                                    <button
                                                        onClick={() => handleLoadSlot(index)}
                                                        className={`flex-1 text-[9px] lg:text-[10px] py-0.5 rounded-b-lg font-bold transition disabled:opacity-50 ${index === activeSlotIndex ? 'bg-yellow-500 text-slate-900' : 'bg-slate-600 hover:bg-blue-500'}`}
                                                        disabled={index === activeSlotIndex}
                                                    >
                                                        {index === activeSlotIndex ? 'í™œì„±' : 'ë¡œë“œ'}
                                                    </button>
                                                    <button
                                                        onClick={() => handleSaveSlot(index)}
                                                        className={`text-[9px] lg:text-[10px] py-0.5 px-1 rounded-b-lg font-bold bg-green-600 text-white hover:bg-green-500 transition flex items-center justify-center`}
                                                        title={`${index === activeSlotIndex ? 'í˜„ì¬ í™œì„± ìŠ¬ë¡¯ì— ë®ì–´ì“°ê¸°' : 'í˜„ì¬ ë¡œì§ì„ ì €ì¥'}`}
                                                    >
                                                        <Save size={12} />
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                {/* // ë¡œì§ ìŠ¬ë¡¯ ê´€ë¦¬ UI ë */}


                                {/* ê²Œì„ ì»¨íŠ¸ë¡¤ ë° íŒŒì¸  ì„±ëŠ¥ (Padding Reduced, Controls consolidated) */}
                                <div className="p-2 lg:p-3 bg-slate-900 border-b border-slate-700 space-y-1 lg:space-y-2">
                                    <div className="flex justify-between items-center">
                                        <h2 className="text-sm lg:text-base font-bold flex items-center gap-1 text-blue-400">
                                            <Wrench size={16} /> íŒŒì¸  ì„±ëŠ¥: {physics.acceleration.toFixed(2)} / {physics.maxSpeed.toFixed(1)}
                                        </h2>
                                        <div className="flex gap-1 lg:gap-2">
                                            <button onClick={() => { resetGame(); playClickSound(); }} className="p-1 lg:p-1.5 bg-slate-700 hover:bg-slate-600 rounded-lg transition" title="ì´ˆê¸°í™”">
                                                <RotateCcw size={16} />
                                            </button>
                                            <button onClick={togglePlay} className={`p-1 lg:p-1.5 rounded-lg transition flex items-center gap-1 lg:gap-2 font-bold px-2 lg:px-3 text-sm lg:text-base ${isPlaying ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-green-600 hover:bg-green-500'}`}>
                                                {isPlaying ? <Pause size={16} /> : <Play size={16} />}
                                                {isPlaying ? 'ì¼ì‹œì •ì§€' : 'ì‹œì‘'}
                                            </button>
                                        </div>
                                    </div>
                                    
                                    {/* ğŸŒŸ ìºë¦­í„° ì„ íƒ (New UI element) */}
                                    <div className="flex items-center gap-2 bg-slate-800 p-1 lg:p-1.5 rounded-lg border border-slate-700">
                                        <Car size={14} className="text-slate-400" />
                                        <select 
                                            className="bg-transparent text-sm lg:text-base w-full outline-none text-slate-200"
                                            value={currentVehicleId}
                                            onChange={(e) => { 
                                                setCurrentVehicleId(e.target.value); 
                                                playClickSound(); 
                                                resetGame(); 
                                            }}
                                        >
                                            {VEHICLE_TYPES.map((v) => (
                                                <option key={v.id} value={v.id}>{v.emoji} {v.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    {/* íŠ¸ë™ ì„ íƒ (í¬ê¸° ìœ ì§€) */}
                                    <div className="flex items-center gap-2 bg-slate-800 p-1 lg:p-1.5 rounded-lg border border-slate-700">
                                        <MapIcon size={14} className="text-slate-400" />
                                        <select 
                                            className="bg-transparent text-sm lg:text-base w-full outline-none text-slate-200"
                                            value={currentTrackIdx}
                                            onChange={(e) => { setCurrentTrackIdx(Number(e.target.value)); playClickSound(); }}
                                        >
                                            {TRACK_LAYOUTS.map((track, idx) => (
                                                <option key={track.id} value={idx}>{track.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                </div>


                                {/* ë¡œì§ ë¸”ë¡ í¸ì§‘ ì˜ì—­ (Main focus area) */}
                                <div className="flex-1 overflow-y-auto p-2 lg:p-4 space-y-2 lg:space-y-3 no-scrollbar">
                                    {blocks.length === 0 && (<div className="text-slate-500 text-center py-10 italic text-sm">ë¡œì§ ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>)}
                                    
                                    {blocks.map((block) => {
                                        const flow = FLOW_OPTIONS.find(f => f.value === block.flowType);
                                        const isElse = block.flowType === 'ELSE';
                                        const isIfElseIf = block.flowType === 'IF' || block.flowType === 'ELSE_IF';
                                        const borderClass = flow ? flow.color : 'border-slate-500';

                                        // ì•¡ì…˜ ì´ë¦„ ë° ìƒ‰ìƒ ë§¤í•‘
                                        let actionClass = 'bg-slate-900 text-slate-200';
                                        if (block.action.startsWith('LEFT') || block.action.startsWith('RIGHT')) {
                                            actionClass = 'bg-indigo-900 text-indigo-200';
                                        } else if (block.action.startsWith('ACCEL')) {
                                            actionClass = 'bg-green-900 text-green-200';
                                        } else if (block.action.startsWith('BRAKE')) {
                                            actionClass = 'bg-red-900 text-red-200';
                                        }

                                        return (
                                            <div key={block.id} className={`bg-slate-700 p-2 lg:p-3 rounded-lg border-l-4 ${borderClass} shadow-sm flex items-center gap-1.5 lg:gap-2 flex-wrap text-xs lg:text-sm group`}>
                                                
                                                <select className={`bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none font-bold max-w-[100px] lg:max-w-[120px] 
                                                     ${block.flowType === 'ELSE' ? 'w-full' : ''}`}
                                                    value={block.flowType} onChange={(e) => updateBlock(block.id, 'flowType', e.target.value)}>
                                                    {FLOW_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                                                </select>

                                                {isIfElseIf && (
                                                    <React.Fragment>
                                                        <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none max-w-[80px] lg:max-w-none"
                                                            value={block.sensor} onChange={(e) => updateBlock(block.id, 'sensor', parseInt(e.target.value))}>
                                                            {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                                        </select>
                                                        
                                                        <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                                            value={block.operator} onChange={(e) => updateBlock(block.id, 'operator', e.target.value)}>
                                                            {OPERATOR_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                                                        </select>

                                                        <button onClick={() => toggleValueType(block.id)}
                                                            className="p-1 rounded bg-slate-600 hover:bg-slate-500 text-slate-200 transition"
                                                            title={block.valueType === 'number' ? "ìˆ«ìì™€ ë¹„êµí•˜ê¸°" : "ë‹¤ë¥¸ ì„¼ì„œì™€ ë¹„êµí•˜ê¸°"}>
                                                            {block.valueType === 'number' ? <Hash size={12} /> : <Radar size={12} />}
                                                        </button>
                                                        
                                                        {block.valueType === 'number' ? (
                                                            <input type="number" className="bg-slate-900 border border-slate-600 rounded w-12 lg:w-16 px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                                                value={block.value} 
                                                                onChange={(e) => {
                                                                    const val = parseInt(e.target.value);
                                                                    updateBlock(block.id, 'value', isNaN(val) ? 0 : val);
                                                                }} 
                                                            />
                                                        ) : (
                                                            <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none w-20 lg:w-24"
                                                                value={block.value} onChange={(e) => updateBlock(block.id, 'value', parseInt(e.target.value))}>
                                                                {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                                            </select>
                                                        )}
                                                    </React.Fragment>
                                                )}

                                                <span className="font-bold text-blue-300">â†’</span>
                                                
                                                {/* ğŸŒŸ í™•ì¥ëœ ì•¡ì…˜ ë“œë¡­ë‹¤ìš´ */}
                                                <select className={`border border-slate-600 rounded px-1 lg:px-2 py-1 font-bold outline-none flex-grow ${actionClass}
                                                     ${isElse ? 'w-full' : ''}`}
                                                    value={block.action} onChange={(e) => updateBlock(block.id, 'action', e.target.value)}>
                                                    <option value="LEFT">ì¢ŒíšŒì „</option>
                                                    <option value="RIGHT">ìš°íšŒì „</option>
                                                    <option value="ACCEL_100">ê°€ì† (100%)</option>
                                                    <option value="ACCEL_75">ê°€ì† (75%)</option>
                                                    <option value="ACCEL_50">ê°€ì† (50%)</option>
                                                    <option value="BRAKE_100">ê°ì† (100%)</option>
                                                    <option value="BRAKE_75">ê°ì† (75%)</option>
                                                    <option value="BRAKE_50">ê°ì† (50%)</option>
                                                </select>
                                                <button onClick={() => removeBlock(block.id)} className="text-slate-500 hover:text-red-400 ml-auto opacity-100 lg:opacity-0 group-hover:opacity-100 transition"><Trash2 size={14} /></button>
                                            </div>
                                        );
                                    })}

                                    <button onClick={addBlock} className="w-full py-2 lg:py-3 border-2 border-dashed border-slate-600 text-slate-400 rounded-lg hover:border-blue-500 hover:text-blue-400 transition flex justify-center items-center gap-2 text-sm lg:text-base">
                                        <Plus size={16} /> ë¡œì§ ë¸”ë¡ ì¶”ê°€
                                    </button>
                                </div>
                            </React.Fragment>
                        )}

                        {/* --- Shop Screen --- */}
                        {currentScreen === 'shop' && <ShopScreen />}

                    </div>

                    {/* --- Main View: Canvas (Width: 60% on LG, Height: 30% on mobile) --- */}
                    <div className="w-full lg:flex-1 h-[30%] lg:h-full relative bg-neutral-800 flex justify-center items-center p-2 lg:p-4 overflow-hidden">
                        {currentScreen === 'race' ? (
                            <canvas ref={canvasRef} width={TRACK_WIDTH} height={TRACK_HEIGHT}
                                className="bg-green-500 rounded-xl shadow-2xl max-w-full max-h-full object-contain cursor-crosshair" />
                        ) : (
                            <div className="text-slate-400 text-center text-xl">ìƒì ì—ì„œ íŒŒì¸ ë¥¼ í™•ì¸í•´ ë³´ì„¸ìš”!</div>
                        )}
                        
                        {/* Top Left: Lap Time History Panel (Visible on race screen only) */}
                        {currentScreen === 'race' && (
                            <div className="absolute top-2 left-2 lg:top-6 lg:left-6 pointer-events-none scale-75 lg:scale-100 origin-top-left">
                                <div className="bg-slate-900/90 backdrop-blur p-3 rounded-xl border border-slate-700 shadow-xl space-y-2 min-w-[140px]">
                                    <div className="text-[10px] uppercase tracking-widest text-slate-400 border-b border-slate-700 pb-1 mb-1">Lap History</div>
                                    {[...Array(TOTAL_LAPS)].map((_, i) => {
                                        const lapTime = userStats.lapHistory[i];
                                        const isCurrent = userStats.laps === i;
                                        return (
                                            <div key={i} className="flex justify-between items-center text-xs font-mono">
                                                <span className={isCurrent ? 'text-yellow-400 font-bold' : 'text-slate-500'}>LAP {i + 1}</span>
                                                <span className={isCurrent ? 'text-white' : (lapTime ? 'text-green-400' : 'text-slate-600')}>
                                                    {lapTime ? fmtTime(lapTime) : (isCurrent ? fmtTime(userStats.currentLapTime) : '--:--')}
                                                </span>
                                            </div>
                                        )
                                    })}
                                    <div className="border-t border-slate-700 pt-1 flex justify-between items-center text-xs font-mono text-blue-300 mt-1">
                                        <span>TOTAL</span>
                                        <span>{fmtTime(userStats.totalTime)}</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Top Right State Badge & Mute (Visible on race screen only) */}
                        {currentScreen === 'race' && (
                            <React.Fragment>
                                <div className="absolute top-2 right-2 lg:top-6 lg:right-6 pointer-events-auto flex gap-2">
                                    <button onClick={toggleMute} className="bg-slate-900/80 backdrop-blur p-2 rounded-full border border-slate-700 shadow-lg text-slate-300 hover:bg-slate-800 transition scale-90 lg:scale-100">
                                        {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
                                    </button>
                                    <div className="bg-slate-900/80 backdrop-blur px-3 py-1 lg:px-6 lg:py-2 rounded-full border border-slate-700 shadow-lg flex items-center gap-2 lg:gap-4 scale-90 lg:scale-100 origin-top-right">
                                        <div className="text-slate-400 text-[10px] lg:text-xs uppercase tracking-widest">ìƒíƒœ</div>
                                        <div className={`text-base lg:text-xl font-black italic ${gameState === 'running' ? 'text-green-400' : 'text-slate-200'}`}>
                                            {gameState === 'idle' && 'READY'}
                                            {gameState === 'running' && 'RUN'}
                                            {gameState === 'finished' && 'FINISH'}
                                        </div>
                                    </div>
                                </div>

                                {/* Winner Badge */}
                                {gameState === 'finished' && (
                                    <div className="absolute top-12 lg:top-6 left-0 right-0 flex justify-center gap-4 px-4 pointer-events-none">
                                        {/* ğŸŒŸ UI ë³´ìƒ ê¸ˆì•¡ ìˆ˜ì • ë°˜ì˜ */}
                                        <div className={`bg-slate-900/90 backdrop-blur px-4 py-2 lg:px-6 lg:py-3 rounded-full border border-slate-700 shadow-2xl flex items-center gap-2 font-bold animate-bounce ${winner === 'user' ? 'text-yellow-400' : 'text-red-400'} text-sm lg:text-base`}>
                                            <Trophy size={16} />
                                            {winner === 'user' ? `ìš°ìŠ¹! ($1000+ íšë“)` : 'íŒ¨ë°°! ($300 íšë“)'}
                                        </div>
                                    </div>
                                )}

                                {/* ğŸŒŸ ì´ë™ëœ ì‹¤ì‹œê°„ ì„¼ì„œ ê±°ë¦¬ (Bottom Right) ğŸŒŸ */}
                                <div className="absolute bottom-2 right-2 lg:bottom-4 lg:right-4 pointer-events-none scale-75 lg:scale-100 origin-bottom-right">
                                    <div className="bg-slate-900/90 backdrop-blur p-2 lg:p-3 rounded-xl border border-slate-700 shadow-xl space-y-1">
                                        <div className="flex items-center gap-2 mb-1 text-[9px] lg:text-[10px] uppercase tracking-wider text-slate-400">
                                            <Activity size={10} /> ì‹¤ì‹œê°„ ì„¼ì„œ ê±°ë¦¬
                                        </div>
                                        <div className="grid grid-cols-5 gap-1 text-center">
                                            {sensorReadings.map((val, idx) => {
                                                const labels = ['ì¢Œì¸¡', 'ì „ë°©ì¢Œì¸¡', 'ì „ë°©', 'ì „ë°©ìš°ì¸¡', 'ìš°ì¸¡'];
                                                const color = val < 50 ? 'text-red-400' : 'text-green-400';
                                                return (
                                                    <div key={idx} className="bg-slate-800 p-0.5 lg:p-1 rounded border border-slate-700">
                                                        <div className="text-[7px] lg:text-[9px] text-slate-500">{labels[idx]}</div>
                                                        <div className={`font-mono text-[9px] lg:text-xs font-bold ${color}`}>{Math.round(val)}</div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* AI Lap Counters (Bottom Left) */}
                                <div className="absolute bottom-2 left-2 lg:bottom-4 lg:left-4 flex gap-2 lg:gap-4 scale-75 lg:scale-100 origin-bottom-left">
                                    {cars.current.slice(1).map(c => (
                                        <div key={c.id} className="bg-slate-900/80 backdrop-blur p-1.5 lg:p-2 rounded border border-slate-700 flex flex-col items-center min-w-[50px] lg:min-w-[60px]">
                                            <div className="w-2.5 h-2.5 lg:w-3 lg:h-3 rounded-full mb-1" style={{backgroundColor: c.color}}></div>
                                            <div className="text-[9px] lg:text-xs text-slate-400">{c.id.toUpperCase()}</div>
                                            <div className="font-mono font-bold text-xs lg:text-sm">{c.laps}/{TOTAL_LAPS}</div>
                                        </div>
                                    ))}
                                </div>
                            </React.Fragment>
                        )}
                    </div>
                </div>
            );
        };

        const root = window.ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
