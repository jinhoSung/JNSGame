<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÏûêÏú®Ï£ºÌñâ Î†àÏù¥Ïã± (Shop & Firebase)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        
        // setLogLevel('Debug'); // ÎîîÎ≤ÑÍπÖ Ïãú Ï£ºÏÑù Ìï¥Ï†ú

        // --- Firebase Globals Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        if (firebaseConfig) {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            const db = getFirestore(app);

            // Export Firestore functions to window for use in the Babel script
            window.firebaseApp = app;
            window.firebaseAuth = auth;
            window.firestoreDB = db;
            window.doc = doc;      
            window.setDoc = setDoc;    
            window.onSnapshot = onSnapshot;  
            
            window.firebaseInitialized = false;

            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth failed:", error);
                    }
                }
                if (user && !window.firebaseInitialized) {
                    window.firebaseInitialized = true;
                    // Trigger custom event to notify React app that Firebase is ready
                    window.dispatchEvent(new CustomEvent('firebase-ready'));
                }
            });
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #f1f5f9; font-family: sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        /* Ïª§Ïä§ÌÖÄ Tailwind ÌÅ¥ÎûòÏä§: w-[40%]Î•º Ï†ïÌôïÌûà ÎßûÏ∂•ÎãàÎã§. */
        .lg-w-40-percent { width: 40%; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = window.React; 

        // --- Icon Components (Inline SVG) ---
        const Play = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>);
        const Pause = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>);
        const RotateCcw = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>);
        const Plus = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>);
        const Trash2 = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>);
        const Cpu = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x="9" y="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>);
        const Activity = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>);
        const Trophy = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 21h8m-4-9v9m-8-2.5a6 6 0 0 1 12 0v2.5"></path><path d="M16 3h-8"></path><path d="M7 3v7a5 5 0 0 0 10 0V3"></path><path d="M19 6h2a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-2"></path><path d="M5 6H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h2"></path></svg>);
        const Hash = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>);
        const Radar = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z"></path><path d="M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path><line x1="12" y1="2" x2="12" y2="4"></line><line x1="12" y1="20" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="6.34" y2="6.34"></line><line x1="17.66" y1="17.66" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="4" y2="12"></line><line x1="20" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="6.34" y2="17.66"></line><line x1="17.66" y1="6.34" x2="19.07" y2="4.93"></line></svg>);
        const Timer = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="10" y1="2" x2="14" y2="2"></line><line x1="12" y1="14" x2="15" y2="11"></line><circle cx="12" cy="14" r="8"></circle></svg>);
        const Flag = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>);
        const MapIcon = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>);
        const Volume2 = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>);
        const VolumeX = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>);
        const ShoppingCart = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>);
        const Wrench = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-3.76 3.76a1 1 0 0 0-1.4 0l-1.6-1.6a1 1 0 0 0 0-1.4l3.77-3.77a6 6 0 0 1 7.94-7.94l-3.76-3.76z"></path><path d="M21.5 2L17 6.5"></path><path d="M19.4 12.6l-2.6 2.6"></path><path d="M12.6 19.4l-2.6 2.6"></path><path d="M16 16l-1.4 1.4"></path><path d="M14 10l-1.4 1.4"></path><path d="M6 6L2 2"></path></svg>);
        const DollarSign = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>);
        const Save = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>);
        const Folder = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 8.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2z"></path></svg>);
        const Car = ({size=24, className=""}) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 17h2a1 1 0 0 0 0-2h-2"></path><path d="M5 17H3a1 1 0 0 1 0-2h2"></path><path d="M21 14V8a2 2 0 0 0-2-2h-1c-1 0-4 1-4 1s-3-1-4-1H5a2 2 0 0 0-2 2v6"></path><path d="M8 10h.01"></path><path d="M16 10h.01"></path><path d="M7 21h10"></path><path d="M12 14v7"></path><path d="M10 14h4"></path></svg>);


        // --- Constants & Config ---
        const TRACK_WIDTH = 800;
        const TRACK_HEIGHT = 600;
        const FPS = 60;
        const CAR_SIZE = { width: 24, height: 14 };
        const MAP_SCALE = 1.0; 
        const MAX_SKID_MARKS = 50; 
        const TOTAL_LAPS = 3;

        // Detection Radius Config
        const CHECKPOINT_RADIUS_NORMAL = 120; 

        // Track Aesthetics
        const TRACK_AESTHETICS = {
            border: 90, 
            curb: 80,   
            asphalt: 70 
        };

        // üåü ÏßÄÌòïÎ≥Ñ ÏÉâÏÉÅ Î∞è Î¨ºÎ¶¨ ÌäπÏÑ± Ï†ïÏùò (Ice, Gravel, Water)
        const TERRAIN_PROPERTIES = {
            asphalt: { trackColor: '#334155', groundColor: '#4ade80', frictionFactor: 1.0, turnFactor: 1.0, skidColor: 'rgba(20, 20, 20, 0.3)' },
            ice: { trackColor: '#80cedd', groundColor: '#f8fafc', frictionFactor: 0.3, turnFactor: 1.0, skidColor: 'rgba(173, 216, 230, 0.6)' }, // Îß§Ïö∞ ÎØ∏ÎÅÑÎü¨ÏõÄ
            gravel: { trackColor: '#8b5e3c', groundColor: '#b4a595', frictionFactor: 0.85, turnFactor: 0.7, skidColor: 'rgba(139, 69, 19, 0.6)' }, // Ï°∞Ìñ• Ïñ¥Î†§ÏõÄ, ÎßàÏ∞∞ Í∞êÏÜå
            water: { trackColor: '#1e3a8a', groundColor: '#3b82f6', frictionFactor: 0.6, turnFactor: 0.8, skidColor: 'rgba(0, 191, 255, 0.6)' } // Í∞êÏÜç Î∞è Ï°∞Ìñ• Ïñ¥Î†§ÏõÄ
        };

        const SENSOR_LABELS = {
            0: 'Ï¢åÏ∏° ÏÑºÏÑú', 1: 'Ï†ÑÎ∞© Ï¢åÏ∏°', 2: 'Ï†ÑÎ∞© ÏÑºÏÑú', 3: 'Ï†ÑÎ∞© Ïö∞Ï∏°', 4: 'Ïö∞Ï∏° ÏÑºÏÑú'
        };

        const OPERATOR_OPTIONS = [
            { value: '<', label: 'ÏûëÎã§Î©¥ (<)' }, { value: '>', label: 'ÌÅ¨Îã§Î©¥ (>)' }, 
            { value: '<=', label: 'Í∞ôÍ±∞ÎÇò ÏûëÎã§Î©¥ (<=)' }, { value: '>=', label: 'Í∞ôÍ±∞ÎÇò ÌÅ¨Îã§Î©¥ (>=)' }, 
            { value: '==', label: 'Í∞ôÎã§Î©¥ (==)' }, { value: '!=', label: 'Í∞ôÏßÄ ÏïäÎã§Î©¥ (!=)' },
        ];
        
        const FLOW_OPTIONS = [
            { value: 'IF', label: 'ÎßåÏïΩ (IF)', color: 'border-blue-500' },
            { value: 'ELSE_IF', label: 'ÏïÑÎãàÎ©¥ ÎßåÏïΩ (ELSE IF)', color: 'border-indigo-500' },
            { value: 'ELSE', label: 'ÏïÑÎãàÎ©¥ (ELSE)', color: 'border-purple-500' },
        ];

        // üåü Í∏∞Î≥∏ Î°úÏßÅ Î∏îÎ°ù (ÏÇ¨Ïö©Ïûê Ï¥àÍ∏∞ Î°úÏßÅ)
        const INITIAL_BLOCKS = [
            { id: 1, flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 80, action: 'BRAKE_100' },
            { id: 2, flowType: 'ELSE_IF', sensor: 0, operator: '>', valueType: 'sensor', value: 4, action: 'RIGHT' },
            { id: 3, flowType: 'ELSE_IF', sensor: 4, operator: '>', valueType: 'sensor', value: 0, action: 'LEFT' },
            { id: 4, flowType: 'ELSE', sensor: 2, operator: '>', valueType: 'number', value: 0, action: 'ACCEL_100' },
        ];

        // --- üåü Ï∫êÎ¶≠ÌÑ∞/Ï∞®Îüâ ÌÉÄÏûÖ Ï†ïÏùò ---
        const VEHICLE_TYPES = [
            { id: 'car', name: 'ÏûêÏú®Ï£ºÌñâ ÏûêÎèôÏ∞®', emoji: 'üöó', trailType: 'skid' },
            { id: 'dragon', name: 'Î∂à ÎøúÎäî ÎìúÎûòÍ≥§', emoji: 'üêâ', trailType: 'dust' },
            { id: 'horse', name: 'Í≤ΩÏ£ºÎßà', emoji: 'üêé', trailType: 'dust' },
            { id: 'rocket', name: 'Î°úÏºì Ï∞®Îüâ', emoji: 'üöÄ', trailType: 'skid' },
            { id: 'ufo', name: 'ÎØ∏ÌôïÏù∏ ÎπÑÌñâÎ¨ºÏ≤¥', emoji: 'üõ∏', trailType: 'none' }, 
        ];


        // --- ÌååÏ∏† Î∞è Ï∞®Îüâ Îç∞Ïù¥ÌÑ∞ (Íµ¨Îß§ ÏãúÏä§ÌÖú) ---
        const PART_TYPES = [
            { id: 'engine', name: 'ÏóîÏßÑ', unit: 'Í∞ÄÏÜçÎ†• (Accel)' },
            { id: 'gearbox', name: 'Î≥ÄÏÜçÍ∏∞', unit: 'ÏµúÍ≥†ÏÜçÎèÑ (Max Speed)' },
            { id: 'tire', name: 'ÌÉÄÏù¥Ïñ¥', unit: 'ÎßàÏ∞∞Î†• (Friction)' },
            { id: 'steering', name: 'Ïä§Ìã∞Ïñ¥ÎßÅ', unit: 'Ï°∞Ìñ• ÏÜçÎèÑ (Turn Speed)' },
            { id: 'downforce', name: 'Îã§Ïö¥Ìè¨Ïä§ Ïúô', unit: 'Ï†ëÏßÄÎ†• (Grip)' },
            { id: 'sensor', name: 'ÏÑºÏÑú Î™®Îìà', unit: 'ÏÑºÏÑú Î≤îÏúÑ (Range)' },
        ];
        
        // üåü Ìã∞Ïñ¥ ÌôïÏû•: 0Î∂ÄÌÑ∞ 5ÍπåÏßÄ Ï¥ù 6Îã®Í≥Ñ. Ï¶ùÍ∞ÄÌè≠ Í∞êÏÜå.
        const PART_STATS = {
            // Tier 0 (Base stats derived from C01)
            '0': { 
                acceleration: 0.70, maxSpeedMod: 9.0, friction: 0.930, turnSpeed: 0.080, gripFactor: 0.050, sensorRange: 150
            },
            // Tier 1
            '1': {
                acceleration: 0.78, maxSpeedMod: 10.0, friction: 0.935, turnSpeed: 0.090, gripFactor: 0.070, sensorRange: 175, price: 1000
            },
            // Tier 2
            '2': {
                acceleration: 0.86, maxSpeedMod: 11.0, friction: 0.940, turnSpeed: 0.100, gripFactor: 0.090, sensorRange: 200, price: 2000
            },
            // Tier 3
            '3': {
                acceleration: 0.95, maxSpeedMod: 12.5, friction: 0.945, turnSpeed: 0.115, gripFactor: 0.120, sensorRange: 230, price: 3500
            },
            // Tier 4
            '4': {
                acceleration: 1.05, maxSpeedMod: 14.0, friction: 0.950, turnSpeed: 0.130, gripFactor: 0.150, sensorRange: 270, price: 5500
            },
            // Tier 5 (MAX TIER)
            '5': {
                acceleration: 1.20, maxSpeedMod: 16.0, friction: 0.955, turnSpeed: 0.150, gripFactor: 0.200, sensorRange: 320, price: 8000
            }
        };

        const CAR_CHASSIS = [
            { id: 'C01', name: 'Í∏∞Î≥∏ Î™®Îç∏ (Blue)', price: 0, color: '#3b82f6', baseAccel: 0.7, baseGrip: 0.05, maxSpeedBonus: 0 },
            { id: 'C02', name: 'Ïä§Ìè¨Ìä∏ Í≤ΩÎüâ (Red)', price: 10000, color: '#ef4444', baseAccel: 0.8, baseGrip: 0.08, maxSpeedBonus: 1 },
            { id: 'C03', name: 'ÌïòÏù¥ Í∑∏Î¶Ω (Green)', price: 25000, color: '#10b981', baseAccel: 0.75, baseGrip: 0.12, maxSpeedBonus: 0 },
        ];

        // --- üåü Ìä∏Îûô Î†àÏù¥ÏïÑÏõÉ Ïû¨ÏÑ§Í≥Ñ (30Í∞ú, ÏßÄÌòï ÌÉÄÏûÖ ÌÜµÌï© Î∞è ÏΩòÏÖâÌä∏ Í∞ïÌôî) ---
        const TRACK_LAYOUTS = [
            // Ï¥àÍ∏â (1-10) - ÏïÑÏä§ÌåîÌä∏ Í∏∞Î≥∏
            { id: 'simple_square', name: '1. Ïã¨Ìîå Ïä§ÌÄòÏñ¥ (ÏûÖÎ¨∏)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'oval', name: '2. Ïä§ÌîºÎìú Ïò§Î≤å (ÏûÖÎ¨∏)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 300 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 50, y: 300 }, { x: 100, y: 50 }], terrainType: 'asphalt' },
            { id: 'smooth_curve', name: '3. Ïä§Î¨¥Ïä§ ÏΩîÎÑà (Ï¥àÍ∏â)', points: [{ x: 400, y: 50 }, { x: 700, y: 100 }, { x: 750, y: 300 }, { x: 700, y: 500 }, { x: 400, y: 550 }, { x: 100, y: 500 }, { x: 50, y: 300 }, { x: 100, y: 100 }], terrainType: 'asphalt' },
            { id: 'mini_technical', name: '4. ÎØ∏Îãà ÌÖåÌÅ¨ÎãàÏª¨ (Ï¥àÍ∏â)', points: [{ x: 350, y: 50 }, { x: 500, y: 50 }, { x: 700, y: 100 }, { x: 750, y: 200 }, { x: 700, y: 400 }, { x: 500, y: 500 }, { x: 300, y: 450 }, { x: 50, y: 300 }, { x: 100, y: 100 }, { x: 200, y: 50 }], terrainType: 'asphalt' },
            { id: 'long_straight', name: '5. Î°± Ïä§Ìä∏Î†àÏù¥Ìä∏ (Ï¥àÍ∏â)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'u_turn_basic', name: '6. Ïú†ÌÑ¥ Í∏∞Î≥∏ (Ï¥àÍ∏â)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 300 }, { x: 500, y: 550 }, { x: 300, y: 550 }, { x: 100, y: 300 }, { x: 100, y: 50 }], terrainType: 'asphalt' },
            { id: 'pentagon', name: '7. ÌéúÌÉÄÍ≥§ Ï±åÎ¶∞ÏßÄ (Ï§ëÍ∏â)', points: [{ x: 400, y: 50 }, { x: 600, y: 80 }, { x: 750, y: 300 }, { x: 500, y: 550 }, { x: 150, y: 520 }, { x: 50, y: 300 }, { x: 200, y: 80 }], terrainType: 'asphalt' },
            { id: 'hairpin_mix', name: '8. Ìó§Ïñ¥ÌïÄ ÎØπÏä§ (Ï§ëÍ∏â)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 350 }, { x: 600, y: 550 }, { x: 400, y: 400 }, { x: 200, y: 550 }, { x: 50, y: 350 }, { x: 50, y: 150 }], terrainType: 'asphalt' },
            { id: 's_and_straights', name: '9. SÏûê Î∞è ÏßÅÏÑ† (Ï§ëÍ∏â)', points: [{ x: 400, y: 50 }, { x: 750, y: 100 }, { x: 550, y: 250 }, { x: 750, y: 400 }, { x: 400, y: 550 }, { x: 50, y: 400 }, { x: 250, y: 250 }, { x: 50, y: 100 }], terrainType: 'asphalt' },
            { id: 'wide_curve_long', name: '10. ÏôÄÏù¥Îìú Ïª§Î∏å Î°± (Ï§ëÍ∏â)', points: [{ x: 400, y: 50 }, { x: 750, y: 100 }, { x: 700, y: 400 }, { x: 400, y: 550 }, { x: 100, y: 400 }, { x: 50, y: 100 }], terrainType: 'asphalt' },
            
            // Ï§ëÏÉÅÍ∏â (11-15) - ÏßÄÌòï ÎèÑÏûÖ (Ice, Gravel)
            { id: 'ice_zigzag', name: '11. ÏïÑÏù¥Ïä§ ÏßÄÍ∑∏Ïû¨Í∑∏ (ÏñºÏùå)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 250 }, { x: 250, y: 350 }, { x: 700, y: 450 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 100, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_reverse', name: '12. Í±∞Ïπú ÌÖåÌÅ¨ÎãàÏª¨ (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 600, y: 150 }, { x: 750, y: 300 }, { x: 600, y: 450 }, { x: 400, y: 550 }, { x: 200, y: 450 }, { x: 50, y: 300 }, { x: 200, y: 150 }], terrainType: 'gravel' },
            { id: 'water_coastline', name: '13. ÏäµÏßÄ Ìï¥ÏïàÏÑ† (Î¨º)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 700, y: 300 }, { x: 750, y: 500 }, { x: 500, y: 550 }, { x: 50, y: 500 }, { x: 50, y: 300 }, { x: 100, y: 100 }], terrainType: 'water' },
            { id: 'ice_spiral', name: '14. CÏûê ÏïÑÏù¥Ïä§ Ïä§ÌååÏù¥Îü¥ (ÏñºÏùå)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 450 }, { x: 400, y: 550 }, { x: 100, y: 450 }, { x: 100, y: 100 }, { x: 250, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_long_s', name: '15. Î°± S Ïª§Î∏å (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 750, y: 150 }, { x: 500, y: 250 }, { x: 750, y: 450 }, { x: 400, y: 550 }, { x: 50, y: 450 }, { x: 300, y: 250 }, { x: 50, y: 150 }], terrainType: 'gravel' },
            
            // ÏÉÅÍ∏â (16-25) - Í∏∏Ïù¥ÏôÄ Î≥µÏû°ÏÑ± Ï¶ùÍ∞Ä
            { id: 'water_slalom', name: '16. ÏõåÌÑ∞ Ïä¨ÎùºÎ°¨ (Î¨º)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 700, y: 200 }, { x: 750, y: 350 }, { x: 600, y: 500 }, { x: 400, y: 550 }, { x: 200, y: 500 }, { x: 50, y: 350 }, { x: 100, y: 200 }, { x: 50, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_grand', name: '17. Í∑∏ÎûúÎìú Ìà¨Ïñ¥ (ÏïÑÏä§ÌåîÌä∏)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 200 }, { x: 650, y: 300 }, { x: 750, y: 450 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 300 }, { x: 50, y: 200 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'ice_oval_ext', name: '18. ÏùµÏä§ÌÖêÎîîÎìú Ïò§Î≤å (ÏñºÏùå)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 300 }, { x: 700, y: 550 }, { x: 100, y: 550 }, { x: 50, y: 300 }, { x: 50, y: 50 }, { x: 250, y: 50 }], terrainType: 'ice' },
            { id: 'gravel_triple', name: '19. Ìä∏Î¶¨Ìîå Ïª§Î∏å (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 750, y: 150 }, { x: 600, y: 300 }, { x: 750, y: 450 }, { x: 400, y: 550 }, { x: 50, y: 450 }, { x: 200, y: 300 }, { x: 50, y: 150 }], terrainType: 'gravel' },
            { id: 'water_wave', name: '20. Ïõ®Ïù¥Î∏å Ìä∏Îûô (Î¨º)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 650, y: 200 }, { x: 750, y: 350 }, { x: 600, y: 500 }, { x: 200, y: 550 }, { x: 150, y: 400 }, { x: 200, y: 200 }, { x: 50, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_snake', name: '21. Ïä§ÎÑ§Ïù¥ÌÅ¨ Ï§ëÌòï (ÏïÑÏä§ÌåîÌä∏)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 250 }, { x: 600, y: 400 }, { x: 750, y: 550 }, { x: 250, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 250 }, { x: 50, y: 50 }], terrainType: 'asphalt' },
            { id: 'ice_complex', name: '22. ÏïÑÏù¥Ïä§ ÌîºÍ≤® (ÏñºÏùå)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 700, y: 250 }, { x: 500, y: 350 }, { x: 700, y: 450 }, { x: 500, y: 550 }, { x: 100, y: 500 }, { x: 300, y: 400 }, { x: 100, y: 250 }, { x: 300, y: 150 }], terrainType: 'ice' },
            { id: 'gravel_tri', name: '23. ÏÇºÍ∞Å ÏÑúÌÇ∑ (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 750, y: 250 }, { x: 500, y: 550 }, { x: 50, y: 250 }, { x: 250, y: 150 }], terrainType: 'gravel' },
            { id: 'water_coffin', name: '24. ÏΩîÌïÄ Î†àÏù¥Ïä§ (Î¨º)', points: [{ x: 400, y: 50 }, { x: 600, y: 50 }, { x: 750, y: 300 }, { x: 600, y: 550 }, { x: 200, y: 550 }, { x: 50, y: 300 }, { x: 200, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_spiral', name: '25. Ïä§ÌååÏù¥Îü¥ ÏïÑÏõÉ (ÏïÑÏä§ÌåîÌä∏)', points: [{ x: 400, y: 50 }, { x: 500, y: 100 }, { x: 700, y: 150 }, { x: 750, y: 300 }, { x: 500, y: 450 }, { x: 200, y: 550 }, { x: 50, y: 300 }, { x: 250, y: 150 }], terrainType: 'asphalt' },
            
            // ÏµúÏÉÅÍ∏â (26-30) - Í∑πÌïúÏùò ÎÇúÏù¥ÎèÑ
            { id: 'ice_mega', name: '26. ÏïÑÏù¥Ïä§ Î©îÍ∞Ä Ï±åÎ¶∞ÏßÄ (ÏñºÏùå)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 650, y: 200 }, { x: 750, y: 300 }, { x: 650, y: 400 }, { x: 750, y: 550 }, { x: 50, y: 550 }, { x: 50, y: 400 }, { x: 150, y: 300 }, { x: 50, y: 200 }, { x: 150, y: 100 }, { x: 400, y: 250 }], terrainType: 'ice' },
            { id: 'gravel_long_tech', name: '27. Î°± ÌÖåÌÅ¨ÎãàÏª¨ (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 150 }, { x: 700, y: 300 }, { x: 750, y: 450 }, { x: 500, y: 550 }, { x: 250, y: 500 }, { x: 50, y: 400 }, { x: 150, y: 250 }, { x: 50, y: 100 }, { x: 250, y: 150 }, { x: 550, y: 150 }], terrainType: 'gravel' },
            { id: 'water_quad', name: '28. ÏøºÎìú Ìó§Ïñ¥ÌïÄ (Î¨º)', points: [{ x: 400, y: 50 }, { x: 750, y: 50 }, { x: 750, y: 200 }, { x: 600, y: 300 }, { x: 750, y: 400 }, { x: 600, y: 550 }, { x: 400, y: 550 }, { x: 200, y: 550 }, { x: 50, y: 400 }, { x: 200, y: 300 }, { x: 50, y: 200 }, { x: 100, y: 50 }], terrainType: 'water' },
            { id: 'asphalt_ultimate', name: '29. ÏñºÌã∞Î∞ã Ïä§ÌîºÎìú (ÏïÑÏä§ÌåîÌä∏)', points: [{ x: 400, y: 50 }, { x: 650, y: 50 }, { x: 750, y: 200 }, { x: 700, y: 400 }, { x: 750, y: 550 }, { x: 400, y: 550 }, { x: 50, y: 550 }, { x: 100, y: 400 }, { x: 50, y: 200 }, { x: 150, y: 50 }, { x: 400, y: 150 }], terrainType: 'asphalt' },
            { id: 'gravel_marathon', name: '30. ÎßàÎùºÌÜ§ ÏÑúÌÇ∑ (ÏûêÍ∞à)', points: [{ x: 400, y: 50 }, { x: 700, y: 50 }, { x: 750, y: 150 }, { x: 650, y: 250 }, { x: 750, y: 350 }, { x: 700, y: 450 }, { x: 750, y: 550 }, { x: 400, y: 500 }, { x: 50, y: 550 }, { x: 150, y: 450 }, { x: 50, y: 350 }, { x: 150, y: 250 }, { x: 50, y: 150 }, { x: 200, y: 50 }, { x: 400, y: 150 }], terrainType: 'gravel' }
        ];


        // --- Core Physics Calculation ---
        const getPhysicsConstants = (userParts, currentChassisId) => {
            const currentChassis = CAR_CHASSIS.find(c => c.id === currentChassisId);
            
            // Tier 0 is the base for all parts, so we merge it with the chassis base.
            const baseStats = {
                // Max speed (Gearbox) includes chassis bonus
                maxSpeed: PART_STATS[userParts.gearbox].maxSpeedMod + currentChassis.maxSpeedBonus, 
                // Friction (Tire)
                friction: PART_STATS[userParts.tire].friction,
                // Turn Speed (Steering)
                turnSpeed: PART_STATS[userParts.steering].turnSpeed,
                // Grip (Downforce)
                gripFactor: PART_STATS[userParts.downforce].gripFactor, 
                // Sensor Range (Sensor)
                sensorRange: PART_STATS[userParts.sensor].sensorRange,
                // Acceleration (Engine)
                acceleration: PART_STATS[userParts.engine].acceleration,
            };
            
            return baseStats;
        };


        // --- Firestore Utilities ---
        const APP_ID = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const USER_DATA_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/gameData/config`;
        // Î°úÏßÅ ÏÑ§Ï†ïÏùÑ ÏúÑÌïú ÏÉàÎ°úÏö¥ Í≤ΩÎ°ú
        const LOGIC_CONFIG_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/logicConfigs/slots`;
        // AI ÎÇúÏù¥ÎèÑ Ï†ÅÏùë Ï†ÄÏû•ÏùÑ ÏúÑÌïú Í≤ΩÎ°ú
        const AI_DIFFICULTY_PATH = (userId) => `artifacts/${APP_ID}/users/${userId}/aiDifficulty/stats`;

        const getUserId = () => window.firebaseAuth?.currentUser?.uid || 'anonymous';
        const getFirestoreDB = () => window.firestoreDB;

        const getDefaultUserData = (userId) => ({
            userId: userId,
            dollars: 5000, // Initial cash for testing
            currentChassis: CAR_CHASSIS[0].id,
            parts: {
                engine: 0, gearbox: 0, tire: 0, steering: 0, downforce: 0, sensor: 0
            },
            lapHistory: []
        });

        const getDefaultLogicData = () => {
            const defaultSlotName = (index) => `Ïä¨Î°Ø ${index + 1} (Í∏∞Î≥∏)`;
            const defaultSlots = [...Array(5)].map((_, index) => ({
                name: defaultSlotName(index),
                blocks: index === 0 ? INITIAL_BLOCKS : [],
            }));
            return {
                slots: defaultSlots,
                activeSlotIndex: 0,
            };
        };

        // üåü AI ÎÇúÏù¥ÎèÑ Îç∞Ïù¥ÌÑ∞ Î°úÎî©
        const loadAIDifficultyData = (setAIDifficultyStats) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;
            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, AI_DIFFICULTY_PATH(userId)); 

            const unsubscribe = window.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    // winStreakMap: { 'trackId': winStreakCount }
                    setAIDifficultyStats(docSnap.data().winStreakMap || {});
                } else {
                    window.setDoc(docRef, { winStreakMap: {} }); 
                    setAIDifficultyStats({});
                }
            }, (error) => {
                console.error("Error listening to AI Difficulty:", error);
            });
            return unsubscribe;
        };
        
        // üåü AI ÎÇúÏù¥ÎèÑ Ï†ÅÏùë Ï†ÄÏû•
        const saveAIDifficultyData = async (trackId, didWin) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, AI_DIFFICULTY_PATH(userId));
                
                const docSnap = await window.getDoc(docRef);
                const data = docSnap.exists() ? docSnap.data().winStreakMap || {} : {};
                
                const currentStreak = data[trackId] || 0;
                let newStreak;

                if (didWin) {
                    newStreak = currentStreak + 1;
                } else {
                    newStreak = Math.max(0, currentStreak - 1); // Ìå®Î∞∞ Ïãú Í∞êÏÜå (ÏµúÏÜå 0)
                }

                data[trackId] = newStreak;

                await window.setDoc(docRef, { winStreakMap: data }, { merge: true });
                console.log(`AI Difficulty for ${trackId} updated. New Win Streak: ${newStreak}`);

            } catch (error) {
                console.error("Error saving AI Difficulty:", error);
            }
        };


        const loadUserData = (setUserData, setAuthReady) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;

            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, USER_DATA_PATH(userId)); 
            setAuthReady(true); 

            const unsubscribe = window.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    setUserData(docSnap.data());
                } else {
                    const defaultData = getDefaultUserData(userId);
                    window.setDoc(docRef, defaultData); 
                    setUserData(defaultData);
                }
            }, (error) => {
                console.error("Error listening to User Data:", error);
                setAuthReady(true);
            });

            return unsubscribe;
        };
        
        const loadLogicData = (setLogicSlots, setActiveSlotIndex, setLogicReady) => {
            const db = getFirestoreDB();
            const auth = window.firebaseAuth;
            if (!db || !auth || !auth.currentUser) return;

            const userId = auth.currentUser.uid;
            const docRef = window.doc(db, LOGIC_CONFIG_PATH(userId)); 

            const unsubscribe = window.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    setLogicSlots(data.slots || getDefaultLogicData().slots);
                    setActiveSlotIndex(data.activeSlotIndex || 0);
                } else {
                    const defaultData = getDefaultLogicData();
                    window.setDoc(docRef, defaultData); 
                    setLogicSlots(defaultData.slots);
                    setActiveSlotIndex(defaultData.activeSlotIndex);
                }
                setLogicReady(true);
            }, (error) => {
                console.error("Error listening to Logic Config:", error);
                setLogicReady(true);
            });

            return unsubscribe;
        };

        const saveUserData = async (newUserData) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, USER_DATA_PATH(userId));
                await window.setDoc(docRef, newUserData, { merge: true });
            } catch (error) {
                console.error("Error saving user data:", error);
            }
        };

        const saveLogicData = async (logicData) => {
            const db = getFirestoreDB();
            const userId = getUserId();
            if (!db || userId === 'anonymous') return;
            
            try {
                const docRef = window.doc(db, LOGIC_CONFIG_PATH(userId));
                await window.setDoc(docRef, logicData, { merge: true });
            } catch (error) {
                console.error("Error saving logic data:", error);
            }
        };


        // --- Shop Helper Function ---
        const getPartStatKey = (partId) => {
            switch(partId) {
                case 'engine': return 'acceleration';
                case 'gearbox': return 'maxSpeedMod';
                case 'tire': return 'friction';
                case 'steering': return 'turnSpeed';
                case 'downforce': return 'gripFactor';
                case 'sensor': return 'sensorRange';
                default: return '';
            }
        };

        // üåü ÏµúÎåÄ Ìã∞Ïñ¥ ÌôïÏù∏ Ìï®Ïàò
        const MAX_TIER = 5;


        const App = () => {
            // --- App State ---
            const [currentScreen, setCurrentScreen] = useState('race');
            const [isPlaying, setIsPlaying] = useState(false);
            const [blocks, setBlocks] = useState(INITIAL_BLOCKS);
            const [gameState, setGameState] = useState('idle');
            const [winner, setWinner] = useState(null);
            const [sensorReadings, setSensorReadings] = useState([0, 0, 0, 0, 0]);
            const [currentTrackIdx, setCurrentTrackIdx] = useState(0);
            const [isMuted, setIsMuted] = useState(false);
            const [authReady, setAuthReady] = useState(false);
            
            // --- User Data State ---
            const [userData, setUserData] = useState(getDefaultUserData('initial'));
            const [physics, setPhysics] = useState(getPhysicsConstants(getDefaultUserData('initial').parts, CAR_CHASSIS[0].id));

            // --- Logic Slot State ---
            const [logicSlots, setLogicSlots] = useState(getDefaultLogicData().slots);
            const [activeSlotIndex, setActiveSlotIndex] = useState(getDefaultLogicData().activeSlotIndex);
            const [logicReady, setLogicReady] = useState(false);
            
            // üåü AI ÎÇúÏù¥ÎèÑ ÏÉÅÌÉú
            const [aiDifficultyStats, setAIDifficultyStats] = useState({});

            // üåü Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù ÏÉÅÌÉú
            const [currentVehicleId, setCurrentVehicleId] = useState(VEHICLE_TYPES[0].id);

            const [userStats, setUserStats] = useState({ 
                laps: 0, 
                currentLapTime: 0, 
                lastLapTime: 0,
                totalTime: 0,
                lapHistory: []
            });

            // --- Time/Game Refs ---
            const canvasRef = useRef(null);
            const cars = useRef([]);
            const requestRef = useRef();
            const startTimeRef = useRef(0);
            const currentSkidSegmentId = useRef(0); 

            // --- Audio Refs (Simplified for brevity) ---
            const audioCtxRef = useRef(null);
            const engineOscRef = useRef(null);
            const engineGainRef = useRef(null);
            const skidOscRef = useRef(null);
            const skidGainRef = useRef(null);
            const skidFilterRef = useRef(null);
            
            // Helper to get current vehicle info
            const currentVehicle = VEHICLE_TYPES.find(v => v.id === currentVehicleId) || VEHICLE_TYPES[0];

            const initAudio = useCallback(() => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume();
                }
            }, []);

            const playTone = useCallback((freq, type, duration, vol = 0.1) => {
                if (isMuted || !audioCtxRef.current) return;
                const osc = audioCtxRef.current.createOscillator();
                const gain = audioCtxRef.current.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
                gain.gain.setValueAtTime(vol, audioCtxRef.current.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtxRef.current.destination);
                osc.start();
                osc.stop(audioCtxRef.current.currentTime + duration);
            }, [isMuted]);

            const playClickSound = useCallback(() => {
                initAudio(); 
                playTone(600, 'sine', 0.1, 0.025);
            }, [initAudio, playTone]);
            
            const playLapSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current) return;
                playTone(880, 'sine', 0.1, 0.05);
                setTimeout(() => playTone(1760, 'sine', 0.2, 0.05), 100);
            }, [isMuted, playTone]);

            const playWinSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current) return;
                const notes = [523.25, 659.25, 783.99, 1046.50]; 
                notes.forEach((note, i) => {
                    setTimeout(() => playTone(note, 'square', 0.2, 0.05), i * 150);
                });
            }, [isMuted, playTone]);

            const startEngineSound = useCallback(() => {
                if (isMuted || !audioCtxRef.current || engineOscRef.current) return;
                const osc = audioCtxRef.current.createOscillator();
                const gain = audioCtxRef.current.createGain();
                osc.type = 'sawtooth'; 
                osc.frequency.value = 100; 
                gain.gain.value = 0.001; 
                osc.connect(gain);
                gain.connect(audioCtxRef.current.destination);
                osc.start();
                engineOscRef.current = osc;
                engineGainRef.current = gain;
            }, [isMuted]);

            const stopEngineSound = useCallback(() => {
                if (engineOscRef.current) {
                    try { engineOscRef.current.stop(); engineOscRef.current.disconnect(); } catch (e) {} 
                    engineOscRef.current = null;
                }
                if (engineGainRef.current) {
                    engineGainRef.current.disconnect();
                    engineGainRef.current = null;
                }
            }, []);

            const updateEnginePitch = useCallback((speed) => {
                if (engineOscRef.current && engineGainRef.current && !isMuted && audioCtxRef.current) {
                    const absSpeed = Math.abs(speed);
                    const pitch = 100 + absSpeed * 30; 
                    engineOscRef.current.frequency.setTargetAtTime(pitch, audioCtxRef.current.currentTime, 0.1);

                    const baseVol = 0.05;
                    const speedRatio = Math.min(absSpeed / physics.maxSpeed, 1.0);
                    const volFactor = 0.1 + speedRatio * 0.9;
                    const volume = baseVol * volFactor;

                    engineGainRef.current.gain.setTargetAtTime(volume, audioCtxRef.current.currentTime, 0.05);
                }
            }, [isMuted, physics.maxSpeed]);

            const updateSkidSound = useCallback((driftIntensity) => {
                if (!audioCtxRef.current || isMuted || currentVehicle.trailType !== 'skid') return;

                if (driftIntensity > 0.15) { 
                    if (!skidOscRef.current) {
                        const bufferSize = audioCtxRef.current.sampleRate * 2;
                        const buffer = audioCtxRef.current.createBuffer(1, bufferSize, audioCtxRef.current.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }

                        const noise = audioCtxRef.current.createBufferSource();
                        noise.buffer = buffer;
                        noise.loop = true;
                        
                        const gain = audioCtxRef.current.createGain();
                        const filter = audioCtxRef.current.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.value = 1200; 
                        filter.Q.value = 5; 

                        noise.connect(filter);
                        filter.connect(gain);
                        gain.connect(audioCtxRef.current.destination);
                        
                        noise.start();
                        skidOscRef.current = noise;
                        skidGainRef.current = gain;
                        skidFilterRef.current = filter;
                    }
                    
                    const vol = Math.min(driftIntensity * 0.8, 0.15); 
                    skidGainRef.current.gain.setTargetAtTime(vol, audioCtxRef.current.currentTime, 0.1);
                    
                    const minPitch = 1000;
                    const maxPitch = 2500;
                    const randomFactor = (Math.random() * 0.2 + 0.9); 
                    const targetPitch = Math.min(minPitch + driftIntensity * (maxPitch - minPitch) * 2 * randomFactor, maxPitch); 
                    skidFilterRef.current.frequency.setTargetAtTime(targetPitch, audioCtxRef.current.currentTime, 0.05);

                } else {
                    if (skidGainRef.current) {
                        skidGainRef.current.gain.setTargetAtTime(0, audioCtxRef.current.currentTime, 0.1);
                    }
                }
            }, [isMuted, currentVehicle.trailType]);

            const stopSkidSound = useCallback(() => {
                if (skidOscRef.current) {
                    try { skidOscRef.current.stop(); skidOscRef.current.disconnect(); } catch (e) {} 
                    skidOscRef.current = null;
                }
                if (skidGainRef.current) {
                    skidGainRef.current.disconnect();
                    skidGainRef.current = null;
                }
            }, []);


            // --- Helpers ---
            const dist = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

            const scalePoint = (p) => ({
                // üåü MAP_SCALEÏù¥ 1.0Ïù¥ÎØÄÎ°ú Ïä§ÏºÄÏùºÎßÅÏùÄ Î∞úÏÉùÌïòÏßÄ ÏïäÏäµÎãàÎã§.
                x: (p.x - TRACK_WIDTH / 2) * MAP_SCALE + TRACK_WIDTH / 2,
                y: (p.y - TRACK_HEIGHT / 2) * MAP_SCALE + TRACK_HEIGHT / 2
            });

            const getCurrentTrackPoints = useCallback(() => TRACK_LAYOUTS[currentTrackIdx].points.map(scalePoint), [currentTrackIdx]);

            const getStartAngle = useCallback(() => {
                const points = getCurrentTrackPoints();
                const p1 = points[0];
                const p2 = points[1];
                return Math.atan2(p2.y - p1.y, p2.x - p1.x);
            }, [getCurrentTrackPoints]);

            const distToSegment = (x, y, x1, y1, x2, y2) => {
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                return dist(x, y, xx, yy);
            };

            const isOffTrack = (x, y) => {
                const points = getCurrentTrackPoints();
                let minDist = Infinity;
                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];
                    const d = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (d < minDist) minDist = d;
                }
                return minDist > (TRACK_AESTHETICS.curb / 2) + 3; 
            };

            // üåü Ìä∏ÎûôÏùò ÏßÄÌòï ÏÜçÏÑ±ÏùÑ Í∏∞Î∞òÏúºÎ°ú Î¨ºÎ¶¨ Ìå©ÌÑ∞ Í≥ÑÏÇ∞
            const getTrackPhysicsFactors = (currentTrackIdx) => {
                const currentTrack = TRACK_LAYOUTS[currentTrackIdx];
                const type = currentTrack.terrainType || 'asphalt';
                const props = TERRAIN_PROPERTIES[type];
                
                return { 
                    friction: props.frictionFactor, 
                    turnSpeed: props.turnFactor,
                    trackColor: props.trackColor,
                    groundColor: props.groundColor,
                    skidColor: props.skidColor
                };
            };


            const castRays = (car, range) => {
                const readings = [];
                const angles = [-60, -30, 0, 30, 60]; 
                
                angles.forEach(offset => {
                    const rayAngle = car.angle + (offset * Math.PI / 180);
                    let distance = 0;
                    let step = 2;
                    let maxDist = range;
                    let rx = car.x;
                    let ry = car.y;

                    while (distance < maxDist) {
                        rx += Math.cos(rayAngle) * step;
                        ry += Math.sin(rayAngle) * step;
                        distance += step;
                        if (isOffTrack(rx, ry)) break;
                    }
                    readings.push(Math.min(distance, maxDist));
                });
                return readings;
            };

            // --- Game Loop Logic ---

            const updateCarPhysics = (car, inputs, timestamp) => {
                if (car.finished) return;

                // üåü Ìä∏Îûô ÏßÄÌòï Î¨ºÎ¶¨ Ìå©ÌÑ∞ Î°úÎìú
                const trackFactors = getTrackPhysicsFactors(currentTrackIdx);

                // Use current user's physics or default AI physics
                const aiBaseStats = PART_STATS['0'];

                const carPhysics = car.isAI ? { 
                    acceleration: aiBaseStats.acceleration,
                    maxSpeed: aiBaseStats.maxSpeedMod,
                    friction: aiBaseStats.friction,
                    turnSpeed: aiBaseStats.turnSpeed,
                    gripFactor: aiBaseStats.gripFactor,
                    sensorRange: aiBaseStats.sensorRange
                } : physics;

                // üåü Ìä∏Îûô ÏßÄÌòï Ìå©ÌÑ∞ Ï†ÅÏö© (Î¨ºÎ¶¨ Î≥¥Ï†ï)
                carPhysics.friction *= trackFactors.friction;
                carPhysics.turnSpeed *= trackFactors.turnSpeed;
                carPhysics.gripFactor *= trackFactors.friction; // ÎßàÏ∞∞Ïù¥ Ï§ÑÎ©¥ Í∑∏Î¶ΩÎèÑ Ï§ÑÏñ¥ ÎØ∏ÎÅÑÎü¨Ïßê Ï¶ùÍ∞Ä
                
                // Steering
                if (Math.abs(car.speed) > 0.5) {
                    car.angle += inputs.steer * carPhysics.turnSpeed * (car.speed > 0 ? 1 : -1);
                }

                if (typeof car.moveAngle === 'undefined') car.moveAngle = car.angle;
                if (typeof car.skidMarks === 'undefined') car.skidMarks = [];
                if (typeof car.currentSkidId === 'undefined') car.currentSkidId = 0;
                if (typeof car.isDrifting === 'undefined') car.isDrifting = false;

                // Physics: Drift 
                const speedRatio = Math.abs(car.speed) / carPhysics.maxSpeed;
                const grip = carPhysics.gripFactor + (1.0 - speedRatio) * (1 - carPhysics.gripFactor); 

                let angleDiff = car.angle - car.moveAngle;
                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                car.moveAngle += angleDiff * grip;

                // Acceleration & Friction
                car.speed += inputs.throttle * carPhysics.acceleration;
                car.speed *= carPhysics.friction;

                // Tire Scrub & Skid Logic
                const driftIntensity = Math.abs(angleDiff);
                const driftThreshold = 0.15; 
                
                const nowDrifting = driftIntensity > driftThreshold && Math.abs(car.speed) > 3;
                
                if (nowDrifting) {
                    if (!car.isDrifting) {
                        currentSkidSegmentId.current += 1;
                        car.currentSkidId = currentSkidSegmentId.current;
                        car.isDrifting = true;
                    }

                    // Scrub speed
                    car.speed *= (1 - driftIntensity * 0.02); 
                    
                    // Add Skid Marks/Dust Trail
                    if (car.trailType !== 'none') {
                        const rearX = car.x - Math.cos(car.angle) * 10;
                        const rearY = car.y - Math.sin(car.angle) * 10;
                        const perp = car.angle + Math.PI/2;
                        const lx = rearX + Math.cos(perp) * 6;
                        const ly = rearY + Math.sin(perp) * 6;
                        const rx = rearX - Math.cos(perp) * 6;
                        const ry = rearY - Math.sin(perp) * 6;

                        // üåü Ïä§ÌÇ§Îìú ÎßàÌÅ¨ ÏÉâÏÉÅÏùÑ Ìä∏Îûô ÏßÄÌòïÏóê ÎßûÍ≤å ÏÇ¨Ïö©
                        car.skidMarks.push({ lx, ly, rx, ry, alpha: 0.3, segmentId: car.currentSkidId, trailType: car.trailType, skidColor: trackFactors.skidColor });
                        
                        if (car.skidMarks.length > MAX_SKID_MARKS) car.skidMarks.shift(); 
                    }
                } else {
                    car.isDrifting = false;
                }

                if (car.id === 'user' && !isMuted) {
                    updateSkidSound(nowDrifting ? driftIntensity : 0);
                }

                if (car.speed > carPhysics.maxSpeed) car.speed = carPhysics.maxSpeed;
                if (car.speed < -carPhysics.maxSpeed / 2) car.speed = -carPhysics.maxSpeed / 2;

                // Move
                car.x += Math.cos(car.moveAngle) * car.speed;
                car.y += Math.sin(car.moveAngle) * car.speed;

                if (isOffTrack(car.x, car.y)) {
                    car.speed *= 0.5; 
                }
                
                // üåü ÏÇ¨Ïö©Ïûê Ï∞®Îüâ 180ÎèÑ Î∞©Ìñ• Î≥¥Ï†ï Î°úÏßÅ
                if (car.id === 'user' && Math.abs(car.speed) > 1.0) {
                    const points = getCurrentTrackPoints();
                    const nextCp = points[(car.lastCP + 1) % points.length];
                    
                    const directionToCp = Math.atan2(nextCp.y - car.y, nextCp.x - car.x);
                    let angleDiffToTarget = directionToCp - car.moveAngle;
                    while (angleDiffToTarget <= -Math.PI) angleDiffToTarget += Math.PI * 2;
                    while (angleDiffToTarget > Math.PI) angleDiffToTarget -= Math.PI * 2;
                    
                    // 135ÎèÑ (3*PI/4) Ïù¥ÏÉÅ Î∞òÎåÄ Î∞©Ìñ•ÏúºÎ°ú Ï£ºÌñâÌïòÎäîÏßÄ ÌôïÏù∏
                    if (Math.abs(angleDiffToTarget) > (3 * Math.PI / 4)) {
                        car.wrongDirectionFrames = (car.wrongDirectionFrames || 0) + 1;
                    } else {
                        car.wrongDirectionFrames = 0;
                    }

                    // 120 ÌîÑÎ†àÏûÑ (2Ï¥à) Ïù¥ÏÉÅ ÏûòÎ™ª Ï£ºÌñâÌñàÏùÑ Í≤ΩÏö∞ Î≥¥Ï†ï
                    if (car.wrongDirectionFrames > 120) {
                        const resetCp = points[car.lastCP];
                        const resetNextCp = points[(car.lastCP + 1) % points.length];

                        // Ïò¨Î∞îÎ•∏ Î∞©Ìñ• Í≥ÑÏÇ∞
                        const correctAngle = Math.atan2(resetNextCp.y - resetCp.y, resetNextCp.x - resetCp.x);
                        
                        // ÎßàÏßÄÎßâ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ ÏúÑÏπòÎ°ú Î¶¨ÏÖã
                        car.x = resetCp.x;
                        car.y = resetCp.y;
                        car.angle = correctAngle;
                        car.moveAngle = correctAngle;
                        car.speed = 0;
                        car.wrongDirectionFrames = 0;
                        
                        console.log("Auto-correction: Wrong direction detected. User car reset.");
                        // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶ºÏùÑ Ï£ºÎäî UI ÌîºÎìúÎ∞±ÏùÑ Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏßÄÎßå, ÌòÑÏû¨Îäî ÏΩòÏÜî Î°úÍ∑∏Î°ú ÎåÄÏ≤¥
                    }
                }


                // Checkpoint
                const points = getCurrentTrackPoints();
                const nextCpIdx = (car.lastCP + 1) % points.length;
                const nextCp = points[nextCpIdx];
                
                let isCheckpointReached = false;

                if (nextCpIdx === 0) {
                    // Rectangular detection for Start Line
                    const p0 = points[0];
                    const p1 = points[1]; 
                    const trackAngle = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                    const dx = car.x - p0.x;
                    const dy = car.y - p0.y;
                    const localX = dx * Math.cos(-trackAngle) - dy * Math.sin(-trackAngle);
                    const localY = dx * Math.sin(-trackAngle) + dy * Math.cos(-trackAngle);
                    
                    if (Math.abs(localX) < 20 && Math.abs(localY) < (TRACK_AESTHETICS.asphalt / 2 + 5)) { 
                        isCheckpointReached = true;
                    }
                } else {
                    if (dist(car.x, car.y, nextCp.x, nextCp.y) < CHECKPOINT_RADIUS_NORMAL) {
                        isCheckpointReached = true;
                    }
                }

                if (isCheckpointReached) {
                    car.lastCP = nextCpIdx;
                    
                    if (nextCpIdx === 0) {
                        car.laps++;
                        if (!car.isAI) playLapSound();

                        const now = timestamp;
                        const lapTime = (now - car.lapStartTime) / 1000;
                        car.lastLapTime = lapTime;
                        car.lapStartTime = now; 
                        
                        if (car.id === 'user') {
                            if (!car.lapHistory) car.lapHistory.push(0); // Ï≤´ Îû©ÌÉÄÏûÑÏùÄ 0 (Î¨¥ÏãúÎê®)
                            car.lapHistory.push(lapTime);
                        }

                        if (car.laps >= TOTAL_LAPS) {
                            car.finished = true;
                            car.finishTime = (now - startTimeRef.current) / 1000;
                            
                            if (!winner) {
                                setWinner(car.id);
                                setGameState('finished');
                                setIsPlaying(false);
                                
                                // üí∞ Î≥¥ÏÉÅ Í≥ÑÏÇ∞ Î∞è ÏßÄÍ∏â Î°úÏßÅ ÏàòÏ†ï
                                if (car.id === 'user') {
                                    playWinSound();
                                    giveReward(car.finishTime, true, currentTrackIdx); // User wins
                                    saveAIDifficultyData(TRACK_LAYOUTS[currentTrackIdx].id, true); // üåü AI ÎÇúÏù¥ÎèÑ ÏÉÅÏäπ
                                } else {
                                    const userCar = cars.current.find(c => c.id === 'user');
                                    giveReward(userCar ? userCar.finishTime : 0, false, currentTrackIdx); // User lost (participation)
                                    saveAIDifficultyData(TRACK_LAYOUTS[currentTrackIdx].id, false); // üåü AI ÎÇúÏù¥ÎèÑ ÌïòÎùΩ
                                }
                                
                                stopEngineSound();
                                stopSkidSound();
                            }
                        }
                    }
                }
            };
            
            // üí∞ Î≥¥ÏÉÅ Í≥ÑÏÇ∞ Î°úÏßÅ ÏàòÏ†ï (ÎÇúÏù¥ÎèÑ Î∞è Í∏∞Î≥∏ ÏÉÅÍ∏à Ï°∞Ï†ï)
            const giveReward = (finishTime, didWin, trackIndex) => {
                const totalTracks = TRACK_LAYOUTS.length;
                // ÎÇúÏù¥ÎèÑÏóê Îî∞Î•∏ Í∏∞Î≥∏ ÏÉÅÍ∏à (ÏµúÎåÄ 3000)
                const trackDifficultyRatio = trackIndex / (totalTracks - 1);
                const baseReward = Math.round(500 + trackDifficultyRatio * 2500); 
                const bonusPerSecond = 8; // ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ Ìå©ÌÑ∞ Ï°∞Ï†ï
                let reward = 0;
                
                if (didWin) {
                    const timeBonus = Math.max(0, 500 - finishTime * bonusPerSecond); // ÏµúÎåÄ ÏãúÍ∞Ñ Î≥¥ÎÑàÏä§ Ï°∞Ï†ï
                    reward = baseReward + timeBonus; 
                } else {
                    reward = 300; // Ï∞∏Ïó¨ ÏÉÅÍ∏à Ï°∞Ï†ï
                }

                const actualReward = Math.max(0, Math.round(reward)); 

                const newDollars = userData.dollars + actualReward;
                saveUserData({...userData, dollars: newDollars});
                console.log(`Reward awarded: ${actualReward} dollars. New balance: ${newDollars}`);
                alert(`Í≤∞Í≥º: ${didWin ? 'Ïö∞Ïäπ' : 'Ìå®Î∞∞'}! ÌöçÎìù ÏÉÅÍ∏à: $${actualReward.toLocaleString()}`); // UI ÌîºÎìúÎ∞± Ï∂îÍ∞Ä
            };

            const evaluateCondition = (block, currentReadings) => {
                if (block.flowType === 'ELSE') return false; 
                
                const leftValue = currentReadings[block.sensor];
                let rightValue = block.valueType === 'sensor' ? currentReadings[block.value] : block.value;

                if (block.operator === '<') return leftValue < rightValue;
                if (block.operator === '>') return leftValue > rightValue;
                if (block.operator === '<=') return leftValue <= rightValue;
                if (block.operator === '>=') return leftValue >= rightValue;
                if (block.operator === '==') return leftValue === rightValue;
                if (block.operator === '!=') return leftValue !== rightValue;
                
                return false;
            }
            
            // üí° applyAction Î°úÏßÅ ÏóÖÎç∞Ïù¥Ìä∏
            const applyAction = (block, steerOutputs) => {
                    switch(block.action) {
                        case 'LEFT': steerOutputs.turnLeft = true; break;
                        case 'RIGHT': steerOutputs.turnRight = true; break;
                        
                        // Í∞ÄÏÜç Îã®Í≥ÑÎ≥Ñ ÏÑ§Ï†ï
                        case 'ACCEL_100': steerOutputs.gas = 1.0; break;
                        case 'ACCEL_75': steerOutputs.gas = 0.75; break;
                        case 'ACCEL_50': steerOutputs.gas = 0.5; break;

                        // Í∞êÏÜç Îã®Í≥ÑÎ≥Ñ ÏÑ§Ï†ï
                        case 'BRAKE_100': steerOutputs.brake = 1.0; break;
                        case 'BRAKE_75': steerOutputs.brake = 0.75; break;
                        case 'BRAKE_50': steerOutputs.brake = 0.5; break;
                        
                        default: 
                            if (block.action.startsWith('ACCEL')) steerOutputs.gas = 1.0;
                            if (block.action.startsWith('BRAKE')) steerOutputs.brake = 1.0;
                            break;
                    }
            }

            // üí° Î°úÏßÅ Î∏îÎ°ù Î∞∞Ïó¥ÏùÑ Ïù∏ÏàòÎ°ú Î∞õÎäî Í≥µÌÜµ ÏûÖÎ†• Í≥ÑÏÇ∞ Ìï®Ïàò
            const getCarInputs = (carLogicBlocks, currentReadings) => {
                const steerOutputs = { turnLeft: false, turnRight: false, gas: 0, brake: 0 };
                let steer = 0;
                let throttle = 0;
                let matchedInChain = false; 

                for (let i = 0; i < carLogicBlocks.length; i++) {
                    const block = carLogicBlocks[i];
                    
                    let conditionMet = evaluateCondition(block, currentReadings);
                    
                    const isStartOfChain = block.flowType === 'IF';
                    const isElseIf = block.flowType === 'ELSE_IF';
                    const isElse = block.flowType === 'ELSE';

                    if (isStartOfChain) {
                        matchedInChain = false;
                        if (conditionMet) {
                            applyAction(block, steerOutputs);
                            matchedInChain = true; 
                        }
                    } else if (isElseIf) {
                        if (!matchedInChain && conditionMet) {
                            applyAction(block, steerOutputs);
                            matchedInChain = true; 
                        }
                    } else if (isElse) {
                        if (!matchedInChain) {
                            applyAction(block, steerOutputs);
                        }
                    } 
                }
                
                if (steerOutputs.turnLeft) steer -= 1;
                if (steerOutputs.turnRight) steer += 1;
                
                // Í∞ÄÏÜç/Í∞êÏÜç Í∞íÏùÑ ÏµúÏ¢Ö throttleÏóê Î∞òÏòÅ
                throttle += steerOutputs.gas;
                throttle -= steerOutputs.brake;

                // throttle Í∞íÏùÄ -1.0ÏóêÏÑú 1.0 ÏÇ¨Ïù¥Í∞Ä Îê©ÎãàÎã§.
                return { steer, throttle: Math.max(-1.0, Math.min(1.0, throttle)) };
            };
            
            // üåü AI Í≤ΩÎ°ú Í∏∞Î∞ò ÏûÖÎ†• (ÎÇúÏù¥ÎèÑ Î∞è Ï†ÅÏùë Ìé∏Ï∞® Ï†ÅÏö©)
            const getAIPathInputs = (car, currentTrackIdx) => {
                const trackId = TRACK_LAYOUTS[currentTrackIdx].id;
                const winStreak = aiDifficultyStats[trackId] || 0;

                const totalTracks = TRACK_LAYOUTS.length;
                // Ìä∏Îûô ÎÇúÏù¥ÎèÑ Ìå©ÌÑ∞: 0.1 (Ïâ¨ÏõÄ) ~ 1.0 (Ïñ¥Î†§ÏõÄ)
                const baseDifficultyFactor = totalTracks > 1 ? (0.1 + (0.9 * (currentTrackIdx / (totalTracks - 1)))) : 1.0;
                
                // üåü Ï†ÅÏùë ÎÇúÏù¥ÎèÑ Ìå©ÌÑ∞: 0 ~ 0.2ÍπåÏßÄ Ï∂îÍ∞Ä ÎÇúÏù¥ÎèÑ Î∂ÄÏó¨ (ÏµúÎåÄ 10Ïó∞Ïäπ Ïãú 0.2)
                const adaptationFactor = Math.min(winStreak * 0.02, 0.2); 
                
                // ÏµúÏ¢Ö ÎÇúÏù¥ÎèÑ Ìå©ÌÑ∞ (1.0 Ï¥àÍ≥º Í∞ÄÎä•)
                const finalDifficultyFactor = baseDifficultyFactor + adaptationFactor;

                // 1. Î™©Ìëú Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Í≥ÑÏÇ∞
                const points = getCurrentTrackPoints();
                const targetIdx = (car.lastCP + 1) % points.length;
                const target = points[targetIdx];
                
                const desiredAngle = Math.atan2(target.y - car.y, target.x - car.x);
                let diff = desiredAngle - car.angle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                // 2. Ï°∞Ìñ• Í≥ÑÏÇ∞ (ÎÇúÏù¥ÎèÑÏôÄ ÎûúÎç§ÏÑ± Ï†ÅÏö©)
                let steer = 0;
                
                // ÎÇúÏù¥ÎèÑÍ∞Ä ÎÜíÏùÑÏàòÎ°ù Îçî Í≥µÍ≤©Ï†ÅÏù¥Í≥† Ï†ïÌôïÌïòÍ≤å Ï°∞Ìñ•
                const AGGRESSION_FACTOR = 0.5 + 0.5 * finalDifficultyFactor; 
                
                // AI Î∂ÄÏ†ïÌôïÏÑ± (ÎÇúÏù¥ÎèÑÍ∞Ä ÎÜíÏùÑÏàòÎ°ù ÎÖ∏Ïù¥Ï¶à Í∞êÏÜå)
                const noiseRange = 0.05 * (1.0 - Math.min(finalDifficultyFactor, 1.0)); // ÎÖ∏Ïù¥Ï¶àÎäî 1.0ÍπåÏßÄÎßå Í∞êÏÜå
                const noise = (Math.random() - 0.5) * noiseRange; 

                // Ï°∞Ìñ• ÎØºÍ∞êÎèÑ (ÎÇúÏù¥ÎèÑÍ∞Ä ÎÜíÏùÑÏàòÎ°ù Ï§ëÏïôÏúºÎ°ú Îçî Îπ†Î•¥Í≤å Î≥µÍ∑Ä)
                const steeringThreshold = 0.1 * (1.0 - AGGRESSION_FACTOR); 

                if (diff > steeringThreshold) steer = 1;
                if (diff < -steeringThreshold) steer = -1;
                
                steer *= AGGRESSION_FACTOR;
                steer += noise;

                // 3. Í∞ÄÏÜç/Í∞êÏÜç Í≥ÑÏÇ∞
                let throttle = 1.0;
                // AI ÏµúÎåÄ ÏÜçÎèÑ Ï†úÌïú (ÎÇúÏù¥ÎèÑÍ∞Ä ÎÜíÏùÑÏàòÎ°ù Îπ†Î•¥Í≤å)
                const MAX_SPEED_CAP = 0.7 + 0.3 * finalDifficultyFactor; 
                
                // ÏΩîÎÑà Í∞êÏÜç: Í∞ÅÎèÑ Ï∞®Ïù¥Í∞Ä ÌÅ¨Î©¥ Í∞êÏÜç
                if (Math.abs(diff) > 0.3) throttle = 0.5; 
                
                // ÌòÑÏû¨ ÏÜçÎèÑÍ∞Ä ÏµúÎåÄ ÏÜçÎèÑÏóê Í∞ÄÍπåÏö∞Î©¥ Í∞ÄÏÜçÎèÑÎ•º Ï§ÑÏûÑ
                if (Math.abs(car.speed) > car.maxSpeed * MAX_SPEED_CAP) throttle = 0.5; 
                
                // AI Í∞úÎ≥Ñ Ìé∏Ï∞® (AIÎßàÎã§ ÏïΩÍ∞ÑÏî© Îã§Î¶Ñ)
                const variance = (parseInt(car.id.slice(-1)) || 0) * 0.03;

                return { steer: Math.max(-1, Math.min(1, steer)), throttle: Math.max(0.1, throttle - variance) };
            };


            const update = (timestamp) => {
                if (gameState === 'finished') return;
                
                if (startTimeRef.current === 0) {
                    startTimeRef.current = timestamp;
                    cars.current.forEach(c => c.lapStartTime = timestamp);
                }

                const currentTotalTime = (timestamp - startTimeRef.current) / 1000;
                
                const userCar = cars.current[0];
                
                // DRAWING GUARD: Only run physics if cars are initialized
                if (!userCar || cars.current.length === 0) {
                     if (!isPlaying) draw(); 
                     return;
                }

                // 1. ÏÇ¨Ïö©Ïûê Ï∞®Îüâ ÏóÖÎç∞Ïù¥Ìä∏
                const readings = castRays(userCar, physics.sensorRange);
                setSensorReadings(readings);
                
                // ÏÇ¨Ïö©ÏûêÍ∞Ä ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ blocks ÏÉÅÌÉúÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
                const userInputs = getCarInputs(blocks, readings); 
                updateCarPhysics(userCar, userInputs, timestamp);
                
                if (!isMuted && gameState === 'running') {
                    updateEnginePitch(userCar.speed);
                }

                // 2. AI Ï∞®Îüâ ÏóÖÎç∞Ïù¥Ìä∏ (Í≤ΩÎ°ú Í∏∞Î∞ò AI)
                
                cars.current.slice(1).forEach(car => {
                    const aiInputs = getAIPathInputs(car, currentTrackIdx); 
                    
                    // AIÏùò Î¨ºÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ (ÎÇ¥Î∂ÄÏ†ÅÏúºÎ°ú car.isAIÎ•º Î≥¥Í≥† Í∏∞Î≥∏ Ïä§ÌÉØ ÏÇ¨Ïö©)
                    updateCarPhysics(car, aiInputs, timestamp);
                });

                setUserStats(prev => {
                    const userCar = cars.current[0] || {}; 
                    return ({
                        ...prev,
                        laps: userCar.laps || 0,
                        currentLapTime: (timestamp - userCar.lapStartTime) / 1000 || 0,
                        lastLapTime: userCar.lastLapTime || 0,
                        totalTime: userCar.finished ? userCar.finishTime : currentTotalTime,
                        lapHistory: userCar.lapHistory || [] 
                    });
                });

                draw();
                if (isPlaying) {
                    requestRef.current = requestAnimationFrame(update);
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                // üåü ÌòÑÏû¨ Ìä∏ÎûôÏùò ÏßÄÌòï ÏÜçÏÑ±ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
                const trackFactors = getTrackPhysicsFactors(currentTrackIdx);
                
                // Clear (ÏûîÎîî ÏÉâÏÉÅ)
                ctx.fillStyle = trackFactors.groundColor;
                ctx.fillRect(0, 0, TRACK_WIDTH, TRACK_HEIGHT);

                const points = getCurrentTrackPoints();
                
                // DRAWING GUARD: Draw only background if cars are not yet initialized (should be temporary)
                if (cars.current.length === 0) {
                    return;
                }
                
                // Draw Track
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Outer Border (Î†àÎìú ÎùºÏù∏)
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = TRACK_AESTHETICS.border;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.stroke();

                // Curb (Ìù∞ÏÉâ ÎùºÏù∏)
                ctx.strokeStyle = '#f8fafc';
                ctx.lineWidth = TRACK_AESTHETICS.curb;
                ctx.stroke();

                // Asphalt (Ìä∏Îûô ÏßÄÌòï ÏÉâÏÉÅ)
                ctx.strokeStyle = trackFactors.trackColor; 
                ctx.lineWidth = TRACK_AESTHETICS.asphalt;
                ctx.stroke();

                // Draw Skid Marks / Trails
                cars.current.forEach(car => {
                    if (car.skidMarks && car.skidMarks.length > 1 && car.trailType !== 'none') {
                        ctx.lineWidth = 4;
                        
                        let trailColor = car.skidMarks[0].skidColor; // üåü Ìä∏Îûô ÏßÄÌòï ÏÉâÏÉÅ ÏÇ¨Ïö©
                        if (car.trailType === 'dust') {
                            trailColor = `rgba(200, 180, 100, 0.5)`; // Sand/Dust color
                        }
                        
                        ctx.strokeStyle = trailColor; 
                        
                        for(let i=0; i<car.skidMarks.length-1; i++) {
                            const p1 = car.skidMarks[i];
                            const p2 = car.skidMarks[i+1];
                            if (p1.segmentId === p2.segmentId) {
                                ctx.beginPath(); ctx.moveTo(p1.lx, p1.ly); ctx.lineTo(p2.lx, p2.ly); ctx.stroke();
                                ctx.beginPath(); ctx.moveTo(p1.rx, p1.ry); ctx.lineTo(p2.rx, p2.ry); ctx.stroke();
                            }
                        }
                    }
                });

                // Center Line (Dashed)
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Start Line (Checkered)
                const startAngle = getStartAngle();
                ctx.save();
                ctx.translate(points[0].x, points[0].y);
                ctx.rotate(startAngle); 
                
                const lineHalfHeight = TRACK_AESTHETICS.asphalt / 2 + 10;
                ctx.fillStyle = '#fff';
                ctx.fillRect(-10, -lineHalfHeight, 20, lineHalfHeight * 2); 
                
                ctx.fillStyle = '#000';
                for(let i=0; i<8; i++) {
                    for(let j=0; j<2; j++) {
                        if((i+j)%2===0) ctx.fillRect(-10 + j*10, -lineHalfHeight + i*(lineHalfHeight*2/8), 10, lineHalfHeight*2/8);
                    }
                }
                ctx.restore();

                // Draw Cars
                cars.current.forEach(car => {
                    const carInfo = CAR_CHASSIS.find(c => c.id === car.chassisId) || CAR_CHASSIS[0];

                    // 1. Draw Body / Character (Rotated context)
                    ctx.save();
                    ctx.translate(car.x, car.y);
                    ctx.rotate(car.angle);

                    if (car.vehicleType === 'car' || car.vehicleType === 'rocket') {
                        // Draw Car (Existing Logic)
                        ctx.fillStyle = car.color;
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        ctx.shadowBlur = 5;
                        ctx.fillRect(-CAR_SIZE.width/2, -CAR_SIZE.height/2, CAR_SIZE.width, CAR_SIZE.height);
                        
                        // Windshield/Cabin (Design detail)
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(2, -5, 6, 10);
                        
                        // Simple Wing (for Downforce visual)
                        ctx.fillStyle = '#334155';
                        ctx.fillRect(-CAR_SIZE.width/2 - 2, -5, 3, 10); 
                    } else {
                        // Draw Character (Emoji)
                        ctx.font = '24px sans-serif'; 
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(car.emoji, 0, 0); 
                    }
                    
                    ctx.restore();

                    // 2. Draw Speed Text (Global coords)
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px sans-serif'; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);
                    ctx.fillText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);

                    if (!car.isAI) {
                        const readings = castRays(car, physics.sensorRange);
                        const angles = [-60, -30, 0, 30, 60];
                        readings.forEach((r, i) => {
                           ctx.save();
                           ctx.translate(car.x, car.y);
                           ctx.rotate(car.angle + (angles[i] * Math.PI / 180));
                           const grad = ctx.createLinearGradient(0, 0, r, 0);
                           grad.addColorStop(0, 'rgba(255, 255, 0, 0.5)');
                           grad.addColorStop(1, 'rgba(255, 0, 0, 0.8)');
                           ctx.fillStyle = grad;
                           ctx.fillRect(0, -1, r, 2);
                           ctx.fillStyle = 'red';
                           ctx.beginPath();
                           ctx.arc(r, 0, 3, 0, Math.PI * 2);
                           ctx.fill();
                           ctx.restore();
                        });
                    }
                });
            };

            // --- Game Control Functions ---

            const resetGame = useCallback(() => {
                setIsPlaying(false);
                setGameState('idle');
                setWinner(null);
                stopEngineSound();
                stopSkidSound();
                startTimeRef.current = 0;
                setUserStats({ laps: 0, currentLapTime: 0, lastLapTime: 0, totalTime: 0, lapHistory: [] });
                currentSkidSegmentId.current = 0;

                const points = getCurrentTrackPoints();
                const startPoint = points[0];
                const startAngle = Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x);
                
                const px = Math.cos(startAngle + Math.PI/2);
                const py = Math.sin(startAngle + Math.PI/2);
                const dx = Math.cos(startAngle);
                const dy = Math.sin(startAngle);

                const spawnX = startPoint.x - dx * 40;
                const spawnY = startPoint.y - dy * 40;
                
                const userChassis = CAR_CHASSIS.find(c => c.id === userData.currentChassis) || CAR_CHASSIS[0]; 
                const aiChassis = CAR_CHASSIS[0]; // AI always uses base chassis (C01)
                const userLogicBlocks = logicSlots[activeSlotIndex].blocks; 
                
                const userVehicle = VEHICLE_TYPES.find(v => v.id === currentVehicleId) || VEHICLE_TYPES[0]; // üåü ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù Ï∫êÎ¶≠ÌÑ∞

                // AI Ï∫êÎ¶≠ÌÑ∞Îäî Í≥†Ï†ï (ÏãúÍ∞ÅÏ†Å ÏùºÍ¥ÄÏÑ±ÏùÑ ÏúÑÌï¥ AIÎäî Í∏∞Î≥∏ Ï∞®ÎüâÏúºÎ°ú Ïú†ÏßÄ)
                const aiVehicle = VEHICLE_TYPES[0]; 

                // üåü cars.currentÏóê Ï∞®Îüâ Í∞ùÏ≤¥Î•º Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÌï©ÎãàÎã§.
                cars.current = [
                    // Player Car
                    { id: 'user', x: spawnX + px * 20, y: spawnY + py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: userChassis.color, chassisId: userChassis.id, isAI: false, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, lapHistory: [], skidMarks: [], isDrifting: false, currentSkidId: 0, logicBlocks: userLogicBlocks, vehicleType: userVehicle.id, emoji: userVehicle.emoji, trailType: userVehicle.trailType },
                    // AI Cars (Í≤ΩÎ°ú Í∏∞Î∞ò AI, Î™®Îëê C01 ÏÑÄÏãú, Í∏∞Î≥∏ Ï∞®Îüâ ÌÉÄÏûÖ)
                    { id: 'ai1', x: spawnX - px * 20, y: spawnY - py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#ef4444', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                    { id: 'ai2', x: spawnX - dx * 40 - px * 10, y: spawnY - dy * 40 + py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#f59e0b', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                    { id: 'ai3', x: spawnX - dx * 40 + px * 10, y: spawnY - dy * 40 - py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#8b5cf6', chassisId: aiChassis.id, isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0, vehicleType: aiVehicle.id, emoji: aiVehicle.emoji, trailType: aiVehicle.trailType },
                ];
                draw(); // Ï¥àÍ∏∞Ìôî ÌõÑ Ï¶âÏãú Í∑∏Î¶¨Í∏∞
            }, [currentTrackIdx, getCurrentTrackPoints, userData, stopEngineSound, stopSkidSound, logicSlots, activeSlotIndex, currentVehicleId]);
            
            const togglePlay = async () => {
                initAudio(); 
                if (currentScreen !== 'race') return;

                if (gameState === 'finished' || gameState === 'idle') { 
                    resetGame(); // Í≤åÏûÑ ÏãúÏûë Ï†Ñ Ï∞®Îüâ Ï¥àÍ∏∞Ìôî Î∞è Í∑∏Î¶¨Í∏∞
                }
                
                const nextIsPlaying = !isPlaying;
                
                if (nextIsPlaying) {
                    setGameState('running');
                    
                    if (startTimeRef.current === 0) {
                        startTimeRef.current = performance.now();
                        cars.current.forEach(c => c.lapStartTime = startTimeRef.current);
                    }
                    if (!isMuted) startEngineSound();
                } else {
                    setGameState('idle');
                    stopEngineSound();
                    stopSkidSound();
                }
                
                setIsPlaying(nextIsPlaying);
                playClickSound();
            };
            
            // --- Logic Slot Handlers ---

            // **Ï£ºÏùò: window.confirm ÎåÄÏã† alert ÏÇ¨Ïö©**
            const handleSaveSlot = (index) => {
                const newSlots = logicSlots.map((slot, i) => 
                    i === index ? { ...slot, blocks: blocks } : slot
                );
                setLogicSlots(newSlots);
                saveLogicData({ slots: newSlots, activeSlotIndex: index });
                playClickSound();
                alert(`Ïä¨Î°Ø ${index + 1} (${newSlots[index].name})Ïóê ÌòÑÏû¨ Î°úÏßÅÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§!`);
                setActiveSlotIndex(index);
            };

            const handleLoadSlot = (index) => {
                if (index === activeSlotIndex) return; // Ïù¥ÎØ∏ Î°úÎìúÎê®
                
                const slotToLoad = logicSlots[index];
                if (slotToLoad) {
                    setBlocks(slotToLoad.blocks || []);
                    setActiveSlotIndex(index);
                    saveLogicData({ slots: logicSlots, activeSlotIndex: index }); // Save active index
                    playClickSound();
                    resetGame(); // Reset game to apply new blocks immediately
                }
            };

            const handleUpdateSlotName = (index, newName) => {
                const safeName = newName.trim().substring(0, 15) || `Ïä¨Î°Ø ${index + 1}`; // 15Ïûê Ï†úÌïú
                const newSlots = logicSlots.map((slot, i) => 
                    i === index ? { ...slot, name: safeName } : slot
                );
                setLogicSlots(newSlots);
                saveLogicData({ slots: newSlots, activeSlotIndex });
                playClickSound();
            };

            // --- React Hooks ---

            useEffect(() => {
                if (isPlaying) {
                    requestRef.current = requestAnimationFrame(update);
                } else {
                    cancelAnimationFrame(requestRef.current);
                    draw();
                    stopEngineSound(); 
                    stopSkidSound();
                }
                return () => {
                    cancelAnimationFrame(requestRef.current);
                    stopEngineSound();
                    stopSkidSound();
                };
            }, [isPlaying, blocks, gameState, physics]);

            // Initial Game/Auth Setup (Load User Data)
            useEffect(() => {
                const handleFirebaseReady = () => {
                    const unsubscribeUser = loadUserData(setUserData, setAuthReady);
                    const unsubscribeAI = loadAIDifficultyData(setAIDifficultyStats); // üåü AI ÎÇúÏù¥ÎèÑ Î°úÎìú
                    return () => { 
                        if (unsubscribeUser) unsubscribeUser(); 
                        if (unsubscribeAI) unsubscribeAI();
                    };
                };

                if (window.firebaseInitialized) {
                    return handleFirebaseReady();
                } else {
                    window.addEventListener('firebase-ready', handleFirebaseReady);
                    return () => window.removeEventListener('firebase-ready', handleFirebaseReady);
                }
            }, []);
            
            // Load Logic Data when Auth is ready
            useEffect(() => {
                if (!authReady) return;

                const unsubscribeLogic = loadLogicData(setLogicSlots, setActiveSlotIndex, setLogicReady);
                
                return () => { 
                    if (unsubscribeLogic) unsubscribeLogic(); 
                };
            }, [authReady]);

            // Sync blocks with loaded logic slots on initial load or active slot change
            useEffect(() => {
                if (logicReady) {
                    const activeSlot = logicSlots[activeSlotIndex];
                    if (activeSlot) {
                         // blocksÍ∞Ä ÌòÑÏû¨ ÌôúÏÑ± Ïä¨Î°ØÏùò ÎÇ¥Ïö©Í≥º Îã§Î•º Í≤ΩÏö∞Îßå ÏóÖÎç∞Ïù¥Ìä∏ (Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ)
                         if (JSON.stringify(blocks) !== JSON.stringify(activeSlot.blocks)) {
                             setBlocks(activeSlot.blocks || []);
                         }
                    }
                }
            }, [logicReady, activeSlotIndex]);


            // Initial reset when Auth & Logic are ready
            useEffect(() => {
                if (authReady && logicReady) {
                    resetGame(); 
                }
            }, [authReady, logicReady]);

            // Reset when track or chassis changes (if game is idle)
            useEffect(() => {
                if (authReady && logicReady && gameState === 'idle') { 
                    resetGame();
                }
            }, [currentTrackIdx, userData.currentChassis, currentVehicleId]);


            // Update physics constants when user data or parts change
            useEffect(() => {
                if (authReady) {
                    const newPhysics = getPhysicsConstants(userData.parts, userData.currentChassis);
                    setPhysics(newPhysics);
                    // üåü Î∂ÄÌíà Î≥ÄÍ≤Ω ÌõÑ Ï∫îÎ≤ÑÏä§Ïóê Ï¶âÏãú Î∞òÏòÅÎêòÎèÑÎ°ù Ïû¨ÏÑ§Ï†ï
                    if(gameState === 'idle') {
                        resetGame();
                    }
                }
            }, [userData.parts, userData.currentChassis, authReady]);


            // --- Block Logic Handlers (Unchanged) ---
            const addBlock = () => {
                const newBlock = { id: Date.now(), flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 50, action: 'BRAKE_100' };
                setBlocks([...blocks, newBlock]);
                playClickSound();
            };

            const updateBlock = (id, field, value) => {
                // Î∏îÎ°ù ÏàòÏ†ï Ïãú active slotÏùò blocksÏôÄ Îã§Î•¥Î©¥ active indexÎ•º -1Î°ú ÏÑ§Ï†ïÌïòÏó¨ 'ÏàòÏ†ïÎê®' ÏÉÅÌÉúÎ•º ÌëúÏãúÌï† ÏàòÎèÑ ÏûàÏßÄÎßå,
                // Ïó¨Í∏∞ÏÑúÎäî Î≥µÏû°ÏÑ±ÏùÑ Ï§ÑÏù¥Í∏∞ ÏúÑÌï¥ ÌòÑÏû¨ blocks ÏÉÅÌÉúÎßå ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
                setBlocks(blocks.map(b => b.id === id ? { ...b, [field]: value } : b));
            };

            const removeBlock = (id) => {
                setBlocks(blocks.filter(b => b.id !== id));
                playClickSound();
            };

            const toggleValueType = (id) => {
                setBlocks(blocks.map(b => {
                    if (b.id === id) {
                        const newType = b.valueType === 'number' ? 'sensor' : 'number';
                        const newValue = newType === 'number' ? 50 : 0; 
                        return { ...b, valueType: newType, value: newValue };
                    }
                    return b;
                }));
                playClickSound();
            };

            const toggleMute = () => {
                setIsMuted(!isMuted);
                playClickSound();
            }

            const fmtTime = (s) => s.toFixed(2) + 's';
            
            // --- Shop/Garage Logic (Upgraded Tiers) ---
            const purchasePart = (partId, currentTier) => {
                const nextTier = currentTier + 1;
                
                // üåü ÏµúÎåÄ Ìã∞Ïñ¥ Ï≤¥ÌÅ¨ Î°úÏßÅ ÏàòÏ†ï
                if (currentTier >= MAX_TIER) {
                   console.error("ÏµúÍ≥† Îì±Í∏âÏûÖÎãàÎã§!");
                   return;
                } 
                
                const nextStats = PART_STATS[nextTier];
                
                if (userData.dollars < nextStats.price) {
                    console.error("Îã¨Îü¨Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!"); 
                    return;
                }

                const newDollars = userData.dollars - nextStats.price;
                const newParts = { ...userData.parts, [partId]: nextTier };
                saveUserData({ ...userData, dollars: newDollars, parts: newParts });
                playClickSound();
                alert(`${PART_TYPES.find(p=>p.id===partId).name} Tier ${nextTier} Íµ¨Îß§ ÏôÑÎ£å!`);
            };
            
            const purchaseChassis = (chassisId, price) => {
                if (userData.currentChassis === chassisId) {
                    saveUserData({ ...userData, currentChassis: chassisId });
                    playClickSound();
                    console.log(`${CAR_CHASSIS.find(c=>c.id===chassisId).name}ÏúºÎ°ú ÍµêÏ≤¥ ÏôÑÎ£å!`);
                    return;
                }
                if (userData.dollars < price) {
                    console.error("Îã¨Îü¨Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!");
                    return;
                }
                
                const chassis = CAR_CHASSIS.find(c => c.id === chassisId);
                const newDollars = userData.dollars - price;
                saveUserData({ ...userData, dollars: newDollars, currentChassis: chassisId });
                playClickSound();
                console.log(`${chassis.name} Íµ¨Îß§ Î∞è Ïû•Ï∞© ÏôÑÎ£å!`);
            };

            // --- UI Components ---
            
            const ShopScreen = () => {
                const currentChassis = CAR_CHASSIS.find(c => c.id === userData.currentChassis) || CAR_CHASSIS[0];

                return (
                    <div className="p-4 lg:p-8 overflow-y-auto no-scrollbar max-w-4xl mx-auto h-full text-slate-200">
                        <h1 className="text-3xl font-extrabold text-yellow-400 mb-6 flex items-center gap-3 border-b border-slate-700 pb-2">
                            <ShoppingCart size={30} /> ÏÉÅÏ†ê (Shop)
                        </h1>
                        <div className="flex justify-between items-center mb-6 p-3 bg-slate-700 rounded-lg shadow-inner">
                            <span className="text-lg font-semibold flex items-center gap-2"><DollarSign size={20} /> ÌòÑÏû¨ ÏûîÏï°:</span>
                            <span className="text-3xl font-mono text-green-400">${userData.dollars.toLocaleString()}</span>
                        </div>

                        {/* --- ÌååÏ∏† ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑπÏÖò --- */}
                        <h2 className="text-2xl font-bold text-blue-400 mt-8 mb-4">ÌååÏ∏† ÏóÖÍ∑∏Î†àÏù¥Îìú (Parts Upgrade)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {PART_TYPES.map(part => {
                                const currentTier = userData.parts[part.id];
                                const nextTier = currentTier + 1;
                                const currentStats = PART_STATS[currentTier];
                                const nextStats = PART_STATS[nextTier];
                                
                                const statKey = getPartStatKey(part.id);

                                const currentVal = currentStats ? currentStats[statKey] : 0; 
                                const nextVal = nextStats ? nextStats[statKey] : null;
                                
                                // üåü MAX TIER Î°úÏßÅ ÏàòÏ†ï
                                const isMaxTier = currentTier >= MAX_TIER;
                                const precision = (part.id === 'tire' || part.id === 'downforce' || part.id === 'steering') ? 3 : 2;

                                return (
                                    <div key={part.id} className="bg-slate-700 p-4 rounded-lg shadow-lg border-l-4 border-slate-600 hover:border-blue-500 transition">
                                        <h3 className="text-xl font-bold mb-2 uppercase">{part.name}</h3>
                                        <div className="text-sm text-slate-400 mb-3">{part.unit} Ìñ•ÏÉÅ</div>
                                        
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-sm">ÌòÑÏû¨ Îì±Í∏â:</span>
                                            <span className={`font-bold text-lg ${currentTier === MAX_TIER ? 'text-yellow-500' : 'text-slate-200'}`}>Tier {currentTier} / {MAX_TIER}</span>
                                        </div>

                                        <div className="flex justify-between items-center mb-4">
                                            <span className="text-sm">ÌòÑÏû¨ ÏÑ±Îä•:</span>
                                            <span className="font-mono text-base text-blue-300">{currentVal.toFixed(precision)}</span>
                                        </div>

                                        <div className="border-t border-slate-600 pt-3">
                                            {isMaxTier ? (
                                                <span className="text-lg font-bold text-green-500">MAX TIER Îã¨ÏÑ±</span>
                                            ) : (
                                                <div className="flex flex-col gap-2">
                                                    <div className="flex justify-between text-sm text-slate-400">
                                                        <span>Îã§Ïùå Îì±Í∏â (T{nextTier}):</span>
                                                        <span className="font-mono text-yellow-300">+{nextVal !== null ? (nextVal - currentVal).toFixed(precision) : 'N/A'}</span>
                                                    </div>
                                                    <button
                                                        onClick={() => purchasePart(part.id, currentTier)}
                                                        className="w-full py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-500 transition disabled:bg-slate-500"
                                                        disabled={userData.dollars < nextStats.price}
                                                    >
                                                        ${nextStats.price.toLocaleString()} Íµ¨Îß§
                                                    </button>
                                                    {userData.dollars < nextStats.price && <span className="text-red-400 text-xs text-center">ÏûîÏï° Î∂ÄÏ°±</span>}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {/* --- Ï∞®Îüâ ÏÑÄÏãú ÏÑπÏÖò --- */}
                        <h2 className="text-2xl font-bold text-blue-400 mt-10 mb-4">Ï∞®Îüâ ÏÑÄÏãú (Chassis)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {CAR_CHASSIS.map(chassis => {
                                const isOwned = userData.currentChassis === chassis.id;
                                const isPurchased = chassis.id !== 'C01' && userData.dollars >= chassis.price;

                                return (
                                    <div key={chassis.id} className={`bg-slate-700 p-4 rounded-lg shadow-lg border-l-4 ${isOwned ? 'border-yellow-500' : 'border-slate-600'} hover:border-yellow-500 transition`}>
                                        <div className="w-full h-10 flex justify-center items-center mb-2">
                                            <div className="w-16 h-8 rounded-md shadow-xl" style={{ backgroundColor: chassis.color }}></div>
                                        </div>
                                        <h3 className="text-xl font-bold mb-1 text-center">{chassis.name}</h3>
                                        <div className="text-xs text-slate-400 text-center mb-3">{chassis.id}</div>
                                        
                                        <ul className="text-sm space-y-1 mb-4 border-t border-slate-600 pt-2">
                                            <li className="flex justify-between">Í∞ÄÏÜç Í∏∞Î∞ò: <span>{chassis.baseAccel}</span></li>
                                            <li className="flex justify-between">Ï†ëÏßÄ Í∏∞Î∞ò: <span>{chassis.baseGrip}</span></li>
                                            <li className="flex justify-between">ÏµúÍ≥† ÏÜçÎèÑ Î≥¥ÎÑàÏä§: <span>+{chassis.maxSpeedBonus}</span></li>
                                        </ul>

                                        <button
                                            onClick={() => purchaseChassis(chassis.id, chassis.price)}
                                            className={`w-full py-2 font-bold rounded-lg transition disabled:bg-slate-500 ${isOwned ? 'bg-yellow-500 text-slate-900' : (chassis.id === 'C01' || isPurchased ? 'bg-green-600 text-white' : 'bg-slate-600 text-slate-300')}`}
                                            disabled={!isOwned && chassis.id !== 'C01' && userData.dollars < chassis.price}
                                        >
                                            {isOwned ? 'ÌòÑÏû¨ Ïû•Ï∞©Îê®' : (chassis.id === 'C01' ? 'Í∏∞Î≥∏ Ïû•Ï∞©' : (userData.dollars >= chassis.price ? `Íµ¨Îß§ Î∞è Ïû•Ï∞© ($${chassis.price.toLocaleString()})` : 'ÏûîÏï° Î∂ÄÏ°±'))}
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            // --- Main App Render ---
            
            if (!authReady || !logicReady) {
                return <div className="flex h-screen items-center justify-center text-xl text-blue-400">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...</div>;
            }

            return (
                <div className="flex flex-col-reverse lg:flex-row h-screen bg-slate-900 text-slate-100 overflow-hidden font-sans">
                    
                    {/* --- Sidebar: Coding Area / Shop / Garage (Width: 40% on LG, Height: 70% on mobile) --- */}
                    <div className="w-full lg:w-[40%] h-[70%] lg:h-full flex flex-col border-t lg:border-t-0 lg:border-r border-slate-700 bg-slate-800 shadow-xl z-20">
                        
                        {/* Tab Navigation */}
                        <div className="flex justify-between items-center p-2 bg-slate-900 border-b border-slate-700">
                            <div className="flex gap-2">
                                <button 
                                    onClick={() => { setCurrentScreen('race'); playClickSound(); }} 
                                    className={`px-3 py-1.5 rounded-t-lg font-bold text-sm lg:text-base transition ${currentScreen === 'race' ? 'bg-slate-800 text-blue-400' : 'text-slate-400 hover:bg-slate-700'}`}>
                                    <Cpu size={18} className="inline-block mr-1" /> Î°úÏßÅ ÏóêÎîîÌÑ∞
                                </button>
                                <button 
                                    onClick={() => { setCurrentScreen('shop'); playClickSound(); }} 
                                    className={`px-3 py-1.5 rounded-t-lg font-bold text-sm lg:text-base transition ${currentScreen === 'shop' ? 'bg-slate-800 text-yellow-400' : 'text-slate-400 hover:bg-slate-700'}`}>
                                    <ShoppingCart size={18} className="inline-block mr-1" /> ÏÉÅÏ†ê
                                </button>
                            </div>
                            {currentScreen === 'shop' && (
                                    <div className="flex items-center gap-2 text-sm lg:text-base font-semibold text-green-400">
                                        <DollarSign size={16} /> ${userData.dollars.toLocaleString()}
                                    </div>
                            )}
                        </div>

                        {/* --- Logic Editor Screen --- */}
                        {currentScreen === 'race' && (
                            <React.Fragment>
                                {/* Î°úÏßÅ Ïä¨Î°Ø Í¥ÄÎ¶¨ UI (Padding Reduced, Text Smaller) */}
                                <div className="p-2 lg:p-3 bg-slate-900 border-b border-slate-700 space-y-2 lg:space-y-3">
                                    <h3 className="text-xs lg:text-sm font-bold text-slate-400 flex items-center gap-2">
                                        <Folder size={14} /> Î°úÏßÅ Ïä¨Î°Ø (5Í∞ú)
                                    </h3>
                                    <div className="grid grid-cols-5 gap-1 lg:gap-2">
                                        {logicSlots.map((slot, index) => (
                                            <div key={index} className="flex flex-col gap-1 items-stretch">
                                                <input 
                                                    type="text"
                                                    value={slot.name}
                                                    onChange={(e) => handleUpdateSlotName(index, e.target.value)}
                                                    className={`bg-slate-700 text-[10px] lg:text-xs text-center px-1 py-0.5 rounded-t-lg border-b-2 outline-none transition ${index === activeSlotIndex ? 'border-yellow-500 text-yellow-300 font-bold' : 'border-slate-600 text-slate-300'}`}
                                                    placeholder={`Ïä¨Î°Ø ${index + 1}`}
                                                    maxLength={15}
                                                />
                                                <div className="flex gap-1 justify-stretch">
                                                    <button
                                                        onClick={() => handleLoadSlot(index)}
                                                        className={`flex-1 text-[9px] lg:text-[10px] py-0.5 rounded-b-lg font-bold transition disabled:opacity-50 ${index === activeSlotIndex ? 'bg-yellow-500 text-slate-900' : 'bg-slate-600 hover:bg-blue-500'}`}
                                                        disabled={index === activeSlotIndex}
                                                    >
                                                        {index === activeSlotIndex ? 'ÌôúÏÑ±' : 'Î°úÎìú'}
                                                    </button>
                                                    <button
                                                        onClick={() => handleSaveSlot(index)}
                                                        className={`text-[9px] lg:text-[10px] py-0.5 px-1 rounded-b-lg font-bold bg-green-600 text-white hover:bg-green-500 transition flex items-center justify-center`}
                                                        title={`${index === activeSlotIndex ? 'ÌòÑÏû¨ ÌôúÏÑ± Ïä¨Î°ØÏóê ÎçÆÏñ¥Ïì∞Í∏∞' : 'ÌòÑÏû¨ Î°úÏßÅÏùÑ Ï†ÄÏû•'}`}
                                                    >
                                                        <Save size={12} />
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                {/* // Î°úÏßÅ Ïä¨Î°Ø Í¥ÄÎ¶¨ UI ÎÅù */}


                                {/* Í≤åÏûÑ Ïª®Ìä∏Î°§ Î∞è ÌååÏ∏† ÏÑ±Îä• (Padding Reduced, Controls consolidated) */}
                                <div className="p-2 lg:p-3 bg-slate-900 border-b border-slate-700 space-y-1 lg:space-y-2">
                                    <div className="flex justify-between items-center">
                                        <h2 className="text-sm lg:text-base font-bold flex items-center gap-1 text-blue-400">
                                            <Wrench size={16} /> ÌååÏ∏† ÏÑ±Îä•: {physics.acceleration.toFixed(2)} / {physics.maxSpeed.toFixed(1)}
                                        </h2>
                                        <div className="flex gap-1 lg:gap-2">
                                            <button onClick={() => { resetGame(); playClickSound(); }} className="p-1 lg:p-1.5 bg-slate-700 hover:bg-slate-600 rounded-lg transition" title="Ï¥àÍ∏∞Ìôî">
                                                <RotateCcw size={16} />
                                            </button>
                                            <button onClick={togglePlay} className={`p-1 lg:p-1.5 rounded-lg transition flex items-center gap-1 lg:gap-2 font-bold px-2 lg:px-3 text-sm lg:text-base ${isPlaying ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-green-600 hover:bg-green-500'}`}>
                                                {isPlaying ? <Pause size={16} /> : <Play size={16} />}
                                                {isPlaying ? 'ÏùºÏãúÏ†ïÏßÄ' : 'ÏãúÏûë'}
                                            </button>
                                        </div>
                                    </div>
                                    
                                    {/* üåü Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù (New UI element) */}
                                    <div className="flex items-center gap-2 bg-slate-800 p-1 lg:p-1.5 rounded-lg border border-slate-700">
                                        <Car size={14} className="text-slate-400" />
                                        <select 
                                            className="bg-transparent text-sm lg:text-base w-full outline-none text-slate-200"
                                            value={currentVehicleId}
                                            onChange={(e) => { 
                                                setCurrentVehicleId(e.target.value); 
                                                playClickSound(); 
                                                resetGame(); 
                                            }}
                                        >
                                            {VEHICLE_TYPES.map((v) => (
                                                <option key={v.id} value={v.id}>{v.emoji} {v.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    {/* Ìä∏Îûô ÏÑ†ÌÉù (ÌÅ¨Í∏∞ Ïú†ÏßÄ) */}
                                    <div className="flex items-center gap-2 bg-slate-800 p-1 lg:p-1.5 rounded-lg border border-slate-700">
                                        <MapIcon size={14} className="text-slate-400" />
                                        <select 
                                            className="bg-transparent text-sm lg:text-base w-full outline-none text-slate-200"
                                            value={currentTrackIdx}
                                            onChange={(e) => { setCurrentTrackIdx(Number(e.target.value)); playClickSound(); }}
                                        >
                                            {TRACK_LAYOUTS.map((track, idx) => (
                                                <option key={track.id} value={idx}>{track.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                </div>


                                {/* Î°úÏßÅ Î∏îÎ°ù Ìé∏Ïßë ÏòÅÏó≠ (Main focus area) */}
                                <div className="flex-1 overflow-y-auto p-2 lg:p-4 space-y-2 lg:space-y-3 no-scrollbar">
                                    {blocks.length === 0 && (<div className="text-slate-500 text-center py-10 italic text-sm">Î°úÏßÅ Î∏îÎ°ùÏù¥ ÏóÜÏäµÎãàÎã§.</div>)}
                                    
                                    {blocks.map((block) => {
                                        const flow = FLOW_OPTIONS.find(f => f.value === block.flowType);
                                        const isElse = block.flowType === 'ELSE';
                                        const isIfElseIf = block.flowType === 'IF' || block.flowType === 'ELSE_IF';
                                        const borderClass = flow ? flow.color : 'border-slate-500';

                                        // Ïï°ÏÖò Ïù¥Î¶Ñ Î∞è ÏÉâÏÉÅ Îß§Ìïë
                                        let actionClass = 'bg-slate-900 text-slate-200';
                                        if (block.action.startsWith('LEFT') || block.action.startsWith('RIGHT')) {
                                            actionClass = 'bg-indigo-900 text-indigo-200';
                                        } else if (block.action.startsWith('ACCEL')) {
                                            actionClass = 'bg-green-900 text-green-200';
                                        } else if (block.action.startsWith('BRAKE')) {
                                            actionClass = 'bg-red-900 text-red-200';
                                        }

                                        return (
                                            <div key={block.id} className={`bg-slate-700 p-2 lg:p-3 rounded-lg border-l-4 ${borderClass} shadow-sm flex items-center gap-1.5 lg:gap-2 flex-wrap text-xs lg:text-sm group`}>
                                                
                                                <select className={`bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none font-bold max-w-[100px] lg:max-w-[120px] 
                                                     ${block.flowType === 'ELSE' ? 'w-full' : ''}`}
                                                    value={block.flowType} onChange={(e) => updateBlock(block.id, 'flowType', e.target.value)}>
                                                    {FLOW_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                                                </select>

                                                {isIfElseIf && (
                                                    <React.Fragment>
                                                        <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none max-w-[80px] lg:max-w-none"
                                                            value={block.sensor} onChange={(e) => updateBlock(block.id, 'sensor', parseInt(e.target.value))}>
                                                            {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                                        </select>
                                                        
                                                        <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                                            value={block.operator} onChange={(e) => updateBlock(block.id, 'operator', e.target.value)}>
                                                            {OPERATOR_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                                                        </select>

                                                        <button onClick={() => toggleValueType(block.id)}
                                                            className="p-1 rounded bg-slate-600 hover:bg-slate-500 text-slate-200 transition"
                                                            title={block.valueType === 'number' ? "Ïà´ÏûêÏôÄ ÎπÑÍµêÌïòÍ∏∞" : "Îã§Î•∏ ÏÑºÏÑúÏôÄ ÎπÑÍµêÌïòÍ∏∞"}>
                                                            {block.valueType === 'number' ? <Hash size={12} /> : <Radar size={12} />}
                                                        </button>
                                                        
                                                        {block.valueType === 'number' ? (
                                                            <input type="number" className="bg-slate-900 border border-slate-600 rounded w-12 lg:w-16 px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                                                value={block.value} 
                                                                onChange={(e) => {
                                                                    const val = parseInt(e.target.value);
                                                                    updateBlock(block.id, 'value', isNaN(val) ? 0 : val);
                                                                }} 
                                                            />
                                                        ) : (
                                                            <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none w-20 lg:w-24"
                                                                value={block.value} onChange={(e) => updateBlock(block.id, 'value', parseInt(e.target.value))}>
                                                                {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                                            </select>
                                                        )}
                                                    </React.Fragment>
                                                )}

                                                <span className="font-bold text-blue-300">‚Üí</span>
                                                
                                                {/* üåü ÌôïÏû•Îêú Ïï°ÏÖò ÎìúÎ°≠Îã§Ïö¥ */}
                                                <select className={`border border-slate-600 rounded px-1 lg:px-2 py-1 font-bold outline-none flex-grow ${actionClass}
                                                     ${isElse ? 'w-full' : ''}`}
                                                    value={block.action} onChange={(e) => updateBlock(block.id, 'action', e.target.value)}>
                                                    <option value="LEFT">Ï¢åÌöåÏ†Ñ</option>
                                                    <option value="RIGHT">Ïö∞ÌöåÏ†Ñ</option>
                                                    <option value="ACCEL_100">Í∞ÄÏÜç (100%)</option>
                                                    <option value="ACCEL_75">Í∞ÄÏÜç (75%)</option>
                                                    <option value="ACCEL_50">Í∞ÄÏÜç (50%)</option>
                                                    <option value="BRAKE_100">Í∞êÏÜç (100%)</option>
                                                    <option value="BRAKE_75">Í∞êÏÜç (75%)</option>
                                                    <option value="BRAKE_50">Í∞êÏÜç (50%)</option>
                                                </select>
                                                <button onClick={() => removeBlock(block.id)} className="text-slate-500 hover:text-red-400 ml-auto opacity-100 lg:opacity-0 group-hover:opacity-100 transition"><Trash2 size={14} /></button>
                                            </div>
                                        );
                                    })}

                                    <button onClick={addBlock} className="w-full py-2 lg:py-3 border-2 border-dashed border-slate-600 text-slate-400 rounded-lg hover:border-blue-500 hover:text-blue-400 transition flex justify-center items-center gap-2 text-sm lg:text-base">
                                        <Plus size={16} /> Î°úÏßÅ Î∏îÎ°ù Ï∂îÍ∞Ä
                                    </button>
                                </div>
                            </React.Fragment>
                        )}

                        {/* --- Shop Screen --- */}
                        {currentScreen === 'shop' && <ShopScreen />}

                    </div>

                    {/* --- Main View: Canvas (Width: 60% on LG, Height: 30% on mobile) --- */}
                    <div className="w-full lg:flex-1 h-[30%] lg:h-full relative bg-neutral-800 flex justify-center items-center p-2 lg:p-4 overflow-hidden">
                        {currentScreen === 'race' ? (
                            <canvas ref={canvasRef} width={TRACK_WIDTH} height={TRACK_HEIGHT}
                                className="bg-green-500 rounded-xl shadow-2xl max-w-full max-h-full object-contain cursor-crosshair" />
                        ) : (
                            <div className="text-slate-400 text-center text-xl">ÏÉÅÏ†êÏóêÏÑú ÌååÏ∏†Î•º ÌôïÏù∏Ìï¥ Î≥¥ÏÑ∏Ïöî!</div>
                        )}
                        
                        {/* Top Left: Lap Time History Panel (Visible on race screen only) */}
                        {currentScreen === 'race' && (
                            <div className="absolute top-2 left-2 lg:top-6 lg:left-6 pointer-events-none scale-75 lg:scale-100 origin-top-left">
                                <div className="bg-slate-900/90 backdrop-blur p-3 rounded-xl border border-slate-700 shadow-xl space-y-2 min-w-[140px]">
                                    <div className="text-[10px] uppercase tracking-widest text-slate-400 border-b border-slate-700 pb-1 mb-1">Lap History</div>
                                    {[...Array(TOTAL_LAPS)].map((_, i) => {
                                        const lapTime = userStats.lapHistory[i];
                                        const isCurrent = userStats.laps === i;
                                        return (
                                            <div key={i} className="flex justify-between items-center text-xs font-mono">
                                                <span className={isCurrent ? 'text-yellow-400 font-bold' : 'text-slate-500'}>LAP {i + 1}</span>
                                                <span className={isCurrent ? 'text-white' : (lapTime ? 'text-green-400' : 'text-slate-600')}>
                                                    {lapTime ? fmtTime(lapTime) : (isCurrent ? fmtTime(userStats.currentLapTime) : '--:--')}
                                                </span>
                                            </div>
                                        )
                                    })}
                                    <div className="border-t border-slate-700 pt-1 flex justify-between items-center text-xs font-mono text-blue-300 mt-1">
                                        <span>TOTAL</span>
                                        <span>{fmtTime(userStats.totalTime)}</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Top Right State Badge & Mute (Visible on race screen only) */}
                        {currentScreen === 'race' && (
                            <React.Fragment>
                                <div className="absolute top-2 right-2 lg:top-6 lg:right-6 pointer-events-auto flex gap-2">
                                    <button onClick={toggleMute} className="bg-slate-900/80 backdrop-blur p-2 rounded-full border border-slate-700 shadow-lg text-slate-300 hover:bg-slate-800 transition scale-90 lg:scale-100">
                                        {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
                                    </button>
                                    <div className="bg-slate-900/80 backdrop-blur px-3 py-1 lg:px-6 lg:py-2 rounded-full border border-slate-700 shadow-lg flex items-center gap-2 lg:gap-4 scale-90 lg:scale-100 origin-top-right">
                                        <div className="text-slate-400 text-[10px] lg:text-xs uppercase tracking-widest">ÏÉÅÌÉú</div>
                                        <div className={`text-base lg:text-xl font-black italic ${gameState === 'running' ? 'text-green-400' : 'text-slate-200'}`}>
                                            {gameState === 'idle' && 'READY'}
                                            {gameState === 'running' && 'RUN'}
                                            {gameState === 'finished' && 'FINISH'}
                                        </div>
                                    </div>
                                </div>

                                {/* Winner Badge */}
                                {gameState === 'finished' && (
                                    <div className="absolute top-12 lg:top-6 left-0 right-0 flex justify-center gap-4 px-4 pointer-events-none">
                                        {/* üåü UI Î≥¥ÏÉÅ Í∏àÏï° ÏàòÏ†ï Î∞òÏòÅ */}
                                        <div className={`bg-slate-900/90 backdrop-blur px-4 py-2 lg:px-6 lg:py-3 rounded-full border border-slate-700 shadow-2xl flex items-center gap-2 font-bold animate-bounce ${winner === 'user' ? 'text-yellow-400' : 'text-red-400'} text-sm lg:text-base`}>
                                            <Trophy size={16} />
                                            {winner === 'user' ? `Ïö∞Ïäπ! ($1000+ ÌöçÎìù)` : 'Ìå®Î∞∞! ($300 ÌöçÎìù)'}
                                        </div>
                                    </div>
                                )}

                                {/* üåü Ïù¥ÎèôÎêú Ïã§ÏãúÍ∞Ñ ÏÑºÏÑú Í±∞Î¶¨ (Bottom Right) üåü */}
                                <div className="absolute bottom-2 right-2 lg:bottom-4 lg:right-4 pointer-events-none scale-75 lg:scale-100 origin-bottom-right">
                                    <div className="bg-slate-900/90 backdrop-blur p-2 lg:p-3 rounded-xl border border-slate-700 shadow-xl space-y-1">
                                        <div className="flex items-center gap-2 mb-1 text-[9px] lg:text-[10px] uppercase tracking-wider text-slate-400">
                                            <Activity size={10} /> Ïã§ÏãúÍ∞Ñ ÏÑºÏÑú Í±∞Î¶¨
                                        </div>
                                        <div className="grid grid-cols-5 gap-1 text-center">
                                            {sensorReadings.map((val, idx) => {
                                                const labels = ['Ï¢åÏ∏°', 'Ï†ÑÎ∞©Ï¢åÏ∏°', 'Ï†ÑÎ∞©', 'Ï†ÑÎ∞©Ïö∞Ï∏°', 'Ïö∞Ï∏°'];
                                                const color = val < 50 ? 'text-red-400' : 'text-green-400';
                                                return (
                                                    <div key={idx} className="bg-slate-800 p-0.5 lg:p-1 rounded border border-slate-700">
                                                        <div className="text-[7px] lg:text-[9px] text-slate-500">{labels[idx]}</div>
                                                        <div className={`font-mono text-[9px] lg:text-xs font-bold ${color}`}>{Math.round(val)}</div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* AI Lap Counters (Bottom Left) */}
                                <div className="absolute bottom-2 left-2 lg:bottom-4 lg:left-4 flex gap-2 lg:gap-4 scale-75 lg:scale-100 origin-bottom-left">
                                    {cars.current.slice(1).map(c => (
                                        <div key={c.id} className="bg-slate-900/80 backdrop-blur p-1.5 lg:p-2 rounded border border-slate-700 flex flex-col items-center min-w-[50px] lg:min-w-[60px]">
                                            <div className="w-2.5 h-2.5 lg:w-3 lg:h-3 rounded-full mb-1" style={{backgroundColor: c.color}}></div>
                                            <div className="text-[9px] lg:text-xs text-slate-400">{c.id.toUpperCase()}</div>
                                            <div className="font-mono font-bold text-xs lg:text-sm">{c.laps}/{TOTAL_LAPS}</div>
                                        </div>
                                    ))}
                                </div>
                            </React.Fragment>
                        )}
                    </div>
                </div>
            );
        };

        const root = window.ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
