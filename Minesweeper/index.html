<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Sweeper</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes bounce {
            0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8,0,1,1); }
            50% { transform: none; animation-timing-function: cubic-bezier(0,0,0.2,1); }
        }
        .animate-bounce {
            animation: bounce 1s infinite;
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen flex items-center justify-center font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // --- ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ (Lucide Icons ëŒ€ì²´) ---
        const Heart = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></svg>
        );
        const Skull = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></svg>
        );
        const Key = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="7.5" cy="15.5" r="5.5"/><path d="m21 2-9.6 9.6"/><path d="m15.5 7.5 3 3L22 7l-3-3"/></svg>
        );
        const DoorOpen = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M13 4h3a2 2 0 0 1 2 2v14"/><path d="M2 20h3"/><path d="M13 20h9"/><path d="M10 12v.01"/><path d="M13 4.562v16.157a1 1 0 0 1-1.242.97L5 20V5.562a2 2 0 0 1 1.515-1.94l4-1A2 2 0 0 1 13 4.561Z"/></svg>
        );
        const RefreshCw = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Trophy = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
        );
        const Coins = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="8" cy="8" r="6"/><path d="M18.09 10.37A6 6 0 1 1 10.34 18"/><path d="M7 6h1v4"/><path d="m7.1 13.8 3.1-9.1"/><path d="M10.8 17.7l-3.1-9.1"/></svg>
        );

        // --- ê²Œì„ ìƒìˆ˜ ---
        const GRID_SIZE = 10;
        const INITIAL_HP = 3;
        const TRAP_COUNT = 15;
        const GOLD_COUNT = 5;
        const POTION_COUNT = 3;

        const DungeonSweeper = () => {
            const [grid, setGrid] = useState([]);
            const [playerPos, setPlayerPos] = useState({ x: 0, y: 0 });
            const [hp, setHp] = useState(INITIAL_HP);
            const [gold, setGold] = useState(0);
            const [hasKey, setHasKey] = useState(false);
            const [gameStatus, setGameStatus] = useState('playing'); // playing, won, lost
            const [message, setMessage] = useState("ë˜ì „ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤! ì—´ì‡ ë¥¼ ì°¾ì•„ íƒˆì¶œí•˜ì„¸ìš”.");
            const [floor, setFloor] = useState(1);

            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            const initGame = useCallback((level = 1) => {
                const newGrid = [];
                const traps = [];
                
                // 1. ê·¸ë¦¬ë“œ ìƒì„±
                for (let y = 0; y < GRID_SIZE; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        row.push({
                            x, y,
                            type: 'empty',
                            state: 'hidden',
                            adjacentDanger: 0,
                            id: `${x}-${y}`
                        });
                    }
                    newGrid.push(row);
                }

                // 2. ì‹œì‘ì  ì„¤ì • (0,0)
                newGrid[0][0].type = 'start';
                newGrid[0][0].state = 'revealed';
                const safeZone = [`0,0`, `0,1`, `1,0`, `1,1`];

                // 3. ì•„ì´í…œ ë°°ì¹˜
                const placeItem = (type, count) => {
                    let placed = 0;
                    while (placed < count) {
                        const rx = Math.floor(Math.random() * GRID_SIZE);
                        const ry = Math.floor(Math.random() * GRID_SIZE);
                        const key = `${rx},${ry}`;
                        
                        if (!safeZone.includes(key) && newGrid[ry][rx].type === 'empty') {
                            newGrid[ry][rx].type = type;
                            if (type === 'trap') traps.push({x: rx, y: ry});
                            placed++;
                        }
                    }
                };

                const currentTrapCount = TRAP_COUNT + (level - 1) * 2;

                placeItem('door', 1);
                placeItem('key', 1);
                placeItem('trap', currentTrapCount);
                placeItem('potion', POTION_COUNT);
                placeItem('gold', GOLD_COUNT);

                // 4. ìœ„í—˜ë„ ê³„ì‚°
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (newGrid[y][x].type === 'trap') continue;

                        let danger = 0;
                        directions.forEach(([dx, dy]) => {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                                if (newGrid[ny][nx].type === 'trap') danger++;
                            }
                        });
                        newGrid[y][x].adjacentDanger = danger;
                    }
                }

                setGrid(newGrid);
                setPlayerPos({ x: 0, y: 0 });
                setHasKey(false);
                setGameStatus('playing');
                if (level === 1) {
                    setHp(INITIAL_HP);
                    setGold(0);
                    setFloor(1);
                    setMessage("ìƒˆë¡œìš´ ëª¨í—˜ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì—´ì‡ ë¥¼ ì°¾ìœ¼ì„¸ìš”!");
                } else {
                    setFloor(level);
                    setMessage(`${level}ì¸µì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ë” ìœ„í—˜í•´ì§‘ë‹ˆë‹¤!`);
                }
            }, []);

            useEffect(() => {
                initGame(1);
            }, [initGame]);

            // í™ìˆ˜ ì•Œê³ ë¦¬ì¦˜ (ë¹ˆ ê³µê°„ ìë™ ì˜¤í”ˆ)
            const revealEmptyArea = (startGrid, x, y) => {
                const queue = [{x, y}];
                const visited = new Set();
                const newGrid = [...startGrid];

                while (queue.length > 0) {
                    const {x: cx, y: cy} = queue.shift();
                    const key = `${cx},${cy}`;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    if (cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE) continue;
                    
                    const cell = newGrid[cy][cx];
                    if (cell.state === 'revealed' && !(cx === x && cy === y)) continue;

                    cell.state = 'revealed';

                    if (cell.type === 'empty' && cell.adjacentDanger === 0) {
                        directions.forEach(([dx, dy]) => {
                            queue.push({x: cx + dx, y: cy + dy});
                        });
                    }
                }
                return newGrid;
            };

            const handleMove = (x, y) => {
                if (gameStatus !== 'playing') return;

                const isAdjacent = Math.abs(playerPos.x - x) <= 1 && Math.abs(playerPos.y - y) <= 1;
                if (!isAdjacent) {
                    setMessage("ê·¸ê³³ì€ ë„ˆë¬´ ë©‰ë‹ˆë‹¤! ì¸ì ‘í•œ ì¹¸ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                    return;
                }

                const targetCell = grid[y][x];
                let newGrid = [...grid];
                let currentHp = hp;
                let currentMsg = "";

                // 1. ì´ë¯¸ ê³µê°œëœ ê³³ìœ¼ë¡œ ì´ë™
                if (targetCell.state === 'revealed') {
                    if (targetCell.type === 'door') {
                        if (hasKey) {
                            initGame(floor + 1);
                            return;
                        } else {
                            currentMsg = "ë¬¸ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ í•„ìš”í•©ë‹ˆë‹¤!";
                        }
                    } else {
                        setPlayerPos({ x, y });
                        return;
                    }
                } 
                // 2. ìˆ¨ê²¨ì§„ ê³³ íƒí—˜
                else {
                    if (targetCell.type === 'trap') {
                        currentHp -= 1;
                        setHp(currentHp);
                        targetCell.state = 'revealed';
                        currentMsg = "ìœ¼ì•…! í•¨ì •ì„ ë°Ÿì•˜ìŠµë‹ˆë‹¤! ì²´ë ¥ -1";
                        
                        if (currentHp <= 0) {
                            setGameStatus('lost');
                            setMessage("ì²´ë ¥ì´ ë‹¤í–ˆìŠµë‹ˆë‹¤... íƒí—˜ ì‹¤íŒ¨.");
                            return;
                        }
                    } else {
                        if (targetCell.type === 'potion') {
                            const newHp = Math.min(currentHp + 1, INITIAL_HP + 2);
                            setHp(newHp);
                            currentHp = newHp;
                            currentMsg = "í¬ì…˜ ë°œê²¬! ì²´ë ¥ì´ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.";
                            targetCell.type = 'empty';
                        } else if (targetCell.type === 'gold') {
                            setGold(g => g + 10);
                            currentMsg = "ê¸ˆí™” ë°œê²¬! (+10 Gold)";
                            targetCell.type = 'empty';
                        } else if (targetCell.type === 'key') {
                            setHasKey(true);
                            currentMsg = "ì—´ì‡ ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤! ì´ì œ ë¬¸ì„ ì—´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
                            targetCell.type = 'empty';
                        } else if (targetCell.type === 'door') {
                            currentMsg = "ì¶œêµ¬ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ í•„ìš”í•©ë‹ˆë‹¤.";
                        }

                        if (targetCell.adjacentDanger === 0 && targetCell.type === 'empty') {
                            newGrid = revealEmptyArea(newGrid, x, y);
                        } else {
                            targetCell.state = 'revealed';
                        }
                    }
                }

                setGrid(newGrid);
                setPlayerPos({ x, y });
                if (currentMsg) setMessage(currentMsg);
            };

            const getCellContent = (cell) => {
                const isPlayerHere = playerPos.x === cell.x && playerPos.y === cell.y;
                
                if (isPlayerHere) {
                    return <div className="text-2xl animate-bounce">ğŸ¤ </div>;
                }

                if (cell.state === 'hidden') {
                    return <div className="w-full h-full bg-slate-700 hover:bg-slate-600 rounded-sm cursor-pointer border border-slate-600" />;
                }

                let content = null;
                if (cell.type === 'trap') content = <Skull className="text-red-500 w-6 h-6" />;
                else if (cell.type === 'potion') content = <Heart className="text-pink-500 fill-pink-500 w-5 h-5" />;
                else if (cell.type === 'gold') content = <Coins className="text-yellow-400 w-5 h-5" />;
                else if (cell.type === 'key') content = <Key className="text-yellow-500 w-6 h-6 rotate-45" />;
                else if (cell.type === 'door') content = <DoorOpen className={`w-6 h-6 ${hasKey ? 'text-green-400' : 'text-slate-400'}`} />;
                else if (cell.type === 'start') content = <span className="text-xs text-slate-400">START</span>;
                else if (cell.adjacentDanger > 0) {
                    const colors = ['text-blue-400', 'text-green-400', 'text-red-400', 'text-purple-400', 'text-orange-400'];
                    content = <span className={`font-bold text-xl ${colors[cell.adjacentDanger-1] || 'text-red-600'}`}>{cell.adjacentDanger}</span>;
                }

                return (
                    <div className={`w-full h-full flex items-center justify-center border border-slate-800 rounded-sm 
                        ${cell.type === 'trap' ? 'bg-red-900/30' : 'bg-slate-900'}`}>
                        {content}
                    </div>
                );
            };

            return (
                <div className="max-w-md w-full bg-slate-900 p-6 rounded-xl shadow-2xl border border-slate-800">
                    
                    {/* ìƒíƒœ ë°” */}
                    <div className="flex justify-between items-center mb-6 bg-slate-800 p-3 rounded-lg">
                        <div className="flex items-center gap-4">
                            <div className="flex items-center gap-1 text-pink-400">
                                <Heart className="fill-pink-400 w-5 h-5" />
                                <span className="font-bold text-lg">x {hp}</span>
                            </div>
                            <div className="flex items-center gap-1 text-yellow-400">
                                <Trophy className="w-5 h-5" />
                                <span className="font-bold text-lg">{floor}F</span>
                            </div>
                            <div className="flex items-center gap-1 text-yellow-200 text-sm">
                                <Coins className="w-4 h-4" />
                                <span>{gold}</span>
                            </div>
                        </div>
                        <div className="flex items-center gap-2">
                            {hasKey ? (
                                <div className="flex items-center gap-1 text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded">
                                    <Key className="w-4 h-4" /> <span className="text-xs font-bold">KEY GET!</span>
                                </div>
                            ) : (
                                <div className="text-slate-500 text-xs">ì—´ì‡  ì°¾ëŠ” ì¤‘...</div>
                            )}
                        </div>
                    </div>

                    {/* ë©”ì‹œì§€ */}
                    <div className="mb-4 text-center h-8 text-sm text-cyan-300 font-medium animate-pulse">
                        {message}
                    </div>

                    {/* ê·¸ë¦¬ë“œ */}
                    <div 
                        className="grid gap-1 mb-6 mx-auto bg-slate-800 p-2 rounded-lg relative"
                        style={{ 
                            gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))`,
                            width: 'fit-content'
                        }}
                    >
                        {grid.map((row, y) => (
                            row.map((cell, x) => (
                                <div 
                                    key={cell.id}
                                    onClick={() => handleMove(x, y)}
                                    className="w-8 h-8 sm:w-9 sm:h-9 relative"
                                >
                                    {getCellContent(cell)}
                                </div>
                            ))
                        ))}
                        
                        {gameStatus === 'lost' && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-lg z-10 backdrop-blur-sm">
                                <Skull className="w-16 h-16 text-red-500 mb-2 animate-bounce" />
                                <h2 className="text-2xl font-bold text-white mb-4">GAME OVER</h2>
                                <button 
                                    onClick={() => initGame(1)}
                                    className="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-full font-bold transition-transform hover:scale-105"
                                >
                                    <RefreshCw className="w-4 h-4" /> ë‹¤ì‹œ ë„ì „
                                </button>
                            </div>
                        )}
                    </div>

                    {/* ì„¤ëª… */}
                    <div className="text-xs text-slate-500 text-center space-y-1 bg-slate-800/50 p-3 rounded">
                        <p>ğŸ¤  <span className="text-slate-300">í”Œë ˆì´ì–´</span>ë¥¼ í´ë¦­í•˜ì—¬ ì¸ì ‘í•œ ì¹¸ì„ íƒí—˜í•˜ì„¸ìš”.</p>
                        <p>ğŸ’€ <span className="text-red-400">í•¨ì •</span>ì„ ë°Ÿìœ¼ë©´ ì²´ë ¥ì´ ê¹ì…ë‹ˆë‹¤. ìˆ«ìëŠ” ì£¼ë³€ í•¨ì • ìˆ˜ì…ë‹ˆë‹¤.</p>
                        <p>ğŸ”‘ <span className="text-yellow-400">ì—´ì‡ </span>ë¥¼ ì°¾ì•„ ğŸšª <span className="text-green-400">ë¬¸</span>ìœ¼ë¡œ íƒˆì¶œí•˜ë©´ ë‹¤ìŒ ì¸µìœ¼ë¡œ!</p>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DungeonSweeper />);
    </script>
</body>
</html>
