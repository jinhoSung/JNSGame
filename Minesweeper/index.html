import React, { useState, useEffect, useCallback } from 'react';
import { Heart, Shield, Key, DoorOpen, Skull, RefreshCw, Trophy, Coins } from 'lucide-react';

// ê²Œì„ ì„¤ì • ìƒìˆ˜
const GRID_SIZE = 10;
const INITIAL_HP = 3;
const TRAP_COUNT = 15;
const GOLD_COUNT = 5;
const POTION_COUNT = 3;

// ì…€ íƒ€ì… ì •ì˜
type CellType = 'empty' | 'trap' | 'potion' | 'gold' | 'key' | 'door' | 'start';
type CellState = 'hidden' | 'revealed' | 'flagged';

interface Cell {
  x: number;
  y: number;
  type: CellType;
  state: CellState;
  adjacentDanger: number; // ì£¼ë³€ í•¨ì • ìˆ˜
  id: string;
}

const DungeonSweeper = () => {
  const [grid, setGrid] = useState<Cell[][]>([]);
  const [playerPos, setPlayerPos] = useState({ x: 0, y: 0 });
  const [hp, setHp] = useState(INITIAL_HP);
  const [gold, setGold] = useState(0);
  const [hasKey, setHasKey] = useState(false);
  const [gameStatus, setGameStatus] = useState<'playing' | 'won' | 'lost'>('playing');
  const [message, setMessage] = useState<string>("ë˜ì „ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤! ì—´ì‡ ë¥¼ ì°¾ì•„ íƒˆì¶œí•˜ì„¸ìš”.");
  const [floor, setFloor] = useState(1);

  // ë°©í–¥ ë²¡í„° (8ë°©í–¥)
  const directions = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];

  // ê²Œì„ ì´ˆê¸°í™”
  const initGame = useCallback((level = 1) => {
    const newGrid: Cell[][] = [];
    const traps: {x: number, y: number}[] = [];
    
    // 1. ê·¸ë¦¬ë“œ ìƒì„±
    for (let y = 0; y < GRID_SIZE; y++) {
      const row: Cell[] = [];
      for (let x = 0; x < GRID_SIZE; x++) {
        row.push({
          x, y,
          type: 'empty',
          state: 'hidden',
          adjacentDanger: 0,
          id: `${x}-${y}`
        });
      }
      newGrid.push(row);
    }

    // 2. ì‹œì‘ì  ì„¤ì • (0,0) ë° ì£¼ë³€ ì•ˆì „ì§€ëŒ€ í™•ë³´
    newGrid[0][0].type = 'start';
    newGrid[0][0].state = 'revealed';
    const safeZone = [`0,0`, `0,1`, `1,0`, `1,1`];

    // 3. ì•„ì´í…œ ë° í•¨ì • ë°°ì¹˜ í•¨ìˆ˜
    const placeItem = (type: CellType, count: number) => {
      let placed = 0;
      while (placed < count) {
        const rx = Math.floor(Math.random() * GRID_SIZE);
        const ry = Math.floor(Math.random() * GRID_SIZE);
        const key = `${rx},${ry}`;
        
        // ì•ˆì „ì§€ëŒ€ê°€ ì•„ë‹ˆê³ , ì•„ì§ ë¹ˆ ì¹¸ì¸ ê²½ìš°ì—ë§Œ ë°°ì¹˜
        if (!safeZone.includes(key) && newGrid[ry][rx].type === 'empty') {
          newGrid[ry][rx].type = type;
          if (type === 'trap') traps.push({x: rx, y: ry});
          placed++;
        }
      }
    };

    // ë‚œì´ë„ ì¡°ì ˆ (ì¸µì´ ì˜¬ë¼ê°ˆìˆ˜ë¡ í•¨ì • ì¦ê°€)
    const currentTrapCount = TRAP_COUNT + (level - 1) * 2;

    placeItem('door', 1); // ì¶œêµ¬ (ê°€ì¥ ë¨¼ ê³³ì— ë°°ì¹˜í•˜ëŠ” ë¡œì§ì€ ìƒëµí•˜ê³  ëœë¤)
    placeItem('key', 1);  // ì—´ì‡ 
    placeItem('trap', currentTrapCount);
    placeItem('potion', POTION_COUNT);
    placeItem('gold', GOLD_COUNT);

    // 4. ì£¼ë³€ ìœ„í—˜ë„ ê³„ì‚° (ì§€ë¢°ì°¾ê¸° ìˆ«ì)
    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        if (newGrid[y][x].type === 'trap') continue;

        let danger = 0;
        directions.forEach(([dx, dy]) => {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            if (newGrid[ny][nx].type === 'trap') danger++;
          }
        });
        newGrid[y][x].adjacentDanger = danger;
      }
    }

    setGrid(newGrid);
    setPlayerPos({ x: 0, y: 0 });
    setHasKey(false);
    setGameStatus('playing');
    if (level === 1) {
      setHp(INITIAL_HP);
      setGold(0);
      setFloor(1);
      setMessage("ìƒˆë¡œìš´ ëª¨í—˜ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì—´ì‡ ë¥¼ ì°¾ìœ¼ì„¸ìš”!");
    } else {
      setFloor(level);
      setMessage(`${level}ì¸µì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ë” ìœ„í—˜í•´ì§‘ë‹ˆë‹¤!`);
    }
  }, []);

  useEffect(() => {
    initGame(1);
  }, [initGame]);

  // í™ìˆ˜ ì•Œê³ ë¦¬ì¦˜ (ë¹ˆ ê³µê°„ ìë™ ì˜¤í”ˆ)
  const revealEmptyArea = (startGrid: Cell[][], x: number, y: number) => {
    const queue = [{x, y}];
    const visited = new Set();
    const newGrid = [...startGrid];

    while (queue.length > 0) {
      const {x: cx, y: cy} = queue.shift()!;
      const key = `${cx},${cy}`;
      if (visited.has(key)) continue;
      visited.add(key);

      // ë²”ìœ„ ì²´í¬ ë° ì´ë¯¸ ê³µê°œëœ ê²½ìš° ìŠ¤í‚µ
      if (cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE) continue;
      
      const cell = newGrid[cy][cx];
      if (cell.state === 'revealed' && !(cx === x && cy === y)) continue; // ì‹œì‘ì  ì œì™¸í•˜ê³  ì´ë¯¸ ì—´ë¦°ê±´ íŒ¨ìŠ¤

      // ê³µê°œ ì²˜ë¦¬
      cell.state = 'revealed';

      // í•¨ì •ì´ ì•„ë‹ˆê³ , ì•„ì´í…œë„ ì•„ë‹ˆê³ , ì£¼ë³€ì— ìœ„í—˜ìš”ì†Œê°€ ì—†ìœ¼ë©´(0ì´ë©´) ì£¼ë³€ë„ íì— ì¶”ê°€
      if (cell.type === 'empty' && cell.adjacentDanger === 0) {
        directions.forEach(([dx, dy]) => {
          queue.push({x: cx + dx, y: cy + dy});
        });
      }
    }
    return newGrid;
  };

  // í”Œë ˆì´ì–´ ì´ë™ ë° ìƒí˜¸ì‘ìš©
  const handleMove = (x: number, y: number) => {
    if (gameStatus !== 'playing') return;

    // ì´ë™ ê°€ëŠ¥ ë²”ìœ„ ì²´í¬ (í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¸ì ‘í•œ ê³³ë§Œ)
    const isAdjacent = Math.abs(playerPos.x - x) <= 1 && Math.abs(playerPos.y - y) <= 1;
    if (!isAdjacent) {
      setMessage("ê·¸ê³³ì€ ë„ˆë¬´ ë©‰ë‹ˆë‹¤! ì¸ì ‘í•œ ì¹¸ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      return;
    }

    const targetCell = grid[y][x];
    let newGrid = [...grid];
    let currentHp = hp;
    let currentMsg = "";

    // 1. ì´ë¯¸ ê³µê°œëœ ê³³ìœ¼ë¡œ ì´ë™
    if (targetCell.state === 'revealed') {
        if (targetCell.type === 'door') {
            if (hasKey) {
                initGame(floor + 1);
                return;
            } else {
                currentMsg = "ë¬¸ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ í•„ìš”í•©ë‹ˆë‹¤!";
            }
        } else {
            // ê·¸ëƒ¥ ì´ë™
            setPlayerPos({ x, y });
            return;
        }
    } 
    // 2. ìˆ¨ê²¨ì§„ ê³³ì„ íƒí—˜ (í´ë¦­)
    else {
        // í•¨ì •ì¸ ê²½ìš°
        if (targetCell.type === 'trap') {
            currentHp -= 1;
            setHp(currentHp);
            targetCell.state = 'revealed'; // í•¨ì • ë“œëŸ¬ë‚¨
            currentMsg = "ìœ¼ì•…! í•¨ì •ì„ ë°Ÿì•˜ìŠµë‹ˆë‹¤! ì²´ë ¥ -1";
            
            if (currentHp <= 0) {
                setGameStatus('lost');
                setMessage("ì²´ë ¥ì´ ë‹¤í–ˆìŠµë‹ˆë‹¤... íƒí—˜ ì‹¤íŒ¨.");
                return;
            }
        }
        // ì•„ì´í…œ ë˜ëŠ” ë¹ˆ ê³µê°„
        else {
            if (targetCell.type === 'potion') {
                const newHp = Math.min(currentHp + 1, INITIAL_HP + 2); // ìµœëŒ€ ì²´ë ¥ ì œí•œ
                setHp(newHp);
                currentHp = newHp;
                currentMsg = "í¬ì…˜ ë°œê²¬! ì²´ë ¥ì´ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤.";
                targetCell.type = 'empty'; // ì•„ì´í…œ íšë“ í›„ ë¹ˆì¹¸ë¨
            } else if (targetCell.type === 'gold') {
                setGold(g => g + 10);
                currentMsg = "ê¸ˆí™” ë°œê²¬! (+10 Gold)";
                targetCell.type = 'empty';
            } else if (targetCell.type === 'key') {
                setHasKey(true);
                currentMsg = "ì—´ì‡ ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤! ì´ì œ ë¬¸ì„ ì—´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
                targetCell.type = 'empty';
            } else if (targetCell.type === 'door') {
                 // ë¬¸ì€ ì—´ë¦¬ì§€ ì•Šì§€ë§Œ ìœ„ì¹˜ëŠ” ë“œëŸ¬ë‚¨
                 currentMsg = "ì¶œêµ¬ë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤. ì—´ì‡ ê°€ í•„ìš”í•©ë‹ˆë‹¤.";
            }

            // ê³µê°„ ì—´ê¸° (0ì´ë©´ ì£¼ë³€ë„ ì—¶)
            if (targetCell.adjacentDanger === 0 && targetCell.type === 'empty') {
                newGrid = revealEmptyArea(newGrid, x, y);
            } else {
                targetCell.state = 'revealed';
            }
        }
    }

    setGrid(newGrid);
    setPlayerPos({ x, y });
    if (currentMsg) setMessage(currentMsg);
  };

  // ì…€ ë Œë”ë§ í—¬í¼
  const getCellContent = (cell: Cell) => {
    const isPlayerHere = playerPos.x === cell.x && playerPos.y === cell.y;
    
    // í”Œë ˆì´ì–´ ë Œë”ë§
    if (isPlayerHere) {
        return <div className="text-2xl animate-bounce">ğŸ¤ </div>;
    }

    if (cell.state === 'hidden') {
      return <div className="w-full h-full bg-slate-700 hover:bg-slate-600 rounded-sm cursor-pointer border border-slate-600" />;
    }

    // ê³µê°œëœ ì…€
    let content = null;
    if (cell.type === 'trap') content = <Skull className="text-red-500 w-6 h-6" />;
    else if (cell.type === 'potion') content = <Heart className="text-pink-500 fill-pink-500 w-5 h-5" />;
    else if (cell.type === 'gold') content = <Coins className="text-yellow-400 w-5 h-5" />;
    else if (cell.type === 'key') content = <Key className="text-yellow-500 w-6 h-6 rotate-45" />;
    else if (cell.type === 'door') content = <DoorOpen className={`w-6 h-6 ${hasKey ? 'text-green-400' : 'text-slate-400'}`} />;
    else if (cell.type === 'start') content = <span className="text-xs text-slate-400">START</span>;
    else if (cell.adjacentDanger > 0) {
        // ìˆ«ì ìƒ‰ìƒ
        const colors = ['text-blue-400', 'text-green-400', 'text-red-400', 'text-purple-400', 'text-orange-400'];
        content = <span className={`font-bold text-xl ${colors[cell.adjacentDanger-1] || 'text-red-600'}`}>{cell.adjacentDanger}</span>;
    }

    return (
      <div className={`w-full h-full flex items-center justify-center border border-slate-800 rounded-sm 
        ${cell.type === 'trap' ? 'bg-red-900/30' : 'bg-slate-900'}`}>
        {content}
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-slate-950 text-slate-100 p-4 font-sans flex flex-col items-center">
      <div className="max-w-md w-full bg-slate-900 p-6 rounded-xl shadow-2xl border border-slate-800">
        
        {/* í—¤ë”: ìƒíƒœ í‘œì‹œì°½ */}
        <div className="flex justify-between items-center mb-6 bg-slate-800 p-3 rounded-lg">
            <div className="flex items-center gap-4">
                <div className="flex items-center gap-1 text-pink-400">
                    <Heart className="fill-pink-400 w-5 h-5" />
                    <span className="font-bold text-lg">x {hp}</span>
                </div>
                <div className="flex items-center gap-1 text-yellow-400">
                    <Trophy className="w-5 h-5" />
                    <span className="font-bold text-lg">{floor}F</span>
                </div>
                <div className="flex items-center gap-1 text-yellow-200 text-sm">
                    <Coins className="w-4 h-4" />
                    <span>{gold}</span>
                </div>
            </div>
            <div className="flex items-center gap-2">
                 {hasKey ? (
                     <div className="flex items-center gap-1 text-yellow-400 bg-yellow-900/30 px-2 py-1 rounded">
                         <Key className="w-4 h-4" /> <span className="text-xs font-bold">KEY GET!</span>
                     </div>
                 ) : (
                     <div className="text-slate-500 text-xs">ì—´ì‡  ì°¾ëŠ” ì¤‘...</div>
                 )}
            </div>
        </div>

        {/* ë©”ì‹œì§€ ì°½ */}
        <div className="mb-4 text-center h-8 text-sm text-cyan-300 font-medium animate-pulse">
            {message}
        </div>

        {/* ê²Œì„ ê·¸ë¦¬ë“œ */}
        <div 
            className="grid gap-1 mb-6 mx-auto bg-slate-800 p-2 rounded-lg relative"
            style={{ 
                gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))`,
                width: 'fit-content'
            }}
        >
            {grid.map((row, y) => (
                row.map((cell, x) => (
                    <div 
                        key={cell.id}
                        onClick={() => handleMove(x, y)}
                        className="w-8 h-8 sm:w-9 sm:h-9 relative"
                    >
                        {getCellContent(cell)}
                    </div>
                ))
            ))}
            
            {/* ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ */}
            {gameStatus === 'lost' && (
                <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center rounded-lg z-10 backdrop-blur-sm">
                    <Skull className="w-16 h-16 text-red-500 mb-2 animate-bounce" />
                    <h2 className="text-2xl font-bold text-white mb-4">GAME OVER</h2>
                    <button 
                        onClick={() => initGame(1)}
                        className="flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-full font-bold transition-transform hover:scale-105"
                    >
                        <RefreshCw className="w-4 h-4" /> ë‹¤ì‹œ ë„ì „
                    </button>
                </div>
            )}
        </div>

        {/* ì¡°ì‘ ì„¤ëª… */}
        <div className="text-xs text-slate-500 text-center space-y-1 bg-slate-800/50 p-3 rounded">
            <p>ğŸ¤  <span className="text-slate-300">í”Œë ˆì´ì–´</span>ë¥¼ í´ë¦­í•˜ì—¬ ì¸ì ‘í•œ ì¹¸ì„ íƒí—˜í•˜ì„¸ìš”.</p>
            <p>ğŸ’€ <span className="text-red-400">í•¨ì •</span>ì„ ë°Ÿìœ¼ë©´ ì²´ë ¥ì´ ê¹ì…ë‹ˆë‹¤. ìˆ«ìëŠ” ì£¼ë³€ í•¨ì • ìˆ˜ì…ë‹ˆë‹¤.</p>
            <p>ğŸ”‘ <span className="text-yellow-400">ì—´ì‡ </span>ë¥¼ ì°¾ì•„ ğŸšª <span className="text-green-400">ë¬¸</span>ìœ¼ë¡œ íƒˆì¶œí•˜ë©´ ë‹¤ìŒ ì¸µìœ¼ë¡œ!</p>
        </div>

      </div>
    </div>
  );
};

export default DungeonSweeper;
