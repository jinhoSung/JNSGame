<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>자율주행 레이싱 (Autonomous Racing)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: #f1f5f9; font-family: sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // React 객체를 window에서 명시적으로 가져와서 ReferenceError를 해결합니다.
        const { useState, useEffect, useRef, useCallback } = window.React; 

        // --- Icon Components (Inline SVG) ---
        const Play = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        );
        const Pause = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
        );
        const RotateCcw = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        );
        const Plus = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        );
        const Trash2 = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        );
        const Cpu = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>
        );
        const Activity = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
        );
        const Trophy = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 21h8m-4-9v9m-8-2.5a6 6 0 0 1 12 0v2.5"></path><path d="M16 3h-8"></path><path d="M7 3v7a5 5 0 0 0 10 0V3"></path><path d="M19 6h2a2 2 0 0 1 2 2v1a2 2 0 0 1-2 2h-2"></path><path d="M5 6H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h2"></path></svg>
        );
        const Hash = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>
        );
        const Radar = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z"></path><path d="M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path><line x1="12" y1="2" x2="12" y2="4"></line><line x1="12" y1="20" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="6.34" y2="6.34"></line><line x1="17.66" y1="17.66" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="4" y2="12"></line><line x1="20" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="6.34" y2="17.66"></line><line x1="17.66" y1="6.34" x2="19.07" y2="4.93"></line></svg>
        );
        const Timer = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="10" y1="2" x2="14" y2="2"></line><line x1="12" y1="14" x2="15" y2="11"></line><circle cx="12" cy="14" r="8"></circle></svg>
        );
        const Flag = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>
        );
        const MapIcon = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>
        );
        const Volume2 = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
        );
        const VolumeX = ({size=24, className=""}) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
        );


        // --- Constants & Config ---
        const TRACK_WIDTH = 800;
        const TRACK_HEIGHT = 600;
        const FPS = 60;
        const CAR_SIZE = { width: 24, height: 14 };
        const SENSOR_RANGE = 150;
        const MAP_SCALE = 0.85;
        const MAX_SKID_MARKS = 50; // 스키드 마크 최대 개수 

        // Detection Config
        const CHECKPOINT_RADIUS_START = 50; 
        const CHECKPOINT_RADIUS_NORMAL = 120;
        const TOTAL_LAPS = 3;

        // Car Physics
        const ACCELERATION = 0.7; 
        const MAX_SPEED = 10;      
        const FRICTION = 0.93;    
        const TURN_SPEED = 0.08;

        // Track Aesthetics (Adjusted to be slightly narrower)
        const TRACK_AESTHETICS = {
            border: 90, // 110 -> 90
            curb: 80,   // 100 -> 80
            asphalt: 70 // 90 -> 70
        };

        const SENSOR_LABELS = {
            0: '좌측 센서',
            1: '전방 좌측',
            2: '전방 센서',
            3: '전방 우측',
            4: '우측 센서'
        };

        const OPERATOR_OPTIONS = [
            { value: '<', label: '작다면 (<)' },
            { value: '>', label: '크다면 (>)' },
            { value: '<=', label: '같거나 작다면 (<=)' },
            { value: '>=', label: '같거나 크다면 (>=)' },
            { value: '==', label: '같다면 (==)' },
            { value: '!=', label: '같지 않다면 (!=)' },
        ];
        
        const FLOW_OPTIONS = [
            { value: 'IF', label: '만약 (IF)', color: 'border-blue-500' },
            { value: 'ELSE_IF', label: '아니면 만약 (ELSE IF)', color: 'border-indigo-500' },
            { value: 'ELSE', label: '아니면 (ELSE)', color: 'border-purple-500' },
        ];


        // Initial Logic Blocks (Updated to use flowType)
        const INITIAL_BLOCKS = [
          { id: 1, flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 80, action: 'BRAKE' },
          { id: 2, flowType: 'ELSE_IF', sensor: 0, operator: '>', valueType: 'sensor', value: 4, action: 'RIGHT' },
          { id: 3, flowType: 'ELSE_IF', sensor: 4, operator: '>', valueType: 'sensor', value: 0, action: 'LEFT' },
          { id: 4, flowType: 'ELSE', sensor: 2, operator: '>', valueType: 'number', value: 0, action: 'ACCEL' },
        ];

        // --- Track Layouts (Adjusted for complexity and length) ---
        const TRACK_LAYOUTS = [
            {
                id: 'technical',
                name: '1. 테크니컬 서킷 (초급)', // 길이 보통, 코너 밸런스
                points: [
                    { x: 350, y: 100 }, { x: 500, y: 50 }, { x: 700, y: 100 },
                    { x: 750, y: 200 }, { x: 700, y: 300 }, { x: 600, y: 350 }, { x: 700, y: 500 },
                    { x: 500, y: 550 }, { x: 300, y: 500 }, { x: 150, y: 450 }, { x: 50, y: 300 }, 
                    { x: 100, y: 100 }, { x: 200, y: 100 }
                ]
            },
            {
                id: 'oval',
                name: '2. 스피드 오벌 (입문)', // 길이 짧음, 단순 코너
                points: [
                    { x: 400, y: 100 }, { x: 650, y: 100 }, { x: 750, y: 300 }, 
                    { x: 650, y: 500 }, { x: 150, y: 500 }, { x: 50, y: 300 },
                    { x: 150, y: 100 }
                ]
            },
            {
                id: 'pentagon',
                name: '3. 펜타곤 챌린지 (중급)', // 길이 보통, 둔각 코너링
                points: [
                    { x: 400, y: 100 }, { x: 500, y: 100 }, { x: 700, y: 300 }, 
                    { x: 550, y: 500 }, { x: 250, y: 500 }, 
                    { x: 100, y: 300 }, { x: 300, y: 100 }
                ]
            },
            {
                id: 'zigzag',
                name: '4. 지그재그 로드 (중급)', // 길이 보통, 연속 코너링
                points: [
                    { x: 400, y: 100 }, { x: 700, y: 100 }, { x: 700, y: 200 }, 
                    { x: 200, y: 300 }, 
                    { x: 700, y: 400 }, { x: 700, y: 500 }, 
                    { x: 100, y: 500 }, { x: 100, y: 100 }
                ]
            },
            {
                id: 'hourglass',
                name: '5. 모래시계 (상급)', // 길이 보통, 좁은 교차점
                points: [
                    { x: 400, y: 100 }, { x: 700, y: 100 }, { x: 500, y: 300 }, 
                    { x: 700, y: 500 }, { x: 100, y: 500 }, 
                    { x: 300, y: 300 }, { x: 100, y: 100 }
                ]
            },
            {
                id: 'hardcore_long',
                name: '6. 하드코어 8자 (상급)', // 길이 김, 교차로 필수
                points: [
                    { x: 400, y: 100 }, { x: 750, y: 100 },
                    { x: 750, y: 250 }, { x: 600, y: 400 }, // Long sweep
                    { x: 750, y: 550 }, { x: 400, y: 300 }, // Cross point
                    { x: 50, y: 550 }, { x: 200, y: 400 },
                    { x: 50, y: 250 }, { x: 50, y: 100 }
                ]
            },
            {
                id: 'slalom_long',
                name: '7. 슈퍼 슬라롬 (최상급)', // 길이 매우 김, 연속 S자 코스
                points: [
                    { x: 400, y: 100 },
                    { x: 750, y: 100 }, { x: 750, y: 250 },
                    { x: 600, y: 350 }, { x: 750, y: 450 },
                    { x: 750, y: 500 }, { x: 400, y: 550 },
                    { x: 50, y: 500 }, { x: 50, y: 450 },
                    { x: 200, y: 350 }, { x: 50, y: 250 },
                    { x: 50, y: 100 }
                ]
            },
            {
                id: 'grand_long',
                name: '8. 그랜드 투어 (최상급)', // 길이 가장 김, 장거리 레이스
                points: [
                    { x: 400, y: 100 }, 
                    { x: 750, y: 100 }, { x: 750, y: 200 }, { x: 650, y: 300 }, 
                    { x: 750, y: 400 }, { x: 750, y: 550 }, 
                    { x: 50, y: 550 }, { x: 50, y: 400 },
                    { x: 150, y: 300 }, { x: 50, y: 200 },
                    { x: 50, y: 100 }
                ]
            },
            {
                id: 'star',
                name: '9. 별 모양 서킷 (이벤트)', // 길이 보통, 급격한 각도
                points: [
                    { x: 400, y: 100 }, { x: 500, y: 100 }, { x: 700, y: 250 }, 
                    { x: 500, y: 400 }, { x: 600, y: 550 }, 
                    { x: 400, y: 450 }, { x: 200, y: 550 }, 
                    { x: 300, y: 400 }, { x: 100, y: 250 }, 
                    { x: 300, y: 100 }
                ]
            },
            {
                id: 'simple_square',
                name: '10. 심플 스퀘어 (입문)', // 길이 짧음, 단순 직각 코너
                points: [
                    { x: 400, y: 100 }, 
                    { x: 700, y: 100 }, { x: 700, y: 500 }, 
                    { x: 100, y: 500 }, { x: 100, y: 100 }
                ]
            }
        ];

        const App = () => {
          // --- State ---
          const canvasRef = useRef(null);
          const [isPlaying, setIsPlaying] = useState(false);
          const [blocks, setBlocks] = useState(INITIAL_BLOCKS);
          const [gameState, setGameState] = useState('idle');
          const [winner, setWinner] = useState(null);
          const [sensorReadings, setSensorReadings] = useState([0, 0, 0, 0, 0]);
          const [currentTrackIdx, setCurrentTrackIdx] = useState(0);
          const [isMuted, setIsMuted] = useState(false);
          
          // Audio Refs
          const audioCtxRef = useRef(null);
          const engineOscRef = useRef(null);
          const engineGainRef = useRef(null);
          const skidOscRef = useRef(null);
          const skidGainRef = useRef(null);
          const skidFilterRef = useRef(null); // Ref for skid filter

          // Time States
          const [currentTime, setCurrentTime] = useState(0); 
          const [userStats, setUserStats] = useState({ 
            laps: 0, 
            currentLapTime: 0, 
            lastLapTime: 0,
            totalTime: 0,
            lapHistory: [] 
          });

          // Mutable Game Objects
          const cars = useRef([]);
          const requestRef = useRef();
          const startTimeRef = useRef(0);
          const currentSkidSegmentId = useRef(0); // Track skid mark segments

          // --- Audio System ---
          const initAudio = () => {
              if (!audioCtxRef.current) {
                  audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
              }
              if (audioCtxRef.current.state === 'suspended') {
                  audioCtxRef.current.resume();
              }
          };

          const playTone = (freq, type, duration, vol = 0.1) => {
              if (isMuted || !audioCtxRef.current) return;
              const osc = audioCtxRef.current.createOscillator();
              const gain = audioCtxRef.current.createGain();
              osc.type = type;
              osc.frequency.setValueAtTime(freq, audioCtxRef.current.currentTime);
              gain.gain.setValueAtTime(vol, audioCtxRef.current.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, audioCtxRef.current.currentTime + duration);
              osc.connect(gain);
              gain.connect(audioCtxRef.current.destination);
              osc.start();
              osc.stop(audioCtxRef.current.currentTime + duration);
          };

          const playClickSound = () => {
              initAudio(); 
              playTone(600, 'sine', 0.1, 0.025);
          };
          
          const playLapSound = () => {
              if (isMuted || !audioCtxRef.current) return;
              playTone(880, 'sine', 0.1, 0.05);
              setTimeout(() => playTone(1760, 'sine', 0.2, 0.05), 100);
          };

          const playWinSound = () => {
              if (isMuted || !audioCtxRef.current) return;
              const notes = [523.25, 659.25, 783.99, 1046.50]; 
              notes.forEach((note, i) => {
                  setTimeout(() => playTone(note, 'square', 0.2, 0.05), i * 150);
              });
          };

          const startEngineSound = () => {
              if (isMuted || !audioCtxRef.current || engineOscRef.current) return;
              const osc = audioCtxRef.current.createOscillator();
              const gain = audioCtxRef.current.createGain();
              osc.type = 'sawtooth'; 
              osc.frequency.value = 100; 
              // Initial gain is set very low, dynamic volume adjustment will handle the actual loudness.
              gain.gain.value = 0.001; 
              osc.connect(gain);
              gain.connect(audioCtxRef.current.destination);
              osc.start();
              engineOscRef.current = osc;
              engineGainRef.current = gain;
          };

          const stopEngineSound = () => {
              if (engineOscRef.current) {
                  try { engineOscRef.current.stop(); engineOscRef.current.disconnect(); } catch (e) {} 
                  engineOscRef.current = null;
              }
              if (engineGainRef.current) {
                  engineGainRef.current.disconnect();
                  engineGainRef.current = null;
              }
          };

          const updateEnginePitch = (speed) => {
              if (engineOscRef.current && engineGainRef.current && !isMuted && audioCtxRef.current) {
                  const absSpeed = Math.abs(speed);
                  // 1. Pitch (Frequency) Adjustment
                  const pitch = 100 + absSpeed * 30; 
                  engineOscRef.current.frequency.setTargetAtTime(pitch, audioCtxRef.current.currentTime, 0.1);

                  // 2. Volume (Gain) Adjustment: Smallest volume at 0 speed, full volume near max speed (10)
                  // Base volume 0.05. Scale it based on speed ratio.
                  // (0.1 + absSpeed / MAX_SPEED * 0.9) to ensure min volume is 10% of base
                  const baseVol = 0.05;
                  const speedRatio = Math.min(absSpeed / MAX_SPEED, 1.0);
                  const volFactor = 0.1 + speedRatio * 0.9; // Ensures volume is between 10% and 100% of baseVol
                  const volume = baseVol * volFactor;

                  engineGainRef.current.gain.setTargetAtTime(volume, audioCtxRef.current.currentTime, 0.05);
              }
          };

          // --- Skid Sound (Improved: Screechier using higher frequency and Q, dynamic pitch) ---
          const updateSkidSound = (driftIntensity) => {
              if (!audioCtxRef.current || isMuted) return;

              if (driftIntensity > 0.15) { // Threshold slightly higher
                  if (!skidOscRef.current) {
                      const bufferSize = audioCtxRef.current.sampleRate * 2;
                      const buffer = audioCtxRef.current.createBuffer(1, bufferSize, audioCtxRef.current.sampleRate);
                      const data = buffer.getChannelData(0);
                      for (let i = 0; i < bufferSize; i++) {
                          data[i] = Math.random() * 2 - 1;
                      }

                      const noise = audioCtxRef.current.createBufferSource();
                      noise.buffer = buffer;
                      noise.loop = true;
                      
                      const gain = audioCtxRef.current.createGain();
                      // Screechy filter
                      const filter = audioCtxRef.current.createBiquadFilter();
                      filter.type = 'bandpass';
                      filter.frequency.value = 1200; // Base pitch
                      filter.Q.value = 5; // Resonant

                      noise.connect(filter);
                      filter.connect(gain);
                      gain.connect(audioCtxRef.current.destination);
                      
                      noise.start();
                      skidOscRef.current = noise;
                      skidGainRef.current = gain;
                      skidFilterRef.current = filter;
                  }
                  
                  // Modulation based on drift
                  const vol = Math.min(driftIntensity * 0.8, 0.15); 
                  skidGainRef.current.gain.setTargetAtTime(vol, audioCtxRef.current.currentTime, 0.1);
                  
                  // Dynamic Pitch Adjustment (Random high-frequency modulation based on intensity)
                  const minPitch = 1000;
                  const maxPitch = 2500;
                  // Introduce a slight random factor to make it sound less synthetic
                  const randomFactor = (Math.random() * 0.2 + 0.9); // 0.9 to 1.1
                  // Pitch is influenced by drift intensity, clamping within a high frequency range
                  const targetPitch = Math.min(minPitch + driftIntensity * (maxPitch - minPitch) * 2 * randomFactor, maxPitch); 
                  skidFilterRef.current.frequency.setTargetAtTime(targetPitch, audioCtxRef.current.currentTime, 0.05);

              } else {
                  if (skidGainRef.current) {
                      skidGainRef.current.gain.setTargetAtTime(0, audioCtxRef.current.currentTime, 0.1);
                  }
              }
          };

          const stopSkidSound = () => {
              if (skidOscRef.current) {
                  try { skidOscRef.current.stop(); skidOscRef.current.disconnect(); } catch (e) {}
                  skidOscRef.current = null;
              }
              if (skidGainRef.current) {
                  skidGainRef.current.disconnect();
                  skidGainRef.current = null;
              }
          };


          // Handle Audio State Changes
          useEffect(() => {
              if (isMuted || !isPlaying || gameState !== 'running') {
                  stopEngineSound();
                  stopSkidSound();
              } else if (isPlaying && gameState === 'running' && !isMuted) {
                  startEngineSound();
              }
          }, [isMuted, isPlaying, gameState]);

          // --- Helpers ---
          const dist = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

          const scalePoint = (p) => ({
              x: (p.x - TRACK_WIDTH / 2) * MAP_SCALE + TRACK_WIDTH / 2,
              y: (p.y - TRACK_HEIGHT / 2) * MAP_SCALE + TRACK_HEIGHT / 2
          });

          const getCurrentTrackPoints = () => TRACK_LAYOUTS[currentTrackIdx].points.map(scalePoint);

          const getStartAngle = () => {
              const points = getCurrentTrackPoints();
              const p1 = points[0];
              const p2 = points[1];
              return Math.atan2(p2.y - p1.y, p2.x - p1.x);
          };

          const isOffTrack = (x, y) => {
            const points = getCurrentTrackPoints();
            let minDist = Infinity;
            for (let i = 0; i < points.length; i++) {
              const p1 = points[i];
              const p2 = points[(i + 1) % points.length];
              const d = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
              if (d < minDist) minDist = d;
            }
            // Track Aesthetics: Check against the new, narrower curb size (TRACK_AESTHETICS.curb / 2 + 3)
            return minDist > (TRACK_AESTHETICS.curb / 2) + 3; 
          };

          const distToSegment = (x, y, x1, y1, x2, y2) => {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return dist(x, y, xx, yy);
          };

          const castRays = (car) => {
            const readings = [];
            const angles = [-60, -30, 0, 30, 60]; 
            
            angles.forEach(offset => {
              const rayAngle = car.angle + (offset * Math.PI / 180);
              let distance = 0;
              let step = 2;
              let maxDist = SENSOR_RANGE;
              let rx = car.x;
              let ry = car.y;

              while (distance < maxDist) {
                rx += Math.cos(rayAngle) * step;
                ry += Math.sin(rayAngle) * step;
                distance += step;
                if (isOffTrack(rx, ry)) break;
              }
              readings.push(Math.min(distance, maxDist));
            });
            return readings;
          };

          // --- Game Loop Logic ---

          const updateCarPhysics = (car, inputs, timestamp) => {
            if (car.finished) return;

            // Steering
            if (Math.abs(car.speed) > 0.5) {
                car.angle += inputs.steer * TURN_SPEED * (car.speed > 0 ? 1 : -1);
            }

            // Initialize moveAngle
            if (typeof car.moveAngle === 'undefined') car.moveAngle = car.angle;
            if (typeof car.skidMarks === 'undefined') car.skidMarks = [];
            if (typeof car.currentSkidId === 'undefined') car.currentSkidId = 0;
            if (typeof car.isDrifting === 'undefined') car.isDrifting = false;

            // Physics: Drift - More slippery logic
            const speedRatio = Math.abs(car.speed) / MAX_SPEED;
            const grip = 0.05 + (1.0 - speedRatio) * 0.9; 

            let angleDiff = car.angle - car.moveAngle;
            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            car.moveAngle += angleDiff * grip;

            // Acceleration & Friction
            car.speed += inputs.throttle * ACCELERATION;
            car.speed *= FRICTION;

            // Tire Scrub & Skid Logic
            const driftIntensity = Math.abs(angleDiff);
            const driftThreshold = 0.15; // Higher threshold for marks
            
            // Detect drift state change
            const nowDrifting = driftIntensity > driftThreshold && Math.abs(car.speed) > 3;
            
            if (nowDrifting) {
                // If just started drifting, increment segment ID
                if (!car.isDrifting) {
                    currentSkidSegmentId.current += 1;
                    car.currentSkidId = currentSkidSegmentId.current;
                    car.isDrifting = true;
                }

                // Scrub speed
                car.speed *= (1 - driftIntensity * 0.02); 
                
                // Add Skid Marks
                // Offset for rear tires
                const rearX = car.x - Math.cos(car.angle) * 10;
                const rearY = car.y - Math.sin(car.angle) * 10;
                // Left and Right tire offsets
                const perp = car.angle + Math.PI/2;
                const lx = rearX + Math.cos(perp) * 6;
                const ly = rearY + Math.sin(perp) * 6;
                const rx = rearX - Math.cos(perp) * 6;
                const ry = rearY - Math.sin(perp) * 6;

                car.skidMarks.push({ lx, ly, rx, ry, alpha: 0.3, segmentId: car.currentSkidId });
                
                if (car.skidMarks.length > MAX_SKID_MARKS) car.skidMarks.shift(); // MAX_SKID_MARKS 적용
            } else {
                car.isDrifting = false;
            }

            if (car.id === 'user' && !isMuted) {
                updateSkidSound(nowDrifting ? driftIntensity : 0);
            }

            if (car.speed > MAX_SPEED) car.speed = MAX_SPEED;
            if (car.speed < -MAX_SPEED / 2) car.speed = -MAX_SPEED / 2;

            // Move
            car.x += Math.cos(car.moveAngle) * car.speed;
            car.y += Math.sin(car.moveAngle) * car.speed;

            if (isOffTrack(car.x, car.y)) {
                car.speed *= 0.5; 
            }

            // Checkpoint
            const points = getCurrentTrackPoints();
            const nextCpIdx = (car.lastCP + 1) % points.length;
            const nextCp = points[nextCpIdx];
            
            let isCheckpointReached = false;

            if (nextCpIdx === 0) {
                // Rectangular detection for Start Line
                const p0 = points[0];
                const p1 = points[1]; 
                const trackAngle = Math.atan2(p1.y - p0.y, p1.x - p0.x);
                const dx = car.x - p0.x;
                const dy = car.y - p0.y;
                const localX = dx * Math.cos(-trackAngle) - dy * Math.sin(-trackAngle);
                const localY = dx * Math.sin(-trackAngle) + dy * Math.cos(-trackAngle);
                
                if (Math.abs(localX) < 20 && Math.abs(localY) < (TRACK_AESTHETICS.asphalt / 2 + 5)) { // Use narrower asphalt width for line check
                    isCheckpointReached = true;
                }
            } else {
                if (dist(car.x, car.y, nextCp.x, nextCp.y) < CHECKPOINT_RADIUS_NORMAL) {
                    isCheckpointReached = true;
                }
            }

            if (isCheckpointReached) {
                car.lastCP = nextCpIdx;
                
                if (nextCpIdx === 0) {
                    car.laps++;
                    if (!car.isAI) playLapSound();

                    const now = timestamp;
                    const lapTime = (now - car.lapStartTime) / 1000;
                    car.lastLapTime = lapTime;
                    car.lapStartTime = now; 
                    
                    if (car.id === 'user') {
                        if (!car.lapHistory) car.lapHistory = [];
                        car.lapHistory.push(lapTime);
                    }

                    if (car.laps >= TOTAL_LAPS) {
                        car.finished = true;
                        car.finishTime = (now - startTimeRef.current) / 1000;
                        
                        if (!winner) {
                            setWinner(car.id);
                            setGameState('finished');
                            setIsPlaying(false);
                            if (car.id === 'user') playWinSound();
                            stopEngineSound();
                            stopSkidSound();
                        }
                    }
                }
            }
          };

          const getAIInputs = (car) => {
            const points = getCurrentTrackPoints();
            const targetIdx = (car.lastCP + 1) % points.length;
            const target = points[targetIdx];
            const desiredAngle = Math.atan2(target.y - car.y, target.x - car.x);
            let diff = desiredAngle - car.angle;
            while (diff <= -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;

            let steer = 0;
            if (diff > 0.1) steer = 1;
            if (diff < -0.1) steer = -1;

            let throttle = 1;
            if (Math.abs(diff) > 0.5) throttle = 0.5;
            const variance = (parseInt(car.id.slice(-1)) || 0) * 0.05;

            return { steer, throttle: throttle - variance };
          };

          const evaluateCondition = (block, currentReadings) => {
              if (block.flowType === 'ELSE') return false; 
              
              const leftValue = currentReadings[block.sensor];
              let rightValue = block.valueType === 'sensor' ? currentReadings[block.value] : block.value;

              if (block.operator === '<') return leftValue < rightValue;
              if (block.operator === '>') return leftValue > rightValue;
              if (block.operator === '<=') return leftValue <= rightValue;
              if (block.operator === '>=') return leftValue >= rightValue;
              if (block.operator === '==') return leftValue === rightValue;
              if (block.operator === '!=') return leftValue !== rightValue;
              
              return false;
          }
          
          const applyAction = (block, steerOutputs) => {
                switch(block.action) {
                    case 'LEFT': steerOutputs.turnLeft = true; break;
                    case 'RIGHT': steerOutputs.turnRight = true; break;
                    case 'ACCEL': steerOutputs.gas = true; break;
                    case 'BRAKE': steerOutputs.brake = true; break;
                    default: break;
                }
          }


          const getUserInputs = (car, currentReadings) => {
            const steerOutputs = {
                turnLeft: false,
                turnRight: false,
                gas: false,
                brake: false,
            };
            
            let steer = 0;
            let throttle = 0;
            let matchedInChain = false; 

            // 그룹화된 IF-ELSE IF-ELSE 체인을 순차적으로 실행
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const conditionMet = evaluateCondition(block, currentReadings);
                
                const isStartOfChain = block.flowType === 'IF';
                const isElseIf = block.flowType === 'ELSE_IF';
                const isElse = block.flowType === 'ELSE';

                if (isStartOfChain) {
                    // 새로운 체인 시작: IF
                    matchedInChain = false;
                    if (conditionMet) {
                        applyAction(block, steerOutputs);
                        matchedInChain = true; // 현재 체인에서 매칭됨
                    }
                } else if (isElseIf) {
                    // ELSE IF
                    if (!matchedInChain && conditionMet) {
                        applyAction(block, steerOutputs);
                        matchedInChain = true; // 매칭되었으므로 다음 ELSE/ELSE_IF는 건너뜀
                    }
                } else if (isElse) {
                    // ELSE
                    if (!matchedInChain) {
                        applyAction(block, steerOutputs);
                        // ELSE 실행 후, 체인이 끝난 것으로 간주하고 matchedInChain을 유지 (다음 IF에서 초기화)
                    }
                } else {
                    // IF, ELSE IF, ELSE가 아닌 독립적인 블록이 필요한 경우 (현재는 사용 안 함)
                    // if (conditionMet) applyAction(block, steerOutputs);
                }
            }
            
            // 최종 행동 합산
            if (steerOutputs.turnLeft) steer -= 1;
            if (steerOutputs.turnRight) steer += 1;
            if (steerOutputs.gas) throttle += 1;
            if (steerOutputs.brake) throttle -= 1;

            return { steer, throttle };
          };

          const update = (timestamp) => {
            if (gameState === 'finished') return;
            
            if (startTimeRef.current === 0) {
                startTimeRef.current = timestamp;
                cars.current.forEach(c => c.lapStartTime = timestamp);
            }

            const currentTotalTime = (timestamp - startTimeRef.current) / 1000;
            setCurrentTime(currentTotalTime);

            const userCar = cars.current[0];
            const readings = castRays(userCar);
            setSensorReadings(readings);
            const userInputs = getUserInputs(userCar, readings);
            updateCarPhysics(userCar, userInputs, timestamp);
            
            if (!isMuted && gameState === 'running') {
                updateEnginePitch(userCar.speed);
            }

            cars.current.slice(1).forEach(car => {
                const aiInputs = getAIInputs(car);
                updateCarPhysics(car, aiInputs, timestamp);
            });

            setUserStats({
                laps: userCar.laps,
                currentLapTime: (timestamp - userCar.lapStartTime) / 1000,
                lastLapTime: userCar.lastLapTime,
                totalTime: userCar.finished ? userCar.finishTime : currentTotalTime,
                lapHistory: userCar.lapHistory || [] // Sync history for UI
            });

            draw();
            if (isPlaying) {
                requestRef.current = requestAnimationFrame(update);
            }
          };

          const draw = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const points = getCurrentTrackPoints();
            
            // Clear
            ctx.fillStyle = '#4ade80';
            ctx.fillRect(0, 0, TRACK_WIDTH, TRACK_HEIGHT);

            // Draw Track
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Border (Red/White)
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = TRACK_AESTHETICS.border;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();

            // White Curb
            ctx.strokeStyle = '#f8fafc';
            ctx.lineWidth = TRACK_AESTHETICS.curb;
            ctx.stroke();

            // Asphalt (Dark Gray)
            ctx.strokeStyle = '#334155'; 
            ctx.lineWidth = TRACK_AESTHETICS.asphalt;
            ctx.stroke();

            // Skid Marks (Segmented)
            cars.current.forEach(car => {
                if (car.skidMarks && car.skidMarks.length > 1) {
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = `rgba(20, 20, 20, 0.3)`; // Darker skid marks
                    
                    for(let i=0; i<car.skidMarks.length-1; i++) {
                        const p1 = car.skidMarks[i];
                        const p2 = car.skidMarks[i+1];
                        
                        // Only connect if they belong to the same continuous drift segment
                        if (p1.segmentId === p2.segmentId) {
                            ctx.beginPath();
                            ctx.moveTo(p1.lx, p1.ly);
                            ctx.lineTo(p2.lx, p2.ly);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(p1.rx, p1.ry);
                            ctx.lineTo(p2.rx, p2.ry);
                            ctx.stroke();
                        }
                    }
                }
            });

            // Center Line
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Start Line (Rotated based on track direction)
            const startAngle = getStartAngle();
            ctx.save();
            ctx.translate(points[0].x, points[0].y);
            ctx.rotate(startAngle); 
            
            // Draw Start Line (Checkered) - Height based on new narrower track width
            const lineHalfHeight = TRACK_AESTHETICS.asphalt / 2 + 10; // Asphalt half-width + small buffer
            ctx.fillStyle = '#fff';
            ctx.fillRect(-10, -lineHalfHeight, 20, lineHalfHeight * 2); 
            
            ctx.fillStyle = '#000';
            for(let i=0; i<8; i++) {
                for(let j=0; j<2; j++) {
                    if((i+j)%2===0) ctx.fillRect(-10 + j*10, -lineHalfHeight + i*(lineHalfHeight*2/8), 10, lineHalfHeight*2/8);
                }
            }
            ctx.restore();

            // Draw Cars
            cars.current.forEach(car => {
                // 1. Draw Body & Rays (Rotated context)
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.rotate(car.angle);

                ctx.fillStyle = car.color;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.fillRect(-CAR_SIZE.width/2, -CAR_SIZE.height/2, CAR_SIZE.width, CAR_SIZE.height);
                
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(2, -5, 6, 10);
                ctx.restore();

                // 2. Draw Speed Text (Global coords)
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);
                ctx.fillText(Math.abs(car.speed).toFixed(1), car.x, car.y - 12);

                if (!car.isAI) {
                    const readings = castRays(car);
                    const angles = [-60, -30, 0, 30, 60];
                    readings.forEach((r, i) => {
                       ctx.save();
                       ctx.translate(car.x, car.y);
                       ctx.rotate(car.angle + (angles[i] * Math.PI / 180));
                       const grad = ctx.createLinearGradient(0, 0, r, 0);
                       grad.addColorStop(0, 'rgba(255, 255, 0, 0.5)');
                       grad.addColorStop(1, 'rgba(255, 0, 0, 0.8)');
                       ctx.fillStyle = grad;
                       ctx.fillRect(0, -1, r, 2);
                       ctx.fillStyle = 'red';
                       ctx.beginPath();
                       ctx.arc(r, 0, 3, 0, Math.PI * 2);
                       ctx.fill();
                       ctx.restore();
                    });
                }
            });
          };

          useEffect(() => {
            if (isPlaying) {
              requestRef.current = requestAnimationFrame(update);
            } else {
              cancelAnimationFrame(requestRef.current);
              draw();
              stopEngineSound(); 
              stopSkidSound();
            }
            return () => {
                cancelAnimationFrame(requestRef.current);
                stopEngineSound();
                stopSkidSound();
            };
          }, [isPlaying, blocks, gameState]);

          // Handle Track Change
          useEffect(() => {
              resetGame();
          }, [currentTrackIdx]);

          useEffect(() => {
            resetGame();
          }, []);

          const togglePlay = async () => {
            if (!audioCtxRef.current) {
                audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtxRef.current.state === 'suspended') {
                await audioCtxRef.current.resume();
            }

            if (gameState === 'finished') resetGame();
            
            const nextIsPlaying = !isPlaying;
            
            if (nextIsPlaying) {
                if (gameState === 'idle') setGameState('running'); 
                
                if (startTimeRef.current === 0) {
                    startTimeRef.current = performance.now();
                    cars.current.forEach(c => c.lapStartTime = startTimeRef.current);
                }
                if (!isMuted) startEngineSound();
            } else {
                stopEngineSound();
                stopSkidSound();
            }
            
            setIsPlaying(nextIsPlaying);
            playClickSound();
          };

          const resetGame = () => {
            setIsPlaying(false);
            setGameState('idle');
            setWinner(null);
            stopEngineSound();
            stopSkidSound();
            startTimeRef.current = 0;
            setCurrentTime(0);
            setUserStats({ laps: 0, currentLapTime: 0, lastLapTime: 0, totalTime: 0, lapHistory: [] });
            currentSkidSegmentId.current = 0; // Reset skid segment counter

            // Initialize cars based on track start position
            const points = TRACK_LAYOUTS[currentTrackIdx].points.map(scalePoint);
            const startPoint = points[0];
            const startAngle = Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x);
            
            const px = Math.cos(startAngle + Math.PI/2);
            const py = Math.sin(startAngle + Math.PI/2);
            const dx = Math.cos(startAngle);
            const dy = Math.sin(startAngle);

            const spawnX = startPoint.x - dx * 40;
            const spawnY = startPoint.y - dy * 40;

            cars.current = [
                { id: 'user', x: spawnX + px * 20, y: spawnY + py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#3b82f6', isAI: false, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, lapHistory: [], skidMarks: [], isDrifting: false, currentSkidId: 0 },
                { id: 'ai1', x: spawnX - px * 20, y: spawnY - py * 20, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#ef4444', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0 },
                { id: 'ai2', x: spawnX - dx * 40 - px * 10, y: spawnY - dy * 40 + py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#f59e0b', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0 },
                { id: 'ai3', x: spawnX - dx * 40 + px * 10, y: spawnY - dy * 40 - py * 10, angle: startAngle, moveAngle: startAngle, speed: 0, color: '#8b5cf6', isAI: true, laps: 0, lastCP: 0, finished: false, lapStartTime: 0, lastLapTime: 0, finishTime: 0, skidMarks: [], isDrifting: false, currentSkidId: 0 },
            ];
            draw();
          };

          const addBlock = () => {
            const newBlock = { id: Date.now(), flowType: 'IF', sensor: 2, operator: '<', valueType: 'number', value: 50, action: 'BRAKE' };
            setBlocks([...blocks, newBlock]);
            playClickSound();
          };

          const updateBlock = (id, field, value) => {
            setBlocks(blocks.map(b => b.id === id ? { ...b, [field]: value } : b));
          };

          const removeBlock = (id) => {
            setBlocks(blocks.filter(b => b.id !== id));
            playClickSound();
          };

          const toggleValueType = (id) => {
            setBlocks(blocks.map(b => {
                if (b.id === id) {
                    const newType = b.valueType === 'number' ? 'sensor' : 'number';
                    const newValue = newType === 'number' ? 50 : 0; 
                    return { ...b, valueType: newType, value: newValue };
                }
                return b;
            }));
            playClickSound();
          };

          const toggleMute = () => {
              setIsMuted(!isMuted);
              playClickSound();
          }

          const fmtTime = (s) => s.toFixed(2) + 's';

          return (
            /* Responsive Container: Column on Mobile, Row on Desktop */
            <div className="flex flex-col-reverse lg:flex-row h-screen bg-slate-900 text-slate-100 overflow-hidden font-sans">
              
              {/* --- Sidebar: Coding Area (Bottom on Mobile, Left on Desktop) --- */}
              <div className="w-full lg:w-1/3 h-[55%] lg:h-full flex flex-col border-t lg:border-t-0 lg:border-r border-slate-700 bg-slate-800 shadow-xl z-20">
                <div className="p-2 lg:p-4 bg-slate-900 border-b border-slate-700 space-y-2 lg:space-y-4">
                  <div className="flex justify-between items-center">
                    <h2 className="text-lg lg:text-xl font-bold flex items-center gap-2 text-blue-400">
                        <Cpu size={20} className="lg:w-6 lg:h-6" /> 
                        로직 에디터
                    </h2>
                    <div className="flex gap-1 lg:gap-2">
                        <button onClick={resetGame} className="p-1.5 lg:p-2 bg-slate-700 hover:bg-slate-600 rounded-lg transition" title="초기화">
                            <RotateCcw size={18} className="lg:w-5 lg:h-5" />
                        </button>
                        <button onClick={togglePlay} className={`p-1.5 lg:p-2 rounded-lg transition flex items-center gap-1 lg:gap-2 font-bold px-3 lg:px-4 text-sm lg:text-base ${isPlaying ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-green-600 hover:bg-green-500'}`}>
                            {isPlaying ? <Pause size={18} className="lg:w-5 lg:h-5" /> : <Play size={18} className="lg:w-5 lg:h-5" />}
                            {isPlaying ? '일시정지' : '시작'}
                        </button>
                    </div>
                  </div>
                  
                  {/* Track Select */}
                  <div className="flex items-center gap-2 bg-slate-800 p-1.5 lg:p-2 rounded-lg border border-slate-700">
                    <MapIcon size={16} className="text-slate-400 lg:w-[18px] lg:h-[18px]" />
                    <select 
                        className="bg-transparent text-sm lg:text-base w-full outline-none text-slate-200"
                        value={currentTrackIdx}
                        onChange={(e) => setCurrentTrackIdx(Number(e.target.value))}
                    >
                        {TRACK_LAYOUTS.map((track, idx) => (
                            <option key={track.id} value={idx}>{track.name}</option>
                        ))}
                    </select>
                  </div>
                </div>

                {/* Sensors */}
                <div className="p-2 lg:p-4 bg-slate-800/50 border-b border-slate-700">
                    <div className="flex items-center gap-2 mb-1 lg:mb-2 text-[10px] lg:text-xs uppercase tracking-wider text-slate-400">
                        <Activity size={12} className="lg:w-[14px] lg:h-[14px]" /> 실시간 센서 거리
                    </div>
                    <div className="grid grid-cols-5 gap-1 text-center">
                        {sensorReadings.map((val, idx) => {
                            const labels = ['좌측', '전방좌측', '전방', '전방우측', '우측'];
                            const color = val < 50 ? 'text-red-400' : 'text-green-400';
                            return (
                                <div key={idx} className="bg-slate-900 p-1 lg:p-2 rounded border border-slate-700">
                                    <div className="text-[9px] lg:text-[10px] text-slate-500">{labels[idx]}</div>
                                    <div className={`font-mono text-xs lg:text-sm font-bold ${color}`}>{Math.round(val)}</div>
                                </div>
                            );
                        })}
                    </div>
                </div>

                {/* Blocks List - Scrollable */}
                <div className="flex-1 overflow-y-auto p-2 lg:p-4 space-y-2 lg:space-y-3 no-scrollbar">
                  {blocks.length === 0 && (
                    <div className="text-slate-500 text-center py-10 italic text-sm">로직 블록이 없습니다.</div>
                  )}
                  
                  {blocks.map((block) => {
                      const flow = FLOW_OPTIONS.find(f => f.value === block.flowType);
                      const isElse = block.flowType === 'ELSE';
                      const isIfElseIf = block.flowType === 'IF' || block.flowType === 'ELSE_IF';
                      const borderClass = flow ? flow.color : 'border-slate-500';

                      return (
                        <div key={block.id} className={`bg-slate-700 p-2 lg:p-3 rounded-lg border-l-4 ${borderClass} shadow-sm flex items-center gap-1.5 lg:gap-2 flex-wrap text-xs lg:text-sm group`}>
                          
                          {/* Flow Type Selector */}
                          <select className={`bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none font-bold max-w-[120px] lg:max-w-none 
                                ${block.flowType === 'ELSE' ? 'w-full' : ''}`}
                            value={block.flowType} onChange={(e) => updateBlock(block.id, 'flowType', e.target.value)}>
                            {FLOW_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                          </select>

                          {/* Condition Fields (Hidden for ELSE) */}
                          {isIfElseIf && (
                              <React.Fragment>
                                  <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none max-w-[80px] lg:max-w-none"
                                    value={block.sensor} onChange={(e) => updateBlock(block.id, 'sensor', parseInt(e.target.value))}>
                                    {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                  </select>
                                  
                                  <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                    value={block.operator} onChange={(e) => updateBlock(block.id, 'operator', e.target.value)}>
                                    {OPERATOR_OPTIONS.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
                                  </select>

                                  <button onClick={() => toggleValueType(block.id)}
                                    className="p-1 rounded bg-slate-600 hover:bg-slate-500 text-slate-200 transition"
                                    title={block.valueType === 'number' ? "숫자와 비교하기" : "다른 센서와 비교하기"}>
                                    {block.valueType === 'number' ? <Hash size={12} className="lg:w-[14px] lg:h-[14px]" /> : <Radar size={12} className="lg:w-[14px] lg:h-[14px]" />}
                                  </button>
                                  
                                  {block.valueType === 'number' ? (
                                      <input type="number" className="bg-slate-900 border border-slate-600 rounded w-12 lg:w-16 px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none"
                                        value={block.value} 
                                        onChange={(e) => {
                                            const val = parseInt(e.target.value);
                                            updateBlock(block.id, 'value', isNaN(val) ? 0 : val);
                                        }} 
                                      />
                                  ) : (
                                      <select className="bg-slate-900 border border-slate-600 rounded px-1 lg:px-2 py-1 text-slate-200 focus:border-blue-500 outline-none w-20 lg:w-24"
                                        value={block.value} onChange={(e) => updateBlock(block.id, 'value', parseInt(e.target.value))}>
                                        {Object.entries(SENSOR_LABELS).map(([k, v]) => (<option key={k} value={k}>{v}</option>))}
                                      </select>
                                  )}
                              </React.Fragment>
                          )}

                          <span className="font-bold text-blue-300">→</span>
                          
                          <select className={`border border-slate-600 rounded px-1 lg:px-2 py-1 font-bold outline-none flex-grow
                                ${block.action === 'LEFT' || block.action === 'RIGHT' ? 'bg-indigo-900 text-indigo-200' : ''}
                                ${block.action === 'ACCEL' ? 'bg-green-900 text-green-200' : ''}
                                ${block.action === 'BRAKE' ? 'bg-red-900 text-red-200' : ''}
                                ${isElse ? 'w-full' : ''}`}
                            value={block.action} onChange={(e) => updateBlock(block.id, 'action', e.target.value)}>
                            <option value="LEFT">좌회전</option>
                            <option value="RIGHT">우회전</option>
                            <option value="ACCEL">가속</option>
                            <option value="BRAKE">감속</option>
                          </select>
                          <button onClick={() => removeBlock(block.id)} className="text-slate-500 hover:text-red-400 ml-auto opacity-100 lg:opacity-0 group-hover:opacity-100 transition"><Trash2 size={14} className="lg:w-[16px] lg:h-[16px]" /></button>
                        </div>
                      );
                  })}

                  <button onClick={addBlock} className="w-full py-2 lg:py-3 border-2 border-dashed border-slate-600 text-slate-400 rounded-lg hover:border-blue-500 hover:text-blue-400 transition flex justify-center items-center gap-2 text-sm lg:text-base">
                    <Plus size={16} className="lg:w-[18px] lg:h-[18px]" /> 로직 블록 추가
                  </button>
                </div>
              </div>

              {/* --- Main View: Canvas (Top on Mobile, Right on Desktop) --- */}
              <div className="w-full lg:flex-1 h-[45%] lg:h-full relative bg-neutral-800 flex justify-center items-center p-2 lg:p-4 overflow-hidden">
                <canvas ref={canvasRef} width={TRACK_WIDTH} height={TRACK_HEIGHT}
                    className="bg-green-500 rounded-xl shadow-2xl max-w-full max-h-full object-contain cursor-crosshair" />
                
                {/* Top Left: Lap Time History Panel */}
                <div className="absolute top-2 left-2 lg:top-6 lg:left-6 pointer-events-none scale-75 lg:scale-100 origin-top-left">
                    <div className="bg-slate-900/90 backdrop-blur p-3 rounded-xl border border-slate-700 shadow-xl space-y-2 min-w-[140px]">
                        <div className="text-[10px] uppercase tracking-widest text-slate-400 border-b border-slate-700 pb-1 mb-1">Lap History</div>
                        {[...Array(TOTAL_LAPS)].map((_, i) => {
                            const lapTime = userStats.lapHistory[i];
                            const isCurrent = userStats.laps === i;
                            return (
                                <div key={i} className="flex justify-between items-center text-xs font-mono">
                                    <span className={isCurrent ? 'text-yellow-400 font-bold' : 'text-slate-500'}>LAP {i + 1}</span>
                                    <span className={isCurrent ? 'text-white' : (lapTime ? 'text-green-400' : 'text-slate-600')}>
                                        {lapTime ? fmtTime(lapTime) : (isCurrent ? fmtTime(userStats.currentLapTime) : '--:--')}
                                    </span>
                                </div>
                            )
                        })}
                        <div className="border-t border-slate-700 pt-1 flex justify-between items-center text-xs font-mono text-blue-300 mt-1">
                            <span>TOTAL</span>
                            <span>{fmtTime(userStats.totalTime)}</span>
                        </div>
                    </div>
                </div>

                {/* Top Right State Badge & Mute */}
                <div className="absolute top-2 right-2 lg:top-6 lg:right-6 pointer-events-auto flex gap-2">
                    <button onClick={toggleMute} className="bg-slate-900/80 backdrop-blur p-2 rounded-full border border-slate-700 shadow-lg text-slate-300 hover:bg-slate-800 transition scale-90 lg:scale-100">
                        {isMuted ? <VolumeX size={18} /> : <Volume2 size={18} />}
                    </button>
                    <div className="bg-slate-900/80 backdrop-blur px-3 py-1 lg:px-6 lg:py-2 rounded-full border border-slate-700 shadow-lg flex items-center gap-2 lg:gap-4 scale-90 lg:scale-100 origin-top-right">
                        <div className="text-slate-400 text-[10px] lg:text-xs uppercase tracking-widest">상태</div>
                        <div className={`text-base lg:text-xl font-black italic ${gameState === 'running' ? 'text-green-400' : 'text-slate-200'}`}>
                            {gameState === 'idle' && 'READY'}
                            {gameState === 'running' && 'RUN'}
                            {gameState === 'finished' && 'FINISH'}
                        </div>
                    </div>
                </div>

                {/* Winner Badge */}
                {gameState === 'finished' && (
                    <div className="absolute top-12 lg:top-6 left-0 right-0 flex justify-center gap-4 px-4 pointer-events-none">
                        <div className={`bg-slate-900/90 backdrop-blur px-4 py-2 lg:px-6 lg:py-3 rounded-full border border-slate-700 shadow-2xl flex items-center gap-2 font-bold animate-bounce ${winner === 'user' ? 'text-yellow-400' : 'text-red-400'} text-sm lg:text-base`}>
                            <Trophy size={16} className="lg:w-[18px] lg:h-[18px]" />
                            {winner === 'user' ? '우승!' : '패배!'}
                        </div>
                    </div>
                )}
                
                {/* AI Lap Counters (Bottom Left) */}
                <div className="absolute bottom-12 lg:bottom-24 left-2 lg:left-8 flex gap-2 lg:gap-4 scale-75 lg:scale-100 origin-bottom-left">
                    {cars.current.slice(1).map(c => (
                        <div key={c.id} className="bg-slate-900/80 backdrop-blur p-1.5 lg:p-2 rounded border border-slate-700 flex flex-col items-center min-w-[50px] lg:min-w-[60px]">
                            <div className="w-2.5 h-2.5 lg:w-3 lg:h-3 rounded-full mb-1" style={{backgroundColor: c.color}}></div>
                            <div className="text-[9px] lg:text-xs text-slate-400">{c.id.toUpperCase()}</div>
                            <div className="font-mono font-bold text-xs lg:text-sm">{c.laps}/{TOTAL_LAPS}</div>
                        </div>
                    ))}
                </div>

              </div>
            </div>
          );
        };

        const root = window.ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
