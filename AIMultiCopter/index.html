<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë“œë¡  ë¹Œë” 3D (ì‹œë®¬ë ˆì´ì…˜)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: white; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        .part-icon { width: 36px; height: 36px; display: flex; justify-content: center; align-items: center; border-radius: 4px; }
        
        /* ë¶€í’ˆ ìŠ¤íƒ€ì¼ (UIìš©) */
        .part-core { background-color: #ecc94b; border: 2px solid #b7791f; box-shadow: 0 0 5px #ecc94b; } /* FC */
        .part-body { background-color: #48bb78; border: 2px solid #2f855a; } /* ë°”ë”” í”„ë ˆì„ */
        .part-frame { background-color: #4a5568; border: 2px solid #2d3748; } /* ì¹´ë³¸ ì•” */
        .part-motor { background-color: #3182ce; border: 2px solid #2b6cb0; position: relative; } /* ëª¨í„° */
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        .selected { border-color: #63b3ed !important; box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); }
        
        /* 3D ëª¨ë“œ ì•Œë¦¼ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes pulse-perspective {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 0.5; }
        }
        .perspective-grid {
            transform: perspective(500px) rotateX(20deg);
        }
    </style>
</head>
<body>

<div id="ui-layer" class="flex flex-col justify-between p-4">
    <!-- ìƒë‹¨ ì •ë³´ íŒ¨ë„ -->
    <div class="flex justify-between items-start interactive">
        <div class="bg-slate-900 bg-opacity-90 p-4 rounded-lg shadow-xl border border-slate-700 backdrop-blur-sm">
            <h1 class="text-2xl font-bold mb-1 text-cyan-400">ğŸš AI ë“œë¡  ë¹Œë” 3D</h1>
            <p class="text-xs text-gray-400 mb-3">ì„¤ê³„ëŠ” Top-Down(í‰ë©´ë„), ë¹„í–‰ì€ 3D ë·°ë¡œ ì§„í–‰ë©ë‹ˆë‹¤.</p>
            <div class="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                <p>ì„¸ëŒ€ (Gen): <span id="gen-count" class="text-yellow-400 font-mono text-lg">1</span></p>
                <p>ìƒì¡´ ë“œë¡ : <span id="alive-count" class="text-green-400 font-mono text-lg">0</span></p>
                <p>ìµœê³  ì ìˆ˜: <span id="best-score" class="text-blue-400 font-mono">0</span></p>
                <p>ìƒíƒœ: <span id="status-text" class="text-gray-300">ì„¤ê³„ ì¤‘</span></p>
            </div>
        </div>
        
        <div class="flex gap-3">
            <button id="btn-build" onclick="setMode('build')" class="interactive px-6 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg font-bold shadow transition hidden">ğŸ›  ì„¤ê³„ ëª¨ë“œ (Top View)</button>
            <button id="btn-sim" onclick="startSimulation()" class="interactive px-6 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold shadow transition text-white ring-2 ring-blue-400 ring-opacity-50">ğŸš€ 3D ë¹„í–‰ ì‹œì‘</button>
        </div>
    </div>

    <!-- í•˜ë‹¨ ë¹Œë” íˆ´ë°” -->
    <div id="builder-panel" class="interactive bg-slate-900 bg-opacity-95 p-4 rounded-t-xl shadow-2xl mx-auto border-t border-slate-700 transition-transform duration-300 transform translate-y-0 w-full max-w-3xl">
        <div class="flex items-center justify-between">
            
            <div class="flex items-center gap-4">
                <div class="text-center mr-4">
                    <div class="text-[10px] text-gray-500 uppercase tracking-wider mb-1">SELECTED</div>
                    <div id="preview-box" class="w-12 h-12 bg-slate-800 rounded flex items-center justify-center border border-slate-600">
                        <div class="part-icon part-body"></div>
                    </div>
                </div>

                <div class="flex gap-2">
                    <button onclick="selectPart('core', this)" class="tool-btn flex flex-col items-center p-2 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-core mb-1"></div>
                        <span class="text-[10px] text-gray-300">FC(ë‘ë‡Œ)</span>
                    </button>
                    <button onclick="selectPart('body', this)" class="tool-btn flex flex-col items-center p-2 rounded hover:bg-slate-800 transition selected">
                        <div class="part-icon part-body mb-1"></div>
                        <span class="text-[10px] text-gray-300">ë°”ë””</span>
                    </button>
                    <button onclick="selectPart('frame', this)" class="tool-btn flex flex-col items-center p-2 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-frame mb-1"></div>
                        <span class="text-[10px] text-gray-300">í”„ë ˆì„</span>
                    </button>
                    <button onclick="selectPart('motor', this)" class="tool-btn flex flex-col items-center p-2 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-motor mb-1"></div>
                        <span class="text-[10px] text-gray-300">ëª¨í„°</span>
                    </button>
                </div>
            </div>

            <div class="h-10 w-px bg-slate-700 mx-2"></div>

            <button onclick="selectPart('delete', this)" class="tool-btn flex flex-col items-center p-2 rounded hover:bg-red-900/30 transition group">
                <div class="w-9 h-9 flex items-center justify-center border-2 border-red-500/50 rounded text-red-400 font-bold text-lg group-hover:border-red-500 group-hover:text-red-300">X</div>
                <span class="text-[10px] text-red-400 mt-1">ì œê±°</span>
            </button>
            
            <div class="text-right text-xs text-gray-400 leading-tight ml-4">
                <p>ìœ„ì—ì„œ ë‚´ë ¤ë‹¤ë³¸ ëª¨ìŠµ(Top View)ìœ¼ë¡œ ì¡°ë¦½í•˜ì„¸ìš”.</p>
                <p>FCëŠ” ë“œë¡ ì˜ ì¤‘ì‹¬ì´ì ë‡Œì…ë‹ˆë‹¤ (1ê°œ í•„ìˆ˜).</p>
                <p class="text-green-400">ë°”ë””(ì´ˆë¡ìƒ‰)ë¡œ ëª¸ì²´ë¥¼ í™•ì¥í•˜ì„¸ìš”.</p>
            </div>
        </div>
    </div>
</div>

<script>
// --- ì„¤ì • ë³€ìˆ˜ ---
const GRID_SIZE = 30; 
const GRID_W = 21; 
const GRID_H = 15; 
const POPULATION_SIZE = 30; 
const MUTATION_RATE = 0.1; 

// --- ì „ì—­ ìƒíƒœ ---
let currentMode = 'build';
let selectedPartType = 'body'; // ê¸°ë³¸ ì„ íƒì„ 'body'ë¡œ ë³€ê²½
let buildGrid = []; 
let engine, render, runner;
let population = []; 
let generation = 1;
let bestGenome = null; 

// Matter.js ë³„ì¹­
const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Composite = Matter.Composite,
      Events = Matter.Events,
      Vector = Matter.Vector;

// --- ì´ˆê¸°í™” ---
function init() {
    // ê·¸ë¦¬ë“œ ì´ˆê¸°í™”
    for(let y=0; y<GRID_H; y++) {
        buildGrid[y] = [];
        for(let x=0; x<GRID_W; x++) buildGrid[y][x] = null;
    }
    // ì¤‘ì•™ì— FC ë°°ì¹˜
    buildGrid[Math.floor(GRID_H/2)][Math.floor(GRID_W/2)] = 'core';

    setupMatter();
    
    // ë Œë” ë£¨í”„ (ì»¤ìŠ¤í…€ ë“œë¡œì‰ìš©)
    (function renderLoop() {
        drawCustomLayer();
        requestAnimationFrame(renderLoop);
    })();
}

function setupMatter() {
    const container = document.body;
    engine = Engine.create();
    engine.world.gravity.y = 1; 

    render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: '#0f172a', // Slate-900
            showAngleIndicator: false
        }
    });

    // ë°”ë‹¥
    const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 200, window.innerWidth * 10, 500, { 
        isStatic: true,
        render: { fillStyle: '#1e293b' }
    });
    Composite.add(engine.world, ground);

    Render.run(render);
    
    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
        Body.setPosition(ground, {x: window.innerWidth/2, y: window.innerHeight + 200});
    });
}

// --- UI ë° ë¹Œë” ë¡œì§ ---
function selectPart(type, btnElement) {
    selectedPartType = type;
    
    // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
    if(btnElement) btnElement.classList.add('selected');

    // ë¯¸ë¦¬ë³´ê¸° ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
    const preview = document.getElementById('preview-box');
    preview.innerHTML = '';
    if(type === 'delete') {
        preview.innerHTML = '<span class="text-red-500 font-bold text-xl">X</span>';
    } else {
        const div = document.createElement('div');
        div.className = `part-icon part-${type}`;
        preview.appendChild(div);
    }
}

function handleGridClick(e) {
    if (currentMode !== 'build') return;

    const canvasCx = window.innerWidth / 2;
    const canvasCy = window.innerHeight / 2;
    const gridPixelW = GRID_W * GRID_SIZE;
    const gridPixelH = GRID_H * GRID_SIZE;
    const startX = canvasCx - gridPixelW / 2;
    const startY = canvasCy - gridPixelH / 2;

    const mouseX = e.clientX;
    const mouseY = e.clientY;

    if (mouseX >= startX && mouseX < startX + gridPixelW &&
        mouseY >= startY && mouseY < startY + gridPixelH) {
        
        const gx = Math.floor((mouseX - startX) / GRID_SIZE);
        const gy = Math.floor((mouseY - startY) / GRID_SIZE);

        if (selectedPartType === 'core') {
            // FCëŠ” í•˜ë‚˜ë§Œ ì¡´ì¬. ë‹¤ë¥¸ ê³³ì— FCë¥¼ ë†“ìœ¼ë©´ ê¸°ì¡´ FC ì œê±°
            for(let y=0; y<GRID_H; y++) 
                for(let x=0; x<GRID_W; x++) 
                    if(buildGrid[y][x] === 'core') buildGrid[y][x] = null;
            buildGrid[gy][gx] = 'core';
        } else {
            // FC ìë¦¬ì—ëŠ” ë‹¤ë¥¸ê±¸ ë®ì–´ì“¸ ìˆ˜ ì—†ìŒ (ë¨¼ì € FCë¥¼ ì˜®ê¸°ê±°ë‚˜ ì§€ìš°ê³  í•´ì•¼í•¨)
            if (buildGrid[gy][gx] !== 'core') {
                buildGrid[gy][gx] = (selectedPartType === 'delete') ? null : selectedPartType;
            }
        }
    }
}

// --- ì»¤ìŠ¤í…€ ë“œë¡œì‰ (ë¹Œë” 2D + ì‹œë®¬ë ˆì´ì…˜ 3D) ---
function drawCustomLayer() {
    const ctx = render.context;
    
    if (currentMode === 'build') {
        drawGrid(ctx);
    } else {
        drawSimulation3D(ctx);
    }
}

function drawGrid(ctx) {
    const canvasCx = render.canvas.width / 2;
    const canvasCy = render.canvas.height / 2;
    const startX = canvasCx - (GRID_W * GRID_SIZE) / 2;
    const startY = canvasCy - (GRID_H * GRID_SIZE) / 2;

    // ë°°ê²½ ë”¤ ì²˜ë¦¬
    ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // Slate-900
    ctx.fillRect(0, 0, render.canvas.width, render.canvas.height);

    // ê·¸ë¦¬ë“œ ë³´ë“œ ë°°ê²½
    ctx.fillStyle = '#1e293b'; // Slate-800
    ctx.fillRect(startX, startY, GRID_W * GRID_SIZE, GRID_H * GRID_SIZE);

    // ëª¨ëˆˆì¢…ì´ íš¨ê³¼
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    
    for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
            const px = startX + x * GRID_SIZE;
            const py = startY + y * GRID_SIZE;
            
            ctx.strokeRect(px, py, GRID_SIZE, GRID_SIZE);

            const type = buildGrid[y][x];
            if (type) {
                const cx = px + GRID_SIZE/2;
                const cy = py + GRID_SIZE/2;
                
                if (type === 'core') {
                    ctx.fillStyle = '#ecc94b';
                    ctx.fillRect(px+2, py+2, GRID_SIZE-4, GRID_SIZE-4);
                    ctx.fillStyle = '#744210';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('FC', cx, cy+4);
                } else if (type === 'body') {
                    ctx.fillStyle = '#48bb78';
                    ctx.fillRect(px+2, py+2, GRID_SIZE-4, GRID_SIZE-4);
                } else if (type === 'frame') {
                    ctx.fillStyle = '#4a5568';
                    ctx.fillRect(px+4, py+4, GRID_SIZE-8, GRID_SIZE-8);
                    // ì—°ê²°ì„  ëŠë‚Œ
                    ctx.fillStyle = '#2d3748';
                    ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
                } else if (type === 'motor') {
                    ctx.fillStyle = '#3182ce';
                    ctx.beginPath(); ctx.arc(cx, cy, GRID_SIZE/2 - 2, 0, Math.PI*2); ctx.fill();
                    // í”„ë¡œí ëŸ¬ (Top View)
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px+GRID_SIZE, py+GRID_SIZE); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(px+GRID_SIZE, py); ctx.lineTo(px, py+GRID_SIZE); ctx.stroke();
                }
            }
        }
    }
    
    // Top View ë¼ë²¨
    ctx.fillStyle = '#94a3b8';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText("Top View (ìœ„ì—ì„œ ë³¸ ì„¤ê³„ë„)", canvasCx, startY - 20);
}

// â˜… 3D ë Œë”ë§ í•¨ìˆ˜
function drawSimulation3D(ctx) {
    // ë°°ê²½ì„ ë§¤ í”„ë ˆì„ í´ë¦¬ì–´ (Matter.js ë Œë”ê°€ ì´ë¯¸ ê·¸ë ¸ì§€ë§Œ, 3D íš¨ê³¼ë¥¼ ìœ„í•´ ë®ì–´ì”€)
    // Matter.js bodyëŠ” íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬í•˜ê³  ìš°ë¦¬ê°€ ì§ì ‘ ê·¸ë¦°ë‹¤.
    ctx.clearRect(0, 0, render.canvas.width, render.canvas.height);
    
    // ë°°ê²½ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (í•˜ëŠ˜)
    // ê·¸ë¼ë°ì´ì…˜
    const grad = ctx.createLinearGradient(0, 0, 0, render.canvas.height);
    grad.addColorStop(0, '#0f172a');
    grad.addColorStop(1, '#1e293b');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, render.canvas.width, render.canvas.height);
    
    // ë°”ë‹¥ (Grid Floor)
    const horizonY = render.canvas.height - 50;
    ctx.fillStyle = '#334155';
    ctx.fillRect(0, horizonY, render.canvas.width, 50);

    population.forEach(drone => {
        if (!drone.alive) return;
        drawDrone3D(ctx, drone);
    });
}

function drawDrone3D(ctx, drone) {
    const cx = drone.body.position.x;
    const cy = drone.body.position.y;
    const angle = drone.body.angle; // 2D Roll

    // 3D íˆ¬ì˜ íŒŒë¼ë¯¸í„°
    // X: ìŠ¤í¬ë¦° ì¢Œìš° (ë¬¼ë¦¬ Xì™€ ë™ì¼)
    // Y: ìŠ¤í¬ë¦° ìƒí•˜ (ë¬¼ë¦¬ Yì™€ ë™ì¼)
    // Z: ê¹Šì´ (ê·¸ë¦¬ë“œ Yê°’). 2D ë¬¼ë¦¬ì—”ì§„ì—ëŠ” ì—†ì§€ë§Œ ì‹œê°ì ìœ¼ë¡œë§Œ ì¡´ì¬.
    
    // ë“œë¡  íŒŒì¸ ë“¤ì„ ê¹Šì´(Z) ìˆœì„œëŒ€ë¡œ ì •ë ¬í•´ì•¼ í•¨ (ë’¤ì— ìˆëŠ”ê±¸ ë¨¼ì € ê·¸ë¦¬ê¸°)
    // FCê°€ (0,0,0) ê¸°ì¤€. 
    // GridYê°€ ì‘ì„ìˆ˜ë¡(ìœ„ìª½) Back, í´ìˆ˜ë¡(ì•„ë˜ìª½) Frontë¼ê³  ê°€ì •.
    // í•˜ì§€ë§Œ ë“œë¡ ì´ íšŒì „í•˜ë©´ ì´ ìˆœì„œë„ ë°”ë€” ìˆ˜ ìˆìŒ? 
    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ Yì¶• íšŒì „ì€ ì—†ë‹¤ê³  ê°€ì •í•˜ê³  (Rollë§Œ ì¡´ì¬), Grid Y ìˆœì„œëŒ€ë¡œ ê·¸ë¦¼.

    // 1. íŒŒì¸  ë°ì´í„° ì¤€ë¹„ (ìƒëŒ€ ì¢Œí‘œ ê³„ì‚°)
    let drawItems = [];
    drone.partsData.forEach(p => {
        // Core(FC) ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ì¢Œí‘œ
        const relGridX = p.x - drone.coreGridPos.x;
        const relGridZ = p.y - drone.coreGridPos.y; // Grid Yë¥¼ Z(ê¹Šì´)ë¡œ ë§¤í•‘

        // ì›”ë“œ ì¢Œí‘œê³„ ë³€í™˜ (ë¬¼ë¦¬ ì—”ì§„ì˜ íšŒì „ ì ìš©)
        // 2D ë¬¼ë¦¬ì—”ì§„ì—ì„œ Angleì€ Roll(ì¢Œìš° ê¸°ìš¸ê¸°)ì…ë‹ˆë‹¤.
        // Xì¶•: ì¢Œìš°, Yì¶•: ìƒí•˜
        // ë¡œì»¬ ì¢Œí‘œ (rx, ry, rz)
        // rz(ê¹Šì´)ëŠ” Rollì— ì˜í–¥ì„ ëœ ë°›ì§€ë§Œ, ì‹œê°ì  ì™œê³¡(Perspective)ì„ ì¤Œ.

        const partSize = GRID_SIZE;
        
        // íˆ¬ì˜ ê³„ì‚° (Pseudo 3D)
        // Zê°’ì´ í´ìˆ˜ë¡(ì•ìª½) í™”ë©´ ì•„ë˜ë¡œ ì¡°ê¸ˆ ë‚´ë ¤ì˜¤ê³ , ì»¤ì§
        const depthFactor = 0.5; // ì›ê·¼ê° ê°•ë„
        const zScale = 1 + relGridZ * 0.05; // ì•ìª½ì´ ì•½ê°„ ì»¤ì§
        
        // íšŒì „ ë³€í™˜ (2D Rotation)
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        // ìƒëŒ€ì  ë¬¼ë¦¬ ìœ„ì¹˜ (2D í‰ë©´ìƒ)
        const physX = relGridX * GRID_SIZE;
        const physY = 0; // ë¶€í’ˆì€ ìˆ˜í‰ë©´(í‰ë©´ë„)ì— ë°°ì¹˜ë˜ë¯€ë¡œ ì´ˆê¸° Yì˜¤í”„ì…‹ì€ 0

        // íšŒì „ í›„ ìœ„ì¹˜
        const rotX = physX * cos - physY * sin;
        const rotY = physX * sin + physY * cos;

        // í™”ë©´ ì¢Œí‘œ
        // Z(ê¹Šì´)ì— ë”°ë¥¸ X, Y ì˜¤í”„ì…‹ ì¶”ê°€ (Isometric ëŠë‚Œ)
        const isoOffsetX = relGridZ * GRID_SIZE * 0.4; // ê¹Šì´ì— ë”°ë¼ ì˜†ìœ¼ë¡œ ì‚´ì§ (ë¹„ìŠ¤ë“¬íˆ ë³´ê¸°)
        const isoOffsetY = relGridZ * GRID_SIZE * 0.2; // ê¹Šì´ì— ë”°ë¼ ì•„ë˜ë¡œ

        const screenX = cx + rotX + isoOffsetX;
        const screenY = cy + rotY + isoOffsetY;

        // ì •ë ¬ì„ ìœ„í•œ Zê°’ (í™”ë©´ ê¹Šì´)
        // ìˆ«ìê°€ ì‘ì„ìˆ˜ë¡ ë’¤(ë¨¼ì € ê·¸ë¦¼)
        const sortZ = relGridZ; 

        drawItems.push({
            type: p.type,
            x: screenX,
            y: screenY,
            z: sortZ,
            scale: zScale,
            angle: angle, // ë“œë¡  ìì²´ì˜ ê°ë„
            motorIdx: (p.type === 'motor') ? drone.motorMap.get(`${p.x},${p.y}`) : -1
        });
    });

    // 2. ê¹Šì´ ì •ë ¬ (ë’¤ì—ì„œ ì•ìœ¼ë¡œ)
    drawItems.sort((a, b) => a.z - b.z);

    // 3. ê·¸ë¦¼ì ê·¸ë¦¬ê¸° (ë‹¨ìˆœí™”)
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(cx, cy + 100, 40, 10, 0, 0, Math.PI*2);
    ctx.fill();

    // 4. íŒŒì¸  ê·¸ë¦¬ê¸°
    drawItems.forEach(item => {
        const s = item.scale;
        const size = GRID_SIZE * s;
        
        ctx.save();
        ctx.translate(item.x, item.y);
        ctx.rotate(item.angle); // ë¶€í’ˆë„ ê°™ì´ íšŒì „

        // ê¹Šì´ì— ë”°ë¥¸ ë°ê¸° ì¡°ì ˆ (ë’¤ìª½ì€ ì–´ë‘¡ê²Œ)
        const brightness = 1 + item.z * 0.1; 
        const shade = (color) => adjustColorBrightness(color, (item.z * 10)); // ê°„ë‹¨í•œ ëª…ì•”

        if (item.type === 'core') {
            // FC (ìœ¡ë©´ì²´ ëŠë‚Œ)
            drawCube(ctx, size, '#ecc94b', '#d69e2e', '#744210');
            ctx.fillStyle = '#744210'; ctx.font = `bold ${10*s}px sans-serif`; ctx.textAlign = 'center';
            ctx.fillText('FC', 0, -size/2);
        } else if (item.type === 'body') {
            drawCube(ctx, size, '#48bb78', '#2f855a', '#22543d');
        } else if (item.type === 'frame') {
            // í”„ë ˆì„ì€ ë‚©ì‘í•˜ê²Œ
            ctx.fillStyle = '#475569';
            ctx.fillRect(-size/2, -size/8, size, size/4);
        } else if (item.type === 'motor') {
            // ëª¨í„° (ì›í†µí˜•)
            ctx.fillStyle = '#3182ce';
            ctx.beginPath(); ctx.ellipse(0, 0, size/2, size/4, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c5282'; // ì˜†ë©´
            ctx.fillRect(-size/2, 0, size, size/2);
            
            // í”„ë¡œí ëŸ¬
            const power = drone.motorPowers[item.motorIdx] || 0;
            drawPropeller(ctx, size, power);
        }

        ctx.restore();
    });
}

// 3D íë¸Œ ê·¸ë¦¬ê¸° ë„ìš°ë¯¸
function drawCube(ctx, size, topColor, sideColor, frontColor) {
    const h = size * 0.6; // ë†’ì´
    const w = size;
    
    // ìœ—ë©´ (ë§ˆë¦„ëª¨)
    ctx.fillStyle = topColor;
    ctx.beginPath();
    ctx.moveTo(0, -h/2);
    ctx.lineTo(w/2, 0);
    ctx.lineTo(0, h/2);
    ctx.lineTo(-w/2, 0);
    ctx.fill();
    
    // ì•ë©´/ì˜†ë©´ (ë‘ê»˜)
    ctx.fillStyle = sideColor;
    ctx.beginPath();
    ctx.moveTo(-w/2, 0);
    ctx.lineTo(0, h/2);
    ctx.lineTo(0, h);
    ctx.lineTo(-w/2, h/2);
    ctx.fill();
    
    ctx.fillStyle = frontColor;
    ctx.beginPath();
    ctx.moveTo(0, h/2);
    ctx.lineTo(w/2, 0);
    ctx.lineTo(w/2, h/2);
    ctx.lineTo(0, h);
    ctx.fill();
}

function drawPropeller(ctx, size, power) {
    if (power < 0.01) {
        // ì •ì§€ ìƒíƒœ
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(-size, 0); ctx.lineTo(size, 0); ctx.stroke();
        return;
    }
    
    // íšŒì „ ìƒíƒœ (ë¸”ëŸ¬ ë””ìŠ¤í¬)
    const alpha = 0.2 + power * 0.5;
    ctx.fillStyle = `rgba(200, 240, 255, ${alpha})`;
    ctx.beginPath();
    ctx.ellipse(0, -size/2, size*1.2, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    
    // ì”ìƒ ë¼ì¸
    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.lineWidth = 1;
    if (Math.random() > 0.5) {
        ctx.beginPath(); ctx.moveTo(-size, -size/2); ctx.lineTo(size, -size/2); ctx.stroke();
    }
    
    // í•˜ê°• ê¸°ë¥˜ (íŒŒì›Œ ì‹œê°í™”)
    if (power > 0.2) {
        ctx.strokeStyle = `rgba(100, 200, 255, ${power * 0.3})`;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, size * 2 * power);
        ctx.stroke();
    }
}

// ìƒ‰ìƒ ë°ê¸° ì¡°ì ˆ ìœ í‹¸ (ê°„ë‹¨)
function adjustColorBrightness(hex, percent) {
    // ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ ì›ë³¸ ìƒ‰ìƒë§Œ ë¦¬í„´í•˜ë„ë¡ ì²˜ë¦¬ (ë³µì¡ë„ ì¤„ì„)
    return hex;
}


// --- ì‹ ê²½ë§ (Brain) ---
class NeuralNetwork {
    constructor(inputCount, outputCount) {
        this.inputCount = inputCount;
        this.outputCount = outputCount;
        this.hiddenCount = 8;
        
        this.w1 = Array(inputCount * this.hiddenCount).fill(0).map(() => Math.random() * 2 - 1);
        this.b1 = Array(this.hiddenCount).fill(0).map(() => Math.random() * 2 - 1);
        this.w2 = Array(this.hiddenCount * outputCount).fill(0).map(() => Math.random() * 2 - 1);
        this.b2 = Array(outputCount).fill(0).map(() => Math.random() * 2 - 1);
    }

    predict(inputs) {
        let hidden = [];
        for(let i=0; i<this.hiddenCount; i++) {
            let sum = 0;
            for(let j=0; j<this.inputCount; j++) sum += inputs[j] * this.w1[j*this.hiddenCount + i];
            hidden[i] = Math.tanh(sum + this.b1[i]);
        }
        let outputs = [];
        for(let i=0; i<this.outputCount; i++) {
            let sum = 0;
            for(let j=0; j<this.hiddenCount; j++) sum += hidden[j] * this.w2[j*this.outputCount + i];
            outputs[i] = 1 / (1 + Math.exp(-(sum + this.b2[i]))); 
        }
        return outputs;
    }

    clone() {
        const c = new NeuralNetwork(this.inputCount, this.outputCount);
        c.w1 = [...this.w1]; c.b1 = [...this.b1];
        c.w2 = [...this.w2]; c.b2 = [...this.b2];
        return c;
    }

    mutate(rate) {
        const mutateVal = v => Math.random() < rate ? v + (Math.random() * 0.4 - 0.2) : v;
        this.w1 = this.w1.map(mutateVal);
        this.b1 = this.b1.map(mutateVal);
        this.w2 = this.w2.map(mutateVal);
        this.b2 = this.b2.map(mutateVal);
    }
}

// --- ë“œë¡  í´ë˜ìŠ¤ ---
class Drone {
    constructor(startX, startY, partsData, brain) {
        this.alive = true;
        this.fitness = 0;
        this.lifeTime = 0;
        this.partsData = partsData; // ë Œë”ë§ìš© ë°ì´í„°
        
        let coreX = 0, coreY = 0;
        partsData.forEach(p => { if(p.type==='core') { coreX=p.x; coreY=p.y; }});
        this.coreGridPos = { x: coreX, y: coreY }; // ë Œë”ë§ ê¸°ì¤€ì 

        // Matter.js Body ìƒì„± (ë¬¼ë¦¬ëŠ” 2D Side View ìœ ì§€)
        const bodyParts = [];
        this.motors = []; 
        this.motorMap = new Map(); // ì¢Œí‘œë¡œ ëª¨í„° ì¸ë±ìŠ¤ ì°¾ê¸°ìš©

        let motorIndex = 0;
        partsData.forEach(p => {
            const relX = (p.x - coreX) * GRID_SIZE;
            const relY = (p.y - coreY) * GRID_SIZE; 
            // ì£¼ì˜: ë¬¼ë¦¬ ì—”ì§„ì—ì„œ relYëŠ” 2D ìƒí•˜ì¢Œí‘œê°€ ì•„ë‹ˆë¼, ì—¬ê¸°ì„œëŠ” "Top-Downì˜ Y"ì´ë¯€ë¡œ ê¹Šì´(Z)ê°€ ë¨.
            // í•˜ì§€ë§Œ Matter.jsëŠ” 2D ë¬¼ë¦¬. ë“œë¡ ì˜ ê· í˜•(Roll)ì€ Xì¶• ë¶„í¬ì— ì˜í•´ ê²°ì •ë¨.
            // Zì¶•(ê¹Šì´) ë¶„í¬ëŠ” 2D ë¬¼ë¦¬ì—ì„œ ë¬´ì‹œí•˜ê±°ë‚˜, Yì¶•(ë†’ì´) ì˜¤í”„ì…‹ì„ 0ìœ¼ë¡œ ë‘¬ì•¼ í•¨.
            
            // ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ "ë¬¼ë¦¬ì  ë°”ë””"ëŠ” ë‚©ì‘í•œ ë§‰ëŒ€ê¸°ì²˜ëŸ¼ ë§Œë“­ë‹ˆë‹¤.
            // ê¹Šì´(Z)ì— ìˆëŠ” ë¶€í’ˆë„ ë¬¼ë¦¬ì ìœ¼ë¡œëŠ” ì¤‘ì•™(Y=0)ì— ê²¹ì³ìˆë‹¤ê³  ê°€ì •í•˜ì—¬ Roll ì œì–´ë§Œ ì‹œë®¬ë ˆì´ì…˜.
            
            const physRelX = relX;
            const physRelY = 0; // ëª¨ë“  ë¶€í’ˆì„ ë¬¼ë¦¬ì  ìˆ˜ì§ ì¤‘ì‹¬ì„ ì— ë°°ì¹˜

            let part;
            const commonOpt = { friction: 0.5, restitution: 0.2 };

            if(p.type === 'core') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, 
                    { ...commonOpt, density: 0.005, render: { visible: false } }); // ë Œë”ë§ì€ ìš°ë¦¬ê°€ ì§ì ‘ í•¨
            } else if (p.type === 'body') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, 
                    { ...commonOpt, density: 0.002, render: { visible: false } });
            } else if (p.type === 'frame') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/4, 
                    { ...commonOpt, density: 0.001, render: { visible: false } });
            } else if (p.type === 'motor') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, 
                    { ...commonOpt, density: 0.003, render: { visible: false } });
                this.motors.push({ relativePos: {x: physRelX, y: physRelY}, gridPos: {x: p.x, y: p.y} });
                this.motorMap.set(`${p.x},${p.y}`, motorIndex++);
            }
            if(part) bodyParts.push(part);
        });

        this.body = Body.create({ parts: bodyParts, frictionAir: 0.05 }); 
        this.body.collisionFilter.group = -1; 

        // ë‡Œ ì„¤ì •
        const motorCount = this.motors.length;
        this.motorPowers = new Array(motorCount).fill(0);
        
        if(brain) {
            this.brain = brain.clone();
            this.brain.mutate(MUTATION_RATE);
        } else {
            this.brain = new NeuralNetwork(6, Math.max(motorCount, 4)); 
        }

        Composite.add(engine.world, this.body);
    }

    update() {
        if(!this.alive) return;
        this.lifeTime++;

        const angle = this.body.angle; 
        const angVel = this.body.angularVelocity;
        const vel = this.body.velocity;
        const h = window.innerHeight - this.body.position.y;
        const targetH = 400; 
        
        const inputs = [
            angle / Math.PI, 
            angVel * 5,      
            vel.x / 10,      
            vel.y / 10,      
            (h - targetH) / 500, 
            1.0 
        ];

        const outputs = this.brain.predict(inputs);

        this.motors.forEach((motor, i) => {
            let power = outputs[i % outputs.length]; 
            this.motorPowers[i] = power;

            if (power > 0) {
                const thrust = 0.003 * power * (1 + this.body.mass * 0.5); 
                const forceVector = Vector.rotate({ x: 0, y: -thrust }, this.body.angle);
                const motorWorldPos = Vector.add(this.body.position, Vector.rotate(motor.relativePos, this.body.angle));
                Body.applyForce(this.body, motorWorldPos, forceVector);
            }
        });

        const distToTarget = Math.abs(h - targetH);
        const stability = 1.0 - Math.min(Math.abs(angle), 1.0);
        const centerBonus = 1.0 - Math.min(Math.abs(this.body.position.x - window.innerWidth/2) / 500, 1.0);

        if (distToTarget < 100) this.fitness += 2;
        if (distToTarget < 300) this.fitness += 1;
        this.fitness += stability * 2;
        this.fitness += centerBonus;

        if (this.body.position.y > window.innerHeight + 100 || 
            this.body.position.y < -500 || 
            Math.abs(this.body.position.x - window.innerWidth/2) > 800 || 
            Math.abs(angle) > Math.PI / 2 
           ) {
            this.alive = false;
            Composite.remove(engine.world, this.body);
        }
    }
}

// --- ì‹œë®¬ë ˆì´ì…˜ ê´€ë¦¬ ---
function setMode(mode) {
    currentMode = mode;
    const ui = document.getElementById('builder-panel');
    const btnBuild = document.getElementById('btn-build');
    const btnSim = document.getElementById('btn-sim');
    const status = document.getElementById('status-text');

    if(mode === 'build') {
        ui.classList.remove('translate-y-full');
        btnBuild.classList.add('hidden');
        btnSim.classList.remove('hidden');
        status.innerText = "ì„¤ê³„ ì¤‘";
        
        if(runner) Runner.stop(runner);
        Composite.clear(engine.world);
        const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 200, window.innerWidth * 10, 500, { isStatic: true, render: { fillStyle: '#1e293b' } });
        Composite.add(engine.world, ground);
        
        population = [];
        generation = 1;
        bestGenome = null;
        updateStats();

    } else {
        ui.classList.add('translate-y-full');
        btnBuild.classList.remove('hidden');
        btnSim.classList.add('hidden');
        status.innerText = "AI 3D ë¹„í–‰ ì¤‘";
    }
}

function startSimulation() {
    const parts = [];
    let hasCore = false;
    let motorCount = 0;
    
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            if(buildGrid[y][x]) {
                parts.push({x, y, type: buildGrid[y][x]});
                if(buildGrid[y][x] === 'core') hasCore = true;
                if(buildGrid[y][x] === 'motor') motorCount++;
            }
        }
    }

    if (!hasCore) { alert("ë“œë¡ ì—ëŠ” FC(ë…¸ë€ìƒ‰ ì½”ì–´)ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤!"); return; }
    if (motorCount < 2) { alert("ìµœì†Œ 2ê°œ ì´ìƒì˜ ëª¨í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤!"); return; }

    setMode('sim');
    runner = Runner.create();
    Runner.run(runner, engine);
    spawnGeneration(parts);
    gameLoop();
}

function spawnGeneration(parts) {
    population = [];
    const startX = window.innerWidth / 2;
    const startY = window.innerHeight - 200;

    for(let i=0; i<POPULATION_SIZE; i++) {
        let brain = null;
        if(bestGenome && i > 0) {
            brain = bestGenome; 
        } else if(bestGenome && i === 0) {
             brain = bestGenome.clone();
             brain.mutate(0); 
        }
        population.push(new Drone(startX, startY, parts, brain));
    }
    updateStats();
}

function gameLoop() {
    if(currentMode !== 'sim') return;

    let aliveCount = 0;
    let maxFit = 0;

    population.forEach(drone => {
        if(drone.alive) {
            drone.update();
            aliveCount++;
            if(drone.fitness > maxFit) maxFit = drone.fitness;
        }
    });

    const bestScoreEl = document.getElementById('best-score');
    if(maxFit > parseInt(bestScoreEl.innerText)) bestScoreEl.innerText = Math.floor(maxFit);
    document.getElementById('alive-count').innerText = aliveCount;

    if(aliveCount === 0) {
        evolve();
        generation++;
        updateStats();
        const parts = population[0].partsData;
        spawnGeneration(parts);
    }
    
    requestAnimationFrame(gameLoop);
}

function evolve() {
    let best = population[0];
    population.forEach(p => { if(p.fitness > best.fitness) best = p; });
    bestGenome = best.brain;
}

function updateStats() {
    document.getElementById('gen-count').innerText = generation;
    document.getElementById('alive-count').innerText = population.length;
}

document.addEventListener('mousedown', handleGridClick);

init();
</script>
</body>
</html>
