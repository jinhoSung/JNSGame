<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë“œë¡  ë¹Œë” 3D (íŠ¸ë ˆì´ë‹ ì„¼í„°)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: white; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        .part-icon { width: 32px; height: 32px; display: flex; justify-content: center; align-items: center; border-radius: 4px; }
        
        /* ë¶€í’ˆ ìŠ¤íƒ€ì¼ (UIìš©) */
        .part-core { background-color: #ecc94b; border: 2px solid #b7791f; box-shadow: 0 0 5px #ecc94b; } /* FC */
        .part-body { background-color: #48bb78; border: 2px solid #2f855a; } /* ë°”ë”” í”„ë ˆì„ */
        .part-frame { background-color: #4a5568; border: 2px solid #2d3748; } /* ì¹´ë³¸ ì•” */
        .part-motor { background-color: #3182ce; border: 2px solid #2b6cb0; position: relative; } /* ëª¨í„° */
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }
        .selected { border-color: #63b3ed !important; box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); }
        
        /* ì»¤ìŠ¤í…€ ìŠ¤í¬ë¡¤ë°” ë“± */
        select { background-color: #1e293b; color: white; border: 1px solid #475569; padding: 2px 4px; border-radius: 4px; font-size: 12px; }
    </style>
</head>
<body>

<div id="ui-layer" class="flex flex-col justify-between p-2">
    <!-- ìƒë‹¨ ì •ë³´ íŒ¨ë„ (ì¶•ì†Œë¨) -->
    <div class="flex flex-col gap-2 items-start interactive">
        <div id="info-panel" class="bg-slate-900 bg-opacity-80 p-3 rounded-lg shadow-lg border border-slate-700 backdrop-blur-sm transition-all duration-300 origin-top-left" style="max-width: 280px;">
            <div class="flex justify-between items-center mb-2">
                <h1 class="text-sm font-bold text-cyan-400">ğŸš AI ë“œë¡  ì—°êµ¬ì†Œ</h1>
                <button onclick="toggleInfo()" class="text-xs text-gray-500 hover:text-white">[ì ‘ê¸°/í´ê¸°]</button>
            </div>
            
            <div id="info-content">
                <div class="grid grid-cols-2 gap-x-2 gap-y-1 text-xs mb-3">
                    <p>ì„¸ëŒ€: <span id="gen-count" class="text-yellow-400 font-mono">1</span></p>
                    <p>ìƒì¡´: <span id="alive-count" class="text-green-400 font-mono">0</span></p>
                    <p>ìµœê³ ì : <span id="best-score" class="text-blue-400 font-mono">0</span></p>
                    <p>ìƒíƒœ: <span id="status-text" class="text-gray-300">ì„¤ê³„ ì¤‘</span></p>
                </div>

                <div class="border-t border-slate-700 pt-2 mb-2">
                    <label class="block text-[10px] text-gray-400 mb-1">AI í•™ìŠµ ëª©í‘œ (Training Goal)</label>
                    <select id="training-mode" onchange="changeTrainingMode(this.value)" class="w-full">
                        <option value="hover">ğŸ”µ ì œìë¦¬ í˜¸ë²„ë§ (Hover)</option>
                        <option value="move">ğŸš© ëª©í‘œ ì§€ì  ì´ë™ (Move)</option>
                        <option value="obstacle">ğŸš§ ì¥ì• ë¬¼ íšŒí”¼ (Obstacle)</option>
                    </select>
                </div>

                <div class="flex gap-2 mt-2">
                    <button id="btn-build" onclick="setMode('build')" class="flex-1 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs font-bold hidden">ğŸ›  ì„¤ê³„</button>
                    <button id="btn-sim" onclick="startSimulation()" class="flex-1 py-1 bg-blue-600 hover:bg-blue-500 rounded text-xs font-bold text-white shadow-lg shadow-blue-500/30">ğŸš€ ë¹„í–‰ ì‹œì‘</button>
                </div>
            </div>
        </div>
    </div>

    <!-- í•˜ë‹¨ ë¹Œë” íˆ´ë°” (ì´ì „ê³¼ ë™ì¼í•˜ì§€ë§Œ ì¡°ê¸ˆ ë” ì»´íŒ©íŠ¸í•˜ê²Œ) -->
    <div id="builder-panel" class="interactive bg-slate-900 bg-opacity-90 p-3 rounded-t-xl shadow-2xl mx-auto border-t border-slate-700 transition-transform duration-300 transform translate-y-0 w-full max-w-2xl">
        <div class="flex items-center justify-between">
            
            <div class="flex items-center gap-3">
                <div class="text-center mr-2">
                    <div id="preview-box" class="w-10 h-10 bg-slate-800 rounded flex items-center justify-center border border-slate-600">
                        <div class="part-icon part-body"></div>
                    </div>
                </div>

                <div class="flex gap-1">
                    <button onclick="selectPart('core', this)" class="tool-btn flex flex-col items-center p-1.5 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-core w-6 h-6 mb-0.5"></div>
                        <span class="text-[9px] text-gray-300">FC</span>
                    </button>
                    <button onclick="selectPart('body', this)" class="tool-btn flex flex-col items-center p-1.5 rounded hover:bg-slate-800 transition selected">
                        <div class="part-icon part-body w-6 h-6 mb-0.5"></div>
                        <span class="text-[9px] text-gray-300">ë°”ë””</span>
                    </button>
                    <button onclick="selectPart('frame', this)" class="tool-btn flex flex-col items-center p-1.5 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-frame w-6 h-6 mb-0.5"></div>
                        <span class="text-[9px] text-gray-300">í”„ë ˆì„</span>
                    </button>
                    <button onclick="selectPart('motor', this)" class="tool-btn flex flex-col items-center p-1.5 rounded hover:bg-slate-800 transition">
                        <div class="part-icon part-motor w-6 h-6 mb-0.5"></div>
                        <span class="text-[9px] text-gray-300">ëª¨í„°</span>
                    </button>
                </div>
            </div>

            <div class="h-8 w-px bg-slate-700 mx-2"></div>

            <button onclick="selectPart('delete', this)" class="tool-btn flex flex-col items-center p-1.5 rounded hover:bg-red-900/30 transition group">
                <div class="w-8 h-8 flex items-center justify-center border-2 border-red-500/50 rounded text-red-400 font-bold text-sm group-hover:border-red-500 group-hover:text-red-300">X</div>
                <span class="text-[9px] text-red-400 mt-0.5">ì œê±°</span>
            </button>
            
            <div class="text-right text-[10px] text-gray-400 leading-tight ml-4 hidden sm:block">
                <p>Top View ì¡°ë¦½</p>
                <p class="text-yellow-400">FC 1ê°œ í•„ìˆ˜</p>
            </div>
        </div>
    </div>
</div>

<script>
// --- ì„¤ì • ë³€ìˆ˜ ---
const GRID_SIZE = 30; 
const GRID_W = 21; 
const GRID_H = 15; 
const POPULATION_SIZE = 30; 
const MUTATION_RATE = 0.1; 

// --- ì „ì—­ ìƒíƒœ ---
let currentMode = 'build';
let trainingGoal = 'hover'; // 'hover', 'move', 'obstacle'
let selectedPartType = 'body'; 
let buildGrid = []; 
let engine, render, runner;
let population = []; 
let obstacles = []; // ì¥ì• ë¬¼ ë°”ë””ë“¤
let targetPoint = { x: 0, y: 0 }; // ëª©í‘œ ì§€ì 
let generation = 1;
let bestGenome = null; 

// Matter.js ë³„ì¹­
const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Composite = Matter.Composite,
      Events = Matter.Events,
      Vector = Matter.Vector;

// --- ì´ˆê¸°í™” ---
function init() {
    for(let y=0; y<GRID_H; y++) {
        buildGrid[y] = [];
        for(let x=0; x<GRID_W; x++) buildGrid[y][x] = null;
    }
    buildGrid[Math.floor(GRID_H/2)][Math.floor(GRID_W/2)] = 'core';

    setupMatter();
    
    (function renderLoop() {
        drawCustomLayer();
        requestAnimationFrame(renderLoop);
    })();
}

function setupMatter() {
    const container = document.body;
    engine = Engine.create();
    engine.world.gravity.y = 1; 

    render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: '#0f172a', 
            showAngleIndicator: false
        }
    });

    const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 200, window.innerWidth * 10, 500, { 
        isStatic: true,
        render: { fillStyle: '#1e293b' }
    });
    Composite.add(engine.world, ground);

    Render.run(render);
    
    window.addEventListener('resize', () => {
        render.canvas.width = window.innerWidth;
        render.canvas.height = window.innerHeight;
        Body.setPosition(ground, {x: window.innerWidth/2, y: window.innerHeight + 200});
    });
}

// --- UI ë¡œì§ ---
function toggleInfo() {
    const content = document.getElementById('info-content');
    if (content.style.display === 'none') {
        content.style.display = 'block';
    } else {
        content.style.display = 'none';
    }
}

function changeTrainingMode(mode) {
    trainingGoal = mode;
    // ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì´ë¼ë©´ ë¦¬ì…‹ ìœ ë„
    if (currentMode === 'sim') {
        startSimulation(); // ì¬ì‹œì‘
    }
}

function selectPart(type, btnElement) {
    selectedPartType = type;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('selected'));
    if(btnElement) btnElement.classList.add('selected');

    const preview = document.getElementById('preview-box');
    preview.innerHTML = '';
    if(type === 'delete') {
        preview.innerHTML = '<span class="text-red-500 font-bold text-xl">X</span>';
    } else {
        const div = document.createElement('div');
        div.className = `part-icon part-${type}`;
        div.style.width = '24px'; div.style.height = '24px';
        preview.appendChild(div);
    }
}

function handleGridClick(e) {
    if (currentMode !== 'build') return;
    const canvasCx = window.innerWidth / 2;
    const canvasCy = window.innerHeight / 2;
    const gridPixelW = GRID_W * GRID_SIZE;
    const gridPixelH = GRID_H * GRID_SIZE;
    const startX = canvasCx - gridPixelW / 2;
    const startY = canvasCy - gridPixelH / 2;

    const mouseX = e.clientX;
    const mouseY = e.clientY;

    if (mouseX >= startX && mouseX < startX + gridPixelW &&
        mouseY >= startY && mouseY < startY + gridPixelH) {
        
        const gx = Math.floor((mouseX - startX) / GRID_SIZE);
        const gy = Math.floor((mouseY - startY) / GRID_SIZE);

        if (selectedPartType === 'core') {
            for(let y=0; y<GRID_H; y++) 
                for(let x=0; x<GRID_W; x++) 
                    if(buildGrid[y][x] === 'core') buildGrid[y][x] = null;
            buildGrid[gy][gx] = 'core';
        } else {
            if (buildGrid[gy][gx] !== 'core') {
                buildGrid[gy][gx] = (selectedPartType === 'delete') ? null : selectedPartType;
            }
        }
    }
}

// --- ì»¤ìŠ¤í…€ ë“œë¡œì‰ ---
function drawCustomLayer() {
    const ctx = render.context;
    
    if (currentMode === 'build') {
        drawGrid(ctx);
    } else {
        drawSimulation3D(ctx);
        drawTrainingElements(ctx); // ëª©í‘œì§€ì , ì¥ì• ë¬¼ ë“± ê·¸ë¦¬ê¸°
    }
}

function drawGrid(ctx) {
    const canvasCx = render.canvas.width / 2;
    const canvasCy = render.canvas.height / 2;
    const startX = canvasCx - (GRID_W * GRID_SIZE) / 2;
    const startY = canvasCy - (GRID_H * GRID_SIZE) / 2;

    ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; 
    ctx.fillRect(0, 0, render.canvas.width, render.canvas.height);

    ctx.fillStyle = '#1e293b'; 
    ctx.fillRect(startX, startY, GRID_W * GRID_SIZE, GRID_H * GRID_SIZE);

    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    
    for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
            const px = startX + x * GRID_SIZE;
            const py = startY + y * GRID_SIZE;
            ctx.strokeRect(px, py, GRID_SIZE, GRID_SIZE);

            const type = buildGrid[y][x];
            if (type) {
                const cx = px + GRID_SIZE/2;
                const cy = py + GRID_SIZE/2;
                if (type === 'core') {
                    ctx.fillStyle = '#ecc94b'; ctx.fillRect(px+2, py+2, GRID_SIZE-4, GRID_SIZE-4);
                    ctx.fillStyle = '#744210'; ctx.font = 'bold 9px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('FC', cx, cy+3);
                } else if (type === 'body') {
                    ctx.fillStyle = '#48bb78'; ctx.fillRect(px+2, py+2, GRID_SIZE-4, GRID_SIZE-4);
                } else if (type === 'frame') {
                    ctx.fillStyle = '#4a5568'; ctx.fillRect(px+4, py+4, GRID_SIZE-8, GRID_SIZE-8);
                    ctx.fillStyle = '#2d3748'; ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI*2); ctx.fill();
                } else if (type === 'motor') {
                    ctx.fillStyle = '#3182ce'; ctx.beginPath(); ctx.arc(cx, cy, GRID_SIZE/2 - 2, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px+GRID_SIZE, py+GRID_SIZE); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(px+GRID_SIZE, py); ctx.lineTo(px, py+GRID_SIZE); ctx.stroke();
                }
            }
        }
    }
    ctx.fillStyle = '#94a3b8'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText("Top View (ìœ„ì—ì„œ ë³¸ ì„¤ê³„ë„)", canvasCx, startY - 20);
}

function drawTrainingElements(ctx) {
    // ëª©í‘œ ì§€ì  í‘œì‹œ (ê¹ƒë°œ)
    if (trainingGoal === 'move' || trainingGoal === 'obstacle') {
        const tx = targetPoint.x;
        const ty = targetPoint.y;
        
        ctx.save();
        ctx.translate(tx, ty);
        
        // ê¹ƒëŒ€
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 50); ctx.stroke();
        
        // ê¹ƒë°œ
        ctx.fillStyle = '#10b981'; // Green
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(30, 10); ctx.lineTo(0, 20); ctx.fill();
        
        // íƒ€ê²Ÿ ì›
        ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText("GOAL", 0, 65);
        
        ctx.restore();
    }
    
    // í˜¸ë²„ë§ íƒ€ê²Ÿ í‘œì‹œ (ê°€ìƒì˜ ë†’ì´ ë¼ì¸)
    if (trainingGoal === 'hover') {
        const h = window.innerHeight - 400; // íƒ€ê²Ÿ ë†’ì´
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, h);
        ctx.lineTo(window.innerWidth, h);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = 'rgba(56, 189, 248, 0.5)';
        ctx.font = '12px sans-serif';
        ctx.fillText("í˜¸ë²„ë§ ëª©í‘œ ê³ ë„", window.innerWidth/2, h - 5);
    }

    // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸° (Matter bodyëŠ” íˆ¬ëª…í•˜ë¯€ë¡œ ì§ì ‘ ê·¸ë¦¼)
    obstacles.forEach(obs => {
        const pos = obs.position;
        // 3D íë¸Œ ëŠë‚Œìœ¼ë¡œ
        drawCube(ctx, 40, '#f87171', '#dc2626', '#991b1b', pos.x, pos.y);
    });
}

function drawSimulation3D(ctx) {
    ctx.clearRect(0, 0, render.canvas.width, render.canvas.height);
    
    const grad = ctx.createLinearGradient(0, 0, 0, render.canvas.height);
    grad.addColorStop(0, '#0f172a'); grad.addColorStop(1, '#1e293b');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, render.canvas.width, render.canvas.height);
    
    const horizonY = render.canvas.height - 50;
    ctx.fillStyle = '#334155'; ctx.fillRect(0, horizonY, render.canvas.width, 50);

    population.forEach(drone => {
        if (!drone.alive) return;
        drawDrone3D(ctx, drone);
    });
}

function drawDrone3D(ctx, drone) {
    const cx = drone.body.position.x;
    const cy = drone.body.position.y;
    const angle = drone.body.angle; 

    let drawItems = [];
    drone.partsData.forEach(p => {
        const relGridX = p.x - drone.coreGridPos.x;
        const relGridZ = p.y - drone.coreGridPos.y; 

        const depthFactor = 0.5; 
        const zScale = 1 + relGridZ * 0.05; 
        
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        const physX = relGridX * GRID_SIZE;
        const physY = 0; 

        const rotX = physX * cos - physY * sin;
        const rotY = physX * sin + physY * cos;

        const isoOffsetX = relGridZ * GRID_SIZE * 0.4; 
        const isoOffsetY = relGridZ * GRID_SIZE * 0.2; 

        const screenX = cx + rotX + isoOffsetX;
        const screenY = cy + rotY + isoOffsetY;
        const sortZ = relGridZ; 

        drawItems.push({
            type: p.type,
            x: screenX,
            y: screenY,
            z: sortZ,
            scale: zScale,
            angle: angle,
            motorIdx: (p.type === 'motor') ? drone.motorMap.get(`${p.x},${p.y}`) : -1
        });
    });

    drawItems.sort((a, b) => a.z - b.z);

    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.ellipse(cx, cy + 100, 40, 10, 0, 0, Math.PI*2);
    ctx.fill();

    drawItems.forEach(item => {
        const s = item.scale;
        const size = GRID_SIZE * s;
        
        ctx.save();
        ctx.translate(item.x, item.y);
        ctx.rotate(item.angle); 

        if (item.type === 'core') {
            drawCube(ctx, size, '#ecc94b', '#d69e2e', '#744210');
            ctx.fillStyle = '#744210'; ctx.font = `bold ${10*s}px sans-serif`; ctx.textAlign = 'center'; ctx.fillText('FC', 0, -size/2);
        } else if (item.type === 'body') {
            drawCube(ctx, size, '#48bb78', '#2f855a', '#22543d');
        } else if (item.type === 'frame') {
            ctx.fillStyle = '#475569'; ctx.fillRect(-size/2, -size/8, size, size/4);
        } else if (item.type === 'motor') {
            ctx.fillStyle = '#3182ce'; ctx.beginPath(); ctx.ellipse(0, 0, size/2, size/4, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c5282'; ctx.fillRect(-size/2, 0, size, size/2);
            const power = drone.motorPowers[item.motorIdx] || 0;
            drawPropeller(ctx, size, power);
        }
        ctx.restore();
    });
}

function drawCube(ctx, size, topColor, sideColor, frontColor, customX=0, customY=0) {
    const h = size * 0.6; 
    const w = size;
    
    // x, y íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ í˜„ì¬ ì»¨í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì‚¬ìš© (translateë¨)
    // ìˆìœ¼ë©´ í•´ë‹¹ ìœ„ì¹˜ì— ê·¸ë¦¼
    const isCustom = (customX !== 0 || customY !== 0);
    const baseX = isCustom ? customX : 0;
    const baseY = isCustom ? customY : 0;

    // ìœ—ë©´
    ctx.fillStyle = topColor;
    ctx.beginPath();
    ctx.moveTo(baseX, baseY - h/2);
    ctx.lineTo(baseX + w/2, baseY);
    ctx.lineTo(baseX, baseY + h/2);
    ctx.lineTo(baseX - w/2, baseY);
    ctx.fill();
    
    // ì˜†ë©´
    ctx.fillStyle = sideColor;
    ctx.beginPath();
    ctx.moveTo(baseX - w/2, baseY);
    ctx.lineTo(baseX, baseY + h/2);
    ctx.lineTo(baseX, baseY + h);
    ctx.lineTo(baseX - w/2, baseY + h/2);
    ctx.fill();
    
    // ì•ë©´
    ctx.fillStyle = frontColor;
    ctx.beginPath();
    ctx.moveTo(baseX, baseY + h/2);
    ctx.lineTo(baseX + w/2, baseY);
    ctx.lineTo(baseX + w/2, baseY + h/2);
    ctx.lineTo(baseX, baseY + h);
    ctx.fill();
}

function drawPropeller(ctx, size, power) {
    if (power < 0.01) {
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(-size, 0); ctx.lineTo(size, 0); ctx.stroke();
        return;
    }
    const alpha = 0.2 + power * 0.5;
    ctx.fillStyle = `rgba(200, 240, 255, ${alpha})`;
    ctx.beginPath(); ctx.ellipse(0, -size/2, size*1.2, size*0.3, 0, 0, Math.PI*2); ctx.fill();
    
    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; ctx.lineWidth = 1;
    if (Math.random() > 0.5) { ctx.beginPath(); ctx.moveTo(-size, -size/2); ctx.lineTo(size, -size/2); ctx.stroke(); }
    
    if (power > 0.2) {
        ctx.strokeStyle = `rgba(100, 200, 255, ${power * 0.3})`;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, size * 2 * power); ctx.stroke();
    }
}

// --- ì‹ ê²½ë§ (Brain) ---
class NeuralNetwork {
    constructor(inputCount, outputCount) {
        this.inputCount = inputCount;
        this.outputCount = outputCount;
        this.hiddenCount = 10; // ì¡°ê¸ˆ ë” ë³µì¡í•œ íŒë‹¨ì„ ìœ„í•´ ë‰´ëŸ° ì¦ê°€
        
        this.w1 = Array(inputCount * this.hiddenCount).fill(0).map(() => Math.random() * 2 - 1);
        this.b1 = Array(this.hiddenCount).fill(0).map(() => Math.random() * 2 - 1);
        this.w2 = Array(this.hiddenCount * outputCount).fill(0).map(() => Math.random() * 2 - 1);
        this.b2 = Array(outputCount).fill(0).map(() => Math.random() * 2 - 1);
    }

    predict(inputs) {
        let hidden = [];
        for(let i=0; i<this.hiddenCount; i++) {
            let sum = 0;
            for(let j=0; j<this.inputCount; j++) sum += inputs[j] * this.w1[j*this.hiddenCount + i];
            hidden[i] = Math.tanh(sum + this.b1[i]);
        }
        let outputs = [];
        for(let i=0; i<this.outputCount; i++) {
            let sum = 0;
            for(let j=0; j<this.hiddenCount; j++) sum += hidden[j] * this.w2[j*this.outputCount + i];
            outputs[i] = 1 / (1 + Math.exp(-(sum + this.b2[i]))); 
        }
        return outputs;
    }

    clone() {
        const c = new NeuralNetwork(this.inputCount, this.outputCount);
        c.w1 = [...this.w1]; c.b1 = [...this.b1];
        c.w2 = [...this.w2]; c.b2 = [...this.b2];
        return c;
    }

    mutate(rate) {
        const mutateVal = v => Math.random() < rate ? v + (Math.random() * 0.5 - 0.25) : v;
        this.w1 = this.w1.map(mutateVal);
        this.b1 = this.b1.map(mutateVal);
        this.w2 = this.w2.map(mutateVal);
        this.b2 = this.b2.map(mutateVal);
    }
}

// --- ë“œë¡  í´ë˜ìŠ¤ ---
class Drone {
    constructor(startX, startY, partsData, brain) {
        this.alive = true;
        this.fitness = 0;
        this.lifeTime = 0;
        this.partsData = partsData; 
        
        let coreX = 0, coreY = 0;
        partsData.forEach(p => { if(p.type==='core') { coreX=p.x; coreY=p.y; }});
        this.coreGridPos = { x: coreX, y: coreY }; 

        const bodyParts = [];
        this.motors = []; 
        this.motorMap = new Map(); 

        let motorIndex = 0;
        partsData.forEach(p => {
            const relX = (p.x - coreX) * GRID_SIZE;
            const physRelX = relX;
            const physRelY = 0; 

            let part;
            const commonOpt = { friction: 0.5, restitution: 0.2 };

            if(p.type === 'core') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, { ...commonOpt, density: 0.005, render: { visible: false } });
            } else if (p.type === 'body') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, { ...commonOpt, density: 0.002, render: { visible: false } });
            } else if (p.type === 'frame') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/4, { ...commonOpt, density: 0.001, render: { visible: false } });
            } else if (p.type === 'motor') {
                part = Bodies.rectangle(startX + physRelX, startY + physRelY, GRID_SIZE, GRID_SIZE/2, { ...commonOpt, density: 0.003, render: { visible: false } });
                this.motors.push({ relativePos: {x: physRelX, y: physRelY}, gridPos: {x: p.x, y: p.y} });
                this.motorMap.set(`${p.x},${p.y}`, motorIndex++);
            }
            if(part) bodyParts.push(part);
        });

        this.body = Body.create({ parts: bodyParts, frictionAir: 0.05 }); 
        this.body.collisionFilter.group = -1; 

        // ë‡Œ ì„¤ì • (ì…ë ¥ê°’ì€ ëª©í‘œì— ë”°ë¼ ë‹¬ë¼ì§)
        // ì…ë ¥: 6ê°œ (ê¸°ë³¸), ì¶œë ¥: ëª¨í„° ìˆ˜
        const motorCount = this.motors.length;
        this.motorPowers = new Array(motorCount).fill(0);
        
        if(brain) {
            this.brain = brain.clone();
            this.brain.mutate(MUTATION_RATE);
        } else {
            // ì…ë ¥ ë…¸ë“œ 7ê°œ: Angle, AngVel, Vx, Vy, DistY, DistX, Bias
            this.brain = new NeuralNetwork(7, Math.max(motorCount, 4)); 
        }

        Composite.add(engine.world, this.body);
    }

    update() {
        if(!this.alive) return;
        this.lifeTime++;

        const angle = this.body.angle; 
        const angVel = this.body.angularVelocity;
        const vel = this.body.velocity;
        const currentH = window.innerHeight - this.body.position.y;
        
        // ëª©í‘œ ì„¤ì •
        let targetH = 400; // í˜¸ë²„ë§ ë†’ì´
        let targetXDiff = 0;
        
        if (trainingGoal === 'hover') {
            // í˜¸ë²„ë§: ì¤‘ì•™(X=0) ìœ ì§€, íƒ€ê²Ÿ ë†’ì´ ìœ ì§€
            targetXDiff = (this.body.position.x - window.innerWidth/2) / 500;
        } else {
            // ì´ë™/ì¥ì• ë¬¼: íƒ€ê²Ÿ í¬ì¸íŠ¸ë¡œ ì´ë™
            targetXDiff = (this.body.position.x - targetPoint.x) / 1000;
            // ì´ë™ ëª¨ë“œì¼ë• ëª©í‘œ ë†’ì´ë¥¼ íƒ€ê²Ÿ Yì™€ ë§ì¶¤
            targetH = window.innerHeight - targetPoint.y;
        }

        // ì‹ ê²½ë§ ì…ë ¥ (ì •ê·œí™” ì¤‘ìš”)
        const inputs = [
            angle / Math.PI,        // 1. ê¸°ìš¸ê¸°
            angVel * 5,             // 2. íšŒì „ ì†ë„
            vel.x / 10,             // 3. ìˆ˜í‰ ì†ë„
            vel.y / 10,             // 4. ìˆ˜ì§ ì†ë„
            (currentH - targetH) / 500, // 5. ë†’ì´ ì°¨ì´
            targetXDiff,            // 6. ìˆ˜í‰ ê±°ë¦¬ ì°¨ì´
            1.0                     // 7. Bias
        ];

        const outputs = this.brain.predict(inputs);

        this.motors.forEach((motor, i) => {
            let power = outputs[i % outputs.length]; 
            this.motorPowers[i] = power;

            if (power > 0) {
                const thrust = 0.0035 * power * (1 + this.body.mass * 0.5); 
                const forceVector = Vector.rotate({ x: 0, y: -thrust }, this.body.angle);
                const motorWorldPos = Vector.add(this.body.position, Vector.rotate(motor.relativePos, this.body.angle));
                Body.applyForce(this.body, motorWorldPos, forceVector);
            }
        });

        // --- í”¼íŠ¸ë‹ˆìŠ¤ (ì ìˆ˜) ê³„ì‚° ---
        // ëª¨ë“œì— ë”°ë¼ ì ìˆ˜ ì£¼ëŠ” ë°©ì‹ì´ ë‹¤ë¦„
        
        if (trainingGoal === 'hover') {
            // 1. ì œìë¦¬ í˜¸ë²„ë§ ëª©í‘œ
            const distToTargetH = Math.abs(currentH - targetH);
            const isStable = Math.abs(angle) < 0.2;
            const isCenter = Math.abs(this.body.position.x - window.innerWidth/2) < 100;
            const isStill = Math.abs(vel.x) < 1 && Math.abs(vel.y) < 1;

            if (distToTargetH < 50) this.fitness += 3; // ë†’ì´ ìœ ì§€ ì ìˆ˜
            if (isStable) this.fitness += 1; // ìì„¸ ì•ˆì • ì ìˆ˜
            if (isCenter) this.fitness += 2; // ìœ„ì¹˜ ì‚¬ìˆ˜ ì ìˆ˜
            if (isStill && distToTargetH < 50) this.fitness += 5; // â˜… ì œìë¦¬ ì •ì§€ ë³´ë„ˆìŠ¤ (ê°€ì¥ ì¤‘ìš”)

            // ìˆ˜í‰ ì´ë™ì— ëŒ€í•œ í˜ë„í‹° (í˜¸ë²„ë§ ëª¨ë“œì´ë¯€ë¡œ)
            this.fitness -= Math.abs(vel.x) * 0.1;

        } else if (trainingGoal === 'move' || trainingGoal === 'obstacle') {
            // 2. ì´ë™ ëª©í‘œ
            const distToGoal = Vector.magnitude(Vector.sub(this.body.position, targetPoint));
            const startDist = Vector.magnitude(Vector.sub({x: window.innerWidth/2, y: window.innerHeight-200}, targetPoint));
            
            // ëª©í‘œì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ ì ìˆ˜
            this.fitness += (startDist - distToGoal) * 0.01;
            
            // ëª©í‘œ ì§€ì  ê·¼ì²˜ ë„ë‹¬ ì‹œ ëŒ€ë°• ì ìˆ˜
            if (distToGoal < 100) this.fitness += 50;
            
            // ë„ˆë¬´ ëŠ¦ê²Œ ê°€ë©´ ê°ì  (ë¹¨ë¦¬ ê°€ë„ë¡ ìœ ë„)
            this.fitness -= 0.1;
        }

        // ê³µí†µ ì‚¬ë§ ì¡°ê±´
        if (this.body.position.y > window.innerHeight + 100 || 
            this.body.position.y < -500 || 
            Math.abs(angle) > Math.PI / 1.5 
           ) {
            this.kill();
        }

        // í™”ë©´ ë°–ìœ¼ë¡œ ë„ˆë¬´ ë©€ë¦¬ ë‚˜ê°€ë©´ ì‚¬ë§
        if (this.body.position.x < -200 || this.body.position.x > window.innerWidth + 200) {
            this.kill();
        }
    }
    
    kill() {
        this.alive = false;
        Composite.remove(engine.world, this.body);
    }
}

// --- ì‹œë®¬ë ˆì´ì…˜ ê´€ë¦¬ ---
function setMode(mode) {
    currentMode = mode;
    const ui = document.getElementById('builder-panel');
    const btnBuild = document.getElementById('btn-build');
    const btnSim = document.getElementById('btn-sim');
    const status = document.getElementById('status-text');

    if(mode === 'build') {
        ui.classList.remove('translate-y-full');
        btnBuild.classList.add('hidden');
        btnSim.classList.remove('hidden');
        status.innerText = "ì„¤ê³„ ì¤‘";
        
        if(runner) Runner.stop(runner);
        Composite.clear(engine.world);
        // ë°”ë‹¥ ì¬ìƒì„±
        const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 200, window.innerWidth * 10, 500, { isStatic: true, render: { fillStyle: '#1e293b' } });
        Composite.add(engine.world, ground);
        
        obstacles = [];
        population = [];
        generation = 1;
        bestGenome = null;
        updateStats();

    } else {
        ui.classList.add('translate-y-full');
        btnBuild.classList.remove('hidden');
        btnSim.classList.add('hidden');
        status.innerText = "AI í•™ìŠµ ë¹„í–‰ ì¤‘";
    }
}

function startSimulation() {
    const parts = [];
    let hasCore = false;
    let motorCount = 0;
    
    for(let y=0; y<GRID_H; y++) {
        for(let x=0; x<GRID_W; x++) {
            if(buildGrid[y][x]) {
                parts.push({x, y, type: buildGrid[y][x]});
                if(buildGrid[y][x] === 'core') hasCore = true;
                if(buildGrid[y][x] === 'motor') motorCount++;
            }
        }
    }

    if (!hasCore) { alert("ë“œë¡ ì—ëŠ” FC(ë…¸ë€ìƒ‰ ì½”ì–´)ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤!"); return; }
    if (motorCount < 2) { alert("ìµœì†Œ 2ê°œ ì´ìƒì˜ ëª¨í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤!"); return; }

    setMode('sim');
    
    // ëª©í‘œ ì§€ì  ì„¤ì • (í™”ë©´ ì˜¤ë¥¸ìª½ ìƒë‹¨)
    targetPoint = { x: window.innerWidth * 0.8, y: window.innerHeight * 0.3 };

    // ì¥ì• ë¬¼ ìƒì„± (ëª¨ë“œì— ë”°ë¼)
    obstacles = [];
    Composite.clear(engine.world); // ê¸°ì¡´ ë¬¼ì²´ ì œê±°
    // ë°”ë‹¥ ë‹¤ì‹œ ì¶”ê°€
    const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 200, window.innerWidth * 10, 500, { isStatic: true, render: { fillStyle: '#1e293b' } });
    Composite.add(engine.world, ground);

    if (trainingGoal === 'obstacle') {
        // ì¤‘ê°„ì— ë²½ ìƒì„±
        const wallX = window.innerWidth * 0.5;
        const wallY = window.innerHeight * 0.5;
        const wall = Bodies.rectangle(wallX, wallY, 40, 200, { isStatic: true, render: { fillStyle: '#dc2626' } });
        obstacles.push(wall);
        Composite.add(engine.world, wall);
    }

    runner = Runner.create();
    Runner.run(runner, engine);
    spawnGeneration(parts);
    gameLoop();
}

function spawnGeneration(parts) {
    population = [];
    const startX = window.innerWidth * 0.2; // ì™¼ìª½ì—ì„œ ì‹œì‘
    const startY = window.innerHeight - 200;

    // í˜¸ë²„ë§ ëª¨ë“œë©´ ì¤‘ì•™ì—ì„œ ì‹œì‘
    const spawnX = (trainingGoal === 'hover') ? window.innerWidth / 2 : startX;

    for(let i=0; i<POPULATION_SIZE; i++) {
        let brain = null;
        if(bestGenome && i > 0) {
            brain = bestGenome; 
        } else if(bestGenome && i === 0) {
             brain = bestGenome.clone();
             brain.mutate(0); 
        }
        population.push(new Drone(spawnX, startY, parts, brain));
    }
    updateStats();
}

function gameLoop() {
    if(currentMode !== 'sim') return;

    let aliveCount = 0;
    let maxFit = -Infinity;

    population.forEach(drone => {
        if(drone.alive) {
            drone.update();
            aliveCount++;
            if(drone.fitness > maxFit) maxFit = drone.fitness;
        }
    });

    const bestScoreEl = document.getElementById('best-score');
    if(maxFit > -Infinity && maxFit > parseInt(bestScoreEl.innerText)) bestScoreEl.innerText = Math.floor(maxFit);
    document.getElementById('alive-count').innerText = aliveCount;

    if(aliveCount === 0) {
        evolve();
        generation++;
        updateStats();
        // íŒŒì¸  ë°ì´í„°ê°€ ë³´ì¡´ë˜ì–´ ìˆë‹¤ê³  ê°€ì • (ì²«ë²ˆì§¸ ë“œë¡ ê±° ì”€)
        // ì‹¤ì œë¡œëŠ” ì „ì—­ë³€ìˆ˜ì— ì €ì¥í•˜ëŠ”ê²Œ ì•ˆì „í•¨
        const parts = population[0].partsData; 
        spawnGeneration(parts);
    }
    
    requestAnimationFrame(gameLoop);
}

function evolve() {
    let best = population[0];
    population.forEach(p => { if(p.fitness > best.fitness) best = p; });
    bestGenome = best.brain;
}

function updateStats() {
    document.getElementById('gen-count').innerText = generation;
    document.getElementById('alive-count').innerText = population.length;
}

document.addEventListener('mousedown', handleGridClick);

init();
</script>
</body>
</html>
