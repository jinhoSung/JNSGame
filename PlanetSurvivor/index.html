<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planet Survivor: Targeting Fix</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #0d1117; color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; touch-action: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 15px; left: 15px; pointer-events: none;
            width: 240px; max-width: 50%; z-index: 10;
        }
        
        #boss-hud {
            display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 60%; max-width: 600px; height: 30px; z-index: 20; pointer-events: none;
        }
        #boss-hud.active { display: block; animation: slideDown 0.5s ease-out; }
        .boss-name { text-align: center; font-weight: bold; color: #ef4444; text-shadow: 0 0 5px black; margin-bottom: 5px; font-size: 18px; }
        .boss-bar-bg { width: 100%; height: 100%; background: #333; border: 2px solid #555; border-radius: 5px; overflow: hidden; position: relative; }
        #boss-hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ef4444, #b91c1c); transition: width 0.1s linear; }

        #warning-msg {
            display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ef4444; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red; z-index: 30; pointer-events: none;
            animation: blink 0.5s infinite alternate;
        }
        @keyframes slideDown { from { top: -50px; } to { top: 20px; } }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }

        .stat-box {
            background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px;
            border: 1px solid #444; margin-bottom: 6px; font-size: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .bar-container { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 4px; }
        #hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #xp-bar { width: 0%; height: 100%; background: #f1c40f; transition: width 0.2s; }

        #weapon-slots { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        .slot {
            width: 32px; height: 32px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px;
            display: flex; justify-content: center; align-items: center; font-size: 16px; position: relative;
        }
        .slot .level-badge {
            position: absolute; bottom: -2px; right: -2px; background: #333; font-size: 9px; padding: 1px 3px; border-radius: 3px; border: 1px solid #777;
        }

        #upgrade-menu {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto; padding: 20px; box-sizing: border-box;
        }
        #upgrade-menu.active { display: flex !important; }

        .cards-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 100%; max-height: 80vh; overflow-y: auto; }
        .card {
            background: linear-gradient(145deg, #1f2937, #111827); border: 2px solid #374151; width: 180px; padding: 15px;
            border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; position: relative; overflow: hidden; flex-shrink: 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .card:hover { transform: translateY(-5px); }
        .card h3 { margin: 8px 0; font-size: 15px; color: #fff; }
        .card p { font-size: 12px; color: #ccc; line-height: 1.4; }
        .card-icon { font-size: 36px; margin-bottom: 8px; display: block; }
        
        .card.common { border-color: #9ca3af; }
        .card.uncommon { border-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .card.rare { border-color: #3b82f6; box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .card.epic { border-color: #a855f7; box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); background: linear-gradient(145deg, #2e1065, #111827); }
        .card.legendary { 
            border-color: #eab308; box-shadow: 0 0 25px rgba(234, 179, 8, 0.6); 
            background: linear-gradient(145deg, #422006, #111827); animation: pulse-gold 2s infinite;
        }
        .card.special {
            border-color: #f43f5e; box-shadow: 0 0 25px rgba(244, 63, 94, 0.5);
            background: linear-gradient(145deg, #4c0519, #111827);
        }
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); }
            50% { box-shadow: 0 0 30px rgba(234, 179, 8, 0.8); }
            100% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); }
        }
        .card-tag {
            position: absolute; top: 8px; right: 8px; font-size: 9px; padding: 2px 5px; border-radius: 3px; background: #333; color: white; font-weight: bold;
        }
        .card.common .card-tag { background: #4b5563; }
        .card.uncommon .card-tag { background: #059669; }
        .card.rare .card-tag { background: #2563eb; }
        .card.epic .card-tag { background: #7c3aed; }
        .card.legendary .card-tag { background: #ca8a04; color: black; }
        .card.special .card-tag { background: #e11d48; }

        @media (max-width: 600px) {
            .cards-container { flex-direction: column; align-items: center; gap: 10px; }
            .card { width: 90%; max-width: 320px; display: flex; flex-direction: row; align-items: center; text-align: left; padding: 10px; min-height: 70px; }
            .card-icon { font-size: 28px !important; margin: 0 15px 0 0 !important; width: 40px; text-align: center; }
            .card h3 { margin: 0 0 4px 0 !important; font-size: 16px !important; }
            .card p { margin: 0 !important; }
            .card-tag { top: 50% !important; transform: translateY(-50%); right: 10px !important; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="stat-box">
        <div style="display:flex; justify-content:space-between;"><span>HP</span><span id="hp-text">100/100</span></div>
        <div class="bar-container"><div id="hp-bar"></div></div>
    </div>
    <div class="stat-box">
        <div style="display:flex; justify-content:space-between;"><span>EXP (Lv.<span id="level-text">1</span>)</span><span id="xp-text">0%</span></div>
        <div class="bar-container"><div id="xp-bar"></div></div>
    </div>
    <div class="stat-box" style="text-align: center;">
        <span style="font-size: 11px; color:#aaa;">SCORE</span><br>
        <span id="score-text" style="font-size: 16px; font-weight: bold;">0</span>
    </div>
    <div id="weapon-slots"></div>
</div>

<div id="boss-hud">
    <div class="boss-name">‚ö†Ô∏è GIANT PLANET EATER ‚ö†Ô∏è</div>
    <div class="boss-bar-bg">
        <div id="boss-hp-bar"></div>
    </div>
</div>
<div id="warning-msg">WARNING!<br><span style="font-size:30px">BOSS APPROACHING</span></div>

<div id="upgrade-menu">
    <h1 style="color:white; margin-bottom:10px; font-size: 24px;">LEVEL UP!</h1>
    <div class="cards-container" id="cards-area"></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const cardsArea = document.getElementById('cards-area');
    const weaponSlotsContainer = document.getElementById('weapon-slots');
    
    const bossHud = document.getElementById('boss-hud');
    const bossHpBar = document.getElementById('boss-hp-bar');
    const warningMsg = document.getElementById('warning-msg');
    
    const ZOOM_SCALE = 0.7;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* ================= Îç∞Ïù¥ÌÑ∞ Î≤†Ïù¥Ïä§ ================= */

    const RARITY = {
        COMMON: { name: 'Common', color: 'common', mult: 1.0, chance: 50 },
        UNCOMMON: { name: 'Uncommon', color: 'uncommon', mult: 1.5, chance: 30 },
        RARE: { name: 'Rare', color: 'rare', mult: 2.0, chance: 15 },
        EPIC: { name: 'Epic', color: 'epic', mult: 3.0, chance: 4 },
        LEGENDARY: { name: 'Legendary', color: 'legendary', mult: 5.0, chance: 1 }
    };

    const WEAPON_DB = {
        'MISSILE': {
            name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', icon: 'üöÄ', type: 'HOMING',
            baseDamage: 30, baseCooldown: 45, color: '#f59e0b',
            range: 600, projectileCount: 1, explosive: false
        },
        'BLASTER': {
            name: 'Í¥ëÏÑ† Îπî', icon: 'üî´', type: 'BEAM',
            baseDamage: 120, baseCooldown: 200, color: '#10b981',
            range: 1000, thickness: 50, projectileCount: 1
        },
        'ORBITAL': {
            name: 'ÌîåÎùºÏ¶àÎßà Ïâ¥Îìú', icon: 'üõ°Ô∏è', type: 'ZONE',
            baseDamage: 8, baseCooldown: 0, color: '#8b5cf6',
            range: 170, hitRate: 12
        },
        'SNIPER': {
            name: 'Î†àÏùºÍ±¥', icon: '‚ö°', type: 'PIERCING',
            baseDamage: 60, baseCooldown: 100, color: '#3b82f6',
            range: 800, projectileCount: 1, rearShot: false
        },
        'MICRO_SWARM': {
            name: 'ÎßàÏù¥ÌÅ¨Î°ú ÎØ∏ÏÇ¨Ïùº', icon: 'üéÜ', type: 'SWARM',
            baseDamage: 12, baseCooldown: 45, color: '#22d3ee', 
            range: 500, projectileCount: 6, spread: 0.5 
        },
        'INTERCEPTOR': {
            name: 'ÏöîÍ≤© Ìé∏ÎåÄ', icon: 'üõ∏', type: 'UNIT',
            baseDamage: 18, baseCooldown: 30, color: '#e879f9', 
            range: 300, unitCount: 1
        },
        'TESLA': {
            name: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù', icon: 'üå©Ô∏è', type: 'CHAIN',
            baseDamage: 35, baseCooldown: 80, color: '#facc15', 
            range: 400, bounceCount: 3
        },
        'GRAVITY': {
            name: 'Ï§ëÎ†•Ïû• ÏÉùÏÑ±Í∏∞', icon: '‚ö´', type: 'SLOW_ZONE',
            baseDamage: 3, baseCooldown: 0, color: '#111827', 
            range: 250, slowFactor: 0.5
        }
    };

    const GAME_STATE = { PLAYING: 0, LEVEL_UP: 1, GAME_OVER: 2 };
    let currentState = GAME_STATE.PLAYING;
    let frame = 0; let score = 0;
    
    let projectiles=[], enemies=[], particles=[], beams=[], explosions=[], drones=[], lightnings=[];
    let boss = null; 

    const player = { level: 1, xp: 0, xpToNext: 150, weapons: [] };
    const core = { x: canvas.width/2, y: canvas.height/2, radius: 35, maxHp: 100, hp: 100, color: '#3b82f6' };

    /* ================= Î≥¥Ï°∞ ÌÅ¥ÎûòÏä§ ================= */

    class BeamEffect {
        constructor(x1, y1, x2, y2, color, thickness) {
            this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.color=color; this.thickness=thickness; 
            this.life=30; this.maxLife=30;
        }
        update(){this.life--;}
        draw(){
            const alpha = this.life/this.maxLife; ctx.save();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle=this.color; ctx.lineWidth=this.thickness*alpha; ctx.lineCap='round'; ctx.globalAlpha=alpha; ctx.shadowBlur=20*alpha; ctx.shadowColor=this.color; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle='white'; ctx.lineWidth=(this.thickness/3)*alpha; ctx.stroke();
            ctx.restore();
        }
    }

    class LightningEffect {
        constructor(x1, y1, x2, y2, color) {
            this.points = []; this.color = color; this.life = 15;
            const steps = 10; const dx = x2 - x1; const dy = y2 - y1;
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                let nx = x1 + dx*t; let ny = y1 + dy*t;
                if(i !== 0 && i !== steps) { nx += (Math.random()-0.5) * 30; ny += (Math.random()-0.5) * 30; }
                this.points.push({x:nx, y:ny});
            }
        }
        update() { this.life--; }
        draw() {
            ctx.save(); ctx.globalAlpha = this.life/15;
            ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
            for(let i=1; i<this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
            ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.stroke();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x, y, vx, vy, damage, color, isPiercing, isSmall=false) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.damage=damage; this.color=color; this.isPiercing=isPiercing; 
            this.radius=isSmall?2:(isPiercing?4:3); 
            this.life=isSmall?60:200; 
            this.hitList=[];
        }
        update(){this.x+=this.vx; this.y+=this.vy; this.life--;}
        draw(){ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();}
    }

    class Explosion {
        constructor(x,y,r,c){this.x=x;this.y=y;this.maxR=r;this.r=10;this.c=c;this.life=15;}
        update(){this.r+=(this.maxR-this.r)*0.2; this.life--;}
        draw(){ctx.globalAlpha=this.life/20; ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;}
    }

    class HomingMissile {
        constructor(x, y, target, damage, explosive) {
            this.x=x; this.y=y; this.target=target; this.damage=damage; this.explosive=explosive; 
            this.speed=4; this.angle=Math.random()*Math.PI*2; this.life=300;
            this.radius = 4; 
        }
        update() {
            if(!this.target || this.target.dead) this.target = this.findNewTarget(); 
            if(this.target && !this.target.dead) {
                const dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                const ta = Math.atan2(this.target.y-this.y, this.target.x-this.x);
                let d = ta - this.angle;
                while(d <= -Math.PI) d+=Math.PI*2; while(d > Math.PI) d-=Math.PI*2;
                
                let turnRate = 0.15;
                if (dist < 200) turnRate = 0.35;
                if (dist < 60) turnRate = 1.0; 

                this.angle += d * turnRate;
            }
            this.x+=Math.cos(this.angle)*this.speed; this.y+=Math.sin(this.angle)*this.speed; this.life--;
            if(Math.random()<0.5) particles.push(new Particle(this.x,this.y,'#555'));
        }
        
        // [ÏàòÏ†ï] Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº Ï†ÑÏö© ÌÉÄÍ≤üÌåÖ (Î≤îÏúÑ Ï†úÌïú ÏóÜÏùå)
        findNewTarget(){
            let n=null; let min=Infinity;
            // Î≥¥Ïä§ Ïö∞ÏÑ† (Í±∞Î¶¨ Î¨¥Í¥Ä)
            if(boss && !boss.dead) return boss;
            // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å
            enemies.forEach(e=>{ 
                if(!e.dead){ 
                    const d=Math.hypot(e.x-this.x,e.y-this.y); 
                    if(d<min){min=d; n=e;} 
                } 
            });
            return n;
        }
        draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle=this.explosive?'#ef4444':'#f59e0b'; ctx.beginPath(); ctx.moveTo(6,0); ctx.lineTo(-4,4); ctx.lineTo(-4,-4); ctx.fill(); ctx.restore(); }
        explode(){
            explosions.push(new Explosion(this.x,this.y,100,'#ef4444'));
            if(boss && !boss.dead && Math.hypot(boss.x-this.x,boss.y-this.y)<100+boss.radius) boss.takeDamage(this.damage);
            enemies.forEach(e=>{ if(!e.dead && Math.hypot(e.x-this.x,e.y-this.y)<100) e.takeDamage(this.damage); });
        }
    }

    class InterceptorUnit {
        constructor(weaponData) {
            this.data = weaponData;
            this.x = core.x; this.y = core.y;
            this.angle = Math.random()*Math.PI*2;
            this.speed = 3;
            this.target = null;
            this.cooldown = 0;
        }
        update() {
            if(!this.target || this.target.dead) {
                this.target = this.findTarget();
                if(!this.target) this.angle += 0.05;
            }
            if(this.target && !this.target.dead) {
                const desiredDist = 150;
                const dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                const angleToTarget = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                
                this.angle = angleToTarget;

                if(dist > desiredDist) {
                    this.x += Math.cos(angleToTarget) * this.speed;
                    this.y += Math.sin(angleToTarget) * this.speed;
                } else {
                    this.x -= Math.cos(angleToTarget) * (this.speed * 0.5);
                    this.y -= Math.sin(angleToTarget) * (this.speed * 0.5);
                }
                if(this.cooldown <= 0) {
                    projectiles.push(new Projectile(
                        this.x, this.y,
                        Math.cos(angleToTarget)*15, Math.sin(angleToTarget)*15,
                        this.data.baseDamage, this.data.color, false, false
                    ));
                    projectiles[projectiles.length-1].radius = 5; 
                    
                    this.cooldown = this.data.baseCooldown;
                }
            } else {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                if(Math.hypot(this.x - core.x, this.y - core.y) > 600) {
                    this.angle = Math.atan2(core.y - this.y, core.x - this.x);
                }
            }
            if(this.cooldown > 0) this.cooldown--;
        }
        
        // [ÏàòÏ†ï] Ïù∏ÌÑ∞ÏÖâÌÑ∞ ÌÉÄÍ≤üÌåÖ (Ïù∏ÌÑ∞ÏÖâÌÑ∞ Í∏∞Ï§Ä Í∞ÄÍπåÏö¥ Ï†Å)
        findTarget() {
            let n=null; let min=Infinity;
            // 1. Î≥¥Ïä§ Ïö∞ÏÑ† (Í±∞Î¶¨ Î¨¥Í¥Ä)
            if(boss && !boss.dead) return boss;
            // 2. Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å
            enemies.forEach(e=>{ 
                if(!e.dead){ 
                    const d=Math.hypot(e.x-this.x,e.y-this.y); 
                    if(d<min){min=d; n=e;} 
                } 
            });
            return n;
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); 
            ctx.rotate(this.angle); 
            ctx.fillStyle = this.data.color; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill();
            ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(-8, 0, 3, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }
    }

    class Enemy {
        constructor() {
             const vW = canvas.width/ZOOM_SCALE; const vH = canvas.height/ZOOM_SCALE;
             const m = 100; const cx = canvas.width/2; const cy = canvas.height/2;
             const side = Math.floor(Math.random()*4);
             if(side===0){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy-vH/2-m;}
             else if(side===1){this.x=cx+vW/2+m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);}
             else if(side===2){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy+vH/2+m;}
             else{this.x=cx-vW/2-m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);}
             
             this.hp=20+(player.level*8); this.maxHp=this.hp;
             this.baseSpeed=0.5+Math.random()*0.5+(player.level*0.05);
             this.speed = this.baseSpeed;
             this.radius=12; this.color=`hsl(${Math.random()*60},70%,50%)`;
             this.dead = false; this.slowed = false;
             
             this.spiralDir = Math.random() < 0.5 ? 1 : -1; 
        }
        update(){
            this.speed = this.baseSpeed;
            if (this.slowed) { this.speed *= 0.5; this.slowed = false; }
            
            const angleToCore = Math.atan2(core.y - this.y, core.x - this.x);
            const moveAngle = angleToCore + (this.spiralDir * 0.78);
            
            this.x += Math.cos(moveAngle) * this.speed; 
            this.y += Math.sin(moveAngle) * this.speed;
        }
        takeDamage(d){
            if(this.dead) return false;
            this.hp-=d; 
            if(this.hp<=0){ this.hp = 0; this.dead = true; this.die(); return true; } 
            return false;
        }
        die(){
            for(let i=0;i<5;i++)particles.push(new Particle(this.x,this.y,this.color)); 
            addXp(10 + player.level); 
            score+=10;
        }
        draw(){
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
            if(this.hp<this.maxHp){
                const hpWidth = 20 * (Math.max(0, this.hp)/this.maxHp);
                ctx.fillStyle='red';ctx.fillRect(this.x-10,this.y-18,20,3);
                ctx.fillStyle='#0f0';ctx.fillRect(this.x-10,this.y-18,hpWidth,3);
            }
        }
    }

    class Boss {
        constructor() {
             const vW = canvas.width/ZOOM_SCALE; const vH = canvas.height/ZOOM_SCALE;
             const m = 150; const cx = canvas.width/2; const cy = canvas.height/2;
             this.x = cx; this.y = cy - vH/2 - m;
             this.maxHp = 1000 + (player.level * 200);
             this.hp = this.maxHp;
             this.speed = 0.3; this.radius = 60; this.color = '#ef4444'; this.shake = 0;
             this.dead = false;
        }
        update() {
            const a=Math.atan2(core.y-this.y, core.x-this.x);
            this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed;
            bossHpBar.style.width = `${Math.max(0, (this.hp/this.maxHp)*100)}%`;
            if(this.shake>0) this.shake--;
        }
        takeDamage(d) {
            if(this.dead) return false;
            this.hp-=d; this.shake = 5;
            if(this.hp<=0){ this.hp = 0; this.dead = true; this.die(); return true; }
            return false;
        }
        die() {
            for(let i=0;i<50;i++) particles.push(new Particle(this.x+(Math.random()-0.5)*100, this.y+(Math.random()-0.5)*100, this.color));
            explosions.push(new Explosion(this.x, this.y, 300, '#fff'));
            addXp(500); score += 1000;
            boss = null; bossHud.classList.remove('active');
            canvas.style.transform=`translate(${Math.random()*20-10}px, ${Math.random()*20-10}px)`;
            setTimeout(()=>canvas.style.transform='translate(0,0)', 200);
        }
        draw() {
            const shakeX = (Math.random()-0.5)*this.shake;
            const shakeY = (Math.random()-0.5)*this.shake;
            ctx.save(); ctx.translate(this.x + shakeX, this.y + shakeY);
            ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.fillStyle='rgba(239, 68, 68, 0.2)'; ctx.fill();
            ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
            ctx.strokeStyle='#7f1d1d'; ctx.lineWidth=5; ctx.stroke();
            ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(-20, -10, 8, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(20, -10, 8, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-30, 20); ctx.quadraticCurveTo(0, 50, 30, 20); ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.stroke();
            ctx.restore();
        }
    }

    class Particle {
        constructor(x,y,c){this.x=x;this.y=y;this.c=c;this.vx=(Math.random()-0.5)*4;this.vy=(Math.random()-0.5)*4;this.life=1;}
        update(){this.x+=this.vx;this.y+=this.vy;this.life-=0.05;}
        draw(){ctx.globalAlpha=this.life;ctx.fillStyle=this.c;ctx.beginPath();ctx.arc(this.x,this.y,2,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;}
    }

    /* ================= Î©îÏù∏ Weapon ÌÅ¥ÎûòÏä§ ================= */

    class Weapon {
        constructor(id) {
            this.id = id; this.level = 1; this.upgradeCount = 0; 
            this.baseData = JSON.parse(JSON.stringify(WEAPON_DB[id]));
            this.currentData = JSON.parse(JSON.stringify(WEAPON_DB[id]));
            this.cooldownTimer = 0;
            this.angle = Math.random() * Math.PI * 2;
            this.orbitRadius = 55 + (Math.random() * 10);
            this.orbitSpeed = 0.02 + (Math.random() * 0.02);
            this.tickTimer = 0;
            if(this.id === 'INTERCEPTOR') { this.units = []; this.spawnUnits(); }
        }

        spawnUnits() {
            const count = this.currentData.unitCount || 1;
            while(this.units.length < count) {
                const u = new InterceptorUnit(this.currentData);
                this.units.push(u); drones.push(u);
            }
        }

        applyGeneralUpgrade(rarityMult, type) {
            this.level++; this.upgradeCount++; 
            const boostPercent = 0.10 * rarityMult; 
            if (type === 'DAMAGE') this.currentData.baseDamage = Math.floor(this.currentData.baseDamage * (1 + boostPercent));
            else if (type === 'COOLDOWN') this.currentData.baseCooldown = Math.max(5, Math.floor(this.currentData.baseCooldown * (1 - (boostPercent * 0.8)))); 
            else if (type === 'RANGE') {
                if(this.currentData.range) this.currentData.range = Math.floor(this.currentData.range * (1 + boostPercent));
                if(this.currentData.thickness) this.currentData.thickness = Math.floor(this.currentData.thickness * (1 + boostPercent));
            }
        }

        applySpecialUpgrade() {
            this.level++;
            if (this.currentData.projectileCount !== undefined) this.currentData.projectileCount++;
            if (this.currentData.unitCount !== undefined) { this.currentData.unitCount++; this.spawnUnits(); }

            if (this.id === 'MISSILE') this.currentData.explosive = true;
            if (this.id === 'SNIPER') this.currentData.rearShot = true;
            if (this.id === 'BLASTER') { this.currentData.baseDamage = Math.floor(this.currentData.baseDamage * 2.5); this.currentData.thickness += 60; }
            if (this.id === 'ORBITAL') this.currentData.hitRate = Math.max(2, Math.floor(this.currentData.hitRate * 0.6));
            if (this.id === 'MICRO_SWARM') this.currentData.projectileCount += 4; 
            if (this.id === 'INTERCEPTOR') { this.currentData.unitCount++; this.spawnUnits(); } 
            if (this.id === 'TESLA') this.currentData.bounceCount += 2; 
            if (this.id === 'GRAVITY') this.currentData.range += 50; 
        }

        update() {
            this.angle += this.orbitSpeed;
            if (this.cooldownTimer > 0) this.cooldownTimer--;

            if (this.currentData.type === 'ZONE' || this.currentData.type === 'SLOW_ZONE') {
                this.updateZone();
            } else if (this.currentData.type === 'UNIT') {
                // units update handled in global loop
            } else if (this.cooldownTimer <= 0) {
                this.fire();
            }
        }

        draw() {
            if(this.currentData.type === 'UNIT') return;

            const wx = core.x + Math.cos(this.angle) * this.orbitRadius;
            const wy = core.y + Math.sin(this.angle) * this.orbitRadius;

            ctx.beginPath(); ctx.moveTo(core.x, core.y); ctx.lineTo(wx, wy);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.stroke();

            ctx.beginPath(); ctx.arc(wx, wy, 8, 0, Math.PI*2);
            ctx.fillStyle = this.currentData.color; ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();

            if (this.currentData.type === 'ZONE') {
                ctx.beginPath(); ctx.arc(core.x, core.y, this.currentData.range, 0, Math.PI*2);
                ctx.fillStyle = `rgba(139, 92, 246, 0.1)`; ctx.fill();
                ctx.strokeStyle = `rgba(139, 92, 246, 0.4)`; ctx.lineWidth = 2; ctx.stroke();
            }
            if (this.currentData.type === 'SLOW_ZONE') {
                ctx.beginPath(); ctx.arc(core.x, core.y, this.currentData.range, 0, Math.PI*2);
                ctx.fillStyle = `rgba(0, 0, 0, 0.3)`; ctx.fill(); 
                ctx.strokeStyle = `rgba(100, 100, 100, 0.5)`; ctx.lineWidth = 2; ctx.stroke();
                if(frame % 20 === 0) {
                    ctx.beginPath(); ctx.arc(core.x, core.y, this.currentData.range, 0, Math.PI*2);
                    ctx.strokeStyle = '#fff'; ctx.globalAlpha=0.1; ctx.stroke(); ctx.globalAlpha=1;
                }
            }
        }

        fire() {
            let target = null;
            const range = this.currentData.range;

            // [ÏàòÏ†ï] ÌÉÄÍ≤üÌåÖ Î°úÏßÅ: 1ÏàúÏúÑ Î≥¥Ïä§(ÏÇ¨Í±∞Î¶¨ ÎÇ¥), 2ÏàúÏúÑ Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å(ÏÇ¨Í±∞Î¶¨ ÎÇ¥)
            let bossInRange = false;
            if (boss && !boss.dead) {
                const distToBoss = Math.hypot(boss.x - core.x, boss.y - core.y);
                if (distToBoss <= range) {
                    target = boss;
                    bossInRange = true;
                }
            }

            if (!bossInRange) {
                let minDist = range;
                enemies.forEach(e => {
                    if (e.dead) return;
                    const dist = Math.hypot(e.x - core.x, e.y - core.y);
                    if (dist <= minDist) {
                        minDist = dist;
                        target = e;
                    }
                });
            }

            if (!target && this.currentData.type !== 'ZONE' && this.currentData.type !== 'SLOW_ZONE') return;

            const wx = core.x + Math.cos(this.angle) * this.orbitRadius;
            const wy = core.y + Math.sin(this.angle) * this.orbitRadius;
            const count = this.currentData.projectileCount || 1;
            const spread = this.currentData.spread || 0.2;

            for (let i = 0; i < count; i++) {
                let angleOffset = (count > 1) ? (i - (count - 1) / 2) * spread : 0;
                
                if (this.currentData.type === 'BEAM') {
                    const baseAngle = Math.atan2(target.y - wy, target.x - wx);
                    const finalAngle = baseAngle + angleOffset;
                    const range = 2000;
                    const endX = wx + Math.cos(finalAngle) * range;
                    const endY = wy + Math.sin(finalAngle) * range;
                    beams.push(new BeamEffect(wx, wy, endX, endY, this.currentData.color, this.currentData.thickness));
                    if(boss && !boss.dead) {
                        const dist = pointToLineDistance(boss.x, boss.y, wx, wy, endX, endY);
                        if (dist < (this.currentData.thickness/2) + boss.radius) boss.takeDamage(this.currentData.baseDamage);
                    }
                    enemies.forEach(e => {
                         if(e.dead) return;
                         if (e.x > core.x - 1000 && e.x < core.x + 1000) {
                            const dist = pointToLineDistance(e.x, e.y, wx, wy, endX, endY);
                            if (dist < (this.currentData.thickness/2) + e.radius) {
                                if (!e.takeDamage(this.currentData.baseDamage)) particles.push(new Particle(e.x, e.y, this.currentData.color));
                            }
                         }
                    });
                } 
                else if (this.currentData.type === 'HOMING') {
                    // Ïú†ÎèÑ ÎØ∏ÏÇ¨ÏùºÏùÄ ÌÉÄÍ≤üÎßå ÏßÄÏ†ïÌï¥Ï£ºÎ©¥ ÏïåÏïÑÏÑú Ï´ìÏïÑÍ∞ê (ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌÉÄÍ≤ü)
                    projectiles.push(new HomingMissile(wx, wy, target, this.currentData.baseDamage, this.currentData.explosive));
                }
                else if (this.currentData.type === 'SWARM') { 
                    const baseAngle = Math.atan2(target.y - wy, target.x - wx);
                    const finalAngle = baseAngle + (Math.random() - 0.5) * spread * 2; 
                    projectiles.push(new Projectile(wx, wy, Math.cos(finalAngle)*6, Math.sin(finalAngle)*6, this.currentData.baseDamage, this.currentData.color, false, true));
                }
                else if (this.currentData.type === 'CHAIN') { 
                    this.castLightning(target, this.currentData.baseDamage, this.currentData.bounceCount || 3);
                    break; 
                }
                else { 
                    const baseAngle = Math.atan2(target.y - wy, target.x - wx);
                    const finalAngle = baseAngle + angleOffset;
                    const projSpeed = (this.currentData.type === 'PIERCING') ? 25 : 8;
                    
                    projectiles.push(new Projectile(wx, wy, Math.cos(finalAngle)*projSpeed, Math.sin(finalAngle)*projSpeed, this.currentData.baseDamage, this.currentData.color, this.currentData.type==='PIERCING', this.currentData.explosive));
                    if(this.currentData.rearShot) {
                        projectiles.push(new Projectile(wx, wy, Math.cos(finalAngle+Math.PI)*projSpeed, Math.sin(finalAngle+Math.PI)*projSpeed, this.currentData.baseDamage, this.currentData.color, this.currentData.type==='PIERCING', this.currentData.explosive));
                    }
                }
            }
            this.cooldownTimer = this.currentData.baseCooldown;
        }

        castLightning(target, damage, bounces) {
            let current = target;
            let visited = [current]; 
            
            current.takeDamage(damage);
            lightnings.push(new LightningEffect(core.x, core.y, current.x, current.y, this.currentData.color));

            for(let i=0; i<bounces; i++) {
                let next = null;
                let minDist = 300; 
                
                enemies.forEach(e => {
                    if(e.dead || e === current || visited.includes(e)) return;
                    const d = Math.hypot(e.x - current.x, e.y - current.y);
                    if(d < minDist) { minDist = d; next = e; }
                });

                if(next) {
                    lightnings.push(new LightningEffect(current.x, current.y, next.x, next.y, this.currentData.color));
                    next.takeDamage(damage);
                    visited.push(next);
                    current = next;
                } else {
                    break;
                }
            }
        }

        updateZone() {
            this.tickTimer++;
            
            if(this.currentData.type === 'SLOW_ZONE') {
                if(boss && !boss.dead && Math.hypot(boss.x - core.x, boss.y - core.y) < this.currentData.range + boss.radius) {
                    if(this.tickTimer % 10 === 0) boss.takeDamage(this.currentData.baseDamage);
                }
                enemies.forEach(e => {
                    if(e.dead) return;
                    const dist = Math.hypot(e.x - core.x, e.y - core.y);
                    if (dist < this.currentData.range + e.radius) {
                        e.slowed = true; 
                        if(this.tickTimer % 10 === 0) {
                            e.takeDamage(this.currentData.baseDamage);
                            particles.push(new Particle(e.x, e.y, '#000'));
                        }
                    }
                });
                return;
            }

            if (this.tickTimer % (this.currentData.hitRate || 10) !== 0) return;
            if(boss && !boss.dead && Math.hypot(boss.x - core.x, boss.y - core.y) < this.currentData.range + boss.radius) {
                boss.takeDamage(this.currentData.baseDamage);
            }
            enemies.forEach(e => {
                if(e.dead) return;
                const dist = Math.hypot(e.x - core.x, e.y - core.y);
                if (dist < this.currentData.range + e.radius) {
                    e.takeDamage(this.currentData.baseDamage);
                    particles.push(new Particle(e.x, e.y, this.currentData.color));
                }
            });
        }
    }

    /* ================= Î°úÏßÅ Ìï®Ïàò ================= */

    addWeapon('MISSILE'); 

    function pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A=px-x1; const B=py-y1; const C=x2-x1; const D=y2-y1;
        const dot=A*C+B*D; const len=C*C+D*D;
        let param=-1; if(len!==0)param=dot/len;
        let xx,yy; if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;}
        const dx=px-xx; const dy=py-yy; return Math.sqrt(dx*dx+dy*dy);
    }

    function addWeapon(id) {
        if(player.weapons.length>=6)return;
        player.weapons.push(new Weapon(id)); renderWeaponSlots();
    }

    function addXp(amount) {
        player.xp+=amount; if(player.xp>=player.xpToNext) levelUp();
        updateUi();
    }
    
    function levelUp(){
        player.level++; player.xp=0; player.xpToNext=Math.floor(player.xpToNext*1.15);
        if (player.level % 5 === 0 && !boss) spawnBoss();
        currentState=GAME_STATE.LEVEL_UP; generateUpgradeCards(); upgradeMenu.classList.add('active');
    }

    function spawnBoss() {
        boss = new Boss();
        bossHud.classList.add('active');
        warningMsg.style.display = 'block';
        setTimeout(() => warningMsg.style.display = 'none', 3000);
    }

    function rollRarity() {
        const rand = Math.random() * 100;
        if (rand < 50) return RARITY.COMMON;
        if (rand < 80) return RARITY.UNCOMMON;
        if (rand < 95) return RARITY.RARE;
        if (rand < 99) return RARITY.EPIC;
        return RARITY.LEGENDARY;
    }

    function generateUpgradeCards() {
        cardsArea.innerHTML = '';
        const options = [];

        player.weapons.forEach((w, index) => {
            if ((w.level + 1) % 5 === 0) {
                options.push({ type: 'SPECIAL', weapon: w, index: index, desc: getSpecialDesc(w) });
            } else {
                const statType = Math.random() < 0.6 ? 'DAMAGE' : 'COOLDOWN'; 
                const rarity = rollRarity();
                options.push({ type: 'GENERAL', weapon: w, index: index, statType: statType, rarity: rarity });
            }
        });

        if (player.weapons.length < 6) {
            Object.keys(WEAPON_DB).forEach(id => {
                if(!player.weapons.some(w=>w.id===id)) options.push({type:'NEW', id:id});
            });
        }
        
        options.push({type:'HEAL'});
        options.sort(()=>Math.random()-0.5);
        const selected = options.slice(0, 3);
        selected.forEach(opt => createCard(opt));
    }

    function getSpecialDesc(weapon) {
        if(weapon.id==='BLASTER') return "Îç∞ÎØ∏ÏßÄ Í∑πÎåÄÌôî + Îπî ÎëêÍªò 2Î∞∞";
        if(weapon.id==='MISSILE') return "Ìè≠Î∞úÏÑ± ÌÉÑÎëê Ïû•Ï∞© (Í¥ëÏó≠ ÌîºÌï¥)";
        if(weapon.id==='SNIPER') return "Ï†ÑÌõÑÎ∞© ÎèôÏãú ÏÇ¨Í≤© ÏãúÏä§ÌÖú";
        if(weapon.id==='ORBITAL') return "ÌöåÏ†Ñ ÏÜçÎèÑ Î∞è ÌÉÄÍ≤© Ï£ºÍ∏∞ 2Î∞∞";
        if(weapon.id==='MICRO_SWARM') return "ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Ïàò ÎåÄÌè≠ Ï¶ùÍ∞Ä (Ìè≠Ïö∞)";
        if(weapon.id==='INTERCEPTOR') return "Ï†ÑÌà¨Í∏∞ 1Í∏∞ Ï∂îÍ∞Ä Î∞∞Ïπò";
        if(weapon.id==='TESLA') return "Ï†ÑÏù¥ ÌöüÏàò Ï¶ùÍ∞Ä (Í≥†Ï†ÑÏïï)";
        if(weapon.id==='GRAVITY') return "Ï§ëÎ†•Ïû• Î≤îÏúÑ 50% Ï¶ùÍ∞Ä";
        return "Î∞úÏÇ¨Ï≤¥ Í∞úÏàò +1 Ï¶ùÍ∞Ä";
    }

    function createCard(opt) {
        const card = document.createElement('div');
        card.className = 'card';
        
        let title, desc, icon, tagClass, tagName;

        if (opt.type === 'NEW') {
            const data = WEAPON_DB[opt.id];
            title = data.name; desc = data.desc; icon = data.icon;
            tagClass = 'uncommon'; tagName = 'NEW';
            card.classList.add('uncommon');
        } else if (opt.type === 'SPECIAL') {
            const w = opt.weapon;
            title = `${w.currentData.name} <span style="font-size:12px; color:#aaa">LV.${w.level} ‚û§ ${w.level+1}</span>`;
            desc = `<span style="color:#f43f5e; font-weight:bold;">üî• EVOLUTION üî•</span><br>${opt.desc}`;
            icon = w.currentData.icon;
            tagClass = 'special'; tagName = 'EVO';
            card.classList.add('special');
        } else if (opt.type === 'GENERAL') {
            const w = opt.weapon; const r = opt.rarity;
            title = `${w.currentData.name} <span style="font-size:12px; color:#aaa">LV.${w.level} ‚û§ ${w.level+1}</span>`;
            let statText = opt.statType === 'DAMAGE' ? 'Í≥µÍ≤©Î†•' : 'Ïø®ÌÉÄÏûÑÍ∞êÏÜå';
            let val = Math.floor(10 * r.mult);
            desc = `${statText} <span style="color:${getColor(r.name)}; font-weight:bold;">+${val}%</span>`;
            icon = w.currentData.icon;
            tagClass = r.color; tagName = r.name.toUpperCase();
            card.classList.add(r.color);
        } else {
            title = "Í∏¥Í∏â ÏàòÎ¶¨"; desc = "Ï≤¥Î†• 50% ÌöåÎ≥µ"; icon = "‚ù§Ô∏è";
            tagClass = 'common'; tagName = 'ITEM';
            card.classList.add('common');
        }
        function getColor(name) {
            if(name==='Legendary') return '#eab308'; if(name==='Epic') return '#a855f7';
            if(name==='Rare') return '#3b82f6'; if(name==='Uncommon') return '#10b981'; return '#9ca3af';
        }
        card.innerHTML = `<div class="card-tag">${tagName}</div><div class="card-icon">${icon}</div><h3>${title}</h3><p>${desc}</p>`;

        card.onclick = () => {
            if (opt.type === 'NEW') addWeapon(opt.id);
            else if (opt.type === 'SPECIAL') opt.weapon.applySpecialUpgrade();
            else if (opt.type === 'GENERAL') opt.weapon.applyGeneralUpgrade(opt.rarity.mult, opt.statType);
            else if (opt.type === 'HEAL') core.hp = Math.min(core.hp+50, core.maxHp);
            renderWeaponSlots(); updateUi();
            upgradeMenu.classList.remove('active'); currentState = GAME_STATE.PLAYING;
        };
        cardsArea.appendChild(card);
    }

    function renderWeaponSlots() {
        weaponSlotsContainer.innerHTML = '';
        for(let i=0; i<6; i++) {
            const slot = document.createElement('div'); slot.className = 'slot';
            if(player.weapons[i]) {
                const w = player.weapons[i];
                slot.innerHTML = `${w.currentData.icon}<div class="level-badge">${w.level}</div>`;
                slot.style.borderColor = w.currentData.color; slot.style.boxShadow = `0 0 5px ${w.currentData.color}`;
            } else slot.innerHTML='<span style="color:#333;font-size:12px">EMPTY</span>';
            weaponSlotsContainer.appendChild(slot);
        }
    }
    function updateUi() {
        document.getElementById('hp-text').innerText=`${Math.ceil(core.hp)}/${core.maxHp}`;
        document.getElementById('hp-bar').style.width=`${(core.hp/core.maxHp)*100}%`;
        document.getElementById('level-text').innerText=player.level;
        document.getElementById('xp-text').innerText=`${Math.floor((player.xp/player.xpToNext)*100)}%`;
        document.getElementById('xp-bar').style.width=`${(player.xp/player.xpToNext)*100}%`;
        document.getElementById('score-text').innerText=score;
    }

    function animate() {
        requestAnimationFrame(animate);
        if(currentState === GAME_STATE.LEVEL_UP) return;
        if(currentState === GAME_STATE.GAME_OVER) {
            ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='red'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center';
            ctx.fillText("MISSION FAILED",canvas.width/2,canvas.height/2);
            ctx.fillStyle='white'; ctx.font='20px sans-serif';
            ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+50); return;
        }

        ctx.fillStyle = 'rgba(13, 17, 23, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(ZOOM_SCALE, ZOOM_SCALE);
        ctx.translate(-canvas.width/2, -canvas.height/2);

        frame++;
        
        // [ÏàòÏ†ï] Ïä§Ìè∞ ÏÜçÎèÑ 2Î∞∞ Ï¶ùÍ∞Ä (ÏµúÏÜå 5ÌîÑÎ†àÏûÑ -> 2ÌîÑÎ†àÏûÑ)
        if (!boss) {
            const spawnRate = Math.max(5, 50 - (player.level * 3));
            if (frame % spawnRate === 0) enemies.push(new Enemy());
        }

        ctx.beginPath(); ctx.arc(core.x, core.y, core.radius, 0, Math.PI * 2);
        ctx.fillStyle = core.color; ctx.shadowBlur = 20; ctx.shadowColor = core.color;
        ctx.fill(); ctx.shadowBlur = 0;

        player.weapons.forEach(w => { w.update(); w.draw(); });
        drones.forEach(d => { d.update(); d.draw(); }); 

        if(boss && !boss.dead) { 
            boss.update(); boss.draw(); 
            if(Math.hypot(boss.x-core.x,boss.y-core.y) < core.radius+boss.radius) { 
                core.hp-=0.5; updateUi(); if(core.hp<=0) currentState=GAME_STATE.GAME_OVER; 
            } 
        }

        for (let i = beams.length - 1; i >= 0; i--) { beams[i].update(); beams[i].draw(); if(beams[i].life<=0) beams.splice(i, 1); }
        for (let i = explosions.length - 1; i >= 0; i--) { explosions[i].update(); explosions[i].draw(); if(explosions[i].life<=0) explosions.splice(i, 1); }
        for (let i = lightnings.length - 1; i >= 0; i--) { lightnings[i].update(); lightnings[i].draw(); if(lightnings[i].life<=0) lightnings.splice(i, 1); }

        const vW = canvas.width/ZOOM_SCALE; const vH = canvas.height/ZOOM_SCALE; const m = 200;
        const cx = canvas.width/2; const cy = canvas.height/2;

        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i]; p.update(); p.draw();
            if(p.life<=0 || p.x<cx-vW/2-m || p.x>cx+vW/2+m || p.y<cy-vH/2-m || p.y>cy+vH/2+m) { projectiles.splice(i, 1); continue; }

            if(boss && !boss.dead && Math.hypot(p.x-boss.x, p.y-boss.y) < boss.radius+p.radius) {
                if(p.explosive) { p.explode(); projectiles.splice(i,1); continue; }
                boss.takeDamage(p.damage);
                particles.push(new Particle(p.x, p.y, p.color));
                if(!p.isPiercing) { projectiles.splice(i,1); continue; }
            }

            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if(e.dead) continue; 
                if(Math.hypot(p.x-e.x, p.y-e.y) < e.radius+p.radius) {
                    if(p.explosive) { p.explode(); projectiles.splice(i,1); break; }
                    else {
                        const died = e.takeDamage(p.damage); 
                        if(!died) particles.push(new Particle(e.x,e.y,'#fff'));
                        
                        if(!p.isPiercing) { projectiles.splice(i,1); break; }
                        else if(!p.hitList.includes(e)) p.hitList.push(e);
                    }
                }
            }
        }

        enemies = enemies.filter(e => {
            if (e.dead) return false;
            e.update(); e.draw();
            if(Math.hypot(e.x-core.x, e.y-core.y) < core.radius+e.radius) {
                core.hp-=10; updateUi();
                canvas.style.transform=`translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(()=>canvas.style.transform='translate(0,0)', 50);
                if(core.hp<=0) currentState=GAME_STATE.GAME_OVER;
                return false; 
            }
            return true;
        });

        for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); particles[i].draw(); if(particles[i].life<=0) particles.splice(i, 1); }
        
        ctx.restore();
    }

    window.addEventListener('resize', () => {
        canvas.width=window.innerWidth; canvas.height=window.innerHeight;
        core.x=canvas.width/2; core.y=canvas.height/2;
    });

    renderWeaponSlots(); updateUi(); animate();
</script>
</body>
</html>
