<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planet Survivor: Ultimate Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d1117; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        canvas { display: block; }
        
        /* UI Í≥µÌÜµ Ïä§ÌÉÄÏùº */
        .hidden { display: none !important; }
        button { cursor: pointer; border: none; outline: none; font-family: inherit; transition: transform 0.1s; }
        button:active { transform: scale(0.95); }

        /* Î©îÏù∏ Î©îÎâ¥ & ÏÉÅÏ†ê Ïä§ÌÉÄÏùº */
        #main-menu, #shop-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        
        .game-title { font-size: 4rem; font-weight: 800; background: linear-gradient(to right, #4ade80, #3b82f6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 30px; text-shadow: 0 0 30px rgba(59, 130, 246, 0.5); text-align: center;}
        
        .menu-btn { 
            background: linear-gradient(45deg, #2563eb, #1d4ed8); color: white; 
            font-size: 1.5rem; padding: 15px 40px; border-radius: 50px; 
            margin: 10px; box-shadow: 0 4px 15px rgba(37, 99, 235, 0.4); border: 2px solid #60a5fa;
            width: 250px;
        }
        .menu-btn.secondary { background: linear-gradient(45deg, #4b5563, #374151); border-color: #9ca3af; box-shadow: none; }
        .menu-btn:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(37, 99, 235, 0.6); }

        /* ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù */
        .difficulty-selector { display: flex; gap: 10px; margin-bottom: 20px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 20px; }
        .diff-btn { padding: 10px 20px; background: transparent; color: #aaa; border: 1px solid #444; border-radius: 15px; font-weight: bold; }
        .diff-btn.selected { background: #ef4444; color: white; border-color: #ef4444; box-shadow: 0 0 10px #ef4444; }

        /* ÏÉÅÏ†ê Í∑∏Î¶¨Îìú */
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-width: 800px; width: 90%; margin-bottom: 20px; max-height: 60vh; overflow-y: auto; }
        .shop-item { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; border: 1px solid #333; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .shop-item h3 { margin: 5px 0; color: #fbbf24; }
        .shop-item p { font-size: 0.9rem; color: #ccc; margin-bottom: 10px; }
        .shop-buy-btn { background: #10b981; color: white; padding: 8px 20px; border-radius: 5px; font-weight: bold; width: 100%; }
        .shop-buy-btn:disabled { background: #374151; color: #6b7280; cursor: not-allowed; }
        .currency-display { font-size: 1.5rem; color: #fbbf24; margin-bottom: 20px; font-weight: bold; display: flex; align-items: center; gap: 10px; }

        /* Ïù∏Í≤åÏûÑ UI */
        #ui-layer { position: absolute; top: 15px; left: 15px; pointer-events: none; width: 240px; max-width: 50%; z-index: 10; }
        
        /* Ïª®Ìä∏Î°§ UI (ÏÇ¨Ïö¥Îìú + Î∞∞ÏÜç) */
        #controls-ui { position: absolute; top: 15px; right: 15px; z-index: 50; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.6); padding: 8px 12px; border-radius: 20px; border: 1px solid #444; pointer-events: auto; }
        .icon-btn { cursor: pointer; font-size: 20px; background: none; border: none; color: white; padding: 0; line-height: 1; width: 30px; text-align: center;}
        #speed-btn { font-size: 14px; font-weight: bold; color: #fbbf24; width: 50px; }
        #volume-slider { width: 80px; height: 4px; -webkit-appearance: none; background: #555; border-radius: 2px; outline: none; cursor: pointer; }
        #volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }

        /* DPS Ìå®ÎÑê Ïä§ÌÉÄÏùº */
        #dps-panel { 
            position: absolute; bottom: 15px; left: 15px; 
            width: 250px; max-height: 40%;
            background: rgba(0, 0, 0, 0.7); 
            border: 1px solid #4ade80; border-radius: 8px;
            padding: 10px; z-index: 50;
            overflow-y: auto; font-size: 0.8rem;
        }
        .dps-title { font-weight: bold; color: #4ade80; margin-bottom: 5px; }
        .dps-item { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .dps-label { font-weight: bold; color: #ccc; }
        .dps-value { color: #f1c40f; }

        /* [Ï∂îÍ∞Ä] ÏùºÏãúÏ†ïÏßÄ Ïò§Î≤ÑÎ†àÏù¥ Î∞è Î™®Îã¨ */
        #pause-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 99;
        }
        #pause-menu.active { display: flex !important; }
        .pause-content {
            background: #1f2937; padding: 30px; border-radius: 15px; border: 2px solid #60a5fa;
            text-align: center; box-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
        }
        .pause-btn-group { margin-top: 20px; }
        .pause-btn { 
            background: #10b981; color: white; padding: 10px 20px; border-radius: 5px; 
            margin: 5px; font-size: 1.1rem; width: 180px;
        }
        .pause-btn.danger { background: #ef4444; }

        #boss-hud { display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 60%; max-width: 600px; height: 30px; z-index: 20; pointer-events: none; }
        #boss-hud.active { display: block; animation: slideDown 0.5s ease-out; }
        .boss-name { text-align: center; font-weight: bold; color: #ef4444; text-shadow: 0 0 5px black; margin-bottom: 5px; font-size: 18px; }
        .boss-bar-bg { width: 100%; height: 100%; background: #333; border: 2px solid #555; border-radius: 5px; overflow: hidden; }
        #boss-hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ef4444, #b91c1c); transition: width 0.1s linear; }
        #warning-msg { display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #ef4444; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red; z-index: 30; pointer-events: none; animation: blink 0.5s infinite alternate; }
        @keyframes slideDown { from { top: -50px; } to { top: 20px; } }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }
        .stat-box { background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px; border: 1px solid #444; margin-bottom: 6px; font-size: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .bar-container { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 4px; }
        #hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #xp-bar { width: 0%; height: 100%; background: #f1c40f; transition: width 0.2s; }
        #weapon-slots { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        .slot { width: 32px; height: 32px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 16px; position: relative; }
        .slot .level-badge { position: absolute; bottom: -2px; right: -2px; background: #333; font-size: 9px; padding: 1px 3px; border-radius: 3px; border: 1px solid #777; }
        #upgrade-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; padding: 20px; box-sizing: border-box; }
        #upgrade-menu.active { display: flex !important; }
        .cards-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 100%; max-height: 80vh; overflow-y: auto; }
        .card { background: linear-gradient(145deg, #1f2937, #111827); border: 2px solid #374151; width: 180px; padding: 15px; border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; position: relative; overflow: hidden; flex-shrink: 0; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .card:hover { transform: translateY(-5px); }
        .card h3 { margin: 8px 0; font-size: 15px; color: #fff; }
        .card p { font-size: 12px; color: #ccc; line-height: 1.4; }
        .card-icon { font-size: 36px; margin-bottom: 8px; display: block; }
        .card.common { border-color: #9ca3af; }
        .card.uncommon { border-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .card.rare { border-color: #3b82f6; box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .card.epic { border-color: #a855f7; box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); background: linear-gradient(145deg, #2e1065, #111827); }
        .card.legendary { border-color: #eab308; box-shadow: 0 0 25px rgba(234, 179, 8, 0.6); background: linear-gradient(145deg, #422006, #111827); animation: pulse-gold 2s infinite; }
        .card.special { border-color: #f43f5e; box-shadow: 0 0 25px rgba(244, 63, 94, 0.5); background: linear-gradient(145deg, #4c0519, #111827); }
        @keyframes pulse-gold { 0% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } 50% { box-shadow: 0 0 30px rgba(234, 179, 8, 0.8); } 100% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } }
        .card-tag { position: absolute; top: 8px; right: 8px; font-size: 9px; padding: 2px 5px; border-radius: 3px; background: #333; color: white; font-weight: bold; }
        .card.common .card-tag { background: #4b5563; } .card.uncommon .card-tag { background: #059669; } .card.rare .card-tag { background: #2563eb; } .card.epic .card-tag { background: #7c3aed; } .card.legendary .card-tag { background: #ca8a04; color: black; } .card.special .card-tag { background: #e11d48; }
        @media (max-width: 600px) { .cards-container { flex-direction: column; align-items: center; gap: 10px; } .card { width: 90%; max-width: 320px; display: flex; flex-direction: row; align-items: center; text-align: left; padding: 10px; min-height: 70px; } .card-icon { font-size: 28px !important; margin: 0 15px 0 0 !important; width: 40px; text-align: center; } .card h3 { margin: 0 0 4px 0 !important; font-size: 16px !important; } .card p { margin: 0 !important; } .card-tag { top: 50% !important; transform: translateY(-50%); right: 10px !important; } }
    </style>
</head>
<body>

<!-- Î©îÏù∏ Î©îÎâ¥ -->
<div id="main-menu">
    <div class="game-title">PLANET<br>SURVIVOR</div>
    <div class="difficulty-selector" id="difficulty-selector">
        <button class="diff-btn selected" data-diff="EASY">EASY</button>
        <button class="diff-btn" data-diff="NORMAL">NORMAL</button>
        <button class="diff-btn" data-diff="HARD">HARD</button>
        <button class="diff-btn" data-diff="HELL" style="color:#ef4444; border-color:#ef4444;">HELL</button>
    </div>
    <button class="menu-btn" onclick="startGame()">GAME START</button>
    <button class="menu-btn secondary" onclick="openShop()">UPGRADE SHOP</button>
    <div style="margin-top: 20px; color: #888; font-size: 0.8rem;">Ver 2.3 Ultimate Evolution</div>
</div>

<!-- ÏÉÅÏ†ê Î©îÎâ¥ -->
<div id="shop-menu" class="hidden">
    <h2 style="font-size: 2rem; margin-bottom: 20px; color: #fbbf24;">RESEARCH LAB</h2>
    <div class="currency-display">
        <span>ü™ô CREDITS:</span>
        <span id="shop-credits">0</span>
    </div>
    <div class="shop-grid" id="shop-items">
        <!-- JSÎ°ú ÏïÑÏù¥ÌÖú ÏÉùÏÑ± -->
    </div>
    <button class="menu-btn secondary" onclick="closeShop()">BACK TO MENU</button>
</div>

<!-- Ïù∏Í≤åÏûÑ UI (Ï¥àÍ∏∞ Ïà®ÍπÄ) -->
<div id="ui-layer" class="hidden">
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>HP</span><span id="hp-text">100/100</span></div><div class="bar-container"><div id="hp-bar"></div></div></div>
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>EXP (Lv.<span id="level-text">1</span>)</span><span id="xp-text">0%</span></div><div class="bar-container"><div id="xp-bar"></div></div></div>
    <div class="stat-box" style="text-align: center;"><span style="font-size: 11px; color:#aaa;">CREDITS</span><br><span id="game-credits" style="font-size: 16px; font-weight: bold; color:#fbbf24;">0</span></div>
    <div id="weapon-slots"></div>
</div>

<!-- [Ï∂îÍ∞Ä] DPS Ìå®ÎÑê -->
<div id="dps-panel" class="hidden">
    <div class="dps-title">WEAPON DPS</div>
    <div id="dps-content"></div>
    <div class="dps-item" style="border-top: 1px solid #444; margin-top: 5px; padding-top: 5px;">
        <span class="dps-label">TOTAL DPS</span>
        <span class="dps-value" id="total-dps">0</span>
    </div>
</div>

<!-- Ïª®Ìä∏Î°§ UI: ÏÇ¨Ïö¥Îìú & Í≤åÏûÑ Î∞∞ÏÜç -->
<div id="controls-ui">
    <button id="sound-btn" class="icon-btn" onclick="toggleMute()">üîä</button>
    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
    <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>
    <button id="speed-btn" class="icon-btn">‚è© 1.0x</button>
    <!-- [Ï∂îÍ∞Ä] ÏùºÏãúÏ†ïÏßÄ Î≤ÑÌäº -->
    <button id="pause-btn" class="icon-btn" onclick="togglePause()">‚è∏Ô∏è</button>
</div>

<!-- [Ï∂îÍ∞Ä] DPS ÌÜ†Í∏Ä Î≤ÑÌäº -->
<button class="menu-btn secondary" id="dps-toggle-btn" style="position: absolute; bottom: 15px; left: 15px; width: 60px; height: 35px; padding: 0; font-size: 1rem; z-index: 51;" onclick="toggleDpsPanel()">DPS</button>


<!-- ÏùºÏãúÏ†ïÏßÄ Î©îÎâ¥ -->
<div id="pause-menu" class="hidden">
    <div class="pause-content">
        <h2 style="color:white; margin-bottom: 15px;">PAUSED</h2>
        <div class="pause-btn-group">
            <button class="pause-btn" onclick="togglePause()">‚ñ∂Ô∏è RESUME</button>
            <button class="pause-btn danger" onclick="confirmGoHome()">üè† EXIT TO MENU</button>
        </div>
    </div>
</div>

<div id="boss-hud"><div class="boss-name">‚ö†Ô∏è GIANT PLANET EATER ‚ö†Ô∏è</div><div class="boss-bar-bg"><div id="boss-hp-bar"></div></div></div>
<div id="warning-msg">WARNING!<br><span style="font-size:30px">BOSS APPROACHING</span></div>

<div id="upgrade-menu"><h1 style="color:white; margin-bottom:10px; font-size: 24px;">LEVEL UP!</h1><div class="cards-container" id="cards-area"></div></div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const mainMenu = document.getElementById('main-menu');
    const shopMenu = document.getElementById('shop-menu');
    const uiLayer = document.getElementById('ui-layer');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const cardsArea = document.getElementById('cards-area');
    const weaponSlotsContainer = document.getElementById('weapon-slots');
    const bossHud = document.getElementById('boss-hud');
    const bossHpBar = document.getElementById('boss-hp-bar');
    const warningMsg = document.getElementById('warning-msg');
    const diffButtons = document.querySelectorAll('.diff-btn');
    const pauseMenu = document.getElementById('pause-menu');
    const dpsPanel = document.getElementById('dps-panel');
    const dpsContent = document.getElementById('dps-content');
    const totalDps = document.getElementById('total-dps');
    
    // Game Logic Variables
    let ZOOM_SCALE = 1.0;
    let GAME_SPEED = 1.0; 
    let spawnTimer = 0; 
    let regenTimer = 0; 

    // [ÏàòÏ†ï] ÏΩîÏñ¥ Í∏∞Î≥∏ HPÎ•º 1000ÏúºÎ°ú Ï¶ùÍ∞Ä
    const CORE_BASE_HP = 1000;
    const core = { x: 0, y: 0, radius: 35, maxHp: CORE_BASE_HP, hp: CORE_BASE_HP, color: '#3b82f6' };
    let gameLoopId = null;
    let isGameRunning = false;
    let currentDifficulty = 'EASY';
    
    // [ÏàòÏ†ï] GAME_STATE Ï†ïÏùòÎ•º ÌÅ¥ÎûòÏä§ Î∞è Ìï®ÏàòÎ≥¥Îã§ ÏïûÏ™ΩÏúºÎ°ú Ïù¥Îèô
    const GAME_STATE = { PLAYING: 0, LEVEL_UP: 1, GAME_OVER: 2, PAUSED: 3 };

    // [ÏàòÏ†ï] RARITY ÏÉÅÏàò Ï†ïÏùòÎ•º ÏµúÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô (ReferenceError Ìï¥Í≤∞)
    const RARITY = {
        COMMON: { name: 'Common', color: 'common', mult: 1.0, chance: 50 },
        UNCOMMON: { name: 'Uncommon', color: 'uncommon', mult: 1.5, chance: 30 },
        RARE: { name: 'Rare', color: 'rare', mult: 2.0, chance: 15 },
        EPIC: { name: 'Epic', color: 'epic', mult: 3.0, chance: 4 },
        LEGENDARY: { name: 'Legendary', color: 'legendary', mult: 5.0, chance: 1 }
    };
    
    // Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞
    let saveFile = {
        credits: 0,
        upgrades: {
            damage: 0,   // Í≥µÍ≤©Î†• (LvÎãπ +10%)
            health: 0,   // Ï≤¥Î†• (LvÎãπ +20)
            haste: 0,    // Ïø®ÌÉÄÏûÑÍ∞êÏÜå (LvÎãπ +3%)
            greed: 0,    // ÏûêÏõêÌöçÎìùÎüâ (LvÎãπ +10%)
            regen: 0,    // ÏûêÎèôÌöåÎ≥µ (LvÎãπ +0.5/sec)
            crit: 0,     // [Ï∂îÍ∞Ä] ÏπòÎ™ÖÌÉÄ (LvÎãπ +5%)
            defense: 0,  // [Ï∂îÍ∞Ä] Î∞©Ïñ¥Î†• (LvÎãπ +5%)
            xp: 0        // [Ï∂îÍ∞Ä] Í≤ΩÌóòÏπò (LvÎãπ +10%)
        }
    };
    
    // [Ï∂îÍ∞Ä] ÏÑ∏ÏÖò ÎèôÏïà ÌöçÎìùÌïú ÏàúÏàò ÌÅ¨Î†àÎîß (Ï†ÄÏû•Îêú ÌÅ¨Î†àÎîßÍ≥º Î∂ÑÎ¶¨)
    let sessionEarnedCredits = 0;
    // [Ï∂îÍ∞Ä] DPS Ï∏°Ï†ïÏö© Î≥ÄÏàò
    let dpsTracker = {};
    let sessionStartTime = 0;

    const DIFFICULTY_SETTINGS = {
        'EASY': { hpMult: 0.8, dmgMult: 0.8, spawnRate: 1.2 }, 
        'NORMAL': { hpMult: 1.0, dmgMult: 1.0, spawnRate: 1.0 },
        'HARD': { hpMult: 1.5, dmgMult: 1.5, spawnRate: 0.8 },
        // [ÏàòÏ†ï] Ìó¨Î™®Îìú ÎÇúÏù¥ÎèÑ ÏÉÅÌñ• Ï°∞Ï†ï
        'HELL': { hpMult: 3.0, dmgMult: 2.5, spawnRate: 0.5 }
    };

    // [ÏàòÏ†ï] ÏÉÅÏ†ê ÏïÑÏù¥ÌÖú Î™©Î°ù (ÌÅ¨Î†àÎîß Î∞∏Îü∞Ïä§ Ï°∞Ï†ï Ïú†ÏßÄ)
    const SHOP_ITEMS = {
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 100 -> 150
        damage: { name: "ÌîåÎùºÏ¶àÎßà Í∞ïÌôî", desc: "Î™®Îì† Î¨¥Í∏∞ Í≥µÍ≤©Î†• +10%", baseCost: 150, costMult: 1.5 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 100 -> 150
        health: { name: "ÎÇòÎÖ∏ Ìï©Í∏à Ïû•Í∞ë", desc: "ÏΩîÏñ¥ ÏµúÎåÄ Ï≤¥Î†• +20", baseCost: 150, costMult: 1.5 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 150 -> 250
        haste: { name: "ÏñëÏûê ÌîÑÎ°úÏÑ∏ÏÑú", desc: "Î¨¥Í∏∞ Ïø®ÌÉÄÏûÑ -3%", baseCost: 250, costMult: 1.6 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 200 -> 350
        crit: { name: "Ï†ïÎ∞Ä ÌÉÄÍ≤© ÏãúÏä§ÌÖú", desc: "ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5% (1.5Î∞∞ ÌîºÌï¥)", baseCost: 350, costMult: 1.6 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 200 -> 300
        defense: { name: "Ï∂©Í≤© Ìù°Ïàò Ïû•Í∞ë", desc: "Î∞õÎäî ÌîºÌï¥Îüâ -5%", baseCost: 300, costMult: 1.6 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 150 -> 250
        xp: { name: "Ï†ÑÏà† Îç∞Ïù¥ÌÑ∞ ÎßÅÌÅ¨", desc: "Í≤ΩÌóòÏπò ÌöçÎìùÎüâ +10%", baseCost: 250, costMult: 1.5 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 200 -> 300
        greed: { name: "ÏûêÍ∏∞Ïû• ÏàòÏßëÍ∏∞", desc: "ÌÅ¨Î†àÎîß ÌöçÎìùÎüâ +10%", baseCost: 300, costMult: 1.7 },
        // [ÏàòÏ†ï] ÎπÑÏö© ÏÉÅÏäπ: 250 -> 400
        regen: { name: "ÎÇòÎÖ∏Î¥á ÏàòÎ¶¨", desc: "Ï≤¥Î†• ÏûêÎèô ÌöåÎ≥µ +0.5/Ï¥à", baseCost: 400, costMult: 1.6 }
    };

    function loadSave() {
        // [Î°úÏª¨ Ï†ÄÏû•ÏÜå] Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è Ï¥àÍ∏∞Ìôî
        const data = localStorage.getItem('planetSurvivorSave');
        if (data) {
            const loaded = JSON.parse(data);
            // Î≥ëÌï© Î°úÏßÅ (ÏÉàÎ°úÏö¥ ÏóÖÍ∑∏Î†àÏù¥Îìú ÌÇ§Î•º ÏïàÏ†ÑÌïòÍ≤å Ï∂îÍ∞Ä)
            saveFile = { ...saveFile, ...loaded, upgrades: { ...saveFile.upgrades, ...loaded.upgrades } };
        }
    }
    function saveGame() {
        // [Î°úÏª¨ Ï†ÄÏû•ÏÜå] Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        localStorage.setItem('planetSurvivorSave', JSON.stringify(saveFile));
    }
    loadSave();

    diffButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            diffButtons.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            currentDifficulty = btn.getAttribute('data-diff');
        });
    });

    /* ================= UI Control ================= */
    const speedBtn = document.getElementById('speed-btn');
    speedBtn.addEventListener('click', () => {
        // [ÏàòÏ†ï] Î∞∞ÏÜç Îã®Í≥ÑÎ•º 1.0 -> 1.5 -> 2.0 -> 3.0 -> 1.0ÏúºÎ°ú ÌôïÏû•
        if(GAME_SPEED === 1.0) GAME_SPEED = 1.5;
        else if(GAME_SPEED === 1.5) GAME_SPEED = 2.0;
        else if(GAME_SPEED === 2.0) GAME_SPEED = 3.0;
        else GAME_SPEED = 1.0;
        
        speedBtn.innerText = `‚è© ${GAME_SPEED.toFixed(1)}x`;
    });

    // [Ï∂îÍ∞Ä] ÏùºÏãúÏ†ïÏßÄ ÌÜ†Í∏Ä Ìï®Ïàò
    window.togglePause = function() {
        if (!isGameRunning) return;

        if (currentState === GAME_STATE.PLAYING) {
            currentState = GAME_STATE.PAUSED;
            pauseMenu.classList.add('active');
        } else if (currentState === GAME_STATE.PAUSED) {
            currentState = GAME_STATE.PLAYING;
            pauseMenu.classList.remove('active');
            animate(); // ÏùºÏãúÏ†ïÏßÄÏóêÏÑú ÌíÄÎ¶¥ Îïå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïû¨ÏãúÏûë
        }
    }
    
    // [Ï∂îÍ∞Ä] DPS Ìå®ÎÑê ÌÜ†Í∏Ä Ìï®Ïàò
    window.toggleDpsPanel = function() {
        dpsPanel.classList.toggle('hidden');
    }

    // [Ï∂îÍ∞Ä] ÌôàÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞ ÌôïÏù∏ Î™®Îã¨
    window.confirmGoHome = function() {
        // [ÏàòÏ†ï] window.confirm ÎåÄÏã† ÏßÅÏ†ë Ìò∏Ï∂úÎêòÎèÑÎ°ù ÏàòÏ†ï. confirm ÏÇ¨Ïö©ÏùÄ Ïú†ÏßÄ.
        const confirmed = window.confirm("Í≤ΩÍ≥†: Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÎ©¥ ÌòÑÏû¨ Í≤åÏûÑ ÏßÑÌñâ ÏÉÅÌô©(XP, Î¨¥Í∏∞ Î†àÎ≤®, Ïä§ÏΩîÏñ¥)ÏùÄ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?");
        if (confirmed) {
            // [ÏàòÏ†ï] ÏàúÏàò ÌöçÎìù ÌÅ¨Î†àÎîßÎßå ÏòÅÍµ¨ Ï†ÄÏû•ÏÜåÏóê Ìï©ÏÇ∞
            saveFile.credits += sessionEarnedCredits;
            saveGame();
            isGameRunning = false;
            window.location.reload(); 
        }
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ZOOM_SCALE = Math.max(0.6, window.innerHeight / 900);
        core.x = canvas.width / 2;
        core.y = canvas.height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    function startGame() {
        if(isGameRunning) return;
        mainMenu.classList.add('hidden');
        uiLayer.classList.remove('hidden');
        isGameRunning = true;
        initGameSession();
        animate();
    }

    function openShop() {
        mainMenu.classList.add('hidden');
        shopMenu.classList.remove('hidden');
        renderShop();
    }

    function closeShop() {
        shopMenu.classList.add('hidden');
        mainMenu.classList.remove('hidden');
        renderShop(); // Î©îÎâ¥Î°ú ÎèåÏïÑÏò¨ Îïå ÏÉÅÏ†ê ÌÅ¨Î†àÎîß Ïû¨Í∞±Ïã†
    }

    function renderShop() {
        document.getElementById('shop-credits').innerText = saveFile.credits;
        const container = document.getElementById('shop-items');
        container.innerHTML = '';

        Object.keys(SHOP_ITEMS).forEach(key => {
            const item = SHOP_ITEMS[key];
            const level = saveFile.upgrades[key];
            const cost = Math.floor(item.baseCost * Math.pow(item.costMult, level));
            
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.innerHTML = `
                <h3>${item.name} (Lv.${level})</h3>
                <p>${item.desc}</p>
                <button class="shop-buy-btn" onclick="buyUpgrade('${key}', ${cost})">
                    ü™ô ${cost} Íµ¨Îß§
                </button>
            `;
            if(saveFile.credits < cost) {
                div.querySelector('button').disabled = true;
                div.querySelector('button').innerText = `ü™ô ${cost} (Î∂ÄÏ°±)`;
            }
            container.appendChild(div);
        });
    }

    window.buyUpgrade = function(key, cost) {
        if(saveFile.credits >= cost) {
            saveFile.credits -= cost;
            saveFile.upgrades[key]++;
            saveGame(); // [Î°úÏª¨ Ï†ÄÏû•ÏÜå] ÏóÖÍ∑∏Î†àÏù¥Îìú ÌõÑ Ï†ÄÏû•
            audio.levelUp(); 
            renderShop();
        }
    };
    
    // [Ï∂îÍ∞Ä] DPS Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
    function updateDps() {
        const elapsedTime = (Date.now() - sessionStartTime) / 1000; // Ï¥à Îã®ÏúÑ
        if (elapsedTime === 0) return;

        let totalDamage = 0;
        let dpsHtml = '';
        
        // Î¨¥Í∏∞Î≥Ñ DPS Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
        player.weapons.forEach(w => {
            const damage = dpsTracker[w.id] || 0;
            const dps = damage / elapsedTime;
            totalDamage += damage;
            
            dpsHtml += `
                <div class="dps-item">
                    <span class="dps-label">${w.currentData.icon} ${w.currentData.name}:</span>
                    <span class="dps-value">${Math.ceil(dps)} DPS / ${Math.ceil(damage)} DMG</span>
                </div>
            `;
        });

        // Ï†ÑÏ≤¥ DPS Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
        const totalDPSValue = totalDamage / elapsedTime;
        
        dpsContent.innerHTML = dpsHtml;
        totalDps.innerText = Math.ceil(totalDPSValue);
    }
    
    // [Ï∂îÍ∞Ä] Í≤åÏûÑ ÏãúÏûë Ïãú DPS Ï∂îÏ†ÅÍ∏∞ Ï¥àÍ∏∞Ìôî
    function initDpsTracker() {
        dpsTracker = {};
        sessionStartTime = Date.now();
        // Î¨¥Í∏∞ Î™©Î°ùÏóê DPS ÌÇ§Î•º ÎØ∏Î¶¨ ÏÉùÏÑ±
        WEAPON_DB.forEach(w => dpsTracker[w.id] = 0);
    }
    
    // [Ï∂îÍ∞Ä] ÌîºÌï¥Îüâ Ìä∏ÎûòÌÇπ Ìï®Ïàò
    function trackDamage(weaponId, damageAmount) {
        if (dpsTracker[weaponId] !== undefined) {
            dpsTracker[weaponId] += damageAmount;
        }
    }


    /* ================= Sound System ================= */
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.muted = false;
            this.volume = 0.5;
            this.initialized = false;
        }
        init() {
            if (this.initialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.initialized = true;
            } catch (e) { console.error("Web Audio API not supported"); }
        }
        playTone(freq, type, duration, volMult = 1.0, slideTo = null) {
            if (!this.ctx || this.muted) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
            gain.gain.setValueAtTime(this.volume * volMult, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }
        playNoise(duration, volMult = 1.0) {
            if (!this.ctx || this.muted) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1200, this.ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + duration);
            gain.gain.setValueAtTime(this.volume * volMult, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        }
        shoot() { this.playTone(800, 'sine', 0.15, 0.2, 100); }
        laser() { this.playTone(400, 'sawtooth', 0.1, 0.15); }
        whoosh() { this.playTone(600, 'triangle', 0.3, 0.3, 200); }
        hit() { this.playTone(200, 'square', 0.08, 0.2, 50); }
        crit() { this.playTone(400, 'square', 0.1, 0.4, 800); } // [Ï∂îÍ∞Ä] ÏπòÎ™ÖÌÉÄ ÏÇ¨Ïö¥Îìú
        explosion() { this.playNoise(0.5, 0.7); }
        levelUp() { 
            if(!this.ctx || this.muted) return;
            [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { setTimeout(() => this.playTone(f, 'sine', 0.4, 0.4), i * 80); });
        }
        warning() {
            if(!this.ctx || this.muted) return;
            this.playTone(200, 'sawtooth', 1.0, 0.5, 600);
            setTimeout(() => this.playTone(600, 'sawtooth', 1.0, 0.5, 200), 500);
        }
        collect() { this.playTone(1200, 'sine', 0.1, 0.1); }
    }

    const audio = new SoundManager();
    const soundBtn = document.getElementById('sound-btn');
    const volumeSlider = document.getElementById('volume-slider');
    soundBtn.addEventListener('click', () => { audio.init(); audio.muted = !audio.muted; soundBtn.innerText = audio.muted ? 'üîá' : 'üîä'; });
    volumeSlider.addEventListener('input', (e) => { audio.init(); audio.volume = parseFloat(e.target.value); if(audio.volume > 0 && audio.muted) { audio.muted = false; soundBtn.innerText = 'üîä'; } });
    window.addEventListener('mousedown', () => audio.init(), { once: true });

    /* ================= Game Logic ================= */
    const WEAPON_DB = {
        // [ÏàòÏ†ï] ÎØ∏ÏÇ¨Ïùº Ï¥àÍ∏∞ Ìè≠Î∞ú Î∞òÍ≤Ω Ï∂ïÏÜå (15 -> 5)
        'MISSILE': { name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', icon: 'üöÄ', type: 'HOMING', baseDamage: 30, baseCooldown: 45, color: '#f59e0b', range: 600, projectileCount: 1, explosive: true, blastRadius: 5 },
        'BLASTER': { name: 'Í¥ëÏÑ† Îπî', icon: 'üî´', type: 'BEAM', baseDamage: 120, baseCooldown: 200, color: '#10b981', range: 1000, thickness: 50, projectileCount: 1 },
        'BOOMERANG': { name: 'ÌîåÎùºÏ¶àÎßà Î∂ÄÎ©îÎûë', icon: 'ü™É', type: 'BOOMERANG', baseDamage: 45, baseCooldown: 120, color: '#8b5cf6', range: 600, projectileCount: 1, speed: 16, isPiercing: true },
        // [ÏàòÏ†ï] Î†àÏùºÍ±¥: Í∏∞Î≥∏ ÌîºÌï¥Îüâ 60 -> 100ÏúºÎ°ú Ï¶ùÍ∞Ä. Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ 25 -> 40ÏúºÎ°ú Ï¶ùÍ∞Ä
        'SNIPER': { name: 'Î†àÏùºÍ±¥', icon: '‚ö°', type: 'PIERCING', baseDamage: 100, baseCooldown: 100, color: '#3b82f6', range: 800, projectileCount: 1, rearShot: false, speed: 40 },
        // [ÏàòÏ†ï] ÎßàÏù¥ÌÅ¨Î°ú ÎØ∏ÏÇ¨Ïùº: Í∏∞Î≥∏ ÌîºÌï¥Îüâ 12 -> 20ÏúºÎ°ú Ï¶ùÍ∞Ä
        'MICRO_SWARM': { name: 'ÎßàÏù¥ÌÅ¨Î°ú ÎØ∏ÏÇ¨Ïùº', icon: 'üéÜ', type: 'SWARM', baseDamage: 20, baseCooldown: 45, color: '#22d3ee', range: 500, projectileCount: 6, spread: 0.5, life: 60 },
        'INTERCEPTOR': { name: 'ÏöîÍ≤© Ìé∏ÎåÄ', icon: 'üõ∏', type: 'UNIT', baseDamage: 18, baseCooldown: 30, color: '#e879f9', range: 300, unitCount: 1, projectileCount: 1 },
        // [ÏàòÏ†ï] Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù: Í∏∞Î≥∏ ÏÇ¨Í±∞Î¶¨ 400 -> 550ÏúºÎ°ú Ï¶ùÍ∞Ä.
        'TESLA': { name: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù', icon: 'üå©Ô∏è', type: 'CHAIN', baseDamage: 35, baseCooldown: 80, color: '#facc15', range: 550, bounceCount: 3 },
        'GRAVITY': { name: 'Ï§ëÎ†•Ïû• ÏÉùÏÑ±Í∏∞', icon: '‚ö´', type: 'SLOW_ZONE', baseDamage: 3, baseCooldown: 0, color: '#111827', range: 250, slowFactor: 0.5 }
    };

    function initGameSession() {
        projectiles=[]; enemies=[]; particles=[]; beams=[]; explosions=[]; drones=[]; lightnings=[]; shockwaves=[];
        boss = null;
        score = 0;
        // [ÏàòÏ†ï] ÏÑ∏ÏÖò ÌÅ¨Î†àÎîßÏùÄ 0Î∂ÄÌÑ∞ ÏãúÏûëÌïòÍ≥†, ÏòÅÍµ¨ ÌÅ¨Î†àÎîßÏùÄ saveFile.creditsÏóê ÎÇ®ÏïÑÏûàÏùå
        sessionEarnedCredits = 0; 
        sessionStartTime = Date.now(); // DPS Ï∂îÏ†ÅÍ∏∞ ÏãúÏûë
        dpsTracker = {}; // DPS Ï∂îÏ†ÅÍ∏∞ Ï¥àÍ∏∞Ìôî

        frame = 0;
        spawnTimer = 0; 
        regenTimer = 0; 
        currentState = GAME_STATE.PLAYING;
        
        // [ÏàòÏ†ï] ÏÉÅÏ†ê ÏóÖÍ∑∏Î†àÏù¥Îìú (Ï≤¥Î†•) Ï†ÅÏö©
        const hpBonus = saveFile.upgrades.health * 20;
        core.maxHp = CORE_BASE_HP + hpBonus; // CORE_BASE_HP (1000) Í∏∞Ï§ÄÏúºÎ°ú Ï†ÅÏö©
        core.hp = core.maxHp;
        
        // [ÏàòÏ†ï] Î¨¥Í∏∞ Î†àÎ≤®ÏùÄ Ìï≠ÏÉÅ 1Î°ú Ï¥àÍ∏∞Ìôî
        player = { level: 1, xp: 0, xpToNext: 150, weapons: [] };
        
        addWeapon('MISSILE'); 
        updateUi();
        
        GAME_SPEED = 1.0;
        speedBtn.innerText = `‚è© ${GAME_SPEED.toFixed(1)}x`;
    }

    /* ================= Classes ================= */
    class BeamEffect {
        constructor(x1, y1, x2, y2, color, thickness) {
            this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.color=color; this.thickness=thickness; this.life=30; this.maxLife=30;
        }
        update(){
            this.life -= 1 * GAME_SPEED;
        }
        draw(){
            const alpha = Math.max(0, this.life/this.maxLife); ctx.save();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle=this.color; ctx.lineWidth=this.thickness*alpha; ctx.lineCap='round'; ctx.globalAlpha=alpha; ctx.shadowBlur=20*alpha; ctx.shadowColor=this.color; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle='white'; ctx.lineWidth=(this.thickness/3)*alpha; ctx.stroke();
            ctx.restore();
        }
    }
    class LightningEffect {
        constructor(x1, y1, x2, y2, color) {
            this.points=[]; this.color=color; this.life=15; const steps=10; const dx=x2-x1; const dy=y2-y1;
            for(let i=0; i<=steps; i++) { const t=i/steps; let nx=x1+dx*t; let ny=y1+dy*t; if(i!==0 && i!==steps){nx+=(Math.random()-0.5)*30; ny+=(Math.random()-0.5)*30;} this.points.push({x:nx, y:ny}); }
        }
        update(){ this.life -= 1 * GAME_SPEED; }
        draw(){ctx.save(); ctx.globalAlpha=Math.max(0, this.life/15); ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); for(let i=1;i<this.points.length;i++)ctx.lineTo(this.points[i].x, this.points[i].y); ctx.strokeStyle=this.color; ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.stroke(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke(); ctx.restore();}
    }
    class Projectile {
        constructor(x, y, vx, vy, damage, color, isPiercing, isSmall=false, weaponId = null, baseLife=200) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.damage=damage; this.color=color; this.isPiercing=isPiercing; 
            this.radius=isSmall?2:(isPiercing?4:3); 
            // [ÏàòÏ†ï] Í∏∞Î≥∏ ÏàòÎ™Ö ÏÑ§Ï†ï
            this.life=isSmall?baseLife/4:baseLife; 
            this.hitList=[];
            this.behavior = null; 
            this.phase = 'OUT'; this.hoverTimer = 0; this.speed = 0; this.rotation = 0; 
            this.weaponId = weaponId; // DPS Ï∂îÏ†ÅÏö©
        }
        update(){
            if(this.behavior === 'BOOMERANG') {
                this.rotation += 0.3 * GAME_SPEED; 
                if(this.phase === 'OUT') {
                    this.x += this.vx * GAME_SPEED;
                    this.y += this.vy * GAME_SPEED;
                    const friction = 1 - (0.04 * GAME_SPEED); 
                    this.speed *= friction; this.vx *= friction; this.vy *= friction;
                    // [ÏàòÏ†ï] Î©àÏ∂§ Ï°∞Í±¥ Îã¨ÏÑ± Ïãú ÏÜçÎèÑ Î≤°ÌÑ∞Î•º ÏôÑÏ†ÑÌûà 0ÏúºÎ°ú ÎßåÎì§Ïñ¥ ÌôïÏã§Ìûà Î©àÏ∂îÍ≤å Ìï® (Í∂§ÎèÑ Î≤ÑÍ∑∏ Î∞©ÏßÄ)
                    if(Math.abs(this.speed) < 1.0) { 
                        this.phase = 'HOVER'; 
                        this.hoverTimer = 60; 
                        this.vx = 0; 
                        this.vy = 0; 
                        this.speed = 0;
                    }
                } else if(this.phase === 'HOVER') {
                    // [ÏàòÏ†ï] Î©àÏ∂ò ÏÉÅÌÉúÏóêÏÑúÎäî ÏúÑÏπò Ïù¥Îèô ÏóÜÏùå (Î≤ÑÍ∑∏ Î∞©ÏßÄ)
                    this.hoverTimer -= GAME_SPEED;
                    if(this.hoverTimer <= 0) { this.phase = 'RETURN'; this.hitList = []; }
                } else if(this.phase === 'RETURN') {
                    const angle = Math.atan2(core.y - this.y, core.x - this.x);
                    this.speed += 0.6 * GAME_SPEED; 
                    if(this.speed > 18) this.speed = 18; 
                    this.x += Math.cos(angle) * this.speed * GAME_SPEED;
                    this.y += Math.sin(angle) * this.speed * GAME_SPEED;
                    if(Math.hypot(core.x - this.x, core.y - this.y) < 20) { this.life = 0; }
                }
            } else {
                this.x += this.vx * GAME_SPEED; 
                this.y += this.vy * GAME_SPEED; 
                this.life -= GAME_SPEED;
            }
        }
        draw(){
            ctx.save(); ctx.translate(this.x, this.y);
            if(this.behavior === 'BOOMERANG') {
                ctx.scale(3.8, 3.8); ctx.rotate(this.rotation); ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.moveTo(-6, -4); ctx.quadraticCurveTo(0, 6, 6, -4); ctx.quadraticCurveTo(0, 0, -6, -4); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 0.5; ctx.stroke();
            } else {
                ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
            }
            ctx.restore();
        }
    }
    class Shockwave {
        constructor(x, y, maxRadius, color) {
            this.x = x; this.y = y; this.maxRadius = maxRadius; this.radius = 1; this.color = color; this.life = 30; this.maxLife = 30;
        }
        update() { 
            this.radius += (this.maxRadius - this.radius) * 0.15 * GAME_SPEED; 
            this.life -= GAME_SPEED; 
        }
        draw() {
            if(this.life <= 0) return;
            const alpha = Math.max(0, this.life / this.maxLife);
            ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.lineWidth = 5 * alpha; ctx.strokeStyle = this.color; ctx.globalAlpha = alpha; ctx.stroke(); ctx.restore();
        }
    }
    class Explosion {
        constructor(x,y,r,c, showArea=false, weaponId = null){
            this.x=x;this.y=y;this.maxR=r;this.r=10;this.c=c;this.life=20; this.showArea = showArea; 
            shockwaves.push(new Shockwave(x, y, r * 1.0, c));
            const pCount = showArea ? 16 : 8;
            for(let i=0; i<pCount; i++) particles.push(new Particle(x, y, c, (Math.random()-0.5)*12, (Math.random()-0.5)*12));
            audio.explosion(); 
            this.weaponId = weaponId; // DPS Ï∂îÏ†ÅÏö©
        }
        update(){
            // [ÏàòÏ†ï] Ìè≠Î∞ú ÏãúÍ∞ÅÏ†Å ÌÅ¨Í∏∞: maxRÏóê ÎπÑÎ°ÄÌïòÏó¨ ÌÅ¨Í∏∞Í∞Ä Ïª§ÏßÄÎèÑÎ°ù Ï°∞Ï†ï (ÏûëÏùÄ Ìè≠Î∞úÏù¥ ÏûëÍ≤å Î≥¥Ïù¥ÎèÑÎ°ù)
            this.r += (this.maxR / 5 + 5) * 0.25 * GAME_SPEED; // ÏûëÏùÄ maxR(5)Ïùº Îïê ÎäêÎ¶¨Í≥†, ÌÅ∞ maxR(150)Ïùº Îïê Îπ†Î•¥Í≤å ÌåΩÏ∞Ω
            this.life -= GAME_SPEED;
        }
        draw(){
            ctx.save(); ctx.globalAlpha=Math.max(0, this.life/20); 
            if(this.showArea) {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.maxR, 0, Math.PI*2);
                ctx.fillStyle = this.c; ctx.globalAlpha = (this.life/30) * 0.4; ctx.fill();
                ctx.strokeStyle = this.c; ctx.lineWidth = 2; ctx.globalAlpha = Math.max(0, this.life/20); ctx.stroke();
            }
            ctx.globalAlpha=Math.max(0, this.life/20);
            ctx.fillStyle=this.c; 
            
            // [ÏàòÏ†ï] Ï§ëÏã¨ Ìè≠Î∞ú ÏãúÍ∞ÅÏ†Å ÌÅ¨Í∏∞ Ï°∞Ï†ï
            const visualRadius = Math.min(this.r, this.maxR);
            ctx.beginPath(); ctx.arc(this.x,this.y,visualRadius,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='white'; 
            ctx.beginPath(); ctx.arc(this.x,this.y,visualRadius*0.7,0,Math.PI*2); ctx.fill(); 
            ctx.restore();
        }
    }
    class HomingMissile {
        constructor(x, y, target, damage, color, explosive, blastRadius, weaponId) {
            this.x=x; this.y=y; this.target=target; this.damage=damage; this.explosive=explosive; this.speed=4; this.angle=Math.random()*Math.PI*2; this.life=300; this.radius=4; this.blastRadius = blastRadius || 120;
            this.weaponId = weaponId; // DPS Ï∂îÏ†ÅÏö©
        }
        update() {
            if(!this.target || this.target.dead) this.target=this.findNewTarget();
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const ta=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                let d=ta-this.angle; while(d<=-Math.PI)d+=Math.PI*2; while(d>Math.PI)d-=Math.PI*2;
                let turnRate=0.15; if(dist<200)turnRate=0.35; if(dist<60)turnRate=1.0;
                this.angle += d * turnRate * GAME_SPEED; 
            }
            this.x += Math.cos(this.angle) * this.speed * GAME_SPEED; 
            this.y += Math.sin(this.angle) * this.speed * GAME_SPEED; 
            this.life -= GAME_SPEED;
            if(Math.random()<0.5 * GAME_SPEED) particles.push(new Particle(this.x,this.y,'#555', null, null, 1.0, 0.1, 0.9));
        }
        findNewTarget(){
            let n=null; let min=Infinity; if(boss && !boss.dead) return boss;
            enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n;
        }
        draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle=this.explosive?'#ef4444':'#f59e0b'; ctx.beginPath(); ctx.moveTo(6,0); ctx.lineTo(-4,4); ctx.lineTo(-4,-4); ctx.fill(); ctx.restore(); }
        explode(){
            explosions.push(new Explosion(this.x, this.y, this.blastRadius, '#ef4444', true, this.weaponId));
            if(boss && !boss.dead) {
                const dist = Math.hypot(this.x - boss.x, this.y - boss.y);
                if (dist < this.blastRadius + boss.radius) {
                    boss.takeDamage(this.damage, this.weaponId); // DPS Ìä∏ÎûòÌÇπ
                }
            }
            enemies.forEach(e => { 
                if(!e.dead) { 
                    const dist = Math.hypot(e.x - this.x, e.y - this.y); 
                    if (dist < this.blastRadius + e.radius) {
                        e.takeDamage(this.damage, this.weaponId); // DPS Ìä∏ÎûòÌÇπ
                    }
                }
            });
        }
    }
    class InterceptorUnit {
        constructor(weaponData, index) {
            this.data=weaponData; this.x=core.x; this.y=core.y; this.angle=(Math.PI*2/6)*index; this.speed=3.5; this.target=null; this.cooldown=0; this.idleAngleOffset=(Math.PI*2/8)*index;
        }
        update() {
            if(!this.target || this.target.dead) { 
                this.target=this.findTarget(); 
                if(!this.target) {
                    this.idleAngleOffset += 0.02 * GAME_SPEED;
                    const desiredX = core.x + Math.cos(this.idleAngleOffset) * 120;
                    const desiredY = core.y + Math.sin(this.idleAngleOffset) * 120;
                    this.x += (desiredX - this.x) * 0.1 * GAME_SPEED; 
                    this.y += (desiredY - this.y) * 0.1 * GAME_SPEED;
                    this.angle = Math.atan2(core.y - this.y, core.x - this.x);
                }
            }
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const a=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                this.angle = a;
                if(dist>150){ 
                    this.x += Math.cos(a) * this.speed * GAME_SPEED; 
                    this.y += Math.sin(a) * this.speed * GAME_SPEED; 
                } else { 
                    this.x -= Math.cos(a) * (this.speed*0.5) * GAME_SPEED; 
                    this.y -= Math.sin(a) * (this.speed*0.5) * GAME_SPEED; 
                }
                if(this.cooldown<=0){
                    const pCount = this.data.projectileCount || 1;
                    for(let i=0; i<pCount; i++) {
                        const spread = 0.2; const offset = (pCount > 1) ? (i - (pCount - 1) / 2) * spread : 0; const fireAngle = a + offset;
                        // [ÏàòÏ†ï] Î∞úÏÇ¨ Ïãú ÏπòÎ™ÖÌÉÄ Ï†ÅÏö©
                        let dmg = this.data.baseDamage;
                        let color = this.data.color;
                        const critChance = saveFile.upgrades.crit * 0.05;
                        if(Math.random() < critChance) { dmg = Math.floor(dmg * 1.5); color = '#fff'; audio.crit(); }

                        const p = new Projectile(this.x, this.y, Math.cos(fireAngle)*15, Math.sin(fireAngle)*15, dmg, color, false, false, 'INTERCEPTOR'); // DPS ID Ï∂îÍ∞Ä
                        p.radius = 5; projectiles.push(p);
                    }
                    if(!audio.muted) audio.shoot(); this.cooldown=this.data.baseCooldown;
                }
            } 
            drones.forEach(other => {
                if (other === this) return;
                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                if (dist < 40 && dist > 0) { 
                    const pushAngle = Math.atan2(this.y - other.y, this.x - other.x); 
                    this.x += Math.cos(pushAngle) * 0.5 * GAME_SPEED; 
                    this.y += Math.sin(pushAngle) * 0.5 * GAME_SPEED; 
                }
            });
            if(this.cooldown>0) this.cooldown -= GAME_SPEED;
        }
        findTarget(){ let n=null; let min=Infinity; if(boss && !boss.dead) return boss; enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n; }
        draw(){ ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle=this.data.color; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill(); ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(-8, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }
    class Enemy {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=100; const cx=canvas.width/2; const cy=canvas.height/2; const side=Math.floor(Math.random()*4);
             if(side===0){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy-vH/2-m;} else if(side===1){this.x=cx+vW/2+m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);} else if(side===2){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy+vH/2+m;} else{this.x=cx-vW/2-m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);}
             
             const diff = DIFFICULTY_SETTINGS[currentDifficulty];
             // [ÏàòÏ†ï] Ï†Å HP Ïä§ÏºÄÏùºÎßÅ Í∞ïÌôî: Í∏∞Î≥∏ HPÍ∞Ä 1000Ïù¥ ÎêòÏóàÏúºÎØÄÎ°ú, Ï†ÅÏùò Í∏∞Î≥∏ HPÎèÑ Ï°∞Ï†ï
             // 50 + (player.level * 20) * diff.hpMultÎ°ú Ï°∞Ï†ï
             this.hp = (50 + (player.level*20)) * diff.hpMult;
             this.maxHp = this.hp;
             this.baseSpeed = (0.5+Math.random()*0.5+(player.level*0.05));
             this.speed = this.baseSpeed;
             
             this.radius=12; this.color=`hsl(${Math.random()*60},70%,50%)`; this.dead=false; this.slowed=false; 
             
             // [ÏàòÏ†ï] 50% ÌôïÎ•†Î°ú ÏôÑÎßåÌïú ÎÇòÏÑ†Ìòï Ï†Å(spiral) ÎòêÎäî Îπ†Î•∏ ÏßÅÏÑ†Ìòï Ï†Å(direct) ÏÉùÏÑ±
             if (Math.random() < 0.5) {
                 // ÏôÑÎßåÌïú ÎÇòÏÑ†Ìòï (Ï≤¥Î†• ÎÜíÏùå, ÎäêÎ¶∞ ÌöåÏ†Ñ)
                 this.spiralDir = Math.random() < 0.5 ? 0.15 : -0.15; // 2Î∞îÌÄ¥ Ïù¥ÏÉÅÏùÑ ÎèåÍ≤å ÏôÑÌôî
                 this.hp *= 1.5; // Ï≤¥Î†• Î≥¥ÎÑàÏä§
                 this.maxHp *= 1.5;
             } else {
                 // Îπ†Î•∏ ÏßÅÏÑ†Ìòï (Ï≤¥Î†• ÎÇÆÏùå, ÏßÅÏÑ† Ïù¥Îèô)
                 this.spiralDir = 0; 
                 this.hp *= 0.8; // Ï≤¥Î†• ÌéòÎÑêÌã∞
                 this.maxHp *= 0.8;
             }
        }
        update(){ 
            this.speed=this.baseSpeed; 
            if(this.slowed){this.speed*=0.5; this.slowed=false;} 
            const a=Math.atan2(core.y-this.y, core.x-this.x); 
            // [ÏàòÏ†ï] ÎÇòÏÑ† Ïù¥Îèô Í∞ÅÎèÑ Ï†ÅÏö©
            const ma=a + this.spiralDir; 
            this.x += Math.cos(ma) * this.speed * GAME_SPEED; 
            this.y += Math.sin(ma) * this.speed * GAME_SPEED; 
        }
        takeDamage(d, weaponId = 'CORE'){ 
            if(this.dead)return false; 
            
            // [Ï∂îÍ∞Ä] DPS Ï∂îÏ†Å: ÌîºÌï¥Îüâ Ìä∏ÎûòÌÇπ
            trackDamage(weaponId, d);
            
            this.hp-=d; 
            for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, '#fff', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 1.0, 0.08, 0.9));
            audio.hit(); 
            if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} 
            return false; 
        }
        die(){ 
            for(let i=0;i<5;i++)particles.push(new Particle(this.x,this.y,this.color)); 
            
            // [ÏàòÏ†ï] Í≤ΩÌóòÏπò Î≥¥ÎÑàÏä§ Ï†ÅÏö©
            const xpBonus = 1 + (saveFile.upgrades.xp * 0.1);
            addXp(Math.ceil((10+player.level) * xpBonus)); 
            
            score+=10; 
            // [ÏàòÏ†ï] ÌÅ¨Î†àÎîß ÌöçÎìùÎüâ Ï°∞Ï†ï
            const greedBonus = 1 + (saveFile.upgrades.greed * 0.1);
            const drop = Math.ceil((0.5 + Math.random()*1.5) * greedBonus); // 0.5~2.0 ÌÅ¨Î†àÎîß
            sessionEarnedCredits += drop; // ÏÑ∏ÏÖò ÌöçÎìù ÌÅ¨Î†àÎîßÏóêÎßå ÎçîÌï®
            audio.collect();
        }
        draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); if(this.hp<this.maxHp){ const w=20*(Math.max(0,this.hp)/this.maxHp); ctx.fillStyle='red';ctx.fillRect(this.x-10,this.y-18,20,3); ctx.fillStyle='#0f0';ctx.fillRect(this.x-10,this.y-18,w,3); } }
    }
    class Boss {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=150; const cx=canvas.width/2; const cy=canvas.height/2; this.x=cx; this.y=cy-vH/2-m;
             const diff = DIFFICULTY_SETTINGS[currentDifficulty];
             this.maxHp = (1000 + (player.level*200)) * diff.hpMult;
             this.hp=this.maxHp; 
             // [ÏàòÏ†ï] Î≥¥Ïä§ ÏÜçÎèÑ ÏôÑÌôî
             this.speed=0.15; 
             this.radius=60; this.color='#ef4444'; this.shake=0; this.dead=false;
             audio.warning(); 
        }
        update(){ 
            const a=Math.atan2(core.y-this.y, core.x-this.x); 
            this.x += Math.cos(a) * this.speed * GAME_SPEED; 
            this.y += Math.sin(a) * this.speed * GAME_SPEED; 
            bossHpBar.style.width=`${Math.max(0,(this.hp/this.maxHp)*100)}%`; 
            if(this.shake>0) this.shake -= GAME_SPEED; 
        }
        takeDamage(d, weaponId = 'CORE'){ 
            if(this.dead)return false; 
            
            // [Ï∂îÍ∞Ä] DPS Ï∂îÏ†Å: ÌîºÌï¥Îüâ Ìä∏ÎûòÌÇπ
            trackDamage(weaponId, d);
            
            this.hp-=d; this.shake=5; audio.hit(); 
            if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} return false; 
        }
        die(){ 
            for(let i=0;i<50;i++)particles.push(new Particle(this.x+(Math.random()-0.5)*100, this.y+(Math.random()-0.5)*100, this.color)); 
            explosions.push(new Explosion(this.x,this.y,300,'#fff')); 
            addXp(500); score+=1000; boss=null; bossHud.classList.remove('active'); 
            const greedBonus = 1 + (saveFile.upgrades.greed * 0.1);
            sessionEarnedCredits += Math.ceil(50 * greedBonus); // Î≥¥Ïä§ ÌÅ¨Î†àÎîßÎèÑ Ï°∞Ï†ï
            canvas.style.transform=`translate(${Math.random()*20-10}px, ${Math.random()*20-10}px)`; setTimeout(()=>canvas.style.transform='translate(0,0)', 200); 
        }
        draw(){ const sx=(Math.random()-0.5)*this.shake; const sy=(Math.random()-0.5)*this.shake; ctx.save(); ctx.translate(this.x+sx, this.y+sy); ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.fillStyle='rgba(239, 68, 68, 0.2)'; ctx.fill(); ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); ctx.strokeStyle='#7f1d1d'; ctx.lineWidth=5; ctx.stroke(); ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(-20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-30,20); ctx.quadraticCurveTo(0,50,30,20); ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.stroke(); ctx.restore(); }
    }
    class Particle { 
        constructor(x,y,c,vx,vy,life, decay, friction){
            this.x=x;this.y=y;this.c=c; this.vx=vx||(Math.random()-0.5)*4; this.vy=vy||(Math.random()-0.5)*4; this.life=life||1; this.decay=decay||0.05; this.friction=friction||0.94;
        } 
        update(){ 
            this.x += this.vx * GAME_SPEED; 
            this.y += this.vy * GAME_SPEED; 
            const adjustedFriction = 1 - ((1-this.friction) * GAME_SPEED);
            this.vx *= adjustedFriction; 
            this.vy *= adjustedFriction; 
            this.life -= this.decay * GAME_SPEED; 
        } 
        draw(){ ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,2,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; } 
    }
    class GravityParticle {
        constructor(x, y, tx, ty, color) {
            this.x = x; this.y = y; this.tx = tx; this.ty = ty; this.color = color; this.life = 1.0;
            const angle = Math.atan2(ty - y, tx - x); this.speed = 2 + Math.random() * 3; this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
        }
        update() { 
            this.x += this.vx * GAME_SPEED; 
            this.y += this.vy * GAME_SPEED; 
            const adjustedAccel = 1 + (0.05 * GAME_SPEED);
            this.vx *= adjustedAccel; 
            this.vy *= adjustedAccel; 
            this.life -= 0.05 * GAME_SPEED; 
        }
        draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.beginPath(); ctx.ellipse(this.x, this.y, 4, 1, Math.atan2(this.vy, this.vx), 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
    }

    class Weapon {
        constructor(id) {
            this.id=id; this.level=1; this.upgradeCount=0;
            // [ÏàòÏ†ï] Î¨¥Í∏∞ Ï¥àÍ∏∞Ìôî Ïãú, WEAPON_DBÏùò Í∞íÏúºÎ°ú ÌÅ¥Î°†ÌïòÏó¨ ÏÇ¨Ïö©
            this.baseData=JSON.parse(JSON.stringify(WEAPON_DB[id])); 
            this.currentData=JSON.parse(JSON.stringify(WEAPON_DB[id])); 
            
            // ÏÉÅÏ†ê ÏóÖÍ∑∏Î†àÏù¥Îìú (Í≥µÍ≤©Î†•/Ïø®ÌÉÄÏûÑ)Îßå Ï†ÅÏö©
            const dmgBonus = 1 + (saveFile.upgrades.damage * 0.1);
            this.currentData.baseDamage = Math.ceil(this.currentData.baseDamage * dmgBonus);
            
            const hasteBonus = 1 - (saveFile.upgrades.haste * 0.03); 
            this.currentData.baseCooldown = Math.max(5, Math.ceil(this.currentData.baseCooldown * hasteBonus));

            this.cooldownTimer=0; this.angle=Math.random()*Math.PI*2; this.orbitRadius=55+(Math.random()*10); this.orbitSpeed=0.02+(Math.random()*0.02); this.tickTimer=0;
            if(this.id==='INTERCEPTOR'){ this.units=[]; this.spawnUnits(); }
        }
        spawnUnits(){ 
            const count=this.currentData.unitCount||1; 
            const currentLen = this.units.length;
            for(let i=0; i < count - currentLen; i++){ const u=new InterceptorUnit(this.currentData, this.units.length + i); this.units.push(u); drones.push(u); } 
        }
        applyGeneralUpgrade(rarityMult, type) {
            this.level++;
            const boost = 0.10 * rarityMult; 
            if (type === 'DAMAGE') {
                this.currentData.baseDamage = Math.floor(this.currentData.baseDamage * (1 + boost));
            } else if (type === 'COOLDOWN') {
                this.currentData.baseCooldown = Math.max(5, Math.floor(this.currentData.baseCooldown * (1 - (boost * 0.8))));
            } else if (type === 'RANGE') {
                if (this.id === 'INTERCEPTOR') { if(!this.currentData.projectileCount) this.currentData.projectileCount = 1; this.currentData.projectileCount += 1; } 
                else if (this.id === 'SNIPER') {
                    // [ÏàòÏ†ï] Î†àÏùºÍ±¥: ÏÇ¨Í±∞Î¶¨ ÎåÄÏã† Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ Ï¶ùÍ∞Ä
                    this.currentData.speed = Math.floor(this.currentData.speed * (1 + boost * 0.5)); // ÏÜçÎèÑ Ï¶ùÍ∞ÄÎüâ ÏôÑÌôî
                } else if (this.id === 'MICRO_SWARM') {
                    // [ÏàòÏ†ï] ÎßàÏù¥ÌÅ¨Î°ú ÎØ∏ÏÇ¨Ïùº: ÏÇ¨Í±∞Î¶¨ ÎåÄÏã† ÏàòÎ™Ö Ï¶ùÍ∞Ä (Îçî Ïò§Îûò Îßµ Ïª§Î≤Ñ)
                    this.currentData.life = Math.floor(this.currentData.life * (1 + boost));
                } else if (this.id === 'TESLA') {
                     // [ÏàòÏ†ï] Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù: ÏÇ¨Í±∞Î¶¨ ÎåÄÏã† Ï†ÑÏù¥ ÌöüÏàò Ï¶ùÍ∞Ä
                     if(this.currentData.bounceCount) this.currentData.bounceCount += 1;
                }
                else {
                    if(this.currentData.range) this.currentData.range = Math.floor(this.currentData.range * (1 + boost));
                    if(this.currentData.thickness) this.currentData.thickness = Math.floor(this.currentData.thickness * (1 + boost));
                    // [ÏàòÏ†ï] blastRadiusÎèÑ range ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ°ú Ïª§ÏßÄÎèÑÎ°ù Ïú†ÏßÄ
                    if(this.currentData.blastRadius) this.currentData.blastRadius = Math.floor(this.currentData.blastRadius * (1 + boost));
                }
            } else if (type === 'COUNT') {
                if (this.currentData.projectileCount !== undefined && this.id !== 'INTERCEPTOR') this.currentData.projectileCount++;
                if (this.currentData.unitCount !== undefined) { this.currentData.unitCount++; this.spawnUnits(); }
                if (this.currentData.bounceCount !== undefined) this.currentData.bounceCount++;
            }
        }
        applySpecialUpgrade() {
            this.level++;
            if(this.id === 'BLASTER') { this.currentData.projectileCount += 2; this.currentData.spread = 0.3; this.currentData.thickness += 30; this.currentData.baseDamage *= 2; }
            if(this.id === 'MISSILE') { this.currentData.explosive = true; this.currentData.baseDamage *= 2.5; this.currentData.blastRadius += 150; }
            if(this.id === 'BOOMERANG') { this.currentData.projectileCount += 2; this.currentData.baseDamage *= 2.0; this.currentData.range += 150; }
            if(this.id === 'SNIPER') { 
                this.currentData.rearShot = true;
                this.currentData.projectileCount += 1; 
                this.currentData.baseDamage *= 2;
                this.currentData.speed *= 1.5;
            }
            if(this.id === 'MICRO_SWARM') { 
                this.currentData.projectileCount = 20; 
                this.currentData.spread = 6.28; 
                this.currentData.baseCooldown = 20; 
                this.currentData.baseDamage *= 2.5; // ÌîºÌï¥Îüâ ÎåÄÌè≠ Ï¶ùÍ∞Ä
            }
            if(this.id === 'INTERCEPTOR') { this.currentData.unitCount += 3; this.spawnUnits(); }
            if(this.id === 'TESLA') { 
                this.currentData.bounceCount += 10; 
                this.currentData.range += 200; 
                this.currentData.baseDamage *= 1.5;
            }
            if(this.id === 'GRAVITY') { this.currentData.range += 150; this.currentData.slowFactor = 0.2; this.currentData.baseDamage *= 3; }
        }
        update() {
            this.angle += this.orbitSpeed * GAME_SPEED; 
            if(this.cooldownTimer>0) this.cooldownTimer -= GAME_SPEED;
            if(this.currentData.type==='ZONE'||this.currentData.type==='SLOW_ZONE') this.updateZone();
            else if(this.currentData.type!=='UNIT' && this.cooldownTimer<=0) this.fire();
        }
        draw() {
            if(this.currentData.type==='UNIT')return;
            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            ctx.beginPath(); ctx.moveTo(core.x,core.y); ctx.lineTo(wx,wy); ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.stroke();
            ctx.beginPath(); ctx.arc(wx,wy,8,0,Math.PI*2); ctx.fillStyle=this.currentData.color; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke();
            if(this.currentData.type==='ZONE'){ ctx.beginPath();ctx.arc(core.x,core.y,this.currentData.range,0,Math.PI*2); ctx.fillStyle='rgba(139,92,246,0.1)';ctx.fill(); ctx.strokeStyle='rgba(139,92,246,0.4)';ctx.lineWidth=2;ctx.stroke(); }
            if(this.currentData.type==='SLOW_ZONE'){ 
                ctx.save(); ctx.translate(core.x, core.y); ctx.rotate(frame * 0.02); ctx.beginPath(); ctx.arc(0,0,this.currentData.range,0,Math.PI*2);
                const grad = ctx.createRadialGradient(0,0,this.currentData.range*0.2, 0,0,this.currentData.range);
                grad.addColorStop(0, 'rgba(0,0,0,0.8)'); grad.addColorStop(0.5, 'rgba(0,0,0,0.4)'); grad.addColorStop(1, 'rgba(100,100,100,0.1)');
                ctx.fillStyle = grad; ctx.fill();
                ctx.beginPath(); for(let i=0; i<3; i++) { ctx.arc(0, 0, this.currentData.range * (0.8 + i*0.1), i + frame*0.05, i + frame*0.05 + Math.PI); }
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; ctx.stroke(); ctx.restore();
            }
        }
        fire() {
            const range=this.currentData.range; let target=null; let bossInRange=false;
            if(boss && !boss.dead && Math.hypot(boss.x-core.x, boss.y-core.y)<=range) { target=boss; bossInRange=true; }
            if(!bossInRange) { let min=range; enemies.forEach(e=>{if(e.dead)return; const d=Math.hypot(e.x-core.x, e.y-core.y); if(d<=min){min=d; target=e;}}); }
            if(!target && this.currentData.type!=='ZONE' && this.currentData.type!=='SLOW_ZONE' && this.currentData.type!=='BOOMERANG') return;

            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            const count=this.currentData.projectileCount||1; const spread=this.currentData.spread||0.2;

            for(let i=0; i<count; i++) {
                let angleOffset=(count>1)?(i-(count-1)/2)*spread:0;
                let dmg = this.currentData.baseDamage;
                let color = this.currentData.color;
                const critChance = saveFile.upgrades.crit * 0.05;
                if(Math.random() < critChance) { dmg = Math.floor(dmg * 1.5); color = '#fff'; audio.crit(); }
                
                // DPS ID ÏÑ§Ï†ï
                const weaponId = this.id;

                if(this.currentData.type==='BEAM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset; const endX=wx+Math.cos(fa)*2000; const endY=wy+Math.sin(fa)*2000;
                    beams.push(new BeamEffect(wx,wy,endX,endY,color,this.currentData.thickness));
                    if(boss && !boss.dead && pointToLineDistance(boss.x,boss.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+boss.radius) boss.takeDamage(dmg, weaponId);
                    enemies.forEach(e=>{if(!e.dead && pointToLineDistance(e.x,e.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+e.radius) e.takeDamage(dmg, weaponId);});
                    audio.laser(); 
                } else if(this.currentData.type==='HOMING') {
                    projectiles.push(new HomingMissile(wx,wy,target,dmg,color,this.currentData.explosive,this.currentData.blastRadius, weaponId)); 
                    audio.shoot(); 
                } else if(this.currentData.type==='SWARM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+(Math.random()-0.5)*spread*2;
                    // [ÏàòÏ†ï] ProjectileÏóê life Í∞í Ï†ÑÎã¨
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*6,Math.sin(fa)*6,dmg,color,false,true, weaponId, this.currentData.life || 60)); 
                    audio.shoot(); 
                } else if(this.currentData.type==='CHAIN') {
                    this.castLightning(target,dmg,this.currentData.bounceCount||3, weaponId); break;
                } else if(this.currentData.type==='BOOMERANG') {
                    const fa = Math.random() * Math.PI * 2; 
                    const p = new Projectile(wx, wy, Math.cos(fa)*this.currentData.speed, Math.sin(fa)*this.currentData.speed, dmg, color, true, false, weaponId);
                    p.behavior = 'BOOMERANG'; p.speed = this.currentData.speed; p.phase = 'OUT'; p.radius = 20;   
                    projectiles.push(p); audio.whoosh(); 
                } else {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset; 
                    const ps=this.currentData.speed || 8; // Î†àÏùºÍ±¥ speed ÏÇ¨Ïö©
                    
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*ps,Math.sin(fa)*ps,dmg,color,this.currentData.type==='PIERCING',this.currentData.explosive, weaponId));
                    if(this.currentData.rearShot) projectiles.push(new Projectile(wx,wy,Math.cos(fa+Math.PI)*ps,Math.sin(fa+Math.PI)*ps,dmg,color,this.currentData.type==='PIERCING',this.currentData.explosive, weaponId));
                    audio.shoot(); 
                }
            }
            this.cooldownTimer=this.currentData.baseCooldown;
        }
        // [ÏàòÏ†ï] DPS Ï∂îÏ†ÅÏùÑ ÏúÑÌï¥ weaponIdÎ•º Ïù∏ÏàòÎ°ú Ï∂îÍ∞Ä
        castLightning(t,d,b, weaponId){ 
            let c=t; let v=[c]; 
            // [ÏàòÏ†ï] Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÏπòÎ™ÖÌÉÄ
            let dmg = d; 
            const critChance = saveFile.upgrades.crit * 0.05;
            if(Math.random() < critChance) { dmg = Math.floor(dmg * 1.5); audio.crit(); }

            c.takeDamage(dmg, weaponId); lightnings.push(new LightningEffect(core.x,core.y,c.x,c.y,this.currentData.color)); audio.laser(); 
            for(let i=0;i<b;i++){ let n=null; let min=300; enemies.forEach(e=>{if(e.dead||e===c||v.includes(e))return; const dist=Math.hypot(e.x-c.x,e.y-c.y); if(dist<min){min=dist;n=e;}}); if(n){lightnings.push(new LightningEffect(c.x,c.y,n.x,n.y,this.currentData.color)); n.takeDamage(dmg, weaponId); v.push(n); c=n;}else break; } 
        }
        updateZone() {
            this.tickTimer += 1 * GAME_SPEED; // ÌÉÄÏù¥Î®∏ÎèÑ ÏÜçÎèÑ Ï†ÅÏö©
            if(this.currentData.type==='SLOW_ZONE'){
                // ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± ÎπàÎèÑÎäî frame Í∏∞Î∞òÏúºÎ°ú Ïú†ÏßÄÌïòÎêò, tickTimerÎ•º Ïù¥Ïö©
                if(Math.floor(this.tickTimer) % 3 === 0) {
                    const angle = Math.random() * Math.PI * 2; const dist = this.currentData.range; const px = core.x + Math.cos(angle) * dist; const py = core.y + Math.sin(angle) * dist;
                    particles.push(new GravityParticle(px, py, core.x, core.y, this.currentData.color));
                }
                if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius && Math.floor(this.tickTimer)%10===0) boss.takeDamage(this.currentData.baseDamage, this.id);
                enemies.forEach(e=>{if(!e.dead && Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius){ e.slowed=true; if(Math.floor(this.tickTimer)%10===0)e.takeDamage(this.currentData.baseDamage, this.id);}}); return;
            }
            // hitRate(Í≥µÍ≤© ÏÜçÎèÑ)ÎèÑ Îπ®ÎùºÏßê
            if(Math.floor(this.tickTimer)%(this.currentData.hitRate||10)!==0)return;
            if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius) boss.takeDamage(this.currentData.baseDamage, this.id);
            enemies.forEach(e=>{if(!e.dead&&Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius) e.takeDamage(this.currentData.baseDamage, this.id);});
        }
    }

    function pointToLineDistance(px,py,x1,y1,x2,y2){ const A=px-x1;const B=py-y1;const C=x2-x1;const D=y2-y1; const dot=A*C+B*D;const len=C*C+D*D; let param=-1;if(len!==0)param=dot/len; let xx,yy;if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;} const dx=px-xx;const dy=py-yy; return Math.sqrt(dx*dx+dy*dy); }
    function addWeapon(id){ 
        if(player.weapons.length>=6)return; 
        
        // [Ï∂îÍ∞Ä] DPS Ï∂îÏ†ÅÍ∏∞Ïóê ÏÉà Î¨¥Í∏∞ Ï∂îÍ∞Ä
        if (dpsTracker[id] === undefined) {
             dpsTracker[id] = 0;
        }

        player.weapons.push(new Weapon(id)); 
        renderWeaponSlots(); 
    }
    function addXp(amount){ player.xp+=amount; if(player.xp>=player.xpToNext)levelUp(); updateUi(); }
    function levelUp(){ 
        player.level++; player.xp=0; player.xpToNext=Math.floor(player.xpToNext*1.15); 
        audio.levelUp(); 
        if(player.level%5===0 && !boss)spawnBoss(); currentState=GAME_STATE.LEVEL_UP; generateUpgradeCards(); upgradeMenu.classList.add('active'); 
    }
    function spawnBoss(){ boss=new Boss(); bossHud.classList.add('active'); warningMsg.style.display='block'; setTimeout(()=>audio.warning(), 200); setTimeout(()=>warningMsg.style.display='none',3000); }
    function rollRarity(){ const r=Math.random()*100; if(r<50)return RARITY.COMMON; if(r<80)return RARITY.UNCOMMON; if(r<95)return RARITY.RARE; if(r<99)return RARITY.EPIC; return RARITY.LEGENDARY; }
    function generateUpgradeCards(){
        cardsArea.innerHTML=''; const options=[];
        player.weapons.forEach((w,i)=>{
            if((w.level+1)%5===0) options.push({type:'SPECIAL', weapon:w, index:i, desc:getSpecialDesc(w)});
            else {
                let type='DAMAGE'; const rnd=Math.random(); 
                if(rnd<0.30) type='DAMAGE'; 
                else if(rnd<0.60) type='COOLDOWN'; 
                else if(rnd<0.80) type='RANGE'; 
                else type='COUNT'; 
                const rarity=rollRarity(); options.push({type:'GENERAL', weapon:w, index:i, statType:type, rarity:rarity});
            }
        });
        if(player.weapons.length<6) Object.keys(WEAPON_DB).forEach(id=>{if(!player.weapons.some(w=>w.id===id))options.push({type:'NEW', id:id});});
        options.push({type:'HEAL'}); options.sort(()=>Math.random()-0.5); options.slice(0,3).forEach(opt=>createCard(opt));
    }
    function getSpecialDesc(w){
        if(w.id==='BLASTER')return"Ìä∏ÎùºÏù¥ÎçòÌä∏ Îπî (3Í∞àÎûò Î∞úÏÇ¨)";
        if(w.id==='MISSILE')return"Îâ¥ÌÅ¥Î¶¨Ïñ¥ (Ï¥àÍ¥ëÏó≠ Ìè≠Î∞ú)";
        if(w.id==='BOOMERANG')return"Ïù∏ÌîºÎãàÌã∞ Ïª§ÌÑ∞ (ÎìÄÏñº Î∂ÄÎ©îÎûë)";
        if(w.id==='SNIPER')return"Î¶¨ÏΩîÏéº ÌÉÑÌôò (Ï†ÅÏ§ë Ïãú ÌäïÍπÄ)";
        if(w.id==='MICRO_SWARM')return"Ïò¥Îãà Î≤ÑÏä§Ìä∏ (360ÎèÑ Ï†ÑÎ∞©Ìñ• ÎÇúÏÇ¨)";
        if(w.id==='INTERCEPTOR')return"Ïö∞Ï£º Î™®Ìï® (Ìé∏ÎåÄ 4Í∏∞Î°ú Ï¶ùÍ∞Ä)";
        if(w.id==='TESLA')return"ÎáåÏã† (Ï†ÑÏù¥ ÌöüÏàò/Î≤îÏúÑ ÎåÄÌè≠ Ï¶ùÍ∞Ä)";
        if(w.id==='GRAVITY')return"Ïù¥Î≤§Ìä∏ Ìò∏ÎùºÏù¥Ï¶å (80% Í∞êÏÜç)";
        return"Í∂ÅÍ∑π ÏßÑÌôî";
    }
    function createCard(opt){
        const card=document.createElement('div'); card.className='card'; let title,desc,icon,tagName;
        if(opt.type==='NEW'){ const d=WEAPON_DB[opt.id]; title=d.name; desc="Ïã†Í∑ú Î¨¥Í∏∞ ÌöçÎìù"; icon=d.icon; card.classList.add('uncommon'); tagName='NEW'; }
        else if(opt.type==='SPECIAL'){ const w=opt.weapon; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}‚û§${w.level+1}</span>`; desc=`<span style="color:#f43f5e;font-weight:bold">üî• ULTIMATE üî•</span><br>${opt.desc}`; icon=w.currentData.icon; card.classList.add('special'); tagName='EVO'; }
        else if(opt.type==='GENERAL'){
            const w=opt.weapon; const r=opt.rarity; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}‚û§${w.level+1}</span>`;
            let txt='Í≥µÍ≤©Î†•', val=Math.floor(10*r.mult)+'%';
            if(opt.statType==='COOLDOWN'){txt='Í≥µÍ≤©ÏÜçÎèÑ';} 
            if(opt.statType==='RANGE'){ 
                txt='Î≤îÏúÑ/ÌÅ¨Í∏∞'; 
                if(w.id==='MISSILE') txt='Ìè≠Î∞ú Î≤îÏúÑ'; 
                if(w.id==='INTERCEPTOR') { txt='ÎØ∏ÏÇ¨Ïùº Í∞úÏàò'; val='+1'; } 
                else if (w.id === 'SNIPER') { txt='Ìà¨ÏÇ¨Ï≤¥ ÏÜçÎèÑ'; val=`+${Math.floor(boost * 50)}%`; }
                else if (w.id === 'MICRO_SWARM') { txt='ÎØ∏ÏÇ¨Ïùº ÏàòÎ™Ö'; val=`+${Math.floor(boost * 100)}%`; }
                else if (w.id === 'TESLA') { txt='Ï†ÑÏù¥ ÌöüÏàò'; val='+1'; }
            } 
            if(opt.statType==='COUNT'){txt='Î∞úÏÇ¨Ï≤¥ Ïàò'; val='+1';}
            desc=`${txt} <span style="color:${getColor(r.name)};font-weight:bold">+${val}</span>`; icon=w.currentData.icon; card.classList.add(r.color); tagName=r.name.toUpperCase();
        } else { title="Í∏¥Í∏â ÏàòÎ¶¨"; desc="Ï≤¥Î†• 50% ÌöåÎ≥µ"; icon="‚ù§Ô∏è"; card.classList.add('common'); tagName='ITEM'; }
        function getColor(n){if(n==='Legendary')return'#eab308';if(n==='Epic')return'#a855f7';if(n==='Rare')return'#3b82f6';if(n==='Uncommon')return'#10b981';return'#9ca3af';}
        card.innerHTML=`<div class="card-tag">${tagName}</div><div class="card-icon">${icon}</div><h3>${title}</h3><p>${desc}</p>`;
        card.onclick=()=>{
            if(opt.type==='NEW')addWeapon(opt.id);
            else if(opt.type==='SPECIAL')opt.weapon.applySpecialUpgrade();
            else if(opt.type==='GENERAL')opt.weapon.applyGeneralUpgrade(opt.rarity.mult, opt.statType);
            else if(opt.type==='HEAL')core.hp=Math.min(core.hp+50, core.maxHp);
            renderWeaponSlots(); updateUi(); upgradeMenu.classList.remove('active'); currentState=GAME_STATE.PLAYING;
        }; cardsArea.appendChild(card);
    }
    function renderWeaponSlots(){ weaponSlotsContainer.innerHTML=''; for(let i=0;i<6;i++){ const slot=document.createElement('div'); slot.className='slot'; if(player.weapons[i]){ const w=player.weapons[i]; slot.innerHTML=`${w.currentData.icon}<div class="level-badge">${w.level}</div>`; slot.style.borderColor=w.currentData.color; slot.style.boxShadow=`0 0 5px ${w.currentData.color}`; }else slot.innerHTML='<span style="color:#333;font-size:12px">EMPTY</span>'; weaponSlotsContainer.appendChild(slot); } }
    
    function updateUi(){ 
        // [ÏàòÏ†ï] UI ÏöîÏÜåÍ∞Ä DOMÏóê Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Î∞©Ïñ¥ ÏΩîÎìú Ï∂îÍ∞Ä
        const hpText = document.getElementById('hp-text');
        const hpBar = document.getElementById('hp-bar');
        const levelText = document.getElementById('level-text');
        const xpText = document.getElementById('xp-text');
        const xpBar = document.getElementById('xp-bar');
        const scoreText = document.getElementById('score-text');
        const gameCredits = document.getElementById('game-credits');
        const shopCredits = document.getElementById('shop-credits'); // ÏÉÅÏ†ê ÌÅ¨Î†àÎîß

        if (hpText) hpText.innerText = `${Math.ceil(core.hp)}/${core.maxHp}`; 
        if (hpBar) hpBar.style.width = `${(core.hp/core.maxHp)*100}%`; 
        if (levelText) levelText.innerText = player.level; 
        if (xpText) xpText.innerText = `${Math.floor((player.xp/player.xpToNext)*100)}%`; 
        if (xpBar) xpBar.style.width = `${(player.xp/player.xpToNext)*100}%`; 
        if (scoreText) scoreText.innerText = score; 
        
        // [ÏàòÏ†ï] Ïù∏Í≤åÏûÑ ÌÅ¨Î†àÎîß ÌëúÏãúÎäî ÏòÅÍµ¨ ÌÅ¨Î†àÎîß ÏûîÏï° + ÏÑ∏ÏÖò ÌöçÎìù ÌÅ¨Î†àÎîß
        if (gameCredits) gameCredits.innerText = saveFile.credits + sessionEarnedCredits;
        // [ÏàòÏ†ï] ÏÉÅÏ†ê ÌÅ¨Î†àÎîß ÌëúÏãúÎäî ÏòÅÍµ¨ ÌÅ¨Î†àÎîß ÏûîÏï°Îßå ÌëúÏãú
        if (shopCredits) shopCredits.innerText = saveFile.credits;
    }

    function animate(){
        if(!isGameRunning) return; 
        
        // [ÏàòÏ†ï] PAUSED ÏÉÅÌÉúÏùº Í≤ΩÏö∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑÎ•º Í≥ÑÏÜç Ìò∏Ï∂úÌïòÎêò ÏóÖÎç∞Ïù¥Ìä∏Îäî Í±¥ÎÑàÎúÅÎãàÎã§.
        if(currentState === GAME_STATE.PAUSED) {
            requestAnimationFrame(animate); 
            return; 
        }
        
        requestAnimationFrame(animate);
        if(currentState===GAME_STATE.LEVEL_UP)return;
        
        if(currentState===GAME_STATE.GAME_OVER){
            ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle='red'; ctx.font='bold 40px sans-serif'; ctx.textAlign='center'; ctx.fillText("MISSION FAILED",canvas.width/2,canvas.height/2);
            ctx.fillStyle='white'; ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+50);
            ctx.fillText(`Earned Credits: ${sessionEarnedCredits}`,canvas.width/2,canvas.height/2+80);
            
            if(!window.gameOverTimer) {
                // [ÏàòÏ†ï] Í≤åÏûÑ Ïò§Î≤Ñ Ïãú ÏàúÏàò ÌöçÎìù ÌÅ¨Î†àÎîßÎßå ÏòÅÍµ¨ Ï†ÄÏû•ÏÜåÏóê Ìï©ÏÇ∞
                saveFile.credits += sessionEarnedCredits;
                saveGame();
                window.gameOverTimer = setTimeout(() => { isGameRunning = false; window.gameOverTimer = null; location.reload(); }, 3000);
            }
            return;
        }
        
        ctx.fillStyle='rgba(13, 17, 23, 0.2)';ctx.fillRect(0,0,canvas.width,canvas.height);
        
        ctx.save(); 
        ctx.translate(canvas.width/2,canvas.height/2); 
        ctx.scale(ZOOM_SCALE,ZOOM_SCALE); 
        ctx.translate(-canvas.width/2,-canvas.height/2);
        
        frame++;
        
        // [ÏàòÏ†ï] Ïä§Ìè∞ Î°úÏßÅ
        const spawnRate = DIFFICULTY_SETTINGS[currentDifficulty].spawnRate;
        const baseRate = Math.max(5, 50-(player.level*3));
        const spawnInterval = baseRate * spawnRate;
        
        spawnTimer -= GAME_SPEED; 
        if(spawnTimer <= 0 && !boss) {
            enemies.push(new Enemy());
            spawnTimer = spawnInterval; 
        }

        // [Ï∂îÍ∞Ä] Ï≤¥Î†• ÏûêÎèô ÌöåÎ≥µ Î°úÏßÅ
        if(saveFile.upgrades.regen > 0) {
            regenTimer += GAME_SPEED;
            if(regenTimer >= 60) { 
                const healAmount = saveFile.upgrades.regen * 0.5;
                if(core.hp < core.maxHp) {
                    core.hp = Math.min(core.hp + healAmount, core.maxHp);
                    updateUi();
                }
                regenTimer = 0;
            }
        }
        
        ctx.beginPath();ctx.arc(core.x,core.y,core.radius,0,Math.PI*2);ctx.fillStyle=core.color;ctx.shadowBlur=20;ctx.shadowColor=core.color;ctx.fill();ctx.shadowBlur=0;
        player.weapons.forEach(w=>{w.update();w.draw();}); drones.forEach(d=>{d.update();d.draw();});
        if(boss&&!boss.dead){
            boss.update();boss.draw();
            if(Math.hypot(boss.x-core.x,boss.y-core.y)<core.radius+boss.radius){
                // [ÏàòÏ†ï] Î∞©Ïñ¥Î†• Ï†ÅÏö©
                const def = 1 - (saveFile.upgrades.defense * 0.05);
                core.hp -= 0.5 * GAME_SPEED * def; 
                updateUi();
                if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;
            }
        }
        for(let i=beams.length-1;i>=0;i--){beams[i].update();beams[i].draw();if(beams[i].life<=0)beams.splice(i,1);}
        for(let i=explosions.length-1;i>=0;i--){explosions[i].update();explosions[i].draw();if(explosions[i].life<=0)explosions.splice(i,1);}
        for(let i=shockwaves.length-1;i>=0;i--){shockwaves[i].update();shockwaves[i].draw();if(shockwaves[i].life<=0)shockwaves.splice(i,1);}
        for(let i=lightnings.length-1;i>=0;i--){lightnings[i].update();lightnings[i].draw();if(lightnings[i].life<=0)lightnings.splice(i,1);}
        
        const vW=canvas.width/ZOOM_SCALE;const vH=canvas.height/ZOOM_SCALE;const m=200;const cx=canvas.width/2;const cy=canvas.height/2;
        
        for(let i=projectiles.length-1;i>=0;i--){
            const p=projectiles[i]; p.update(); p.draw();
            if(p.life<=0 || (p.behavior !== 'BOOMERANG' && (p.x<cx-vW/2-m||p.x>cx+vW/2+m||p.y<cy-vH/2-m||p.y>cy+vH/2+m))){
                projectiles.splice(i,1); continue;
            }
            if(boss&&!boss.dead&&Math.hypot(p.x-boss.x,p.y-boss.y)<boss.radius+p.radius){if(p.explosive){p.explode();projectiles.splice(i,1);continue;}boss.takeDamage(p.damage);particles.push(new Particle(p.x,p.y,p.color,null,null,1.0,0.1));if(!p.isPiercing){projectiles.splice(i,1);continue;}}
            for(let j=enemies.length-1;j>=0;j--){const e=enemies[j];if(e.dead)continue;
                
                // Î∂ÄÎ©îÎûëÏù¥ Ïù¥ÎØ∏ Ïù¥ Ï†ÅÏùÑ ÎïåÎ†∏ÎäîÏßÄ ÌôïÏù∏
                const alreadyHit = p.isPiercing && p.hitList.includes(e);

                if(Math.hypot(p.x-e.x,p.y-e.y)<e.radius+p.radius && !alreadyHit){
                    if(p.explosive){
                        p.explode();
                        projectiles.splice(i,1);
                        break;
                    }else{
                        const died=e.takeDamage(p.damage);
                        if(!died)particles.push(new Particle(e.x,e.y,'#fff',null,null,1.0,0.1));
                        
                        if(!p.isPiercing){
                            projectiles.splice(i,1);
                            break;
                        }else if(p.isPiercing && !p.hitList.includes(e)){
                             p.hitList.push(e); // Í¥ÄÌÜµÌòï Î¨¥Í∏∞Îäî ÎßûÏùÄ Ï†ÅÏùÑ Í∏∞Î°ù
                        }
                    }
                }
            }
        }
        enemies=enemies.filter(e=>{
            if(e.dead)return false;
            e.update();e.draw();
            if(Math.hypot(e.x-core.x,e.y-core.y)<core.radius+e.radius){
                // [ÏàòÏ†ï] Î∞©Ïñ¥Î†• Ï†ÅÏö©
                const def = 1 - (saveFile.upgrades.defense * 0.05);
                core.hp -= 10 * def;
                
                updateUi();
                canvas.style.transform=`translate(${Math.random()*10-5}px,${Math.random()*10-5}px)`;
                setTimeout(()=>canvas.style.transform='translate(0,0)',50);
                if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;return false;
            }
            return true;
        });
        for(let i=particles.length-1;i>=0;i--){particles[i].update();particles[i].draw();if(particles[i].life<=0)particles.splice(i,1);}
        ctx.restore();
        
        // [Ï∂îÍ∞Ä] 1Ï¥àÎßàÎã§ DPS ÏóÖÎç∞Ïù¥Ìä∏
        if (frame % 60 === 0) {
            updateDps();
        }
    }
    
    resize();
</script>
</body>
</html>
