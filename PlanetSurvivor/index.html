<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planet Survivor: Ultimate Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d1117; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 15px; left: 15px; pointer-events: none; width: 240px; max-width: 50%; z-index: 10; }
        #boss-hud { display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 60%; max-width: 600px; height: 30px; z-index: 20; pointer-events: none; }
        #boss-hud.active { display: block; animation: slideDown 0.5s ease-out; }
        .boss-name { text-align: center; font-weight: bold; color: #ef4444; text-shadow: 0 0 5px black; margin-bottom: 5px; font-size: 18px; }
        .boss-bar-bg { width: 100%; height: 100%; background: #333; border: 2px solid #555; border-radius: 5px; overflow: hidden; }
        #boss-hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ef4444, #b91c1c); transition: width 0.1s linear; }
        #warning-msg { display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #ef4444; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red; z-index: 30; pointer-events: none; animation: blink 0.5s infinite alternate; }
        @keyframes slideDown { from { top: -50px; } to { top: 20px; } }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }
        .stat-box { background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px; border: 1px solid #444; margin-bottom: 6px; font-size: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .bar-container { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 4px; }
        #hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #xp-bar { width: 0%; height: 100%; background: #f1c40f; transition: width 0.2s; }
        #weapon-slots { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        .slot { width: 32px; height: 32px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 16px; position: relative; }
        .slot .level-badge { position: absolute; bottom: -2px; right: -2px; background: #333; font-size: 9px; padding: 1px 3px; border-radius: 3px; border: 1px solid #777; }
        #upgrade-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; padding: 20px; box-sizing: border-box; }
        #upgrade-menu.active { display: flex !important; }
        .cards-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 100%; max-height: 80vh; overflow-y: auto; }
        .card { background: linear-gradient(145deg, #1f2937, #111827); border: 2px solid #374151; width: 180px; padding: 15px; border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; position: relative; overflow: hidden; flex-shrink: 0; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .card:hover { transform: translateY(-5px); }
        .card h3 { margin: 8px 0; font-size: 15px; color: #fff; }
        .card p { font-size: 12px; color: #ccc; line-height: 1.4; }
        .card-icon { font-size: 36px; margin-bottom: 8px; display: block; }
        .card.common { border-color: #9ca3af; }
        .card.uncommon { border-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .card.rare { border-color: #3b82f6; box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .card.epic { border-color: #a855f7; box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); background: linear-gradient(145deg, #2e1065, #111827); }
        .card.legendary { border-color: #eab308; box-shadow: 0 0 25px rgba(234, 179, 8, 0.6); background: linear-gradient(145deg, #422006, #111827); animation: pulse-gold 2s infinite; }
        .card.special { border-color: #f43f5e; box-shadow: 0 0 25px rgba(244, 63, 94, 0.5); background: linear-gradient(145deg, #4c0519, #111827); }
        @keyframes pulse-gold { 0% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } 50% { box-shadow: 0 0 30px rgba(234, 179, 8, 0.8); } 100% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } }
        .card-tag { position: absolute; top: 8px; right: 8px; font-size: 9px; padding: 2px 5px; border-radius: 3px; background: #333; color: white; font-weight: bold; }
        .card.common .card-tag { background: #4b5563; } .card.uncommon .card-tag { background: #059669; } .card.rare .card-tag { background: #2563eb; } .card.epic .card-tag { background: #7c3aed; } .card.legendary .card-tag { background: #ca8a04; color: black; } .card.special .card-tag { background: #e11d48; }
        @media (max-width: 600px) { .cards-container { flex-direction: column; align-items: center; gap: 10px; } .card { width: 90%; max-width: 320px; display: flex; flex-direction: row; align-items: center; text-align: left; padding: 10px; min-height: 70px; } .card-icon { font-size: 28px !important; margin: 0 15px 0 0 !important; width: 40px; text-align: center; } .card h3 { margin: 0 0 4px 0 !important; font-size: 16px !important; } .card p { margin: 0 !important; } .card-tag { top: 50% !important; transform: translateY(-50%); right: 10px !important; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>HP</span><span id="hp-text">100/100</span></div><div class="bar-container"><div id="hp-bar"></div></div></div>
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>EXP (Lv.<span id="level-text">1</span>)</span><span id="xp-text">0%</span></div><div class="bar-container"><div id="xp-bar"></div></div></div>
    <div class="stat-box" style="text-align: center;"><span style="font-size: 11px; color:#aaa;">SCORE</span><br><span id="score-text" style="font-size: 16px; font-weight: bold;">0</span></div>
    <div id="weapon-slots"></div>
</div>

<div id="boss-hud"><div class="boss-name">‚ö†Ô∏è GIANT PLANET EATER ‚ö†Ô∏è</div><div class="boss-bar-bg"><div id="boss-hp-bar"></div></div></div>
<div id="warning-msg">WARNING!<br><span style="font-size:30px">BOSS APPROACHING</span></div>

<div id="upgrade-menu"><h1 style="color:white; margin-bottom:10px; font-size: 24px;">LEVEL UP!</h1><div class="cards-container" id="cards-area"></div></div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const cardsArea = document.getElementById('cards-area');
    const weaponSlotsContainer = document.getElementById('weapon-slots');
    const bossHud = document.getElementById('boss-hud');
    const bossHpBar = document.getElementById('boss-hp-bar');
    const warningMsg = document.getElementById('warning-msg');
    
    const ZOOM_SCALE = 0.7;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* ================= DB & Constants ================= */
    const RARITY = {
        COMMON: { name: 'Common', color: 'common', mult: 1.0, chance: 50 },
        UNCOMMON: { name: 'Uncommon', color: 'uncommon', mult: 1.5, chance: 30 },
        RARE: { name: 'Rare', color: 'rare', mult: 2.0, chance: 15 },
        EPIC: { name: 'Epic', color: 'epic', mult: 3.0, chance: 4 },
        LEGENDARY: { name: 'Legendary', color: 'legendary', mult: 5.0, chance: 1 }
    };

    const WEAPON_DB = {
        'MISSILE': { name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', icon: 'üöÄ', type: 'HOMING', baseDamage: 30, baseCooldown: 45, color: '#f59e0b', range: 600, projectileCount: 1, explosive: false, blastRadius: 150 },
        'BLASTER': { name: 'Í¥ëÏÑ† Îπî', icon: 'üî´', type: 'BEAM', baseDamage: 120, baseCooldown: 200, color: '#10b981', range: 1000, thickness: 50, projectileCount: 1 },
        'ORBITAL': { name: 'ÌîåÎùºÏ¶àÎßà Ïâ¥Îìú', icon: 'üõ°Ô∏è', type: 'ZONE', baseDamage: 8, baseCooldown: 0, color: '#8b5cf6', range: 170, hitRate: 12 },
        'SNIPER': { name: 'Î†àÏùºÍ±¥', icon: '‚ö°', type: 'PIERCING', baseDamage: 60, baseCooldown: 100, color: '#3b82f6', range: 800, projectileCount: 1, rearShot: false },
        'MICRO_SWARM': { name: 'ÎßàÏù¥ÌÅ¨Î°ú ÎØ∏ÏÇ¨Ïùº', icon: 'üéÜ', type: 'SWARM', baseDamage: 12, baseCooldown: 45, color: '#22d3ee', range: 500, projectileCount: 6, spread: 0.5 },
        'INTERCEPTOR': { name: 'ÏöîÍ≤© Ìé∏ÎåÄ', icon: 'üõ∏', type: 'UNIT', baseDamage: 18, baseCooldown: 30, color: '#e879f9', range: 300, unitCount: 1 },
        'TESLA': { name: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù', icon: 'üå©Ô∏è', type: 'CHAIN', baseDamage: 35, baseCooldown: 80, color: '#facc15', range: 400, bounceCount: 3 },
        'GRAVITY': { name: 'Ï§ëÎ†•Ïû• ÏÉùÏÑ±Í∏∞', icon: '‚ö´', type: 'SLOW_ZONE', baseDamage: 3, baseCooldown: 0, color: '#111827', range: 250, slowFactor: 0.5 }
    };

    const GAME_STATE = { PLAYING: 0, LEVEL_UP: 1, GAME_OVER: 2 };
    let currentState = GAME_STATE.PLAYING;
    let frame = 0; let score = 0;
    
    let projectiles=[], enemies=[], particles=[], beams=[], explosions=[], drones=[], lightnings=[], shockwaves=[];
    let boss = null; 
    const player = { level: 1, xp: 0, xpToNext: 150, weapons: [] };
    const core = { x: canvas.width/2, y: canvas.height/2, radius: 35, maxHp: 100, hp: 100, color: '#3b82f6' };

    /* ================= Classes ================= */
    class BeamEffect {
        constructor(x1, y1, x2, y2, color, thickness) {
            this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.color=color; this.thickness=thickness; this.life=30; this.maxLife=30;
        }
        update(){this.life--;}
        draw(){
            const alpha = this.life/this.maxLife; ctx.save();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle=this.color; ctx.lineWidth=this.thickness*alpha; ctx.lineCap='round'; ctx.globalAlpha=alpha; ctx.shadowBlur=20*alpha; ctx.shadowColor=this.color; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle='white'; ctx.lineWidth=(this.thickness/3)*alpha; ctx.stroke();
            ctx.restore();
        }
    }
    class LightningEffect {
        constructor(x1, y1, x2, y2, color) {
            this.points=[]; this.color=color; this.life=15; const steps=10; const dx=x2-x1; const dy=y2-y1;
            for(let i=0; i<=steps; i++) { const t=i/steps; let nx=x1+dx*t; let ny=y1+dy*t; if(i!==0 && i!==steps){nx+=(Math.random()-0.5)*30; ny+=(Math.random()-0.5)*30;} this.points.push({x:nx, y:ny}); }
        }
        update(){this.life--;}
        draw(){ctx.save(); ctx.globalAlpha=this.life/15; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); for(let i=1;i<this.points.length;i++)ctx.lineTo(this.points[i].x, this.points[i].y); ctx.strokeStyle=this.color; ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.stroke(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke(); ctx.restore();}
    }
    class Projectile {
        constructor(x, y, vx, vy, damage, color, isPiercing, isSmall=false) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.damage=damage; this.color=color; this.isPiercing=isPiercing; 
            this.radius=isSmall?2:(isPiercing?4:3); this.life=isSmall?60:200; this.hitList=[];
        }
        update(){this.x+=this.vx; this.y+=this.vy; this.life--;}
        draw(){ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();}
    }
    class Shockwave {
        constructor(x, y, maxRadius, color) {
            this.x = x; this.y = y; this.maxRadius = maxRadius; this.radius = 1; this.color = color; this.life = 30; this.maxLife = 30;
        }
        update() { this.radius += (this.maxRadius - this.radius) * 0.15; this.life--; }
        draw() {
            if(this.life <= 0) return;
            const alpha = this.life / this.maxLife;
            ctx.save();
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.lineWidth = 5 * alpha; ctx.strokeStyle = this.color; ctx.globalAlpha = alpha;
            ctx.stroke(); ctx.restore();
        }
    }
    class Explosion {
        constructor(x,y,r,c){
            this.x=x;this.y=y;this.maxR=r;this.r=10;this.c=c;this.life=20;
            // Ï∂©Í≤©Ìåå Ï∂îÍ∞Ä
            shockwaves.push(new Shockwave(x, y, r * 1.2, c));
            // ÌååÌé∏ Ï∂îÍ∞Ä
            for(let i=0; i<12; i++){
                particles.push(new Particle(x, y, c, (Math.random()-0.5)*10, (Math.random()-0.5)*10));
            }
        }
        update(){this.r+=(this.maxR-this.r)*0.25; this.life--;}
        draw(){
            ctx.save();
            ctx.globalAlpha=this.life/20; ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r*0.7,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }
    }
    class HomingMissile {
        constructor(x, y, target, damage, explosive, blastRadius) {
            this.x=x; this.y=y; this.target=target; this.damage=damage; this.explosive=explosive; this.speed=4; this.angle=Math.random()*Math.PI*2; this.life=300; this.radius=4;
            this.blastRadius = blastRadius || 100;
        }
        update() {
            if(!this.target || this.target.dead) this.target=this.findNewTarget();
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const ta=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                let d=ta-this.angle; while(d<=-Math.PI)d+=Math.PI*2; while(d>Math.PI)d-=Math.PI*2;
                let turnRate=0.15; if(dist<200)turnRate=0.35; if(dist<60)turnRate=1.0;
                this.angle+=d*turnRate;
            }
            this.x+=Math.cos(this.angle)*this.speed; this.y+=Math.sin(this.angle)*this.speed; this.life--;
            if(Math.random()<0.5) particles.push(new Particle(this.x,this.y,'#555'));
        }
        findNewTarget(){
            let n=null; let min=Infinity; if(boss && !boss.dead) return boss;
            enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n;
        }
        draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle=this.explosive?'#ef4444':'#f59e0b'; ctx.beginPath(); ctx.moveTo(6,0); ctx.lineTo(-4,4); ctx.lineTo(-4,-4); ctx.fill(); ctx.restore(); }
        explode(){
            explosions.push(new Explosion(this.x,this.y,this.blastRadius,'#ef4444'));
            if(boss && !boss.dead && Math.hypot(boss.x-this.x,boss.y-this.y)<this.blastRadius+boss.radius) boss.takeDamage(this.damage);
            enemies.forEach(e=>{ if(!e.dead && Math.hypot(e.x-this.x,e.y-this.y)<this.blastRadius) e.takeDamage(this.damage); });
        }
    }
    class InterceptorUnit {
        constructor(weaponData) {
            this.data=weaponData; this.x=core.x; this.y=core.y; this.angle=Math.random()*Math.PI*2; this.speed=3; this.target=null; this.cooldown=0;
        }
        update() {
            if(!this.target || this.target.dead) { this.target=this.findTarget(); if(!this.target) this.angle+=0.05; }
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const a=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                this.angle = a;
                if(dist>150){ this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed; }
                else{ this.x-=Math.cos(a)*(this.speed*0.5); this.y-=Math.sin(a)*(this.speed*0.5); }
                if(this.cooldown<=0){
                    projectiles.push(new Projectile(this.x, this.y, Math.cos(a)*15, Math.sin(a)*15, this.data.baseDamage, this.data.color, false, false));
                    projectiles[projectiles.length-1].radius=5; this.cooldown=this.data.baseCooldown;
                }
            } else {
                this.x+=Math.cos(this.angle)*this.speed; this.y+=Math.sin(this.angle)*this.speed;
                if(Math.hypot(this.x-core.x, this.y-core.y)>600) this.angle=Math.atan2(core.y-this.y, core.x-this.x);
            }
            if(this.cooldown>0) this.cooldown--;
        }
        findTarget(){ let n=null; let min=Infinity; if(boss && !boss.dead) return boss; enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n; }
        draw(){ ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle=this.data.color; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill(); ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(-8, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }
    class Enemy {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=100; const cx=canvas.width/2; const cy=canvas.height/2; const side=Math.floor(Math.random()*4);
             if(side===0){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy-vH/2-m;} else if(side===1){this.x=cx+vW/2+m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);} else if(side===2){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy+vH/2+m;} else{this.x=cx-vW/2-m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);}
             this.hp=20+(player.level*8); this.maxHp=this.hp; this.baseSpeed=0.5+Math.random()*0.5+(player.level*0.05); this.speed=this.baseSpeed; this.radius=12; this.color=`hsl(${Math.random()*60},70%,50%)`; this.dead=false; this.slowed=false; this.spiralDir=Math.random()<0.5?1:-1;
        }
        update(){ this.speed=this.baseSpeed; if(this.slowed){this.speed*=0.5; this.slowed=false;} const a=Math.atan2(core.y-this.y, core.x-this.x); const ma=a+(this.spiralDir*0.78); this.x+=Math.cos(ma)*this.speed; this.y+=Math.sin(ma)*this.speed; }
        takeDamage(d){ 
            if(this.dead)return false; 
            this.hp-=d; 
            // ÌÉÄÍ≤© Ïù¥ÌéôÌä∏ (Ïä§ÌååÌÅ¨)
            for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, '#fff', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 10));
            
            if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} 
            return false; 
        }
        die(){ for(let i=0;i<5;i++)particles.push(new Particle(this.x,this.y,this.color)); addXp(10+player.level); score+=10; }
        draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); if(this.hp<this.maxHp){ const w=20*(Math.max(0,this.hp)/this.maxHp); ctx.fillStyle='red';ctx.fillRect(this.x-10,this.y-18,20,3); ctx.fillStyle='#0f0';ctx.fillRect(this.x-10,this.y-18,w,3); } }
    }
    class Boss {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=150; const cx=canvas.width/2; const cy=canvas.height/2; this.x=cx; this.y=cy-vH/2-m;
             this.maxHp=1000+(player.level*200); this.hp=this.maxHp; this.speed=0.3; this.radius=60; this.color='#ef4444'; this.shake=0; this.dead=false;
        }
        update(){ const a=Math.atan2(core.y-this.y, core.x-this.x); this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed; bossHpBar.style.width=`${Math.max(0,(this.hp/this.maxHp)*100)}%`; if(this.shake>0)this.shake--; }
        takeDamage(d){ if(this.dead)return false; this.hp-=d; this.shake=5; if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} return false; }
        die(){ for(let i=0;i<50;i++)particles.push(new Particle(this.x+(Math.random()-0.5)*100, this.y+(Math.random()-0.5)*100, this.color)); explosions.push(new Explosion(this.x,this.y,300,'#fff')); addXp(500); score+=1000; boss=null; bossHud.classList.remove('active'); canvas.style.transform=`translate(${Math.random()*20-10}px, ${Math.random()*20-10}px)`; setTimeout(()=>canvas.style.transform='translate(0,0)', 200); }
        draw(){ const sx=(Math.random()-0.5)*this.shake; const sy=(Math.random()-0.5)*this.shake; ctx.save(); ctx.translate(this.x+sx, this.y+sy); ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.fillStyle='rgba(239, 68, 68, 0.2)'; ctx.fill(); ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); ctx.strokeStyle='#7f1d1d'; ctx.lineWidth=5; ctx.stroke(); ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(-20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-30,20); ctx.quadraticCurveTo(0,50,30,20); ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.stroke(); ctx.restore(); }
    }
    class Particle { 
        constructor(x,y,c,vx,vy,life){this.x=x;this.y=y;this.c=c;this.vx=vx||(Math.random()-0.5)*4;this.vy=vy||(Math.random()-0.5)*4;this.life=life||1;} 
        update(){this.x+=this.vx;this.y+=this.vy;this.life-=0.05;} 
        draw(){ctx.globalAlpha=Math.max(0,this.life);ctx.fillStyle=this.c;ctx.beginPath();ctx.arc(this.x,this.y,2,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;} 
    }
    // Ï§ëÎ†•Ïû• Ï†ÑÏö© ÌååÌã∞ÌÅ¥ (Ï§ëÏã¨ÏúºÎ°ú Îπ®Î†§Îì§Ïñ¥Í∞ê)
    class GravityParticle {
        constructor(x, y, tx, ty, color) {
            this.x = x; this.y = y; this.tx = tx; this.ty = ty; this.color = color;
            this.life = 1.0;
            const angle = Math.atan2(ty - y, tx - x);
            this.speed = 2 + Math.random() * 3;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            // Ï§ëÏã¨ÏúºÎ°ú Í∞àÏàòÎ°ù Í∞ÄÏÜç
            this.vx *= 1.05; this.vy *= 1.05;
            this.life -= 0.05;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            // Í∏∏Ï≠âÌïú ÌòïÌÉúÎ°ú Í∑∏Î¶º (Îπ®Î†§Îì§Ïñ¥Í∞ÄÎäî ÎäêÎÇå)
            ctx.ellipse(this.x, this.y, 4, 1, Math.atan2(this.vy, this.vx), 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    /* ================= Weapon System ================= */
    class Weapon {
        constructor(id) {
            this.id=id; this.level=1; this.upgradeCount=0;
            this.baseData=JSON.parse(JSON.stringify(WEAPON_DB[id])); this.currentData=JSON.parse(JSON.stringify(WEAPON_DB[id]));
            this.cooldownTimer=0; this.angle=Math.random()*Math.PI*2; this.orbitRadius=55+(Math.random()*10); this.orbitSpeed=0.02+(Math.random()*0.02); this.tickTimer=0;
            if(this.id==='INTERCEPTOR'){ this.units=[]; this.spawnUnits(); }
        }
        spawnUnits(){ const count=this.currentData.unitCount||1; while(this.units.length<count){ const u=new InterceptorUnit(this.currentData); this.units.push(u); drones.push(u); } }
        
        applyGeneralUpgrade(rarityMult, type) {
            this.level++;
            const boost = 0.10 * rarityMult; 
            
            if (type === 'DAMAGE') {
                this.currentData.baseDamage = Math.floor(this.currentData.baseDamage * (1 + boost));
            } else if (type === 'COOLDOWN') {
                this.currentData.baseCooldown = Math.max(5, Math.floor(this.currentData.baseCooldown * (1 - (boost * 0.8))));
            } else if (type === 'RANGE') {
                if(this.currentData.range) this.currentData.range = Math.floor(this.currentData.range * (1 + boost));
                if(this.currentData.thickness) this.currentData.thickness = Math.floor(this.currentData.thickness * (1 + boost));
                if(this.currentData.blastRadius) this.currentData.blastRadius = Math.floor(this.currentData.blastRadius * (1 + boost));
            } else if (type === 'COUNT') {
                if (this.currentData.projectileCount !== undefined) this.currentData.projectileCount++;
                if (this.currentData.unitCount !== undefined) { this.currentData.unitCount++; this.spawnUnits(); }
                if (this.currentData.bounceCount !== undefined) this.currentData.bounceCount++;
            }
        }

        applySpecialUpgrade() {
            this.level++;
            if(this.id === 'BLASTER') { 
                this.currentData.projectileCount += 2; 
                this.currentData.spread = 0.3;
                this.currentData.thickness += 30;
                this.currentData.baseDamage *= 2;
            }
            if(this.id === 'MISSILE') { 
                this.currentData.explosive = true;
                this.currentData.baseDamage *= 2;
                this.currentData.blastRadius = 250;
            }
            if(this.id === 'ORBITAL') { 
                this.currentData.range += 100;
                this.currentData.baseDamage *= 1.5;
                this.currentData.hitRate = 5; 
            }
            if(this.id === 'SNIPER') { 
                this.currentData.rearShot = true;
                this.currentData.projectileCount += 1;
            }
            if(this.id === 'MICRO_SWARM') { 
                this.currentData.projectileCount = 20; 
                this.currentData.spread = 6.28; 
                this.currentData.baseCooldown = 20; 
            }
            if(this.id === 'INTERCEPTOR') { 
                this.currentData.unitCount += 3; 
                this.spawnUnits();
            }
            if(this.id === 'TESLA') { 
                this.currentData.bounceCount += 10;
                this.currentData.range += 200;
            }
            if(this.id === 'GRAVITY') { 
                this.currentData.range += 150;
                this.currentData.slowFactor = 0.2; 
                this.currentData.baseDamage *= 3;
            }
        }

        update() {
            this.angle+=this.orbitSpeed; if(this.cooldownTimer>0)this.cooldownTimer--;
            if(this.currentData.type==='ZONE'||this.currentData.type==='SLOW_ZONE') this.updateZone();
            else if(this.currentData.type!=='UNIT' && this.cooldownTimer<=0) this.fire();
        }
        draw() {
            if(this.currentData.type==='UNIT')return;
            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            ctx.beginPath(); ctx.moveTo(core.x,core.y); ctx.lineTo(wx,wy); ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.stroke();
            ctx.beginPath(); ctx.arc(wx,wy,8,0,Math.PI*2); ctx.fillStyle=this.currentData.color; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke();
            
            // ÏùºÎ∞ò Ïò§Îùº Ï°¥ (ORBITAL)
            if(this.currentData.type==='ZONE'){ 
                ctx.beginPath();ctx.arc(core.x,core.y,this.currentData.range,0,Math.PI*2);
                ctx.fillStyle='rgba(139,92,246,0.1)';ctx.fill();
                ctx.strokeStyle='rgba(139,92,246,0.4)';ctx.lineWidth=2;ctx.stroke();
            }
            // Ï§ëÎ†•Ïû• (GRAVITY) - ÏãúÍ∞Å Ìö®Í≥º Í∞ïÌôî
            if(this.currentData.type==='SLOW_ZONE'){ 
                ctx.save();
                ctx.translate(core.x, core.y);
                // ÌöåÏ†ÑÌïòÎäî Ìö®Í≥º
                ctx.rotate(frame * 0.02);
                ctx.beginPath();
                ctx.arc(0,0,this.currentData.range,0,Math.PI*2);
                const grad = ctx.createRadialGradient(0,0,this.currentData.range*0.2, 0,0,this.currentData.range);
                grad.addColorStop(0, 'rgba(0,0,0,0.8)'); // Ï§ëÏã¨ Î∏îÎûôÌôÄ
                grad.addColorStop(0.5, 'rgba(0,0,0,0.4)');
                grad.addColorStop(1, 'rgba(100,100,100,0.1)');
                ctx.fillStyle = grad;
                ctx.fill();
                
                // Ïô∏Í≥ΩÏÑ† ÏÜåÏö©ÎèåÏù¥
                ctx.beginPath();
                for(let i=0; i<3; i++) {
                    ctx.arc(0, 0, this.currentData.range * (0.8 + i*0.1), i + frame*0.05, i + frame*0.05 + Math.PI);
                }
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }
        fire() {
            const range=this.currentData.range; let target=null; let bossInRange=false;
            if(boss && !boss.dead && Math.hypot(boss.x-core.x, boss.y-core.y)<=range) { target=boss; bossInRange=true; }
            if(!bossInRange) { let min=range; enemies.forEach(e=>{if(e.dead)return; const d=Math.hypot(e.x-core.x, e.y-core.y); if(d<=min){min=d; target=e;}}); }
            if(!target && this.currentData.type!=='ZONE' && this.currentData.type!=='SLOW_ZONE') return;

            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            const count=this.currentData.projectileCount||1; const spread=this.currentData.spread||0.2;

            for(let i=0; i<count; i++) {
                let angleOffset=(count>1)?(i-(count-1)/2)*spread:0;
                if(this.currentData.type==='BEAM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset;
                    const endX=wx+Math.cos(fa)*2000; const endY=wy+Math.sin(fa)*2000;
                    beams.push(new BeamEffect(wx,wy,endX,endY,this.currentData.color,this.currentData.thickness));
                    if(boss && !boss.dead && pointToLineDistance(boss.x,boss.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+boss.radius) boss.takeDamage(this.currentData.baseDamage);
                    enemies.forEach(e=>{if(!e.dead && pointToLineDistance(e.x,e.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+e.radius) e.takeDamage(this.currentData.baseDamage);});
                } else if(this.currentData.type==='HOMING') {
                    projectiles.push(new HomingMissile(wx,wy,target,this.currentData.baseDamage,this.currentData.explosive,this.currentData.blastRadius));
                } else if(this.currentData.type==='SWARM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+(Math.random()-0.5)*spread*2;
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*6,Math.sin(fa)*6,this.currentData.baseDamage,this.currentData.color,false,true));
                } else if(this.currentData.type==='CHAIN') {
                    this.castLightning(target,this.currentData.baseDamage,this.currentData.bounceCount||3); break;
                } else {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset; const ps=(this.currentData.type==='PIERCING')?25:8;
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*ps,Math.sin(fa)*ps,this.currentData.baseDamage,this.currentData.color,this.currentData.type==='PIERCING',this.currentData.explosive));
                    if(this.currentData.rearShot) projectiles.push(new Projectile(wx,wy,Math.cos(fa+Math.PI)*ps,Math.sin(fa+Math.PI)*ps,this.currentData.baseDamage,this.currentData.color,this.currentData.type==='PIERCING',this.currentData.explosive));
                }
            }
            this.cooldownTimer=this.currentData.baseCooldown;
        }
        castLightning(t,d,b){ let c=t; let v=[c]; c.takeDamage(d); lightnings.push(new LightningEffect(core.x,core.y,c.x,c.y,this.currentData.color)); for(let i=0;i<b;i++){ let n=null; let min=300; enemies.forEach(e=>{if(e.dead||e===c||v.includes(e))return; const dist=Math.hypot(e.x-c.x,e.y-c.y); if(dist<min){min=dist;n=e;}}); if(n){lightnings.push(new LightningEffect(c.x,c.y,n.x,n.y,this.currentData.color)); n.takeDamage(d); v.push(n); c=n;}else break; } }
        updateZone() {
            this.tickTimer++;
            if(this.currentData.type==='SLOW_ZONE'){
                // Ï§ëÎ†•Ïû• Ïù¥ÌéôÌä∏: ÏûÖÏûê Îπ®ÏïÑÎì§Ïù¥Í∏∞
                if(frame % 3 === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = this.currentData.range;
                    // Í∞ÄÏû•ÏûêÎ¶¨ÏóêÏÑú ÏÉùÏÑ±
                    const px = core.x + Math.cos(angle) * dist;
                    const py = core.y + Math.sin(angle) * dist;
                    // ÏΩîÏñ¥ Ï™ΩÏúºÎ°ú Îπ®Î†§Îì§Ïñ¥Í∞ÄÎäî GravityParticle ÏÉùÏÑ±
                    particles.push(new GravityParticle(px, py, core.x, core.y, this.currentData.color));
                }

                if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius && this.tickTimer%10===0) boss.takeDamage(this.currentData.baseDamage);
                enemies.forEach(e=>{if(!e.dead && Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius){ e.slowed=true; if(this.tickTimer%10===0)e.takeDamage(this.currentData.baseDamage);}}); return;
            }
            if(this.tickTimer%(this.currentData.hitRate||10)!==0)return;
            if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius) boss.takeDamage(this.currentData.baseDamage);
            enemies.forEach(e=>{if(!e.dead&&Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius) e.takeDamage(this.currentData.baseDamage);});
        }
    }

    addWeapon('MISSILE');
    function pointToLineDistance(px,py,x1,y1,x2,y2){ const A=px-x1;const B=py-y1;const C=x2-x1;const D=y2-y1; const dot=A*C+B*D;const len=C*C+D*D; let param=-1;if(len!==0)param=dot/len; let xx,yy;if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;} const dx=px-xx;const dy=py-yy; return Math.sqrt(dx*dx+dy*dy); }
    function addWeapon(id){ if(player.weapons.length>=6)return; player.weapons.push(new Weapon(id)); renderWeaponSlots(); }
    function addXp(amount){ player.xp+=amount; if(player.xp>=player.xpToNext)levelUp(); updateUi(); }
    function levelUp(){ player.level++; player.xp=0; player.xpToNext=Math.floor(player.xpToNext*1.15); if(player.level%5===0 && !boss)spawnBoss(); currentState=GAME_STATE.LEVEL_UP; generateUpgradeCards(); upgradeMenu.classList.add('active'); }
    function spawnBoss(){ boss=new Boss(); bossHud.classList.add('active'); warningMsg.style.display='block'; setTimeout(()=>warningMsg.style.display='none',3000); }
    function rollRarity(){ const r=Math.random()*100; if(r<50)return RARITY.COMMON; if(r<80)return RARITY.UNCOMMON; if(r<95)return RARITY.RARE; if(r<99)return RARITY.EPIC; return RARITY.LEGENDARY; }
    function generateUpgradeCards(){
        cardsArea.innerHTML=''; const options=[];
        player.weapons.forEach((w,i)=>{
            if((w.level+1)%5===0) options.push({type:'SPECIAL', weapon:w, index:i, desc:getSpecialDesc(w)});
            else {
                // ÏùºÎ∞ò ÏóÖÍ∑∏Î†àÏù¥Îìú ÌÉÄÏûÖ ÎûúÎç§
                let type='DAMAGE'; const rnd=Math.random();
                if(rnd<0.35) type='DAMAGE'; else if(rnd<0.70) type='COOLDOWN'; else if(rnd<0.95) type='RANGE'; else type='COUNT';
                const rarity=rollRarity();
                if(type==='COUNT' && rarity.name==='Common') type='RANGE';
                options.push({type:'GENERAL', weapon:w, index:i, statType:type, rarity:rarity});
            }
        });
        if(player.weapons.length<6) Object.keys(WEAPON_DB).forEach(id=>{if(!player.weapons.some(w=>w.id===id))options.push({type:'NEW', id:id});});
        options.push({type:'HEAL'}); options.sort(()=>Math.random()-0.5); options.slice(0,3).forEach(opt=>createCard(opt));
    }
    function getSpecialDesc(w){
        if(w.id==='BLASTER')return"Ìä∏ÎùºÏù¥ÎçòÌä∏ Îπî (3Í∞àÎûò Î∞úÏÇ¨)";
        if(w.id==='MISSILE')return"Îâ¥ÌÅ¥Î¶¨Ïñ¥ (Ï¥àÍ¥ëÏó≠ Ìè≠Î∞ú)";
        if(w.id==='ORBITAL')return"Î≥¥Ïù¥Îìú Ï°¥ (Î≤îÏúÑ/Îç∞ÎØ∏ÏßÄ Í∑πÎåÄÌôî)";
        if(w.id==='SNIPER')return"Î¶¨ÏΩîÏéº ÌÉÑÌôò (Ï†ÅÏ§ë Ïãú ÌäïÍπÄ)";
        if(w.id==='MICRO_SWARM')return"Ïò¥Îãà Î≤ÑÏä§Ìä∏ (360ÎèÑ Ï†ÑÎ∞©Ìñ• ÎÇúÏÇ¨)";
        if(w.id==='INTERCEPTOR')return"Ïö∞Ï£º Î™®Ìï® (Ìé∏ÎåÄ 4Í∏∞Î°ú Ï¶ùÍ∞Ä)";
        if(w.id==='TESLA')return"ÎáåÏã† (Ï†ÑÏù¥ ÌöüÏàò/Î≤îÏúÑ ÎåÄÌè≠ Ï¶ùÍ∞Ä)";
        if(w.id==='GRAVITY')return"Ïù¥Î≤§Ìä∏ Ìò∏ÎùºÏù¥Ï¶å (80% Í∞êÏÜç)";
        return"Í∂ÅÍ∑π ÏßÑÌôî";
    }
    function createCard(opt){
        const card=document.createElement('div'); card.className='card'; let title,desc,icon,tagName;
        if(opt.type==='NEW'){ const d=WEAPON_DB[opt.id]; title=d.name; desc="Ïã†Í∑ú Î¨¥Í∏∞ ÌöçÎìù"; icon=d.icon; card.classList.add('uncommon'); tagName='NEW'; }
        else if(opt.type==='SPECIAL'){ const w=opt.weapon; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}‚û§${w.level+1}</span>`; desc=`<span style="color:#f43f5e;font-weight:bold">üî• ULTIMATE üî•</span><br>${opt.desc}`; icon=w.currentData.icon; card.classList.add('special'); tagName='EVO'; }
        else if(opt.type==='GENERAL'){
            const w=opt.weapon; const r=opt.rarity; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}‚û§${w.level+1}</span>`;
            let txt='Í≥µÍ≤©Î†•', val=Math.floor(10*r.mult)+'%';
            if(opt.statType==='COOLDOWN'){txt='Í≥µÍ≤©ÏÜçÎèÑ';} 
            if(opt.statType==='RANGE'){
                txt='Î≤îÏúÑ/ÌÅ¨Í∏∞';
                if(w.id==='MISSILE') txt='ÏÇ¨Í±∞Î¶¨/Ìè≠Î∞úÎ∞òÍ≤Ω';
            } 
            if(opt.statType==='COUNT'){txt='Î∞úÏÇ¨Ï≤¥ Ïàò'; val='+1';}
            desc=`${txt} <span style="color:${getColor(r.name)};font-weight:bold">+${val}</span>`; icon=w.currentData.icon; card.classList.add(r.color); tagName=r.name.toUpperCase();
        } else { title="Í∏¥Í∏â ÏàòÎ¶¨"; desc="Ï≤¥Î†• 50% ÌöåÎ≥µ"; icon="‚ù§Ô∏è"; card.classList.add('common'); tagName='ITEM'; }
        function getColor(n){if(n==='Legendary')return'#eab308';if(n==='Epic')return'#a855f7';if(n==='Rare')return'#3b82f6';if(n==='Uncommon')return'#10b981';return'#9ca3af';}
        card.innerHTML=`<div class="card-tag">${tagName}</div><div class="card-icon">${icon}</div><h3>${title}</h3><p>${desc}</p>`;
        card.onclick=()=>{
            if(opt.type==='NEW')addWeapon(opt.id);
            else if(opt.type==='SPECIAL')opt.weapon.applySpecialUpgrade();
            else if(opt.type==='GENERAL')opt.weapon.applyGeneralUpgrade(opt.rarity.mult, opt.statType);
            else if(opt.type==='HEAL')core.hp=Math.min(core.hp+50, core.maxHp);
            renderWeaponSlots(); updateUi(); upgradeMenu.classList.remove('active'); currentState=GAME_STATE.PLAYING;
        }; cardsArea.appendChild(card);
    }
    function renderWeaponSlots(){ weaponSlotsContainer.innerHTML=''; for(let i=0;i<6;i++){ const slot=document.createElement('div'); slot.className='slot'; if(player.weapons[i]){ const w=player.weapons[i]; slot.innerHTML=`${w.currentData.icon}<div class="level-badge">${w.level}</div>`; slot.style.borderColor=w.currentData.color; slot.style.boxShadow=`0 0 5px ${w.currentData.color}`; }else slot.innerHTML='<span style="color:#333;font-size:12px">EMPTY</span>'; weaponSlotsContainer.appendChild(slot); } }
    function updateUi(){ document.getElementById('hp-text').innerText=`${Math.ceil(core.hp)}/${core.maxHp}`; document.getElementById('hp-bar').style.width=`${(core.hp/core.maxHp)*100}%`; document.getElementById('level-text').innerText=player.level; document.getElementById('xp-text').innerText=`${Math.floor((player.xp/player.xpToNext)*100)}%`; document.getElementById('xp-bar').style.width=`${(player.xp/player.xpToNext)*100}%`; document.getElementById('score-text').innerText=score; }
    function animate(){
        requestAnimationFrame(animate);
        if(currentState===GAME_STATE.LEVEL_UP)return;
        if(currentState===GAME_STATE.GAME_OVER){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='red';ctx.font='bold 40px sans-serif';ctx.textAlign='center';ctx.fillText("MISSION FAILED",canvas.width/2,canvas.height/2);ctx.fillStyle='white';ctx.font='20px sans-serif';ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+50);return;}
        ctx.fillStyle='rgba(13, 17, 23, 0.2)';ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.save(); ctx.translate(canvas.width/2,canvas.height/2); ctx.scale(ZOOM_SCALE,ZOOM_SCALE); ctx.translate(-canvas.width/2,-canvas.height/2);
        frame++;
        if(!boss){ const rate=Math.max(5, 50-(player.level*3)); if(frame%rate===0)enemies.push(new Enemy()); }
        ctx.beginPath();ctx.arc(core.x,core.y,core.radius,0,Math.PI*2);ctx.fillStyle=core.color;ctx.shadowBlur=20;ctx.shadowColor=core.color;ctx.fill();ctx.shadowBlur=0;
        player.weapons.forEach(w=>{w.update();w.draw();}); drones.forEach(d=>{d.update();d.draw();});
        if(boss&&!boss.dead){boss.update();boss.draw();if(Math.hypot(boss.x-core.x,boss.y-core.y)<core.radius+boss.radius){core.hp-=0.5;updateUi();if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;}}
        for(let i=beams.length-1;i>=0;i--){beams[i].update();beams[i].draw();if(beams[i].life<=0)beams.splice(i,1);}
        for(let i=explosions.length-1;i>=0;i--){explosions[i].update();explosions[i].draw();if(explosions[i].life<=0)explosions.splice(i,1);}
        for(let i=shockwaves.length-1;i>=0;i--){shockwaves[i].update();shockwaves[i].draw();if(shockwaves[i].life<=0)shockwaves.splice(i,1);}
        for(let i=lightnings.length-1;i>=0;i--){lightnings[i].update();lightnings[i].draw();if(lightnings[i].life<=0)lightnings.splice(i,1);}
        const vW=canvas.width/ZOOM_SCALE;const vH=canvas.height/ZOOM_SCALE;const m=200;const cx=canvas.width/2;const cy=canvas.height/2;
        for(let i=projectiles.length-1;i>=0;i--){
            const p=projectiles[i]; p.update(); p.draw();
            if(p.life<=0||p.x<cx-vW/2-m||p.x>cx+vW/2+m||p.y<cy-vH/2-m||p.y>cy+vH/2+m){projectiles.splice(i,1);continue;}
            if(boss&&!boss.dead&&Math.hypot(p.x-boss.x,p.y-boss.y)<boss.radius+p.radius){if(p.explosive){p.explode();projectiles.splice(i,1);continue;}boss.takeDamage(p.damage);particles.push(new Particle(p.x,p.y,p.color));if(!p.isPiercing){projectiles.splice(i,1);continue;}}
            for(let j=enemies.length-1;j>=0;j--){const e=enemies[j];if(e.dead)continue;if(Math.hypot(p.x-e.x,p.y-e.y)<e.radius+p.radius){if(p.explosive){p.explode();projectiles.splice(i,1);break;}else{const died=e.takeDamage(p.damage);if(!died)particles.push(new Particle(e.x,e.y,'#fff'));if(!p.isPiercing){projectiles.splice(i,1);break;}else if(!p.hitList.includes(e))p.hitList.push(e);}}}
        }
        enemies=enemies.filter(e=>{if(e.dead)return false;e.update();e.draw();if(Math.hypot(e.x-core.x,e.y-core.y)<core.radius+e.radius){core.hp-=10;updateUi();canvas.style.transform=`translate(${Math.random()*10-5}px,${Math.random()*10-5}px)`;setTimeout(()=>canvas.style.transform='translate(0,0)',50);if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;return false;}return true;});
        for(let i=particles.length-1;i>=0;i--){particles[i].update();particles[i].draw();if(particles[i].life<=0)particles.splice(i,1);}
        ctx.restore();
    }
    window.addEventListener('resize',()=>{canvas.width=window.innerWidth;canvas.height=window.innerHeight;core.x=canvas.width/2;core.y=canvas.height/2;});
    renderWeaponSlots(); updateUi(); animate();
</script>
</body>
</html>
