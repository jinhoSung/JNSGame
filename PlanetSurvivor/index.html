<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Planet Survivor: Ultimate Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d1117; color: white; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 15px; left: 15px; pointer-events: none; width: 240px; max-width: 50%; z-index: 10; }
        
        /* ì‚¬ìš´ë“œ UI */
        #sound-controls { position: absolute; top: 15px; right: 15px; z-index: 50; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.6); padding: 8px 12px; border-radius: 20px; border: 1px solid #444; pointer-events: auto; }
        #sound-btn { cursor: pointer; font-size: 20px; background: none; border: none; color: white; padding: 0; line-height: 1; }
        #volume-slider { width: 80px; height: 4px; -webkit-appearance: none; background: #555; border-radius: 2px; outline: none; cursor: pointer; }
        #volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }

        #boss-hud { display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 60%; max-width: 600px; height: 30px; z-index: 20; pointer-events: none; }
        #boss-hud.active { display: block; animation: slideDown 0.5s ease-out; }
        .boss-name { text-align: center; font-weight: bold; color: #ef4444; text-shadow: 0 0 5px black; margin-bottom: 5px; font-size: 18px; }
        .boss-bar-bg { width: 100%; height: 100%; background: #333; border: 2px solid #555; border-radius: 5px; overflow: hidden; }
        #boss-hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ef4444, #b91c1c); transition: width 0.1s linear; }
        #warning-msg { display: none; position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #ef4444; font-size: 50px; font-weight: bold; text-shadow: 0 0 20px red; z-index: 30; pointer-events: none; animation: blink 0.5s infinite alternate; }
        @keyframes slideDown { from { top: -50px; } to { top: 20px; } }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }
        .stat-box { background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px; border: 1px solid #444; margin-bottom: 6px; font-size: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .bar-container { width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 4px; }
        #hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        #xp-bar { width: 0%; height: 100%; background: #f1c40f; transition: width 0.2s; }
        #weapon-slots { display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap; }
        .slot { width: 32px; height: 32px; background: rgba(0,0,0,0.5); border: 1px solid #555; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 16px; position: relative; }
        .slot .level-badge { position: absolute; bottom: -2px; right: -2px; background: #333; font-size: 9px; padding: 1px 3px; border-radius: 3px; border: 1px solid #777; }
        #upgrade-menu { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; padding: 20px; box-sizing: border-box; }
        #upgrade-menu.active { display: flex !important; }
        .cards-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 100%; max-height: 80vh; overflow-y: auto; }
        .card { background: linear-gradient(145deg, #1f2937, #111827); border: 2px solid #374151; width: 180px; padding: 15px; border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; position: relative; overflow: hidden; flex-shrink: 0; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .card:hover { transform: translateY(-5px); }
        .card h3 { margin: 8px 0; font-size: 15px; color: #fff; }
        .card p { font-size: 12px; color: #ccc; line-height: 1.4; }
        .card-icon { font-size: 36px; margin-bottom: 8px; display: block; }
        .card.common { border-color: #9ca3af; }
        .card.uncommon { border-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .card.rare { border-color: #3b82f6; box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .card.epic { border-color: #a855f7; box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); background: linear-gradient(145deg, #2e1065, #111827); }
        .card.legendary { border-color: #eab308; box-shadow: 0 0 25px rgba(234, 179, 8, 0.6); background: linear-gradient(145deg, #422006, #111827); animation: pulse-gold 2s infinite; }
        .card.special { border-color: #f43f5e; box-shadow: 0 0 25px rgba(244, 63, 94, 0.5); background: linear-gradient(145deg, #4c0519, #111827); }
        @keyframes pulse-gold { 0% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } 50% { box-shadow: 0 0 30px rgba(234, 179, 8, 0.8); } 100% { box-shadow: 0 0 15px rgba(234, 179, 8, 0.4); } }
        .card-tag { position: absolute; top: 8px; right: 8px; font-size: 9px; padding: 2px 5px; border-radius: 3px; background: #333; color: white; font-weight: bold; }
        .card.common .card-tag { background: #4b5563; } .card.uncommon .card-tag { background: #059669; } .card.rare .card-tag { background: #2563eb; } .card.epic .card-tag { background: #7c3aed; } .card.legendary .card-tag { background: #ca8a04; color: black; } .card.special .card-tag { background: #e11d48; }
        @media (max-width: 600px) { .cards-container { flex-direction: column; align-items: center; gap: 10px; } .card { width: 90%; max-width: 320px; display: flex; flex-direction: row; align-items: center; text-align: left; padding: 10px; min-height: 70px; } .card-icon { font-size: 28px !important; margin: 0 15px 0 0 !important; width: 40px; text-align: center; } .card h3 { margin: 0 0 4px 0 !important; font-size: 16px !important; } .card p { margin: 0 !important; } .card-tag { top: 50% !important; transform: translateY(-50%); right: 10px !important; } }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>HP</span><span id="hp-text">100/100</span></div><div class="bar-container"><div id="hp-bar"></div></div></div>
    <div class="stat-box"><div style="display:flex; justify-content:space-between;"><span>EXP (Lv.<span id="level-text">1</span>)</span><span id="xp-text">0%</span></div><div class="bar-container"><div id="xp-bar"></div></div></div>
    <div class="stat-box" style="text-align: center;"><span style="font-size: 11px; color:#aaa;">SCORE</span><br><span id="score-text" style="font-size: 16px; font-weight: bold;">0</span></div>
    <div id="weapon-slots"></div>
</div>

<div id="sound-controls">
    <button id="sound-btn">ğŸ”Š</button>
    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
</div>

<div id="boss-hud"><div class="boss-name">âš ï¸ GIANT PLANET EATER âš ï¸</div><div class="boss-bar-bg"><div id="boss-hp-bar"></div></div></div>
<div id="warning-msg">WARNING!<br><span style="font-size:30px">BOSS APPROACHING</span></div>

<div id="upgrade-menu"><h1 style="color:white; margin-bottom:10px; font-size: 24px;">LEVEL UP!</h1><div class="cards-container" id="cards-area"></div></div>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const cardsArea = document.getElementById('cards-area');
    const weaponSlotsContainer = document.getElementById('weapon-slots');
    const bossHud = document.getElementById('boss-hud');
    const bossHpBar = document.getElementById('boss-hp-bar');
    const warningMsg = document.getElementById('warning-msg');
    
    // [ìˆ˜ì •] ë™ì  í•´ìƒë„ ë° ìœ„ì¹˜ ë³´ì •
    let ZOOM_SCALE = 1.0;
    const core = { x: 0, y: 0, radius: 35, maxHp: 100, hp: 100, color: '#3b82f6' };
    
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // ì°½ ë†’ì´ 900px ê¸°ì¤€ìœ¼ë¡œ ìŠ¤ì¼€ì¼ ì¡°ì • (ë„ˆë¬´ ì‘ì•„ì§€ì§€ ì•Šê²Œ ìµœì†Œê°’ 0.6)
        ZOOM_SCALE = Math.max(0.6, window.innerHeight / 900);
        
        // [ì¤‘ìš”] ë¦¬ì‚¬ì´ì¦ˆ ì‹œ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¥¼ í•­ìƒ í™”ë©´ ì¤‘ì•™ìœ¼ë¡œ ê°±ì‹ 
        core.x = canvas.width / 2;
        core.y = canvas.height / 2;
    }
    window.addEventListener('resize', resize);

    /* ================= Sound System (Improved Sci-Fi SFX) ================= */
    class SoundManager {
        constructor() {
            this.ctx = null;
            this.muted = false;
            this.volume = 0.5;
            this.initialized = false;
        }

        init() {
            if (this.initialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.initialized = true;
            } catch (e) { console.error("Web Audio API not supported"); }
        }

        // [ìˆ˜ì •] ì£¼íŒŒìˆ˜ ìŠ¬ë¼ì´ë“œ(Pitch Slide) ê¸°ëŠ¥ìœ¼ë¡œ ë” SFì ì¸ íš¨ê³¼ìŒ ìƒì„±
        playTone(freq, type, duration, volMult = 1.0, slideTo = null) {
            if (!this.ctx || this.muted) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            
            if (slideTo) {
                osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
            }

            gain.gain.setValueAtTime(this.volume * volMult, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }

        playNoise(duration, volMult = 1.0) {
            if (!this.ctx || this.muted) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            
            // í­ë°œìŒ í•„í„° ê°œì„  (ë¬µì§í•˜ê²Œ)
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1200, this.ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + duration);

            gain.gain.setValueAtTime(this.volume * volMult, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        }

        shoot() { this.playTone(800, 'sine', 0.15, 0.2, 100); } // í”¼ìŠ
        laser() { this.playTone(400, 'sawtooth', 0.1, 0.15); } // ì§€ì‰
        whoosh() { this.playTone(600, 'triangle', 0.3, 0.3, 200); } // ë¶€ë©”ë‘ ì†Œë¦¬
        hit() { this.playTone(200, 'square', 0.08, 0.2, 50); } // í½
        explosion() { this.playNoise(0.5, 0.7); } // ì¾…
        levelUp() { 
            if(!this.ctx || this.muted) return;
            [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { 
                setTimeout(() => this.playTone(f, 'sine', 0.4, 0.4), i * 80);
            });
        }
        warning() {
            if(!this.ctx || this.muted) return;
            this.playTone(200, 'sawtooth', 1.0, 0.5, 600);
            setTimeout(() => this.playTone(600, 'sawtooth', 1.0, 0.5, 200), 500);
        }
    }

    const audio = new SoundManager();
    const soundBtn = document.getElementById('sound-btn');
    const volumeSlider = document.getElementById('volume-slider');

    soundBtn.addEventListener('click', () => {
        audio.init(); 
        audio.muted = !audio.muted;
        soundBtn.innerText = audio.muted ? 'ğŸ”‡' : 'ğŸ”Š';
    });

    volumeSlider.addEventListener('input', (e) => {
        audio.init();
        audio.volume = parseFloat(e.target.value);
        if(audio.volume > 0 && audio.muted) {
            audio.muted = false;
            soundBtn.innerText = 'ğŸ”Š';
        }
    });
    
    window.addEventListener('mousedown', () => audio.init(), { once: true });


    /* ================= DB & Constants ================= */
    const RARITY = {
        COMMON: { name: 'Common', color: 'common', mult: 1.0, chance: 50 },
        UNCOMMON: { name: 'Uncommon', color: 'uncommon', mult: 1.5, chance: 30 },
        RARE: { name: 'Rare', color: 'rare', mult: 2.0, chance: 15 },
        EPIC: { name: 'Epic', color: 'epic', mult: 3.0, chance: 4 },
        LEGENDARY: { name: 'Legendary', color: 'legendary', mult: 5.0, chance: 1 }
    };

    const WEAPON_DB = {
        'MISSILE': { name: 'ìœ ë„ ë¯¸ì‚¬ì¼', icon: 'ğŸš€', type: 'HOMING', baseDamage: 30, baseCooldown: 45, color: '#f59e0b', range: 600, projectileCount: 1, explosive: true, blastRadius: 15 },
        'BLASTER': { name: 'ê´‘ì„  ë¹”', icon: 'ğŸ”«', type: 'BEAM', baseDamage: 120, baseCooldown: 200, color: '#10b981', range: 1000, thickness: 50, projectileCount: 1 },
        // [ìˆ˜ì •] ORBITAL(ì‹¤ë“œ) ì‚­ì œ -> BOOMERANG(ë¶€ë©”ë‘) ì¶”ê°€
        // ê´€í†µí˜•, ëŒì•„ì˜¤ëŠ” íŠ¹ì„±
        'BOOMERANG': { name: 'í”Œë¼ì¦ˆë§ˆ ë¶€ë©”ë‘', icon: 'ğŸªƒ', type: 'BOOMERANG', baseDamage: 45, baseCooldown: 70, color: '#8b5cf6', range: 400, projectileCount: 1, speed: 7, isPiercing: true },
        'SNIPER': { name: 'ë ˆì¼ê±´', icon: 'âš¡', type: 'PIERCING', baseDamage: 60, baseCooldown: 100, color: '#3b82f6', range: 800, projectileCount: 1, rearShot: false },
        'MICRO_SWARM': { name: 'ë§ˆì´í¬ë¡œ ë¯¸ì‚¬ì¼', icon: 'ğŸ†', type: 'SWARM', baseDamage: 12, baseCooldown: 45, color: '#22d3ee', range: 500, projectileCount: 6, spread: 0.5 },
        'INTERCEPTOR': { name: 'ìš”ê²© í¸ëŒ€', icon: 'ğŸ›¸', type: 'UNIT', baseDamage: 18, baseCooldown: 30, color: '#e879f9', range: 300, unitCount: 1, projectileCount: 1 },
        'TESLA': { name: 'ì²´ì¸ ë¼ì´íŠ¸ë‹', icon: 'ğŸŒ©ï¸', type: 'CHAIN', baseDamage: 35, baseCooldown: 80, color: '#facc15', range: 400, bounceCount: 3 },
        'GRAVITY': { name: 'ì¤‘ë ¥ì¥ ìƒì„±ê¸°', icon: 'âš«', type: 'SLOW_ZONE', baseDamage: 3, baseCooldown: 0, color: '#111827', range: 250, slowFactor: 0.5 }
    };

    const GAME_STATE = { PLAYING: 0, LEVEL_UP: 1, GAME_OVER: 2 };
    let currentState = GAME_STATE.PLAYING;
    let frame = 0; let score = 0;
    
    let projectiles=[], enemies=[], particles=[], beams=[], explosions=[], drones=[], lightnings=[], shockwaves=[];
    let boss = null; 
    const player = { level: 1, xp: 0, xpToNext: 150, weapons: [] };

    /* ================= Classes ================= */
    class BeamEffect {
        constructor(x1, y1, x2, y2, color, thickness) {
            this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.color=color; this.thickness=thickness; this.life=30; this.maxLife=30;
        }
        update(){this.life--;}
        draw(){
            const alpha = this.life/this.maxLife; ctx.save();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle=this.color; ctx.lineWidth=this.thickness*alpha; ctx.lineCap='round'; ctx.globalAlpha=alpha; ctx.shadowBlur=20*alpha; ctx.shadowColor=this.color; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.strokeStyle='white'; ctx.lineWidth=(this.thickness/3)*alpha; ctx.stroke();
            ctx.restore();
        }
    }
    class LightningEffect {
        constructor(x1, y1, x2, y2, color) {
            this.points=[]; this.color=color; this.life=15; const steps=10; const dx=x2-x1; const dy=y2-y1;
            for(let i=0; i<=steps; i++) { const t=i/steps; let nx=x1+dx*t; let ny=y1+dy*t; if(i!==0 && i!==steps){nx+=(Math.random()-0.5)*30; ny+=(Math.random()-0.5)*30;} this.points.push({x:nx, y:ny}); }
        }
        update(){this.life--;}
        draw(){ctx.save(); ctx.globalAlpha=this.life/15; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); for(let i=1;i<this.points.length;i++)ctx.lineTo(this.points[i].x, this.points[i].y); ctx.strokeStyle=this.color; ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.stroke(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke(); ctx.restore();}
    }
    class Projectile {
        constructor(x, y, vx, vy, damage, color, isPiercing, isSmall=false) {
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.damage=damage; this.color=color; this.isPiercing=isPiercing; 
            this.radius=isSmall?2:(isPiercing?4:3); this.life=isSmall?60:200; this.hitList=[];
            
            // [ìˆ˜ì •] ë¶€ë©”ë‘ ë¡œì§ìš© ì†ì„±
            this.behavior = null; 
            this.returnPhase = false;
            this.speed = 0; // ë¶€ë©”ë‘ìš© ìŠ¤í”¼ë“œ ì €ì¥
            this.rotation = 0; // íšŒì „ê°
        }
        update(){
            if(this.behavior === 'BOOMERANG') {
                // ë¶€ë©”ë‘: ë‚˜ê°”ë‹¤ê°€ í”Œë ˆì´ì–´ì—ê²Œ ëŒì•„ì˜´
                if(!this.returnPhase) {
                    // ë‚˜ê°€ëŠ” ë‹¨ê³„: ê°ì†
                    this.x += this.vx;
                    this.y += this.vy;
                    this.speed *= 0.94; // ë§ˆì°°ë¡œ ì†ë„ ì¤„ì„
                    // ì†ë„ ì¬ê³„ì‚°
                    this.vx *= 0.94;
                    this.vy *= 0.94;
                    
                    if(this.speed < 0.5) {
                        this.returnPhase = true;
                    }
                } else {
                    // ëŒì•„ì˜¤ëŠ” ë‹¨ê³„: í”Œë ˆì´ì–´ ìª½ìœ¼ë¡œ ê°€ì†
                    const angle = Math.atan2(core.y - this.y, core.x - this.x);
                    this.speed += 0.5; // ê°€ì†
                    if(this.speed > 15) this.speed = 15; // ìµœëŒ€ ì†ë„ ì œí•œ
                    
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // í”Œë ˆì´ì–´ì™€ ë‹¿ìœ¼ë©´ ì œê±°
                    if(Math.hypot(core.x - this.x, core.y - this.y) < 20) {
                        this.life = 0;
                    }
                }
                this.rotation += 0.4; // ë±…ê¸€ë±…ê¸€ íšŒì „
            } else {
                // ì¼ë°˜ íˆ¬ì‚¬ì²´
                this.x+=this.vx; this.y+=this.vy; this.life--;
            }
        }
        draw(){
            ctx.save();
            ctx.translate(this.x, this.y);
            if(this.behavior === 'BOOMERANG') {
                // ë¶€ë©”ë‘ ê·¸ë¦¬ê¸° (íšŒì „í•˜ëŠ” ë‚« ëª¨ì–‘)
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI*2);
                ctx.fill();
                // ë‚ ê°œ
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.quadraticCurveTo(8, 0, 0, 8);
                ctx.quadraticCurveTo(-3, 0, 0, -8);
                ctx.fill();
                ctx.beginPath();
                ctx.rotate(Math.PI/2);
                ctx.moveTo(0, -8);
                ctx.quadraticCurveTo(8, 0, 0, 8);
                ctx.quadraticCurveTo(-3, 0, 0, -8);
                ctx.fill();
            } else {
                // ì¼ë°˜ íƒ„í™˜
                ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
            }
            ctx.restore();
        }
    }
    class Shockwave {
        constructor(x, y, maxRadius, color) {
            this.x = x; this.y = y; this.maxRadius = maxRadius; this.radius = 1; this.color = color; this.life = 30; this.maxLife = 30;
        }
        update() { this.radius += (this.maxRadius - this.radius) * 0.15; this.life--; }
        draw() {
            if(this.life <= 0) return;
            const alpha = this.life / this.maxLife;
            ctx.save();
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.lineWidth = 5 * alpha; ctx.strokeStyle = this.color; ctx.globalAlpha = alpha;
            ctx.stroke(); ctx.restore();
        }
    }
    class Explosion {
        constructor(x,y,r,c, showArea=false){
            this.x=x;this.y=y;this.maxR=r;this.r=10;this.c=c;this.life=20;
            this.showArea = showArea; 
            shockwaves.push(new Shockwave(x, y, r * 1.0, c));
            const pCount = showArea ? 16 : 8;
            for(let i=0; i<pCount; i++){
                particles.push(new Particle(x, y, c, (Math.random()-0.5)*12, (Math.random()-0.5)*12));
            }
            audio.explosion(); 
        }
        update(){this.r+=(this.maxR-this.r)*0.25; this.life--;}
        draw(){
            ctx.save();
            ctx.globalAlpha=this.life/20; 
            if(this.showArea) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxR, 0, Math.PI*2);
                ctx.fillStyle = this.c;
                ctx.globalAlpha = (this.life/30) * 0.4; 
                ctx.fill();
                ctx.strokeStyle = this.c;
                ctx.lineWidth = 2;
                ctx.globalAlpha = this.life/20;
                ctx.stroke();
            }
            ctx.globalAlpha=this.life/20;
            ctx.fillStyle=this.c; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r*0.7,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }
    }
    class HomingMissile {
        constructor(x, y, target, damage, explosive, blastRadius) {
            this.x=x; this.y=y; this.target=target; this.damage=damage; this.explosive=explosive; this.speed=4; this.angle=Math.random()*Math.PI*2; this.life=300; this.radius=4;
            this.blastRadius = blastRadius || 120;
        }
        update() {
            if(!this.target || this.target.dead) this.target=this.findNewTarget();
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const ta=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                let d=ta-this.angle; while(d<=-Math.PI)d+=Math.PI*2; while(d>Math.PI)d-=Math.PI*2;
                let turnRate=0.15; if(dist<200)turnRate=0.35; if(dist<60)turnRate=1.0;
                this.angle+=d*turnRate;
            }
            this.x+=Math.cos(this.angle)*this.speed; this.y+=Math.sin(this.angle)*this.speed; this.life--;
            if(Math.random()<0.5) particles.push(new Particle(this.x,this.y,'#555', null, null, 1.0, 0.1, 0.9));
        }
        findNewTarget(){
            let n=null; let min=Infinity; if(boss && !boss.dead) return boss;
            enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n;
        }
        draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle); ctx.fillStyle=this.explosive?'#ef4444':'#f59e0b'; ctx.beginPath(); ctx.moveTo(6,0); ctx.lineTo(-4,4); ctx.lineTo(-4,-4); ctx.fill(); ctx.restore(); }
        
        explode(){
            explosions.push(new Explosion(this.x, this.y, this.blastRadius, '#ef4444', true));
            if(boss && !boss.dead) {
                const dist = Math.hypot(this.x - boss.x, this.y - boss.y);
                if (dist < this.blastRadius + boss.radius) {
                    boss.takeDamage(this.damage);
                }
            }
            enemies.forEach(e => { 
                if(!e.dead) {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < this.blastRadius + e.radius) {
                        e.takeDamage(this.damage);
                    }
                }
            });
        }
    }
    class InterceptorUnit {
        constructor(weaponData, index) {
            this.data=weaponData; 
            const startAngle = (Math.PI * 2 / 6) * index; 
            this.x=core.x + Math.cos(startAngle) * 100; 
            this.y=core.y + Math.sin(startAngle) * 100; 
            this.angle=startAngle; 
            this.speed=3.5; 
            this.target=null; 
            this.cooldown=0;
            this.idleAngleOffset = (Math.PI * 2 / 8) * index; 
        }
        update() {
            if(!this.target || this.target.dead) { 
                this.target=this.findTarget(); 
                if(!this.target) {
                    const orbitRadius = 120;
                    const orbitSpeed = 0.02;
                    this.idleAngleOffset += orbitSpeed;
                    
                    const desiredX = core.x + Math.cos(this.idleAngleOffset) * orbitRadius;
                    const desiredY = core.y + Math.sin(this.idleAngleOffset) * orbitRadius;
                    
                    this.x += (desiredX - this.x) * 0.1;
                    this.y += (desiredY - this.y) * 0.1;
                    
                    this.angle = Math.atan2(core.y - this.y, core.x - this.x);
                }
            }
            
            if(this.target && !this.target.dead) {
                const dist=Math.hypot(this.target.x-this.x, this.target.y-this.y);
                const a=Math.atan2(this.target.y-this.y, this.target.x-this.x);
                this.angle = a;
                
                if(dist>150){ 
                    this.x+=Math.cos(a)*this.speed; 
                    this.y+=Math.sin(a)*this.speed; 
                } else { 
                    this.x-=Math.cos(a)*(this.speed*0.5); 
                    this.y-=Math.sin(a)*(this.speed*0.5); 
                }
                
                if(this.cooldown<=0){
                    const pCount = this.data.projectileCount || 1;
                    for(let i=0; i<pCount; i++) {
                        const spread = 0.2; 
                        const offset = (pCount > 1) ? (i - (pCount - 1) / 2) * spread : 0;
                        const fireAngle = a + offset;
                        
                        const p = new Projectile(this.x, this.y, Math.cos(fireAngle)*15, Math.sin(fireAngle)*15, this.data.baseDamage, this.data.color, false, false);
                        p.radius = 5;
                        projectiles.push(p);
                    }
                    audio.shoot(); 
                    this.cooldown=this.data.baseCooldown;
                }
            } 

            drones.forEach(other => {
                if (other === this) return;
                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                const minSeparation = 40; 
                
                if (dist < minSeparation && dist > 0) {
                    const pushFactor = 0.5; 
                    const pushAngle = Math.atan2(this.y - other.y, this.x - other.x);
                    this.x += Math.cos(pushAngle) * pushFactor;
                    this.y += Math.sin(pushAngle) * pushFactor;
                }
            });

            if(this.cooldown>0) this.cooldown--;
        }
        findTarget(){ let n=null; let min=Infinity; if(boss && !boss.dead) return boss; enemies.forEach(e=>{ if(!e.dead){ const d=Math.hypot(e.x-this.x,e.y-this.y); if(d<min){min=d; n=e;} } }); return n; }
        draw(){ ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle=this.data.color; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.fill(); ctx.fillStyle='orange'; ctx.beginPath(); ctx.arc(-8, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }
    class Enemy {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=100; const cx=canvas.width/2; const cy=canvas.height/2; const side=Math.floor(Math.random()*4);
             if(side===0){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy-vH/2-m;} else if(side===1){this.x=cx+vW/2+m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);} else if(side===2){this.x=Math.random()*(vW+m*2)+(cx-vW/2-m); this.y=cy+vH/2+m;} else{this.x=cx-vW/2-m; this.y=Math.random()*(vH+m*2)+(cy-vH/2-m);}
             this.hp=20+(player.level*8); this.maxHp=this.hp; this.baseSpeed=0.5+Math.random()*0.5+(player.level*0.05); this.speed=this.baseSpeed; this.radius=12; this.color=`hsl(${Math.random()*60},70%,50%)`; this.dead=false; this.slowed=false; this.spiralDir=Math.random()<0.5?1:-1;
        }
        update(){ this.speed=this.baseSpeed; if(this.slowed){this.speed*=0.5; this.slowed=false;} const a=Math.atan2(core.y-this.y, core.x-this.x); const ma=a+(this.spiralDir*0.78); this.x+=Math.cos(ma)*this.speed; this.y+=Math.sin(ma)*this.speed; }
        takeDamage(d){ 
            if(this.dead)return false; 
            this.hp-=d; 
            for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, '#fff', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 1.0, 0.08, 0.9));
            audio.hit(); 
            if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} 
            return false; 
        }
        die(){ for(let i=0;i<5;i++)particles.push(new Particle(this.x,this.y,this.color)); addXp(10+player.level); score+=10; }
        draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); if(this.hp<this.maxHp){ const w=20*(Math.max(0,this.hp)/this.maxHp); ctx.fillStyle='red';ctx.fillRect(this.x-10,this.y-18,20,3); ctx.fillStyle='#0f0';ctx.fillRect(this.x-10,this.y-18,w,3); } }
    }
    class Boss {
        constructor() {
             const vW=canvas.width/ZOOM_SCALE; const vH=canvas.height/ZOOM_SCALE; const m=150; const cx=canvas.width/2; const cy=canvas.height/2; this.x=cx; this.y=cy-vH/2-m;
             this.maxHp=1000+(player.level*200); this.hp=this.maxHp; this.speed=0.3; this.radius=60; this.color='#ef4444'; this.shake=0; this.dead=false;
             audio.warning(); 
        }
        update(){ const a=Math.atan2(core.y-this.y, core.x-this.x); this.x+=Math.cos(a)*this.speed; this.y+=Math.sin(a)*this.speed; bossHpBar.style.width=`${Math.max(0,(this.hp/this.maxHp)*100)}%`; if(this.shake>0)this.shake--; }
        takeDamage(d){ 
            if(this.dead)return false; 
            this.hp-=d; this.shake=5; 
            audio.hit(); 
            if(this.hp<=0){this.hp=0; this.dead=true; this.die(); return true;} return false; 
        }
        die(){ for(let i=0;i<50;i++)particles.push(new Particle(this.x+(Math.random()-0.5)*100, this.y+(Math.random()-0.5)*100, this.color)); explosions.push(new Explosion(this.x,this.y,300,'#fff')); addXp(500); score+=1000; boss=null; bossHud.classList.remove('active'); canvas.style.transform=`translate(${Math.random()*20-10}px, ${Math.random()*20-10}px)`; setTimeout(()=>canvas.style.transform='translate(0,0)', 200); }
        draw(){ const sx=(Math.random()-0.5)*this.shake; const sy=(Math.random()-0.5)*this.shake; ctx.save(); ctx.translate(this.x+sx, this.y+sy); ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.fillStyle='rgba(239, 68, 68, 0.2)'; ctx.fill(); ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill(); ctx.strokeStyle='#7f1d1d'; ctx.lineWidth=5; ctx.stroke(); ctx.fillStyle='yellow'; ctx.beginPath(); ctx.arc(-20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-30,20); ctx.quadraticCurveTo(0,50,30,20); ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.stroke(); ctx.restore(); }
    }
    class Particle { 
        constructor(x,y,c,vx,vy,life, decay, friction){
            this.x=x;this.y=y;this.c=c;
            this.vx=vx||(Math.random()-0.5)*4;
            this.vy=vy||(Math.random()-0.5)*4;
            this.life=life||1;
            this.decay=decay||0.05; 
            this.friction=friction||0.94;
        } 
        update(){
            this.x+=this.vx;
            this.y+=this.vy;
            this.vx*=this.friction;
            this.vy*=this.friction;
            this.life-=this.decay; 
        } 
        draw(){
            ctx.globalAlpha=Math.max(0,this.life);
            ctx.fillStyle=this.c;
            ctx.beginPath();
            ctx.arc(this.x,this.y,2,0,Math.PI*2);
            ctx.fill();
            ctx.globalAlpha=1;
        } 
    }
    class GravityParticle {
        constructor(x, y, tx, ty, color) {
            this.x = x; this.y = y; this.tx = tx; this.ty = ty; this.color = color;
            this.life = 1.0;
            const angle = Math.atan2(ty - y, tx - x);
            this.speed = 2 + Math.random() * 3;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vx *= 1.05; this.vy *= 1.05;
            this.life -= 0.05;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            ctx.ellipse(this.x, this.y, 4, 1, Math.atan2(this.vy, this.vx), 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    /* ================= Weapon System ================= */
    class Weapon {
        constructor(id) {
            this.id=id; this.level=1; this.upgradeCount=0;
            this.baseData=JSON.parse(JSON.stringify(WEAPON_DB[id])); this.currentData=JSON.parse(JSON.stringify(WEAPON_DB[id]));
            this.cooldownTimer=0; this.angle=Math.random()*Math.PI*2; this.orbitRadius=55+(Math.random()*10); this.orbitSpeed=0.02+(Math.random()*0.02); this.tickTimer=0;
            if(this.id==='INTERCEPTOR'){ this.units=[]; this.spawnUnits(); }
        }
        spawnUnits(){ 
            const count=this.currentData.unitCount||1; 
            const currentLen = this.units.length;
            for(let i=0; i < count - currentLen; i++){ 
                const u=new InterceptorUnit(this.currentData, this.units.length + i); 
                this.units.push(u); 
                drones.push(u); 
            } 
        }
        
        applyGeneralUpgrade(rarityMult, type) {
            this.level++;
            const boost = 0.10 * rarityMult; 
            
            if (type === 'DAMAGE') {
                this.currentData.baseDamage = Math.floor(this.currentData.baseDamage * (1 + boost));
            } else if (type === 'COOLDOWN') {
                this.currentData.baseCooldown = Math.max(5, Math.floor(this.currentData.baseCooldown * (1 - (boost * 0.8))));
            } else if (type === 'RANGE') {
                if (this.id === 'INTERCEPTOR') {
                    if(!this.currentData.projectileCount) this.currentData.projectileCount = 1;
                    this.currentData.projectileCount += 1;
                } else {
                    if(this.currentData.range) this.currentData.range = Math.floor(this.currentData.range * (1 + boost));
                    if(this.currentData.thickness) this.currentData.thickness = Math.floor(this.currentData.thickness * (1 + boost));
                    if(this.currentData.blastRadius) this.currentData.blastRadius = Math.floor(this.currentData.blastRadius * (1 + boost));
                }
            } else if (type === 'COUNT') {
                if (this.currentData.projectileCount !== undefined && this.id !== 'INTERCEPTOR') this.currentData.projectileCount++;
                if (this.currentData.unitCount !== undefined) { this.currentData.unitCount++; this.spawnUnits(); }
                if (this.currentData.bounceCount !== undefined) this.currentData.bounceCount++;
            }
        }

        applySpecialUpgrade() {
            this.level++;
            if(this.id === 'BLASTER') { 
                this.currentData.projectileCount += 2; 
                this.currentData.spread = 0.3;
                this.currentData.thickness += 30;
                this.currentData.baseDamage *= 2;
            }
            if(this.id === 'MISSILE') { 
                this.currentData.explosive = true;
                this.currentData.baseDamage *= 2.5; 
                this.currentData.blastRadius += 150; 
            }
            // [ìˆ˜ì •] ë¶€ë©”ë‘ íŠ¹ìˆ˜ ì§„í™”: ì¸í”¼ë‹ˆí‹° ì»¤í„° (ê°œìˆ˜+2, ë°ë¯¸ì§€ ì¦ê°€)
            if(this.id === 'BOOMERANG') { 
                this.currentData.projectileCount += 2;
                this.currentData.baseDamage *= 2.0;
                this.currentData.range += 150;
            }
            if(this.id === 'SNIPER') { 
                this.currentData.rearShot = true;
                this.currentData.projectileCount += 1;
            }
            if(this.id === 'MICRO_SWARM') { 
                this.currentData.projectileCount = 20; 
                this.currentData.spread = 6.28; 
                this.currentData.baseCooldown = 20; 
            }
            if(this.id === 'INTERCEPTOR') { 
                this.currentData.unitCount += 3; 
                this.spawnUnits();
            }
            if(this.id === 'TESLA') { 
                this.currentData.bounceCount += 10;
                this.currentData.range += 200;
            }
            if(this.id === 'GRAVITY') { 
                this.currentData.range += 150;
                this.currentData.slowFactor = 0.2; 
                this.currentData.baseDamage *= 3;
            }
        }

        update() {
            this.angle+=this.orbitSpeed; if(this.cooldownTimer>0)this.cooldownTimer--;
            if(this.currentData.type==='ZONE'||this.currentData.type==='SLOW_ZONE') this.updateZone();
            else if(this.currentData.type!=='UNIT' && this.cooldownTimer<=0) this.fire();
        }
        draw() {
            if(this.currentData.type==='UNIT')return;
            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            ctx.beginPath(); ctx.moveTo(core.x,core.y); ctx.lineTo(wx,wy); ctx.strokeStyle='rgba(255,255,255,0.1)'; ctx.stroke();
            ctx.beginPath(); ctx.arc(wx,wy,8,0,Math.PI*2); ctx.fillStyle=this.currentData.color; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke();
            
            if(this.currentData.type==='ZONE'){ 
                ctx.beginPath();ctx.arc(core.x,core.y,this.currentData.range,0,Math.PI*2);
                ctx.fillStyle='rgba(139,92,246,0.1)';ctx.fill();
                ctx.strokeStyle='rgba(139,92,246,0.4)';ctx.lineWidth=2;ctx.stroke();
            }
            if(this.currentData.type==='SLOW_ZONE'){ 
                ctx.save();
                ctx.translate(core.x, core.y);
                ctx.rotate(frame * 0.02);
                ctx.beginPath();
                ctx.arc(0,0,this.currentData.range,0,Math.PI*2);
                const grad = ctx.createRadialGradient(0,0,this.currentData.range*0.2, 0,0,this.currentData.range);
                grad.addColorStop(0, 'rgba(0,0,0,0.8)'); 
                grad.addColorStop(0.5, 'rgba(0,0,0,0.4)');
                grad.addColorStop(1, 'rgba(100,100,100,0.1)');
                ctx.fillStyle = grad;
                ctx.fill();
                
                ctx.beginPath();
                for(let i=0; i<3; i++) {
                    ctx.arc(0, 0, this.currentData.range * (0.8 + i*0.1), i + frame*0.05, i + frame*0.05 + Math.PI);
                }
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }
        fire() {
            const range=this.currentData.range; let target=null; let bossInRange=false;
            if(boss && !boss.dead && Math.hypot(boss.x-core.x, boss.y-core.y)<=range) { target=boss; bossInRange=true; }
            if(!bossInRange) { let min=range; enemies.forEach(e=>{if(e.dead)return; const d=Math.hypot(e.x-core.x, e.y-core.y); if(d<=min){min=d; target=e;}}); }
            if(!target && this.currentData.type!=='ZONE' && this.currentData.type!=='SLOW_ZONE' && this.currentData.type!=='BOOMERANG') return;

            const wx=core.x+Math.cos(this.angle)*this.orbitRadius; const wy=core.y+Math.sin(this.angle)*this.orbitRadius;
            const count=this.currentData.projectileCount||1; const spread=this.currentData.spread||0.2;

            for(let i=0; i<count; i++) {
                let angleOffset=(count>1)?(i-(count-1)/2)*spread:0;
                if(this.currentData.type==='BEAM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset;
                    const endX=wx+Math.cos(fa)*2000; const endY=wy+Math.sin(fa)*2000;
                    beams.push(new BeamEffect(wx,wy,endX,endY,this.currentData.color,this.currentData.thickness));
                    if(boss && !boss.dead && pointToLineDistance(boss.x,boss.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+boss.radius) boss.takeDamage(this.currentData.baseDamage);
                    enemies.forEach(e=>{if(!e.dead && pointToLineDistance(e.x,e.y,wx,wy,endX,endY)<(this.currentData.thickness/2)+e.radius) e.takeDamage(this.currentData.baseDamage);});
                    audio.laser(); 
                } else if(this.currentData.type==='HOMING') {
                    projectiles.push(new HomingMissile(wx,wy,target,this.currentData.baseDamage,this.currentData.explosive,this.currentData.blastRadius));
                    audio.shoot(); 
                } else if(this.currentData.type==='SWARM') {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+(Math.random()-0.5)*spread*2;
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*6,Math.sin(fa)*6,this.currentData.baseDamage,this.currentData.color,false,true));
                    audio.shoot(); 
                } else if(this.currentData.type==='CHAIN') {
                    this.castLightning(target,this.currentData.baseDamage,this.currentData.bounceCount||3); break;
                } else if(this.currentData.type==='BOOMERANG') {
                    // [ìˆ˜ì •] ë¶€ë©”ë‘ ë°œì‚¬ ë¡œì§
                    // íƒ€ê²Ÿ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬, ì—†ìœ¼ë©´ ê·¸ëƒ¥ ì•(ë§ˆìš°ìŠ¤ìª½? ì—†ìœ¼ë‹ˆ ëœë¤)ìœ¼ë¡œ
                    let aimAngle = this.angle;
                    if(target) aimAngle = Math.atan2(target.y-wy, target.x-wx);
                    const fa = aimAngle + angleOffset;
                    const p = new Projectile(wx, wy, Math.cos(fa)*this.currentData.speed, Math.sin(fa)*this.currentData.speed, this.currentData.baseDamage, this.currentData.color, true, false);
                    p.behavior = 'BOOMERANG'; // ë™ì‘ ì„¤ì •
                    p.speed = this.currentData.speed; // ì´ˆê¸° ì†ë„
                    projectiles.push(p);
                    audio.whoosh(); // ë¶€ë©”ë‘ ì†Œë¦¬
                } else {
                    const ba=Math.atan2(target.y-wy, target.x-wx); const fa=ba+angleOffset; const ps=(this.currentData.type==='PIERCING')?25:8;
                    projectiles.push(new Projectile(wx,wy,Math.cos(fa)*ps,Math.sin(fa)*ps,this.currentData.baseDamage,this.currentData.color,this.currentData.type==='PIERCING',this.currentData.explosive));
                    if(this.currentData.rearShot) projectiles.push(new Projectile(wx,wy,Math.cos(fa+Math.PI)*ps,Math.sin(fa+Math.PI)*ps,this.currentData.baseDamage,this.currentData.color,this.currentData.type==='PIERCING',this.currentData.explosive));
                    audio.shoot(); 
                }
            }
            this.cooldownTimer=this.currentData.baseCooldown;
        }
        castLightning(t,d,b){ 
            let c=t; let v=[c]; c.takeDamage(d); lightnings.push(new LightningEffect(core.x,core.y,c.x,c.y,this.currentData.color)); 
            audio.laser(); 
            for(let i=0;i<b;i++){ let n=null; let min=300; enemies.forEach(e=>{if(e.dead||e===c||v.includes(e))return; const dist=Math.hypot(e.x-c.x,e.y-c.y); if(dist<min){min=dist;n=e;}}); if(n){lightnings.push(new LightningEffect(c.x,c.y,n.x,n.y,this.currentData.color)); n.takeDamage(d); v.push(n); c=n;}else break; } 
        }
        updateZone() {
            this.tickTimer++;
            if(this.currentData.type==='SLOW_ZONE'){
                if(frame % 3 === 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = this.currentData.range;
                    const px = core.x + Math.cos(angle) * dist;
                    const py = core.y + Math.sin(angle) * dist;
                    particles.push(new GravityParticle(px, py, core.x, core.y, this.currentData.color));
                }

                if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius && this.tickTimer%10===0) boss.takeDamage(this.currentData.baseDamage);
                enemies.forEach(e=>{if(!e.dead && Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius){ e.slowed=true; if(this.tickTimer%10===0)e.takeDamage(this.currentData.baseDamage);}}); return;
            }
            if(this.tickTimer%(this.currentData.hitRate||10)!==0)return;
            if(boss&&!boss.dead&&Math.hypot(boss.x-core.x,boss.y-core.y)<this.currentData.range+boss.radius) boss.takeDamage(this.currentData.baseDamage);
            enemies.forEach(e=>{if(!e.dead&&Math.hypot(e.x-core.x,e.y-core.y)<this.currentData.range+e.radius) e.takeDamage(this.currentData.baseDamage);});
        }
    }

    addWeapon('MISSILE');
    function pointToLineDistance(px,py,x1,y1,x2,y2){ const A=px-x1;const B=py-y1;const C=x2-x1;const D=y2-y1; const dot=A*C+B*D;const len=C*C+D*D; let param=-1;if(len!==0)param=dot/len; let xx,yy;if(param<0){xx=x1;yy=y1;}else if(param>1){xx=x2;yy=y2;}else{xx=x1+param*C;yy=y1+param*D;} const dx=px-xx;const dy=py-yy; return Math.sqrt(dx*dx+dy*dy); }
    function addWeapon(id){ if(player.weapons.length>=6)return; player.weapons.push(new Weapon(id)); renderWeaponSlots(); }
    function addXp(amount){ player.xp+=amount; if(player.xp>=player.xpToNext)levelUp(); updateUi(); }
    function levelUp(){ 
        player.level++; player.xp=0; player.xpToNext=Math.floor(player.xpToNext*1.15); 
        audio.levelUp(); 
        if(player.level%5===0 && !boss)spawnBoss(); currentState=GAME_STATE.LEVEL_UP; generateUpgradeCards(); upgradeMenu.classList.add('active'); 
    }
    function spawnBoss(){ boss=new Boss(); bossHud.classList.add('active'); warningMsg.style.display='block'; setTimeout(()=>warningMsg.style.display='none',3000); }
    function rollRarity(){ const r=Math.random()*100; if(r<50)return RARITY.COMMON; if(r<80)return RARITY.UNCOMMON; if(r<95)return RARITY.RARE; if(r<99)return RARITY.EPIC; return RARITY.LEGENDARY; }
    function generateUpgradeCards(){
        cardsArea.innerHTML=''; const options=[];
        player.weapons.forEach((w,i)=>{
            if((w.level+1)%5===0) options.push({type:'SPECIAL', weapon:w, index:i, desc:getSpecialDesc(w)});
            else {
                let type='DAMAGE'; const rnd=Math.random();
                if(rnd<0.30) type='DAMAGE'; 
                else if(rnd<0.60) type='COOLDOWN'; 
                else if(rnd<0.80) type='RANGE'; 
                else type='COUNT'; 

                const rarity=rollRarity();
                options.push({type:'GENERAL', weapon:w, index:i, statType:type, rarity:rarity});
            }
        });
        if(player.weapons.length<6) Object.keys(WEAPON_DB).forEach(id=>{if(!player.weapons.some(w=>w.id===id))options.push({type:'NEW', id:id});});
        options.push({type:'HEAL'}); options.sort(()=>Math.random()-0.5); options.slice(0,3).forEach(opt=>createCard(opt));
    }
    function getSpecialDesc(w){
        if(w.id==='BLASTER')return"íŠ¸ë¼ì´ë˜íŠ¸ ë¹” (3ê°ˆë˜ ë°œì‚¬)";
        if(w.id==='MISSILE')return"ë‰´í´ë¦¬ì–´ (ì´ˆê´‘ì—­ í­ë°œ)";
        if(w.id==='BOOMERANG')return"ì¸í”¼ë‹ˆí‹° ì»¤í„° (ë“€ì–¼ ë¶€ë©”ë‘)";
        if(w.id==='SNIPER')return"ë¦¬ì½”ì¼ íƒ„í™˜ (ì ì¤‘ ì‹œ íŠ•ê¹€)";
        if(w.id==='MICRO_SWARM')return"ì˜´ë‹ˆ ë²„ìŠ¤íŠ¸ (360ë„ ì „ë°©í–¥ ë‚œì‚¬)";
        if(w.id==='INTERCEPTOR')return"ìš°ì£¼ ëª¨í•¨ (í¸ëŒ€ 4ê¸°ë¡œ ì¦ê°€)";
        if(w.id==='TESLA')return"ë‡Œì‹  (ì „ì´ íšŸìˆ˜/ë²”ìœ„ ëŒ€í­ ì¦ê°€)";
        if(w.id==='GRAVITY')return"ì´ë²¤íŠ¸ í˜¸ë¼ì´ì¦Œ (80% ê°ì†)";
        return"ê¶ê·¹ ì§„í™”";
    }
    function createCard(opt){
        const card=document.createElement('div'); card.className='card'; let title,desc,icon,tagName;
        if(opt.type==='NEW'){ const d=WEAPON_DB[opt.id]; title=d.name; desc="ì‹ ê·œ ë¬´ê¸° íšë“"; icon=d.icon; card.classList.add('uncommon'); tagName='NEW'; }
        else if(opt.type==='SPECIAL'){ const w=opt.weapon; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}â¤${w.level+1}</span>`; desc=`<span style="color:#f43f5e;font-weight:bold">ğŸ”¥ ULTIMATE ğŸ”¥</span><br>${opt.desc}`; icon=w.currentData.icon; card.classList.add('special'); tagName='EVO'; }
        else if(opt.type==='GENERAL'){
            const w=opt.weapon; const r=opt.rarity; title=`${w.currentData.name} <span style="font-size:12px;color:#aaa">Lv.${w.level}â¤${w.level+1}</span>`;
            let txt='ê³µê²©ë ¥', val=Math.floor(10*r.mult)+'%';
            if(opt.statType==='COOLDOWN'){txt='ê³µê²©ì†ë„';} 
            if(opt.statType==='RANGE'){
                txt='ë²”ìœ„/í¬ê¸°';
                if(w.id==='MISSILE') txt='í­ë°œ ë²”ìœ„';
                if(w.id==='INTERCEPTOR') { txt='ë¯¸ì‚¬ì¼ ê°œìˆ˜'; val='+1'; }
            } 
            if(opt.statType==='COUNT'){txt='ë°œì‚¬ì²´ ìˆ˜'; val='+1';}
            desc=`${txt} <span style="color:${getColor(r.name)};font-weight:bold">+${val}</span>`; icon=w.currentData.icon; card.classList.add(r.color); tagName=r.name.toUpperCase();
        } else { title="ê¸´ê¸‰ ìˆ˜ë¦¬"; desc="ì²´ë ¥ 50% íšŒë³µ"; icon="â¤ï¸"; card.classList.add('common'); tagName='ITEM'; }
        function getColor(n){if(n==='Legendary')return'#eab308';if(n==='Epic')return'#a855f7';if(n==='Rare')return'#3b82f6';if(n==='Uncommon')return'#10b981';return'#9ca3af';}
        card.innerHTML=`<div class="card-tag">${tagName}</div><div class="card-icon">${icon}</div><h3>${title}</h3><p>${desc}</p>`;
        card.onclick=()=>{
            if(opt.type==='NEW')addWeapon(opt.id);
            else if(opt.type==='SPECIAL')opt.weapon.applySpecialUpgrade();
            else if(opt.type==='GENERAL')opt.weapon.applyGeneralUpgrade(opt.rarity.mult, opt.statType);
            else if(opt.type==='HEAL')core.hp=Math.min(core.hp+50, core.maxHp);
            renderWeaponSlots(); updateUi(); upgradeMenu.classList.remove('active'); currentState=GAME_STATE.PLAYING;
        }; cardsArea.appendChild(card);
    }
    function renderWeaponSlots(){ weaponSlotsContainer.innerHTML=''; for(let i=0;i<6;i++){ const slot=document.createElement('div'); slot.className='slot'; if(player.weapons[i]){ const w=player.weapons[i]; slot.innerHTML=`${w.currentData.icon}<div class="level-badge">${w.level}</div>`; slot.style.borderColor=w.currentData.color; slot.style.boxShadow=`0 0 5px ${w.currentData.color}`; }else slot.innerHTML='<span style="color:#333;font-size:12px">EMPTY</span>'; weaponSlotsContainer.appendChild(slot); } }
    function updateUi(){ document.getElementById('hp-text').innerText=`${Math.ceil(core.hp)}/${core.maxHp}`; document.getElementById('hp-bar').style.width=`${(core.hp/core.maxHp)*100}%`; document.getElementById('level-text').innerText=player.level; document.getElementById('xp-text').innerText=`${Math.floor((player.xp/player.xpToNext)*100)}%`; document.getElementById('xp-bar').style.width=`${(player.xp/player.xpToNext)*100}%`; document.getElementById('score-text').innerText=score; }
    function animate(){
        requestAnimationFrame(animate);
        if(currentState===GAME_STATE.LEVEL_UP)return;
        if(currentState===GAME_STATE.GAME_OVER){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='red';ctx.font='bold 40px sans-serif';ctx.textAlign='center';ctx.fillText("MISSION FAILED",canvas.width/2,canvas.height/2);ctx.fillStyle='white';ctx.font='20px sans-serif';ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+50);return;}
        ctx.fillStyle='rgba(13, 17, 23, 0.2)';ctx.fillRect(0,0,canvas.width,canvas.height);
        
        ctx.save(); 
        ctx.translate(canvas.width/2,canvas.height/2); 
        ctx.scale(ZOOM_SCALE,ZOOM_SCALE); 
        ctx.translate(-canvas.width/2,-canvas.height/2);
        
        frame++;
        if(!boss){ const rate=Math.max(5, 50-(player.level*3)); if(frame%rate===0)enemies.push(new Enemy()); }
        ctx.beginPath();ctx.arc(core.x,core.y,core.radius,0,Math.PI*2);ctx.fillStyle=core.color;ctx.shadowBlur=20;ctx.shadowColor=core.color;ctx.fill();ctx.shadowBlur=0;
        player.weapons.forEach(w=>{w.update();w.draw();}); drones.forEach(d=>{d.update();d.draw();});
        if(boss&&!boss.dead){boss.update();boss.draw();if(Math.hypot(boss.x-core.x,boss.y-core.y)<core.radius+boss.radius){core.hp-=0.5;updateUi();if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;}}
        for(let i=beams.length-1;i>=0;i--){beams[i].update();beams[i].draw();if(beams[i].life<=0)beams.splice(i,1);}
        for(let i=explosions.length-1;i>=0;i--){explosions[i].update();explosions[i].draw();if(explosions[i].life<=0)explosions.splice(i,1);}
        for(let i=shockwaves.length-1;i>=0;i--){shockwaves[i].update();shockwaves[i].draw();if(shockwaves[i].life<=0)shockwaves.splice(i,1);}
        for(let i=lightnings.length-1;i>=0;i--){lightnings[i].update();lightnings[i].draw();if(lightnings[i].life<=0)lightnings.splice(i,1);}
        
        const vW=canvas.width/ZOOM_SCALE;const vH=canvas.height/ZOOM_SCALE;const m=200;const cx=canvas.width/2;const cy=canvas.height/2;
        
        for(let i=projectiles.length-1;i>=0;i--){
            const p=projectiles[i]; p.update(); p.draw();
            // [ìˆ˜ì •] ë¶€ë©”ë‘ì€ ëŒì•„ì˜¬ ë•Œê¹Œì§€ ìƒì¡´
            if(p.life<=0 || (p.behavior !== 'BOOMERANG' && (p.x<cx-vW/2-m||p.x>cx+vW/2+m||p.y<cy-vH/2-m||p.y>cy+vH/2+m))){
                projectiles.splice(i,1); continue;
            }
            if(boss&&!boss.dead&&Math.hypot(p.x-boss.x,p.y-boss.y)<boss.radius+p.radius){if(p.explosive){p.explode();projectiles.splice(i,1);continue;}boss.takeDamage(p.damage);particles.push(new Particle(p.x,p.y,p.color,null,null,1.0,0.1));if(!p.isPiercing){projectiles.splice(i,1);continue;}}
            for(let j=enemies.length-1;j>=0;j--){const e=enemies[j];if(e.dead)continue;if(Math.hypot(p.x-e.x,p.y-e.y)<e.radius+p.radius){if(p.explosive){p.explode();projectiles.splice(i,1);break;}else{const died=e.takeDamage(p.damage);if(!died)particles.push(new Particle(e.x,e.y,'#fff',null,null,1.0,0.1));if(!p.isPiercing){projectiles.splice(i,1);break;}else if(!p.hitList.includes(e))p.hitList.push(e);}}}
        }
        enemies=enemies.filter(e=>{if(e.dead)return false;e.update();e.draw();if(Math.hypot(e.x-core.x,e.y-core.y)<core.radius+e.radius){core.hp-=10;updateUi();canvas.style.transform=`translate(${Math.random()*10-5}px,${Math.random()*10-5}px)`;setTimeout(()=>canvas.style.transform='translate(0,0)',50);if(core.hp<=0)currentState=GAME_STATE.GAME_OVER;return false;}return true;});
        for(let i=particles.length-1;i>=0;i--){particles[i].update();particles[i].draw();if(particles[i].life<=0)particles.splice(i,1);}
        ctx.restore();
    }
    
    resize();
    renderWeaponSlots(); updateUi(); animate();
</script>
</body>
</html>
