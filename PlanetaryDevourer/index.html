<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Harvester: Planetary Devourer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050814;
            color: #e2e8f0;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ïù∏Í≤åÏûÑ UI */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            z-index: 10;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #f8fafc;
            text-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
        }
        
        .timer-warn { color: #ef4444; text-shadow: 0 0 15px rgba(239, 68, 68, 0.6); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        /* ÏΩ§Î≥¥ UI */
        .combo-box {
            align-self: center;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }
        .combo-val {
            font-size: 4rem; font-weight: 900; 
            background: linear-gradient(to bottom, #fcd34d, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-style: italic;
        }
        .combo-label { font-size: 1.2rem; color: #fbbf24; font-weight: 700; letter-spacing: 2px; }

        /* ÏóÖÏ†Å ÏïåÎ¶º UI */
        #achievement-container {
            position: absolute;
            top: 220px; 
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 15;
        }
        
        .achievement-toast {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #3b82f6;
            border-left: 5px solid #3b82f6;
            padding: 10px 15px;
            border-radius: 4px;
            color: white;
            width: 280px;
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s forwards;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        @keyframes slideIn { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Ìå®ÏãúÎ∏å Î≥¥ÎÑàÏä§ ÌëúÏãú */
        #passive-stats {
            position: absolute;
            top: 100px;
            left: 20px;
            font-size: 0.8rem;
            color: #94a3b8;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10;
            display: none; 
            line-height: 1.4;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Ïä§ÌÇ¨ Î∞î UI */
        #skill-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        .skill-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.3;
            filter: grayscale(1);
            transition: all 0.3s;
            pointer-events: auto;
            cursor: pointer;
            position: relative;
        }

        .skill-slot.unlocked {
            opacity: 1;
            filter: grayscale(0);
        }
        
        .skill-icon {
            width: 60px; height: 60px;
            border-radius: 16px;
            background: #1e293b;
            border: 2px solid #475569;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .skill-slot.unlocked .skill-icon {
            background: #4f46e5;
            border-color: #818cf8;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        
        .skill-overlay {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
        }

        .skill-active-glow {
            position: absolute; top:0; left:0; width:100%; height:100%;
            border: 3px solid #facc15;
            border-radius: 16px;
            box-shadow: 0 0 15px #facc15;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .skill-key {
            margin-top: 5px;
            font-size: 0.8rem; font-weight: bold; color: #cbd5e1;
            background: rgba(0,0,0,0.5); padding: 2px 8px; border-radius: 10px;
        }

        .skill-level-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #facc15;
            color: #0f172a;
            font-size: 0.7rem;
            font-weight: 800;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            display: none; /* Initially hidden */
        }
        .skill-slot.unlocked .skill-level-indicator {
            display: flex;
        }
        
        /* ÏùåÏÜåÍ±∞ Î≤ÑÌäº */
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.8);
            color: white;
            border: 1px solid #475569;
            border-radius: 50%;
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        #mute-btn:hover { background: #334155; }

        /* ÏùºÏãúÏ†ïÏßÄ Ïò§Î≤ÑÎ†àÏù¥ */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            z-index: 90; display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; font-size: 3rem; font-weight: 900;
        }
        .pause-text { margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .pause-sub { font-size: 1.2rem; font-weight: 400; color: #94a3b8; }

        /* ÏúÑÍ∏∞ Í≤ΩÍ≥† Ïò§Î≤ÑÎ†àÏù¥ */
        #danger-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(239, 68, 68, 0.8);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            mix-blend-mode: overlay;
        }

        /* ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 16, 38, 0.98); 
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            width: 100%;
            max-width: 800px;
        }

        .screen-title { font-size: 2rem; font-weight: 900; color: #f1f5f9; margin: 0; text-shadow: 0 0 20px rgba(124, 58, 237, 0.5); }
        .screen-subtitle { font-size: 0.9rem; color: #94a3b8; margin-bottom: 5px; }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1e293b;
            padding: 10px 20px;
            border-radius: 12px;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 90%;
            margin-bottom: 15px;
        }

        .money-badge { font-size: 1.2rem; font-weight: 800; color: #fbbf24; }
        .level-badge { font-size: 1rem; font-weight: 700; color: #818cf8; }
        
        .reset-data-btn {
            font-size: 0.7rem; color: #64748b; text-decoration: underline; cursor: pointer;
            transition: color 0.2s;
        }
        .reset-data-btn:hover { color: #94a3b8; }

        .tree-scroll-area {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 100px 20px;
            scrollbar-width: thin;
            scrollbar-color: #475569 #0f172a;
        }

        .tier-section { width: 100%; max-width: 1000px; margin-bottom: 40px; position: relative; }
        .tier-header { display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 5px; border-bottom: 2px solid #334155; }
        .tier-title { font-size: 1.2rem; font-weight: 800; color: #e2e8f0; margin-right: 15px; }
        .tier-lock-msg { font-size: 0.9rem; color: #f87171; font-weight: 600; background: rgba(239, 68, 68, 0.1); padding: 2px 8px; border-radius: 4px; }
        .tier-unlock-msg { font-size: 0.9rem; color: #34d399; font-weight: 600; background: rgba(16, 185, 129, 0.1); padding: 2px 8px; border-radius: 4px; }
        .tier-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; }
        
        .card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; position: relative; min-height: 140px;
        }
        .card:hover:not(.disabled):not(.locked) { transform: translateY(-3px); box-shadow: 0 10px 15px rgba(0,0,0,0.3); border-color: #8b5cf6; background: #273549; }
        .card.disabled { opacity: 0.6; filter: grayscale(0.8); }
        .card.locked { background: #0f172a; border: 1px dashed #334155; cursor: not-allowed; opacity: 0.7; align-items: center; justify-content: center; color: #64748b; }
        .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .card-icon { font-size: 24px; }
        .card-name { font-weight: 800; font-size: 0.85rem; color: #f1f5f9; line-height: 1.2; }
        .card-desc { font-size: 0.7rem; color: #94a3b8; margin-bottom: 8px; flex-grow: 1; line-height: 1.3; }
        .card-footer { margin-top: auto; border-top: 1px solid #334155; padding-top: 8px; }
        .card-stat { font-size: 0.7rem; color: #a78bfa; font-weight: 600; margin-bottom: 2px; }
        .card-cost { font-weight: 700; color: #60a5fa; font-size: 0.95rem; }
        .card-lvl { position: absolute; top: 10px; right: 10px; font-size: 0.7rem; font-weight: 800; color: #cbd5e1; background: #334155; padding: 2px 6px; border-radius: 4px; }
        .max-lvl { color: #6ee7b7; background: rgba(16, 185, 129, 0.2); }

        .bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; padding: 20px;
            background: linear-gradient(to top, #0b1026, rgba(11, 16, 38, 0));
            display: flex; justify-content: center; pointer-events: none;
        }
        
        .btn-action {
            pointer-events: auto;
            background: linear-gradient(135deg, #7c3aed, #2563eb);
            color: white; padding: 15px 80px; border-radius: 50px; font-size: 1.2rem; font-weight: 800; border: none;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 0 20px rgba(124, 58, 237, 0.4);
        }
        .btn-action:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(124, 58, 237, 0.6); }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0b1026; display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s; color: white;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="danger-overlay"></div>

    <div id="ingame-ui">
        <div id="passive-stats"></div>
        <div class="top-row">
            <div class="timer-box">
                <span id="timer-display">10.0</span>s
            </div>
            <div class="score-val" id="score-display">$0</div>
        </div>
        <div class="combo-box" id="combo-box">
            <div class="combo-val" id="combo-val">x1.0</div>
            <div class="combo-label">COMBO!</div>
        </div>
        <div id="achievement-container"></div>
    </div>
    
    <div id="skill-bar">
        <div class="skill-slot" id="slot-bomb" onclick="activateSkill('bomb')">
            <div class="skill-icon">üí£<div class="skill-overlay" id="cd-bomb"></div><div class="skill-active-glow" id="glow-bomb"></div></div>
            <div class="skill-key">Q</div>
            <div class="skill-level-indicator" id="lvl-bomb">1</div>
        </div>
        <div class="skill-slot" id="slot-stasis" onclick="activateSkill('stasis')">
            <div class="skill-icon">‚ùÑÔ∏è<div class="skill-overlay" id="cd-stasis"></div><div class="skill-active-glow" id="glow-stasis"></div></div>
            <div class="skill-key">W</div>
            <div class="skill-level-indicator" id="lvl-stasis">1</div>
        </div>
        <div class="skill-slot" id="slot-surge" onclick="activateSkill('surge')">
            <div class="skill-icon">‚öõÔ∏è<div class="skill-overlay" id="cd-surge"></div><div class="skill-active-glow" id="glow-surge"></div></div>
            <div class="skill-key">E</div>
            <div class="skill-level-indicator" id="lvl-surge">1</div>
        </div>
        <div class="skill-slot" id="slot-storm" onclick="activateSkill('storm')">
            <div class="skill-icon">‚ö°<div class="skill-overlay" id="cd-storm"></div><div class="skill-active-glow" id="glow-storm"></div></div>
            <div class="skill-key">R</div>
            <div class="skill-level-indicator" id="lvl-storm">1</div>
        </div>
    </div>
    
    <div id="pause-overlay">
        <div class="pause-text">PAUSED</div>
        <div class="pause-sub">Press ESC to Resume</div>
    </div>

    <button id="mute-btn" onclick="toggleMute()">üîä</button>

    <div id="upgrade-screen">
        <div class="upgrade-header">
            <h1 class="screen-title">RESEARCH LAB</h1>
            <p class="screen-subtitle">Ïö∞Ï£ºÏùò ÌûòÏùÑ Ïó∞Íµ¨ÌïòÏó¨ Î∏îÎûôÌôÄÏùÑ ÏßÑÌôîÏãúÌÇ§ÏÑ∏Ïöî.</p>
        </div>
        <div class="status-bar">
            <div class="level-badge" id="total-level-display">Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: 0</div>
            <div class="money-badge" id="upgrade-money">$0</div>
        </div>
        <div style="margin-bottom: 10px;">
             <span class="reset-data-btn" onclick="resetSaveData()">[Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî]</span>
        </div>
        <div class="tree-scroll-area" id="tree-container"></div>
        <div class="bottom-bar">
            <button class="btn-action" onclick="startGame()">Start Loop</button>
        </div>
    </div>

    <div id="start-overlay">
        <h1 class="text-5xl font-black mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-blue-500">Void Harvester:<br>Planetary Devourer</h1>
        <p class="text-gray-400 mb-8 text-xl">ÌñâÏÑ±ÏùÑ ÌååÍ¥¥ÌïòÍ≥† Ìù°ÏàòÌïòÏó¨ ÎÅùÏóÜÏù¥ ÏÑ±Ïû•ÌïòÏÑ∏Ïöî.</p>
        <button class="btn-action" onclick="firstStart()">Í≤åÏûÑ ÏãúÏûë</button>
    </div>

    <script>
        // --- 1. GLOBAL VARIABLES ---
        let canvas, ctx;
        let scoreEl, timerEl, upgradeScreen, upgradeMoneyEl, totalLevelEl, treeContainer, startOverlay, ingameUi, comboBox, comboValEl, passiveStatsEl, pauseOverlay;
        let slotBomb, slotStasis, slotSurge, slotStorm;
        let cdBomb, cdStasis, cdSurge, cdStorm;
        let glowBomb, glowStasis, glowSurge, glowStorm;
        let lvlBombEl, lvlStasisEl, lvlSurgeEl, lvlStormEl;

        const VALUE_MULTIPLIER = 0.4; 
        const BASE_RESOLUTION = 1080;
        const TIER_UNLOCKS = [0, 4, 12, 24, 40, 60, 90, 130, 180, 240, 310, 390, 480, 580, 700, 850, 1050, 1300, 1600, 2000, 2500];

        const UPGRADES = [
            // Tier 0
            { id: 'force', name: 'Ï§ëÎ†•Ïû• Í∞ïÎèÑ', desc: 'ÌååÌé∏ÏùÑ ÎãπÍ∏∞Îäî Ìûò.', icon: 'üß≤', tier: 0, level: 1, maxLevel: 99, baseCost: 15, mult: 1.4, val: 0.12, inc: 0.03 },
            { id: 'radius', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ†', desc: 'ÏòÅÌñ• Î≤îÏúÑ ÌôïÏû•.', icon: '‚≠ï', tier: 0, level: 1, maxLevel: 99, baseCost: 15, mult: 1.4, val: 80, inc: 4 }, 
            { id: 'friction', name: 'Í≥µÍ∞Ñ Ï†êÏÑ±', desc: 'ÌååÌé∏Ïù¥ Îçú ÎØ∏ÎÅÑÎü¨Ïßê.', icon: 'üï∏Ô∏è', tier: 0, level: 1, maxLevel: 10, baseCost: 50, mult: 1.5, val: 0.92, inc: -0.01 },

            // Tier 1
            { id: 'density', name: 'Ï¥àÍ∏∞ Î∞ÄÎèÑ', desc: 'ÏãúÏûë ÌñâÏÑ± Ïàò Ï¶ùÍ∞Ä.', icon: 'üåå', tier: 1, level: 0, maxLevel: 20, baseCost: 100, mult: 1.5, val: 30, inc: 10 },
            { id: 'respawn', name: 'ÌñâÏÑ± Î≤àÏãù', desc: 'Ìù°Ïàò Ïãú Ïû¨ÏÉùÏÑ± ÌôïÎ•†.', icon: 'üå±', tier: 1, level: 0, maxLevel: 20, baseCost: 150, mult: 1.5, val: 0, inc: 5 },
            { id: 'time', name: 'ÏãúÍ∞Ñ ÏôúÍ≥°', desc: 'Ï†úÌïú ÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚è≥', tier: 1, level: 0, maxLevel: 50, baseCost: 200, mult: 1.5, val: 10, inc: 1.5 }, // ÏãúÍ∞Ñ Í∏∞Î≥∏Í∞í 10Ï¥à Í≥†Ï†ï

            // Tier 2
            { id: 'value', name: 'Ï±ÑÍµ¥ Ìö®Ïú®', desc: 'ÌñâÏÑ± Í∞ÄÏπò ÏÉÅÏäπ.', icon: 'üíé', tier: 2, level: 0, maxLevel: 99, baseCost: 300, mult: 1.5, val: 1.0, inc: 0.5 },
            // Skill Bomb: Levelable
            { id: 'unlock_bomb', name: 'Ï§ëÎ†• Ìè≠ÌÉÑ [Skill]', desc: '[Q] Ï£ºÎ≥Ä ÌñâÏÑ± ÎãπÍ∏∞Í∏∞. Î†àÎ≤®ÏóÖ Ïãú ÏúÑÎ†• Ï¶ùÍ∞Ä/Ïø®ÌÉÄÏûÑ Í∞êÏÜå.', icon: 'üí£', type: 'skill', tier: 2, level: 0, maxLevel: 10, baseCost: 1000, mult: 1.5, val: 0, inc: 1 },
            { id: 'heavy', name: 'Í≥†Ï§ëÎ†•', desc: 'Î¨¥Í±∞Ïö¥ ÌñâÏÑ± Î¨¥Í≤å Î¨¥Ïãú.', icon: '‚öì', tier: 2, level: 0, maxLevel: 20, baseCost: 350, mult: 1.5, val: 1.0, inc: 0.2 },

            // Tier 3
            { id: 'attract_range', name: 'ÏûêÏó∞ Ï§ëÎ†•', desc: 'Î∏îÎûôÌôÄ Í∏∞Î≥∏ Ìù°ÏûÖ Î≤îÏúÑ.', icon: 'üåë', tier: 3, level: 0, maxLevel: 20, baseCost: 800, mult: 1.5, val: 150, inc: 20 },
            { id: 'tier_unlock', name: 'Ïã¨Ïö∞Ï£º ÌÉêÏÇ¨', desc: 'Îçî ÎÜíÏùÄ Îì±Í∏â ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üî≠', tier: 3, level: 0, maxLevel: 5, baseCost: 2000, mult: 3.0, val: 1, inc: 1 },
            { id: 'lightning_unlock', name: 'ÎáåÏ†Ñ ÌñâÏÑ±', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌñâÏÑ± Îì±Ïû•.', icon: '‚ö°', tier: 3, level: 0, maxLevel: 1, baseCost: 3000, mult: 1, val: 0, inc: 1 },
            
            // Tier 4
            // Skill Stasis: Levelable
            { id: 'unlock_stasis', name: 'ÌÉÄÏûÑ ÌîÑÎ¶¨Ï¶à [Skill]', desc: '[W] ÏãúÍ∞Ñ Ï†ïÏßÄ. Î†àÎ≤®ÏóÖ Ïãú ÏßÄÏÜçÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚ùÑÔ∏è', type: 'skill', tier: 4, level: 0, maxLevel: 10, baseCost: 8000, mult: 1.5, val: 0, inc: 1 },
            { id: 'l_force', name: 'Ï†ÑÏûêÍ∏∞Ïû•', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏ÎãùÏùò ÎãπÍ∏∞Îäî Ìûò Ï¶ùÍ∞Ä.', icon: 'üß≤', tier: 4, level: 0, maxLevel: 20, baseCost: 5000, mult: 1.5, val: 40, inc: 10 },
            { id: 'crit', name: 'ÌñâÏÑ± Î∂ïÍ¥¥', desc: 'Í∞ÄÏπò 2Î∞∞ ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•†.', icon: 'üí•', tier: 4, level: 0, maxLevel: 20, baseCost: 2500, mult: 1.5, val: 0, inc: 2 },
            { id: 'l_range', name: 'Ï†ÑÏù¥ Î≤îÏúÑ', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù Í±∞Î¶¨.', icon: 'üì°', tier: 4, level: 0, maxLevel: 10, baseCost: 4000, mult: 1.6, val: 150, inc: 20 }, 
            { id: 'l_count', name: 'Í≥ºÎ∂ÄÌïò', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌÉÄÍ≤ü Ïàò.', icon: 'üîó', tier: 4, level: 0, maxLevel: 10, baseCost: 4500, mult: 1.8, val: 3, inc: 1 },

            // Tier 5
            // Skill Surge: Levelable
            { id: 'unlock_surge', name: 'Î∏îÎûôÌôÄ Í∞úÎ∞© [Skill]', desc: '[E] Ìù°ÏûÖÎ†•/Î≤îÏúÑ Í∞ïÌôî. Î†àÎ≤®ÏóÖ Ïãú ÏßÄÏÜçÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚öõÔ∏è', type: 'skill', tier: 5, level: 0, maxLevel: 10, baseCost: 25000, mult: 1.6, val: 0, inc: 1 },
            { id: 'luck', name: 'ÌñâÏö¥Ïùò Î≥Ñ', desc: 'Ìù¨Í∑Ä ÌñâÏÑ± ÌôïÎ•† Ï¶ùÍ∞Ä.', icon: 'üçÄ', tier: 5, level: 0, maxLevel: 10, baseCost: 5000, mult: 1.6, val: 1.0, inc: 0.2 },
            { id: 'blackhole_size', name: 'Í±∞ÎåÄ Î∏îÎûôÌôÄ', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä.', icon: '‚ö´', tier: 5, level: 0, maxLevel: 10, baseCost: 10000, mult: 2.5, val: 35, inc: 3 },
            
            // Tier 6
            { id: 'expansion', name: 'Ïö∞Ï£º ÌôïÏû•', desc: 'ÏãúÏïºÎ•º ÎÑìÌòÄ Í±∞ÎåÄ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üî≠', tier: 6, level: 0, maxLevel: 10, baseCost: 30000, mult: 2.0, val: 1.0, inc: 0.1 },
            { id: 'siphon', name: 'ÏãúÍ∞Ñ Ìù°Ïàò', desc: 'Ìù°Ïàò Ïãú ÏãúÍ∞Ñ Ïó∞Ïû• ÌôïÎ•†.', icon: '‚è≥', tier: 6, level: 0, maxLevel: 20, baseCost: 30000, mult: 1.8, val: 0, inc: 2 },
            { id: 'unlock_magnet', name: 'ÏûêÏÑ± ÌñâÏÑ±', desc: 'Ìù°Ïàò Ïãú Ï£ºÎ≥Ä ÌñâÏÑ±ÏùÑ Í∞ïÎ†•ÌïòÍ≤å ÎãπÍπÅÎãàÎã§.', icon: 'üß≤', tier: 6, level: 0, maxLevel: 1, baseCost: 60000, mult: 1, val: 0, inc: 1 },
            { id: 'frenzy', name: 'ÏΩîÏä§ÎØπ ÌîÑÎ†åÏßÄ', desc: '3Ï¥à Ïù¥ÌïòÏùº Îïå Ï§ëÎ†• 2Î∞∞.', icon: 'üî•', tier: 6, level: 0, maxLevel: 1, baseCost: 50000, mult: 1, val: 0, inc: 1 },

            // Tier 7
            // NEW SKILL: Void Storm
            { id: 'unlock_storm', name: 'Í≥µÌóàÏùò Ìè≠Ìíç [Skill]', desc: '[R] ÌôîÎ©¥ Ï†ÑÏ≤¥ Î¨¥ÏûëÏúÑ ÌÉÄÍ≤©. Î†àÎ≤®ÏóÖ Ïãú ÏúÑÎ†• Ï¶ùÍ∞Ä.', icon: '‚ö°', type: 'skill', tier: 7, level: 0, maxLevel: 10, baseCost: 150000, mult: 1.7, val: 0, inc: 1 },
            { id: 'unlock_ring', name: 'Í≥†Î¶¨ ÌñâÏÑ±', desc: 'Í±∞ÎåÄÌïú Í≥†Î¶¨ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'ü™ê', tier: 7, level: 0, maxLevel: 1, baseCost: 100000, mult: 1, val: 0, inc: 1 },
            { id: 'interest', name: 'ÏïîÌùë Î¨ºÏßà Î∞òÏùë', desc: 'ÎùºÏö¥Îìú Ï¢ÖÎ£å Ïãú Î≥¥Ïú†Í∏à Ïù¥Ïûê.', icon: 'üìà', tier: 7, level: 0, maxLevel: 10, baseCost: 15000, mult: 2.0, val: 0, inc: 1 },
            
            // Tier 8 ~ 20 (Expanded)
            { id: 'singularity', name: 'ÌäπÏù¥Ï†ê', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥ ÏïΩÌïú Ï§ëÎ†•Ïû• ÏÉùÏÑ±.', icon: '‚öõÔ∏è', tier: 8, level: 0, maxLevel: 5, baseCost: 80000, mult: 3.0, val: 0, inc: 1 },
            { id: 'neutron_unlock', name: 'Ï§ëÏÑ±ÏûêÎ≥Ñ', desc: 'Ï¥àÍ≥†Î∞ÄÎèÑ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üåü', tier: 8, level: 0, maxLevel: 1, baseCost: 200000, mult: 1, val: 0, inc: 1 },
            { id: 'unlock_nova', name: 'ÎÖ∏Î∞î ÏΩîÏñ¥', desc: 'Ìù°Ïàò Ïãú Ìè≠Î∞úÏ†ÅÏù∏ Ìù°ÏûÖÎ†•ÏùÑ Î∞úÏÉùÏãúÌÇµÎãàÎã§.', icon: 'üéá', tier: 8, level: 0, maxLevel: 1, baseCost: 180000, mult: 1, val: 0, inc: 1 },
            
            { id: 'gravity_lens', name: 'Ï§ëÎ†• Î†åÏ¶à', desc: 'Ìù°ÏûÖ Î≤îÏúÑ Ï∂îÍ∞Ä ÌôïÏû•.', icon: 'üîç', tier: 9, level: 0, maxLevel: 20, baseCost: 120000, mult: 1.8, val: 1.0, inc: 0.1 },
            { id: 'chrono_battery', name: 'ÌÅ¨Î°úÎÖ∏ Î∞∞ÌÑ∞Î¶¨', desc: 'ÏµúÎåÄ ÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: 'üîã', tier: 9, level: 0, maxLevel: 20, baseCost: 250000, mult: 1.6, val: 5, inc: 1 },
            
            { id: 'skill_mastery', name: 'Ïä§ÌÇ¨ ÎßàÏä§ÌÑ∞Î¶¨', desc: 'Î™®Îì† Ïä§ÌÇ¨ Ïø®ÌÉÄÏûÑ Í∞êÏÜå.', icon: 'üéì', tier: 10, level: 0, maxLevel: 10, baseCost: 300000, mult: 2.0, val: 0, inc: 5 }, // %
            { id: 'star_unlock', name: 'Ìï≠ÏÑ± Î∞úÍ≤¨', desc: 'Ïä§Ïä§Î°ú ÎπõÎÇòÎäî Î≥Ñ Î∞úÍ≤¨.', icon: '‚òÄÔ∏è', tier: 10, level: 0, maxLevel: 1, baseCost: 500000, mult: 1, val: 0, inc: 1 },
            
            { id: 'nucleosynthesis', name: 'ÌïµÏúµÌï©', desc: 'Î™®Îì† ÌñâÏÑ± Í∞ÄÏπò ÎåÄÌè≠ Ï¶ùÍ∞Ä.', icon: '‚ò¢Ô∏è', tier: 11, level: 0, maxLevel: 50, baseCost: 400000, mult: 1.5, val: 1.0, inc: 0.5 },
            { id: 'void_hunger', name: 'Ï§ëÎ†• Ïö∞Î¨º', desc: 'ÏûêÏó∞ Ï§ëÎ†• Ìù°ÏûÖÎ†• Í∞ïÌôî.', icon: 'üëø', tier: 11, level: 0, maxLevel: 10, baseCost: 600000, mult: 2.0, val: 1.0, inc: 0.5 },
            
            { id: 'event_horizon_ex', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ† II', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï∂îÍ∞Ä ÌôïÏû•.', icon: '‚ö´', tier: 12, level: 0, maxLevel: 10, baseCost: 700000, mult: 2.0, val: 0, inc: 5 },
            { id: 'antimatter', name: 'Î∞òÎ¨ºÏßà ÏÉùÏÑ±', desc: 'ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•† Ï∂îÍ∞Ä.', icon: 'üí†', tier: 12, level: 0, maxLevel: 20, baseCost: 800000, mult: 1.6, val: 0, inc: 2 },
            
            { id: 'warp_drive', name: 'ÏõåÌîÑ ÎìúÎùºÏù¥Î∏å', desc: 'ÎßàÏ∞∞Î†• Ï∂îÍ∞Ä Í∞êÏÜå.', icon: 'üöÄ', tier: 13, level: 0, maxLevel: 10, baseCost: 900000, mult: 2.0, val: 0, inc: 0.005 },
            { id: 'federation', name: 'ÏùÄÌïò Ïó∞Ìï©', desc: 'ÌñâÏÑ± Î∞ÄÎèÑ ÎåÄÌè≠ Ï¶ùÍ∞Ä.', icon: 'üõ∏', tier: 13, level: 0, maxLevel: 10, baseCost: 1200000, mult: 1.8, val: 0, inc: 20 },
            
            { id: 'dyson_sphere', name: 'Îã§Ïù¥Ïä® Ïä§ÌîºÏñ¥', desc: 'ÎùºÏö¥Îìú Ï¢ÖÎ£å Ïù¥Ïûê Ï¶ùÍ∞Ä.', icon: 'üåê', tier: 14, level: 0, maxLevel: 10, baseCost: 1500000, mult: 2.0, val: 0, inc: 2 },
            { id: 'dark_energy', name: 'ÏïîÌùë ÏóêÎÑàÏßÄ', desc: 'Ï§ëÎ†•Ïû• Ìûò Í∑πÎåÄÌôî.', icon: 'üü£', tier: 14, level: 0, maxLevel: 20, baseCost: 2000000, mult: 1.6, val: 1.0, inc: 0.2 },
            
            { id: 'expansion_2', name: 'Ïö∞Ï£º ÌôïÏû• II', desc: 'ÏãúÏïº Ï∂îÍ∞Ä ÌôïÏû• (Ï§åÏïÑÏõÉ).', icon: 'üî≠', tier: 15, level: 0, maxLevel: 5, baseCost: 2500000, mult: 3.0, val: 0, inc: 0.1 },
            { id: 'gamma_ray', name: 'Í∞êÎßàÏÑ† Ìè≠Î∞ú', desc: 'Ïä§ÌÇ¨ Ìö®Í≥º Ï¶ùÌè≠.', icon: 'üîÜ', tier: 15, level: 0, maxLevel: 5, baseCost: 3000000, mult: 2.5, val: 1.0, inc: 0.2 },

            { id: 'multiverse', name: 'Îã§Ï§ëÏö∞Ï£º Ï±ÑÍµ¥', desc: 'Í∞ÄÏπò Í∑πÎåÄÌôî.', icon: 'üåå', tier: 16, level: 0, maxLevel: 20, baseCost: 4000000, mult: 1.7, val: 1.0, inc: 1.0 },
            { id: 'reality_anchor', name: 'ÌòÑÏã§ Í≥†Ï†ï', desc: 'ÏãúÍ∞Ñ ÏôúÍ≥° Ìö®Ïú® Ï¶ùÍ∞Ä.', icon: '‚öì', tier: 16, level: 0, maxLevel: 10, baseCost: 5000000, mult: 2.0, val: 0, inc: 2.0 },

            { id: 'supermassive', name: 'Ï¥àÍ±∞ÎåÄ ÏßàÎüâ', desc: 'Í≥†Ï§ëÎ†• Ìö®Í≥º Í∞ïÌôî.', icon: 'üèãÔ∏è', tier: 17, level: 0, maxLevel: 10, baseCost: 7000000, mult: 2.0, val: 1.0, inc: 0.5 },
            
            { id: 'quasar_unlock', name: 'ÌÄòÏù¥ÏÇ¨ ÌååÌé∏', desc: 'Ï†ÑÏÑ§Ï†ÅÏù∏ Î¨ºÏßà Î∞úÍ≤¨.', icon: '‚ú®', tier: 18, level: 0, maxLevel: 1, baseCost: 10000000, mult: 1, val: 0, inc: 1 },
            { id: 'time_dilation', name: 'ÏãúÍ∞Ñ ÏßÄÏó∞', desc: 'ÌñâÏÑ± ÏÜçÎèÑ Í∞êÏÜå.', icon: 'üêå', tier: 18, level: 0, maxLevel: 5, baseCost: 9000000, mult: 2.0, val: 1.0, inc: 0.1 },

            { id: 'omega_point', name: 'Ïò§Î©îÍ∞Ä Ìè¨Ïù∏Ìä∏', desc: 'Î™®Îì† Îä•Î†•Ïπò ÏÜåÌè≠ Ï¶ùÍ∞Ä.', icon: 'Œ©', tier: 19, level: 0, maxLevel: 50, baseCost: 15000000, mult: 1.4, val: 0, inc: 0.05 },
            
            { id: 'big_bang', name: 'ÎπÖÎ±Ö', desc: 'Í∂ÅÍ∑πÏùò Ìûò.', icon: 'üí•', tier: 20, level: 0, maxLevel: 1, baseCost: 100000000, mult: 1, val: 0, inc: 1 },
        ];

        // Achievements
        const ACHIEVEMENTS = [
            { id: 'novice', name: 'Ï¥àÎ≥¥ Ìè¨ÏãùÏûê', desc: 'ÌñâÏÑ± 100Í∞ú Ìù°Ïàò', req: { type: 'count', val: 100 }, bonus: 'force', amount: 0.05 },
            { id: 'skilled', name: 'ÏàôÎ†®Îêú Ìè¨ÏãùÏûê', desc: 'ÌñâÏÑ± 1000Í∞ú Ìù°Ïàò', req: { type: 'count', val: 1000 }, bonus: 'force', amount: 0.1 },
            { id: 'master', name: 'Ïö∞Ï£ºÏùò ÏßÄÎ∞∞Ïûê', desc: 'ÌñâÏÑ± 5000Í∞ú Ìù°Ïàò', req: { type: 'count', val: 5000 }, bonus: 'force', amount: 0.15 },
            { id: 'rich', name: 'Î∂ÄÏûê', desc: 'ÎàÑÏ†Å $100,000 Îã¨ÏÑ±', req: { type: 'money', val: 100000 }, bonus: 'value', amount: 0.2 },
            { id: 'combo', name: 'ÏΩ§Î≥¥ ÎßàÏä§ÌÑ∞', desc: '50 ÏΩ§Î≥¥ Îã¨ÏÑ±', req: { type: 'combo', val: 50 }, bonus: 'crit', amount: 5 } 
        ];

        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 5,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 15,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 40,  valMult: 20, weight: 5 },
            { id: 'electric', color: '#facc15', minR: 15, maxR: 20, mass: 10, valMult: 15, weight: 0, isLightning: true },
            { id: 'giant',    color: '#ef4444', minR: 40, maxR: 60, mass: 80,  valMult: 50, weight: 0 },
            { id: 'ringed',   color: '#d97706', minR: 50, maxR: 70, mass: 150, valMult: 100, weight: 0, hasRings: true },
            { id: 'neutron',  color: '#ffffff', minR: 8,  maxR: 12, mass: 200, valMult: 300, weight: 0, glow: '#0ea5e9' },
            { id: 'star',     color: '#f59e0b', minR: 80, maxR: 120, mass: 500, valMult: 200, weight: 0, isStar: true },
            { id: 'quasar',   color: '#ec4899', minR: 30, maxR: 40, mass: 300, valMult: 500, weight: 0, pulse: true },
            { id: 'comet', color: '#fbbf24', minR: 15, maxR: 20, mass: 20, valMult: 100, weight: 0, isComet: true },
            { id: 'flux', color: '#3b82f6', minR: 15, maxR: 20, mass: 10, valMult: 10, weight: 0, isFlux: true },
            { id: 'magnet', color: '#94a3b8', minR: 15, maxR: 20, mass: 30, valMult: 20, weight: 0, isMagnet: true },
            { id: 'nova', color: '#f97316', minR: 20, maxR: 25, mass: 50, valMult: 40, weight: 0, isNova: true }
        ];

        // Global State
        let GAME = {
            running: false, paused: false, phase: 'start', money: 0, scoreInRound: 0, timeLeft: 10.0, maxTime: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0, lastTime: 0,
            combo: 0, comboTimer: 0, shakeX: 0, shakeY: 0, shakeTime: 0, shakeAmount: 0,
            zoom: 1.0, bhAngle: 0, bhPulse: 0,
            skills: { 
                bomb: { cd: 0, max: 15 }, 
                stasis: { cd: 0, max: 30, dur: 0 }, 
                surge: { cd: 0, max: 60, dur: 0 },
                storm: { cd: 0, max: 45 } 
            },
            bgStars: [], nebulae: [], pixelScale: 1.0,
            stats: { totalAbsorbed: 0, totalMoney: 0, maxCombo: 0, achievements: [] } 
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        let entities = [];
        let texts = [];
        let particles = []; 
        let bolts = []; 
        const blackHole = { radius: 22, angle: 0 }; // Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï§ÑÏûÑ (35 -> 22)

        // 2. HELPER FUNCTIONS
        function getUpgrade(id) { return UPGRADES.find(u => u.id === id); }
        function getTotalLevels() { 
            return UPGRADES.reduce((sum, u) => {
                if(u.tier === 0) return sum + Math.max(0, u.level - 1);
                return sum + u.level;
            }, 0); 
        } 
        function rand(min, max) { return Math.random() * (max - min) + min; }

        function saveGame() {
            const data = { 
                money: GAME.money, 
                upgrades: UPGRADES.map(u => ({ id: u.id, level: u.level })),
                stats: GAME.stats 
            };
            localStorage.setItem('void_harvester_save_v10', JSON.stringify(data));
        }

        function loadGame() {
            const str = localStorage.getItem('void_harvester_save_v10');
            if(!str) return;
            try {
                const data = JSON.parse(str);
                GAME.money = data.money || 0;
                if(data.stats) GAME.stats = data.stats;
                if(data.upgrades) {
                    data.upgrades.forEach(saved => {
                        const u = UPGRADES.find(x => x.id === saved.id);
                        if(u) {
                            u.level = saved.level;
                            const startLvl = u.tier === 0 ? 1 : 0;
                            const gained = Math.max(0, u.level - startLvl);
                            if(gained > 0) {
                                u.val += u.inc * gained;
                                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));
                            }
                        }
                    });
                }
            } catch(e) { console.error("Save load failed", e); }
        }

        function resetSaveData() {
            if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
                localStorage.removeItem('void_harvester_save_v10');
                location.reload();
            }
        }

        function checkAchievements() {
            let newlyUnlocked = false;
            ACHIEVEMENTS.forEach(ach => {
                if (!GAME.stats.achievements.includes(ach.id)) {
                    let unlocked = false;
                    if (ach.req.type === 'count' && GAME.stats.totalAbsorbed >= ach.req.val) unlocked = true;
                    if (ach.req.type === 'money' && GAME.stats.totalMoney >= ach.req.val) unlocked = true;
                    if (ach.req.type === 'combo' && GAME.stats.maxCombo >= ach.req.val) unlocked = true;
                    
                    if (unlocked) {
                        GAME.stats.achievements.push(ach.id);
                        showAchievementToast(ach.name);
                        newlyUnlocked = true;
                    }
                }
            });
            if(newlyUnlocked) updatePassiveStats();
        }

        function showAchievementToast(name) {
            const el = document.createElement('div');
            el.className = 'achievement-toast';
            el.innerHTML = `<strong>üèÜ ÏóÖÏ†Å Îã¨ÏÑ±!</strong><br>${name}`;
            document.getElementById('achievement-container').appendChild(el);
            setTimeout(() => el.remove(), 4000);
        }

        function updatePassiveStats() {
            let forceBonus = 0;
            let valueBonus = 0;
            let critBonus = 0;
            
            GAME.stats.achievements.forEach(id => {
                const ach = ACHIEVEMENTS.find(a => a.id === id);
                if(ach) {
                    if(ach.bonus === 'force') forceBonus += ach.amount;
                    if(ach.bonus === 'value') valueBonus += ach.amount;
                    if(ach.bonus === 'crit') critBonus += ach.amount;
                }
            });
            
            const el = document.getElementById('passive-stats');
            if (forceBonus > 0 || valueBonus > 0 || critBonus > 0) {
                el.style.display = 'block';
                el.innerHTML = `ÏóÖÏ†Å Î≥¥ÎÑàÏä§:<br>Ìûò +${(forceBonus*100).toFixed(0)}%<br>Í∞ÄÏπò +${(valueBonus*100).toFixed(0)}%<br>ÏπòÎ™ÖÌÉÄ +${critBonus}%`;
            }
        }

        function getAchievementMultiplier(type) {
            let mult = 1.0;
            let add = 0;
            GAME.stats.achievements.forEach(id => {
                const ach = ACHIEVEMENTS.find(a => a.id === id);
                if(ach) {
                    if(type === 'force' && ach.bonus === 'force') mult += ach.amount;
                    if(type === 'value' && ach.bonus === 'value') mult += ach.amount;
                    if(type === 'crit' && ach.bonus === 'crit') add += ach.amount;
                }
            });
            return { mult, add };
        }

        // 3. CLASSES 
        class SoundManager {
            constructor() { this.ctx = null; this.muted = false; }
            init() { 
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }
            playTone(freq, type, duration, vol=0.1) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + duration);
            }
            playPop() { this.playTone(300 + Math.random()*200, 'triangle', 0.1); }
            playSkill(type) { this.playTone(100, 'sawtooth', 0.5); }
            playBuy() { this.playTone(1200, 'sine', 0.1); }
            playStart() { this.playTone(100, 'sawtooth', 1.0); }
            playBonus(type) { this.playTone(1500, 'sine', 0.5, 0.2); }
            playDamage() { this.playTone(150, 'sawtooth', 0.3, 0.5); }
            startGravityHum() {} 
            stopGravityHum() {}
            playSuck() {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine'; // Ï°∞Í∏à Îçî Î∂ÄÎìúÎüΩÍ≥† Î¨µÏßÅÌïòÍ≤å Î≥ÄÍ≤Ω
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.2); // Îçî ÎÇÆÍ≤å Îñ®Ïñ¥Ïßê
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            }
        }
        const audio = new SoundManager();

        class EffectParticle {
            constructor(x, y, color, type) {
                this.x = x; this.y = y; this.color = color; this.type = type; this.life = 1.0;
                if (type === 'explode') {
                    const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 3 + 1;
                    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                    this.decay = 0.05; this.size = Math.random() * 3 + 1;
                } else if (type === 'gravity_suck') {
                    this.vx = 0; this.vy = 0; this.decay = 0.05; this.size = Math.random() * 2 + 1;
                } else if (type === 'trail') {
                    this.vx = 0; this.vy = 0; this.decay = 0.05; this.size = Math.random() * 2 + 2; 
                } else if (type === 'time_bonus') {
                    this.vx = 0; this.vy = -2; this.decay = 0.03; this.size = 0; 
                } else if (type === 'comet_trail') {
                    this.vx = 0; this.vy = 0; this.decay = 0.1; this.size = Math.random() * 3 + 2;
                } else if (type === 'spiral_in') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.dist = Math.random() * 40 + 20; 
                    this.speed = Math.random() * 0.1 + 0.05;
                    this.size = Math.random() * 2 + 1;
                    this.decay = 0.05;
                } else if (type === 'shockwave') {
                    this.vx = 0; this.vy = 0; this.decay = 0.02; this.size = 10;
                    this.maxSize = 300; 
                } else if (type === 'spark') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = 0.1; this.size = Math.random() * 2 + 1;
                } else if (type === 'implode') { // ÎÇ¥Ìåå Ïù¥ÌéôÌä∏
                    this.vx = 0; this.vy = 0;
                    this.decay = 0.1;
                    this.size = 50; // Î∏îÎûôÌôÄÎ≥¥Îã§ ÏïΩÍ∞Ñ ÌÅ∞ ÌÅ¨Í∏∞ÏóêÏÑú ÏãúÏûë
                    this.life = 1.0;
                }
            }
            update(dt) {
                const timeScale = dt * 60;
                if(this.type === 'gravity_suck') {
                    const dx = 0 - this.x; const dy = 0 - this.y;
                    const angle = Math.atan2(dy, dx);
                    this.vx += Math.cos(angle) * 50 * 0.1; this.vy += Math.sin(angle) * 50 * 0.1;
                    this.x += this.vx * timeScale; this.y += this.vy * timeScale;
                } else if (this.type === 'spiral_in') {
                    this.angle += 0.3 * timeScale;
                    this.dist -= 5 * timeScale; // Îπ®Î†§ÎìúÎäî ÏÜçÎèÑ
                    this.x = Math.cos(this.angle) * this.dist;
                    this.y = Math.sin(this.angle) * this.dist;
                    if(this.dist <= 2) this.life = 0; 
                } else if (this.type === 'shockwave') {
                    this.size += 15 * timeScale;
                    if (this.size > this.maxSize) this.life = 0;
                } else if (this.type === 'implode') {
                    this.size -= 15 * timeScale; // Îπ†Î•¥Í≤å ÏûëÏïÑÏßê
                    if (this.size <= 0) this.life = 0;
                } else {
                    this.x += this.vx * timeScale; this.y += this.vy * timeScale;
                }
                this.life -= this.decay * timeScale;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life); 
                if(this.type === 'time_bonus') { 
                    ctx.fillStyle = this.color;
                    ctx.font = 'bold 16px sans-serif'; ctx.fillText(this.color === '#ef4444' ? "-5.0s" : "+0.5s", this.x, this.y); 
                } else if (this.type === 'shockwave') {
                    ctx.strokeStyle = this.color || 'white';
                    ctx.lineWidth = 5 * this.life;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.stroke();
                } else if (this.type === 'implode') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, Math.max(0, this.size), 0, Math.PI * 2); ctx.stroke();
                } else { 
                    ctx.fillStyle = this.color;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); 
                }
                ctx.globalAlpha = 1.0;
            }
        }

        class PopText {
            constructor(x, y, val, isCrit) {
                // x, y ÏúÑÏπòÎ•º ÎûúÎç§ÌïòÍ≤å Î∂ÑÏÇ∞ÏãúÏºú Í≤πÏπ® Î∞©ÏßÄ
                this.x = x + (Math.random() - 0.5) * 60; 
                this.y = y - Math.random() * 40; 
                this.text = "+$" + val; 
                this.life = 1.0; 
                this.vy = -4.0; // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî ÏÜçÎèÑ Ï¶ùÍ∞Ä (Í∏∞Ï°¥ -1.5)
                this.isCrit = isCrit;
                this.vx = (Math.random() - 0.5) * 3; // Ï¢åÏö∞ ÌçºÏßê Ï†ïÎèÑ Ï¶ùÍ∞Ä
            }
            update(dt) { 
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60; 
                this.life -= 0.015 * dt * 60; // ÏÇ¨ÎùºÏßÄÎäî ÏÜçÎèÑ Ï°∞Í∏à Îä¶Ï∂§
                this.vy *= 0.96; // ÎßàÏ∞∞Î†• Ï°∞Ï†à
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.isCrit ? '#ef4444' : '#4ade80';
                if(parseInt(this.text.substring(2)) > 1000) ctx.fillStyle = '#facc15'; 
                
                // Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÎåÄÌè≠ ÌôïÎåÄ
                ctx.font = this.isCrit ? '900 45px "Pretendard"' : '800 32px "Pretendard"';
                ctx.textAlign = "center"; // ÌÖçÏä§Ìä∏ Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨
                
                // Scale effect for pop text
                const scale = this.life > 0.8 ? 1.2 : 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(scale, scale);
                
                // Í∏ÄÏûê ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 5;
                ctx.strokeText(this.text, 0, 0);
                
                ctx.fillText(this.text, 0, 0); 
                ctx.restore();
                
                ctx.globalAlpha = 1.0;
                ctx.textAlign = "start"; // Ï†ïÎ†¨ Ï¥àÍ∏∞Ìôî
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2) { 
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; 
                this.life = 1.0; 
                this.segments = [];
                this.generateSegments();
            }

            generateSegments() {
                const dist = Math.sqrt((this.x2-this.x1)**2 + (this.y2-this.y1)**2);
                const steps = Math.floor(dist / 10);
                let cx = this.x1;
                let cy = this.y1;
                
                this.segments.push({x: cx, y: cy});

                for(let i=1; i<steps; i++) {
                    const t = i / steps;
                    // Linear interpolation
                    let lx = this.x1 + (this.x2 - this.x1) * t;
                    let ly = this.y1 + (this.y2 - this.y1) * t;
                    
                    // Jitter
                    const jitter = (Math.random() - 0.5) * 20;
                    lx += jitter * (this.y2 - this.y1) / dist; // Perpendicular offset approx
                    ly += jitter * (this.x1 - this.x2) / dist;

                    this.segments.push({x: lx, y: ly});
                    cx = lx; cy = ly;
                }
                this.segments.push({x: this.x2, y: this.y2});
            }

            update(dt) { this.life -= 0.1 * dt * 60; }
            
            draw(ctx) { 
                if(this.life<=0) return; 
                ctx.globalAlpha = this.life; 
                ctx.strokeStyle = '#facc15'; 
                ctx.lineWidth = 3; 
                
                // Outer glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#facc15';

                ctx.beginPath(); 
                ctx.moveTo(this.segments[0].x, this.segments[0].y);
                for(let i=1; i<this.segments.length; i++) {
                    ctx.lineTo(this.segments[i].x, this.segments[i].y);
                }
                ctx.stroke(); 
                
                // Reset shadow
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0; 
            }
        }

        class Shard {
            constructor(forceType) {
                const expansion = getUpgrade('expansion').val + (getUpgrade('expansion_2') ? getUpgrade('expansion_2').val : 0);
                GAME.zoom = 0.7 / Math.max(1, expansion);
                const angle = Math.random() * Math.PI * 2;
                
                // ** Spawn Distance Reduced **
                const minDist = 300 / GAME.zoom; // Was 600
                const dist = minDist + Math.random() * 300;
                
                this.x = Math.cos(angle) * dist;
                this.y = Math.sin(angle) * dist;
                this.orbitSpeed = 0.003 * (Math.random() < 0.5 ? 1 : -1);
                
                this.vx = 0; this.vy = 0;
                let frictionBase = getUpgrade('friction').val;
                if(getUpgrade('warp_drive')) frictionBase -= getUpgrade('warp_drive').val;
                this.friction = frictionBase;

                if (forceType) {
                    let t = SHARD_TYPES.find(x => x.id === forceType);
                    this.type = t; this.color = t.color; this.radius = rand(t.minR, t.maxR);
                    this.mass = t.mass; 
                    this.sides = 0; // ÌäπÏàò ÏÉùÏÑ±ÏùÄ Í∏∞Î≥∏ ÏõêÌòï
                    this.rotation = 0;
                    this.spin = (Math.random() - 0.5) * 0.1;
                    this.value = Math.floor(this.radius * 2 * t.valMult * VALUE_MULTIPLIER);
                    this.orbitSpeed *= 5; return;
                }

                let available = [SHARD_TYPES[0]]; 
                const tierLvl = getUpgrade('tier_unlock').val; 
                if (tierLvl >= 2) available.push(SHARD_TYPES[1]);
                if (tierLvl >= 3) available.push(SHARD_TYPES[2]);
                if (tierLvl >= 4) available.push(SHARD_TYPES[3]);
                
                const lightningUnlocked = getUpgrade('lightning_unlock').level > 0;
                const ringUnlocked = getUpgrade('unlock_ring').level > 0;
                const magnetUnlocked = getUpgrade('unlock_magnet').level > 0;
                const novaUnlocked = getUpgrade('unlock_nova').level > 0;
                const neutronUnlocked = getUpgrade('neutron_unlock') && getUpgrade('neutron_unlock').level > 0;
                const starUnlocked = getUpgrade('star_unlock') && getUpgrade('star_unlock').level > 0;
                const quasarUnlocked = getUpgrade('quasar_unlock') && getUpgrade('quasar_unlock').level > 0;
                
                if (expansion >= 1.2) available.push(SHARD_TYPES[5]); 
                if (ringUnlocked && expansion >= 1.4) available.push(SHARD_TYPES[6]);
                if (neutronUnlocked && expansion >= 1.6) available.push(SHARD_TYPES[7]);
                if (starUnlocked && expansion >= 2.0) available.push(SHARD_TYPES[8]);
                if (quasarUnlocked && expansion >= 2.5) available.push(SHARD_TYPES[9]);
                if (magnetUnlocked) available.push(SHARD_TYPES[12]);
                if (novaUnlocked) available.push(SHARD_TYPES[13]);

                const luckBonus = getUpgrade('luck') ? getUpgrade('luck').val : 1;

                let type = null;
                if (lightningUnlocked && Math.random() < 0.05 * luckBonus) type = SHARD_TYPES[4];
                else {
                    const totalW = available.reduce((a,b)=>a+(b.weight || 10), 0);
                    let r = Math.random() * totalW;
                    type = available[0];
                    for(let t of available){
                        if(r < (t.weight || 10)) { type = t; break; }
                        r -= (t.weight || 10);
                    }
                }
                
                this.type = type; this.color = type.color; this.radius = rand(type.minR, type.maxR);
                this.mass = type.mass; 
                
                // Î™®Ïñë ÎûúÎç§Ìôî (0: Ïõê, 3: ÏÇºÍ∞ÅÌòï, 4: ÏÇ¨Í∞ÅÌòï, 5: Ïò§Í∞ÅÌòï, 6: Ïú°Í∞ÅÌòï)
                this.sides = 0;
                if(['blue', 'green', 'orange', 'purple', 'electric', 'giant'].includes(this.type.id)) {
                    const shapes = [0, 3, 4, 5, 6]; 
                    this.sides = shapes[Math.floor(Math.random() * shapes.length)];
                }
                
                // ÏûêÏ†Ñ ÏÑ§Ï†ï
                this.rotation = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.15; // ÏûêÏ†Ñ ÏÜçÎèÑ

                const valueBonus = getUpgrade('value').val;
                this.value = Math.floor(this.radius * 2 * type.valMult * valueBonus * VALUE_MULTIPLIER);
            }

            update(dt) {
                const timeScale = dt * 60;
                let globalSpeed = 1.0;
                let playerSuctionMult = 1.0;

                // ÏûêÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
                this.rotation += this.spin * timeScale;

                if (GAME.skills.stasis.dur > 0) {
                    globalSpeed = 0.0;
                    playerSuctionMult = 3.0;
                }
                
                // Anomaly moves anyway
                if (this.type.isComet || this.type.isFlux) {
                      globalSpeed = 1.0; 
                      particles.push(new EffectParticle(this.x, this.y, this.color, 'comet_trail'));
                }

                const currentOrbitSpeed = this.orbitSpeed * timeScale * globalSpeed;
                const cos = Math.cos(currentOrbitSpeed); const sin = Math.sin(currentOrbitSpeed);
                const nx = this.x * cos - this.y * sin; const ny = this.x * sin + this.y * cos;
                this.x = nx; this.y = ny;

                const distSq = this.x*this.x + this.y*this.y;
                const dist = Math.sqrt(distSq);

                // Natural Gravity
                let naturalRange = getUpgrade('attract_range').val / GAME.zoom;
                let naturalG = 1000;
                const wellMult = getUpgrade('void_hunger') ? getUpgrade('void_hunger').val : 1.0;
                naturalG *= wellMult;
                if (GAME.skills.surge.dur > 0) { naturalRange = 10000; naturalG *= 3; }

                if (dist < naturalRange) {
                    const g = naturalG / distSq;
                    let force = g / this.mass;
                    if(GAME.skills.stasis.dur > 0) force = 0;
                    if (globalSpeed > 0 || GAME.skills.surge.dur > 0) {
                        this.vx += (-this.x/dist) * force * timeScale;
                        this.vy += (-this.y/dist) * force * timeScale;
                    }
                }

                if (INPUT.isDown) {
                    const radius = getUpgrade('radius').val / GAME.zoom;
                    let power = getUpgrade('force').val;
                    if(getUpgrade('dark_energy')) power *= getUpgrade('dark_energy').val;
                    
                    const heavyBonus = getUpgrade('heavy').val + (getUpgrade('supermassive') ? getUpgrade('supermassive').val : 0);
                    const frenzy = getUpgrade('frenzy') && getUpgrade('frenzy').level > 0;
                    if(frenzy && GAME.timeLeft <= 3.0) power *= 2;

                    // Mouse Logic Coordinates
                    const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                    const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                    const mdx = worldMouseX - this.x; const mdy = worldMouseY - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        let effectiveMass = this.mass;
                        if (GAME.skills.stasis.dur > 0) effectiveMass *= 0.5;
                        else if(effectiveMass > 8) effectiveMass /= heavyBonus; 

                        const accel = (2.0 * power * playerSuctionMult) / effectiveMass;

                        this.vx += (-this.x / Math.sqrt(this.x*this.x+this.y*this.y)) * accel * timeScale;
                        this.vy += (-this.y / Math.sqrt(this.x*this.x+this.y*this.y)) * accel * timeScale;
                    }
                }
                
                const sForce = (getUpgrade('singularity').val * 0.05) / this.mass;
                if (sForce > 0) {
                    this.vx += (-this.x/dist) * sForce * timeScale;
                    this.vy += (-this.y/dist) * sForce * timeScale;
                }

                // Tunneling Prevention (High speed collision)
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy) * timeScale;
                // Dot product < 0 means moving towards center
                if (speed > dist && (this.x * this.vx + this.y * this.vy) < 0) {
                     this.x = 0; this.y = 0; // Force capture
                     return true;
                }

                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.vx *= Math.pow(this.friction, timeScale);
                this.vy *= Math.pow(this.friction, timeScale);

                // Re-calculate distance for collision
                const newDist = Math.sqrt(this.x*this.x + this.y*this.y);
                const bhSize = blackHole.radius + 10; 
                if (newDist < bhSize) return true;
                return false;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation); // ÌöåÏ†Ñ Ï†ÅÏö©
                ctx.fillStyle = this.color;
                
                if (this.type.isComet) {
                    ctx.shadowColor = this.color; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.ellipse(0, 0, this.radius*1.5, this.radius*0.8, 0, 0, Math.PI*2); ctx.fill();
                } else if (this.type.isStar) {
                    ctx.shadowColor = this.color; ctx.shadowBlur = 30;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                } else if (this.type.isMagnet) {
                    ctx.shadowColor = '#cbd5e1'; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#475569'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.fillStyle = '#1e293b'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                    ctx.fillText('U', 0, 0); // Magnet shape
                } else if (this.type.isNova) {
                    ctx.shadowColor = '#f97316'; ctx.shadowBlur = 25;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    // Pulse animation
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(Date.now()/100)*0.5})`;
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, this.radius*1.2, 0, Math.PI*2); ctx.stroke();
                } else {
                    // Îã§Í∞ÅÌòï Í∑∏Î¶¨Í∏∞ Î°úÏßÅ
                    ctx.beginPath();
                    if (this.sides >= 3) {
                        for(let i=0; i<this.sides; i++) {
                            const theta = (i / this.sides) * Math.PI * 2;
                            const px = Math.cos(theta) * this.radius;
                            const py = Math.sin(theta) * this.radius;
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                    } else {
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }
                
                if (this.type.hasRings) {
                    ctx.beginPath(); ctx.ellipse(0, 0, this.radius * 2.2, this.radius * 0.6, -0.2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)'; ctx.lineWidth = this.radius * 0.3; ctx.stroke();
                }
                ctx.restore();
            }
        }

        // 4. LOGIC
        function triggerChainLightning(source) {
             const range = getUpgrade('l_range').val / GAME.zoom;
             const count = getUpgrade('l_count').val;
             const lForce = getUpgrade('l_force').val;

             let candidates = entities.filter(e => e !== source && (e.x-source.x)**2 + (e.y-source.y)**2 < range**2);
             for(let i=0; i<count && candidates.length>0; i++) {
                 const idx = Math.floor(Math.random()*candidates.length);
                 const e = candidates[idx]; candidates.splice(idx,1);
                 
                 // Improved Lightning Visual
                 bolts.push(new LightningBolt(source.x, source.y, e.x, e.y));
                 GAME.shakeTime = 0.2; GAME.shakeAmount = 5;

                 // Spawn Sparks
                 for(let k=0; k<5; k++) particles.push(new EffectParticle(e.x, e.y, '#facc15', 'spark'));

                 // Apply Pull Force
                 const force = lForce / e.mass; 
                 e.vx += (-e.x / Math.sqrt(e.x*e.x+e.y*e.y)) * force;
                 e.vy += (-e.y / Math.sqrt(e.x*e.x+e.y*e.y)) * force;
             }
        }

        function updateGame(dt) {
            if (GAME.paused) return;

            GAME.bhAngle += dt; // Spin the black hole
            GAME.bhPulse += dt * 2; // Pulse effect

            if (GAME.skills.stasis.dur > 0) GAME.skills.stasis.dur -= dt;
            if (GAME.skills.surge.dur > 0) GAME.skills.surge.dur -= dt;
            if (GAME.skills.bomb.cd > 0) GAME.skills.bomb.cd -= dt;
            
            // Skill Cooldowns
            if (GAME.skills.stasis.cd > 0) GAME.skills.stasis.cd -= dt;
            if (GAME.skills.surge.cd > 0) GAME.skills.surge.cd -= dt;
            if (GAME.skills.storm.cd > 0) GAME.skills.storm.cd -= dt;

            // Combo Timer
            if (GAME.combo > 0) {
                GAME.comboTimer -= dt;
                if (GAME.comboTimer <= 0) {
                    GAME.combo = 0;
                    updateComboUI();
                }
            }

            if (GAME.skills.stasis.dur <= 0) GAME.timeLeft -= dt;
            if (GAME.timeLeft <= 0) { GAME.timeLeft = 0; endGame(); return; }

            if (Math.random() < 0.005) {
                 if(Math.random() < 0.5) entities.push(new Shard('comet'));
                 else entities.push(new Shard('flux'));
            }

            if (entities.length < 5) entities.push(new Shard());
            if (INPUT.isDown) {
                const radius = getUpgrade('radius').val / GAME.zoom;
                for(let i=0; i<2; i++) {
                    const angle = Math.random() * Math.PI * 2; const dist = Math.random() * radius;
                    const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                    const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                    const px = worldMouseX + Math.cos(angle) * dist;
                    const py = worldMouseY + Math.sin(angle) * dist;
                    particles.push(new EffectParticle(px, py, '#22d3ee', 'gravity_suck'));
                }
            }

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update(dt)) {
                    // Logic when absorbed
                    if (e.type.isLightning) triggerChainLightning(e);
                    
                    if (e.type.isMagnet) {
                        audio.playSkill('bomb'); // Use bomb sound
                        GAME.shakeTime = 0.5; GAME.shakeAmount = 15;
                        particles.push(new EffectParticle(0,0, '#94a3b8', 'shockwave'));
                        entities.forEach(target => {
                             const dist = Math.sqrt(target.x*target.x + target.y*target.y);
                             target.vx += (-target.x/dist) * 200;
                             target.vy += (-target.y/dist) * 200;
                        });
                    }

                    if (e.type.isNova) {
                        audio.playSkill('bomb');
                        GAME.shakeTime = 1.0; GAME.shakeAmount = 30;
                        particles.push(new EffectParticle(0,0, '#f97316', 'shockwave'));
                          // Massive suction
                          entities.forEach(target => {
                             const distSq = target.x*target.x + target.y*target.y;
                             if(distSq < 400*400) { // Range
                                 const dist = Math.sqrt(distSq);
                                 target.vx += (-target.x/dist) * 800;
                                 target.vy += (-target.y/dist) * 800;
                             }
                        });
                    }

                    if (e.type.isComet) { audio.playBonus('comet'); GAME.scoreInRound += e.value*5; GAME.money += e.value*5; texts.push(new PopText(0, -60, e.value*5, true)); }
                    if (e.type.isFlux) { 
                        audio.playBonus('flux'); 
                        GAME.scoreInRound += e.value; // Add score
                        GAME.money += e.value;       // Add money
                        texts.push(new PopText(0, -60, e.value, true)); // Visual feedback for money
                        
                        if(GAME.timeLeft < GAME.maxTime) GAME.timeLeft += 3; 
                        particles.push(new EffectParticle(0, -50, '#3b82f6', 'time_bonus')); 
                    }
                    
                    if (!e.type.isComet && !e.type.isFlux) {
                        GAME.scoreInRound += e.value; GAME.money += e.value;
                        
                        // Combo Logic
                        GAME.combo++;
                        GAME.comboTimer = 2.0;
                        if(GAME.combo > GAME.stats.maxCombo) GAME.stats.maxCombo = GAME.combo;
                        updateComboUI();

                        texts.push(new PopText(0, -30, e.value, false));
                        audio.playPop();
                        audio.playSuck(); // Îπ®ÏïÑÎì§Ïù¥Îäî ÏÜåÎ¶¨ Ï∂îÍ∞Ä
                        
                        // Spawn suck-in particles (ÌôïÏã§ÌïòÍ≤å Ï∂îÍ∞Ä)
                        for(let k=0; k<3; k++) particles.push(new EffectParticle(0,0, e.color, 'spiral_in'));
                        
                        // Implosion Effect (ÏÉàÎ°ú Ï∂îÍ∞Ä)
                        particles.push(new EffectParticle(0,0, e.color, 'implode'));
                        
                        // Small Shake
                        GAME.shakeTime = 0.1; GAME.shakeAmount = 3;

                        // Giant Shockwave
                        if(e.type.id === 'giant' || e.type.id === 'star' || e.type.id === 'quasar') {
                             particles.push(new EffectParticle(0,0, e.color, 'shockwave'));
                             GAME.shakeTime = 0.3; GAME.shakeAmount = 10;
                        }

                        GAME.stats.totalAbsorbed++;
                        GAME.stats.totalMoney += e.value;
                        checkAchievements();
                    }
                    
                    entities.splice(i, 1);
                    if(!e.type.isComet && !e.type.isFlux && Math.random()*100 < getUpgrade('respawn').val) entities.push(new Shard());
                }
            }

            for(let i=bolts.length-1; i>=0; i--) { bolts[i].update(dt); if(bolts[i].life<=0) bolts.splice(i,1); }
            for(let i=particles.length-1; i>=0; i--) { particles[i].update(dt); if(particles[i].life<=0) particles.splice(i,1); }
            for(let i=texts.length-1; i>=0; i--) { texts[i].update(dt); if(texts[i].life<=0) texts.splice(i,1); }
            
            if(timerEl) timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(timerEl) {
                if(GAME.timeLeft <= 5.0) {
                    timerEl.classList.add('timer-warn');
                    document.getElementById('danger-overlay').style.opacity = (Math.sin(Date.now() / 150) + 1) * 0.4;
                } else {
                    timerEl.classList.remove('timer-warn');
                    document.getElementById('danger-overlay').style.opacity = 0;
                }
            }

            if(scoreEl) scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();

            updateSkillUI();
        }

        function drawGame() {
            // Screen Shake
            let dx = 0, dy = 0;
            if (GAME.shakeTime > 0) {
                GAME.shakeTime -= 0.016;
                const amt = GAME.shakeAmount || 5;
                dx = (Math.random()-0.5) * amt; dy = (Math.random()-0.5) * amt;
            }

            ctx.setTransform(1,0,0,1,0,0);
            ctx.clearRect(0,0,GAME.width, GAME.height);

            // Draw Background (Static Stars)
            ctx.save();
            ctx.fillStyle = "#ffffff";
            GAME.bgStars.forEach(s => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.restore();

            // Setup Camera
            ctx.translate(GAME.centerX + dx, GAME.centerY + dy);
            ctx.scale(GAME.zoom * GAME.pixelScale, GAME.zoom * GAME.pixelScale);
            
            // Draw Range Indicators
            if (INPUT.isDown) {
                const radius = getUpgrade('radius').val / GAME.zoom;
                const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                
                ctx.beginPath();
                ctx.arc(worldMouseX, worldMouseY, radius, 0, Math.PI*2);
                ctx.fillStyle = "rgba(100, 150, 255, 0.1)";
                ctx.fill();
                ctx.strokeStyle = "rgba(100, 150, 255, 0.3)";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw Black Hole (Revised Effect)
            const bhSize = (blackHole.radius + (getUpgrade('blackhole_size') ? getUpgrade('blackhole_size').val : 0) + (getUpgrade('event_horizon_ex') ? getUpgrade('event_horizon_ex').val : 0));
            const pulse = Math.sin(GAME.bhPulse * 2) * 2;
            
            // 1. Outer Glow (Aura)
            const grad = ctx.createRadialGradient(0, 0, bhSize, 0, 0, bhSize * 3 + pulse);
            grad.addColorStop(0, "rgba(0, 0, 0, 0)"); 
            grad.addColorStop(0.2, "rgba(124, 58, 237, 0.2)"); // Purple weak
            grad.addColorStop(0.5, "rgba(139, 92, 246, 0.1)"); // Purple even weaker
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, bhSize * 4, 0, Math.PI*2); ctx.fill();

            // 2. Accretion Disk Swirls (Cleaner lines)
            ctx.save();
            ctx.rotate(GAME.bhAngle);
            ctx.strokeStyle = "rgba(167, 139, 250, 0.3)"; // Soft Purple Lines
            ctx.lineWidth = 3;
            for(let i=0; i<4; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, bhSize * (1.3 + i*0.25) + pulse/2, i * Math.PI/2, i * Math.PI/2 + Math.PI);
                ctx.stroke();
            }
            ctx.restore();

            // 3. Event Horizon (Sharp Black Circle)
            ctx.save();
            ctx.shadowColor = "#8b5cf6"; // Violet Glow
            ctx.shadowBlur = 20 + pulse;
            ctx.fillStyle = "#000000";
            ctx.beginPath(); ctx.arc(0, 0, bhSize, 0, Math.PI*2); ctx.fill();
            
            // 4. Photon Ring (White Rim)
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Draw Game Objects
            entities.forEach(e => e.draw(ctx));
            bolts.forEach(b => b.draw(ctx));
            particles.forEach(p => p.draw(ctx));
            texts.forEach(t => t.draw());
        }

        function gameLoop() {
            if (GAME.running) {
                const now = performance.now();
                const dt = Math.min((now - GAME.lastTime) / 1000, 0.1);
                GAME.lastTime = now;
                updateGame(dt);
                drawGame();
                requestAnimationFrame(gameLoop);
            }
        }

        // 5. UI & CONTROL
        function startGame() {
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            document.getElementById('skill-bar').style.display = 'flex';
            
            GAME.timeLeft = getUpgrade('time').val + (getUpgrade('chrono_battery') ? getUpgrade('chrono_battery').val : 0);
            GAME.maxTime = GAME.timeLeft;
            GAME.scoreInRound = 0;
            GAME.combo = 0;
            updateComboUI();
            
            // Reset Skill CD partially or fully? Let's reset durations but keep CD?
            // Usually roguelikes reset skills per round or keep state. Let's keep state for strategy.
            // Reset durations though.
            GAME.skills.stasis.dur = 0;
            GAME.skills.surge.dur = 0;

            GAME.running = true;
            GAME.lastTime = performance.now();
            
            // Reset Entities based on density
            entities = [];
            const density = 5 + getUpgrade('density').val + (getUpgrade('federation') ? getUpgrade('federation').val : 0);
            for(let i=0; i<density; i++) entities.push(new Shard());
            
            gameLoop();
            audio.playStart();
        }

        function endGame() {
            GAME.running = false;
            ingameUi.style.display = 'none';
            document.getElementById('skill-bar').style.display = 'none';
            upgradeScreen.style.display = 'flex';

            // Interest
            const interest = getUpgrade('interest').level * 0.05 + (getUpgrade('dyson_sphere') ? getUpgrade('dyson_sphere').level * 0.02 : 0);
            if(interest > 0) {
                 const bonus = Math.floor(GAME.money * interest);
                 GAME.money += bonus;
                 // maybe show toast?
            }

            saveGame();
            renderTree();
            upgradeMoneyEl.innerText = '$' + Math.floor(GAME.money).toLocaleString();
            totalLevelEl.innerText = "Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: " + getTotalLevels();
        }

        function firstStart() {
            audio.init();
            startOverlay.style.opacity = 0;
            setTimeout(() => { 
                startOverlay.style.display = 'none'; 
                renderTree(); // Ensure tree is ready
                startGame(); // Start immediately
            }, 500);
        }

        function toggleMute() {
            audio.muted = !audio.muted;
            document.getElementById('mute-btn').innerText = audio.muted ? 'üîá' : 'üîä';
        }

        // Upgrade Tree System
        function renderTree() {
            treeContainer.innerHTML = '';
            upgradeMoneyEl.innerText = '$' + Math.floor(GAME.money).toLocaleString();
            totalLevelEl.innerText = "Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: " + getTotalLevels();

            const currentTotalLevels = getTotalLevels();
            
            // Group by tier
            const maxTier = Math.max(...UPGRADES.map(u => u.tier));

            for (let t = 0; t <= maxTier; t++) {
                const tierUpgrades = UPGRADES.filter(u => u.tier === t);
                if (tierUpgrades.length === 0) continue;

                const section = document.createElement('div');
                section.className = 'tier-section';
                
                const req = TIER_UNLOCKS[t];
                const locked = currentTotalLevels < req;
                
                let headerHTML = `<div class="tier-header"><span class="tier-title">TIER ${t}</span>`;
                if(locked) headerHTML += `<span class="tier-lock-msg">üîí ÌïÑÏöî Î†àÎ≤®: ${req}</span>`;
                else headerHTML += `<span class="tier-unlock-msg">üîì UNLOCKED</span>`;
                headerHTML += `</div>`;
                
                section.innerHTML = headerHTML;

                const grid = document.createElement('div');
                grid.className = 'tier-grid';

                tierUpgrades.forEach(u => {
                    const el = document.createElement('div');
                    el.className = `card ${locked ? 'locked' : ''}`;
                    const isMax = u.level >= u.maxLevel;
                    const cost = Math.floor(u.baseCost * Math.pow(u.mult, u.level));
                    
                    if (locked) {
                        el.innerHTML = `üîí Tier ${t}`;
                    } else {
                        if (GAME.money < cost && !isMax) el.classList.add('disabled');
                        
                        el.onclick = () => buyUpgrade(u);
                        
                        el.innerHTML = `
                            <div class="card-lvl ${isMax ? 'max-lvl' : ''}">Lv.${u.level}</div>
                            <div class="card-header">
                                <span class="card-icon">${u.icon}</span>
                                <span class="card-name">${u.name}</span>
                            </div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-footer">
                                <div class="card-stat">ÌòÑÏû¨: ${Number.isInteger(u.val) ? u.val : u.val.toFixed(2)}</div>
                                <div class="card-cost">${isMax ? 'MAX' : '$' + cost.toLocaleString()}</div>
                            </div>
                        `;
                    }
                    grid.appendChild(el);
                });

                section.appendChild(grid);
                treeContainer.appendChild(section);
            }
        }

        function buyUpgrade(u) {
            if (u.level >= u.maxLevel) return;
            const cost = Math.floor(u.baseCost * Math.pow(u.mult, u.level));
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                // Fix float precision issues
                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));
                
                audio.playBuy();
                saveGame();
                renderTree();
                
                // Unlock check
                if (u.type === 'skill') {
                     // Skill unlcok logic handled in updateSkillUI via level check
                }
            }
        }

        // Skill System
        function activateSkill(id) {
            if (GAME.paused) return;
            
            const skillData = GAME.skills[id];
            const upgrade = UPGRADES.find(u => u.id === `unlock_${id}`);
            
            if (!upgrade || upgrade.level <= 0) return; // Not unlocked
            if (skillData.cd > 0) return; // Cooldown

            const mastery = getUpgrade('skill_mastery') ? getUpgrade('skill_mastery').val : 0; // % reduction
            const gamma = getUpgrade('gamma_ray') ? getUpgrade('gamma_ray').val : 1.0;

            audio.playSkill(id);

            if (id === 'bomb') {
                // Massive Gravity Pulse
                GAME.shakeTime = 0.5; GAME.shakeAmount = 20;
                particles.push(new EffectParticle(0,0, '#ef4444', 'shockwave'));
                
                // Î∞∏Îü∞Ïä§ Ï°∞Ï†ï: Ï¥àÍ∏∞ ÏúÑÎ†• 50, Î†àÎ≤®Îãπ +15 (Í∏∞Ï°¥ 150 Í≥†Ï†ïÏóêÏÑú Î≥ÄÍ≤Ω)
                const baseForce = 50 + (upgrade.level * 15);
                const finalForce = baseForce * gamma;

                entities.forEach(e => {
                     const dist = Math.sqrt(e.x*e.x + e.y*e.y);
                     e.vx += (-e.x/dist) * finalForce; 
                     e.vy += (-e.y/dist) * finalForce;
                });
                
                // Ïø®ÌÉÄÏûÑ Í∞êÏÜå: Î†àÎ≤®Îãπ 0.5Ï¥à Í∞êÏÜå
                const baseCd = Math.max(5, skillData.max - (upgrade.level * 0.5));
                skillData.cd = baseCd * (1 - mastery/100);
            } 
            else if (id === 'stasis') {
                skillData.dur = (3.0 + upgrade.level * 0.5) * gamma;
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            else if (id === 'surge') {
                skillData.dur = (5.0 + upgrade.level * 0.5) * gamma;
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            else if (id === 'storm') {
                // Destroy random targets
                const count = (15 + upgrade.level * 3) * gamma; // Î≤ÑÌîÑ: Í∏∞Î≥∏ 15Ìöå, Î†àÎ≤®Îãπ +3Ìöå
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                         if(entities.length > 0) {
                             const target = entities[Math.floor(Math.random()*entities.length)];
                             triggerChainLightning(target); // Reuse logic
                         }
                    }, i * 50); // Î≤ÑÌîÑ: Î∞úÎèô ÏÜçÎèÑ 2Î∞∞ (100ms -> 50ms)
                }
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            
            updateSkillUI();
        }

        function updateSkillUI() {
            const list = ['bomb', 'stasis', 'surge', 'storm'];
            list.forEach(id => {
                const upgrade = UPGRADES.find(u => u.id === `unlock_${id}`);
                const slot = document.getElementById(`slot-${id}`);
                const cdOverlay = document.getElementById(`cd-${id}`);
                const glow = document.getElementById(`glow-${id}`);
                const lvlInd = document.getElementById(`lvl-${id}`);

                if (upgrade && upgrade.level > 0) {
                    slot.classList.add('unlocked');
                    lvlInd.innerText = upgrade.level;
                    
                    const data = GAME.skills[id];
                    if (data.cd > 0) {
                        const pct = (data.cd / data.max) * 100;
                        cdOverlay.style.height = `${pct}%`;
                        slot.style.cursor = 'default';
                    } else {
                        cdOverlay.style.height = '0%';
                        slot.style.cursor = 'pointer';
                    }

                    if (data.dur > 0) glow.style.opacity = 1;
                    else glow.style.opacity = 0;

                } else {
                    slot.classList.remove('unlocked');
                }
            });
        }

        function updateComboUI() {
            if (GAME.combo > 1) {
                comboBox.style.opacity = 1;
                comboBox.style.transform = `scale(${1 + GAME.combo*0.02})`;
                comboValEl.innerText = `x${GAME.combo}`;
            } else {
                comboBox.style.opacity = 0;
                comboBox.style.transform = 'scale(1)';
            }
        }

        // Initialization
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            scoreEl = document.getElementById('score-display');
            timerEl = document.getElementById('timer-display');
            upgradeScreen = document.getElementById('upgrade-screen');
            upgradeMoneyEl = document.getElementById('upgrade-money');
            totalLevelEl = document.getElementById('total-level-display');
            treeContainer = document.getElementById('tree-container');
            startOverlay = document.getElementById('start-overlay');
            ingameUi = document.getElementById('ingame-ui');
            comboBox = document.getElementById('combo-box');
            comboValEl = document.getElementById('combo-val');
            passiveStatsEl = document.getElementById('passive-stats');
            pauseOverlay = document.getElementById('pause-overlay');

            lvlBombEl = document.getElementById('lvl-bomb');
            lvlStasisEl = document.getElementById('lvl-stasis');
            lvlSurgeEl = document.getElementById('lvl-surge');
            lvlStormEl = document.getElementById('lvl-storm');

            window.addEventListener('resize', resize);
            resize();
            
            // Input Handlers
            canvas.addEventListener('mousedown', e => { INPUT.isDown = true; INPUT.x = e.clientX; INPUT.y = e.clientY; audio.startGravityHum(); });
            window.addEventListener('mouseup', () => { INPUT.isDown = false; audio.stopGravityHum(); });
            canvas.addEventListener('mousemove', e => { INPUT.x = e.clientX; INPUT.y = e.clientY; });
            
            canvas.addEventListener('touchstart', e => { 
                INPUT.isDown = true; 
                INPUT.x = e.touches[0].clientX; INPUT.y = e.touches[0].clientY; 
                e.preventDefault();
            }, {passive: false});
            window.addEventListener('touchend', () => INPUT.isDown = false);
            canvas.addEventListener('touchmove', e => {
                 INPUT.x = e.touches[0].clientX; INPUT.y = e.touches[0].clientY;
                 e.preventDefault();
            }, {passive: false});

            // Keyboard
            window.addEventListener('keydown', e => {
                if (e.key === 'q' || e.key === 'Q') activateSkill('bomb');
                if (e.key === 'w' || e.key === 'W') activateSkill('stasis');
                if (e.key === 'e' || e.key === 'E') activateSkill('surge');
                if (e.key === 'r' || e.key === 'R') activateSkill('storm');
                if (e.key === 'Escape') togglePause();
            });

            // Load Data
            loadGame();
            
            // Generate BG Stars
            for(let i=0; i<200; i++) {
                GAME.bgStars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2
                });
            }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
            GAME.pixelScale = Math.min(canvas.width, canvas.height) / BASE_RESOLUTION * 1.5; 
            // Regenerate BG stars
             GAME.bgStars = [];
             for(let i=0; i<200; i++) {
                GAME.bgStars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2
                });
            }
        }

        function togglePause() {
            if (GAME.phase !== 'start' && upgradeScreen.style.display !== 'flex') {
                GAME.paused = !GAME.paused;
                pauseOverlay.style.display = GAME.paused ? 'flex' : 'none';
            }
        }

    </script>
</body>
</html><!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Void Harvester: Planetary Devourer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050814;
            color: #e2e8f0;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ïù∏Í≤åÏûÑ UI */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            z-index: 10;
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #f8fafc;
            text-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
        }
        
        .timer-warn { color: #ef4444; text-shadow: 0 0 15px rgba(239, 68, 68, 0.6); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        /* ÏΩ§Î≥¥ UI */
        .combo-box {
            align-self: center;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }
        .combo-val {
            font-size: 4rem; font-weight: 900; 
            background: linear-gradient(to bottom, #fcd34d, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-style: italic;
        }
        .combo-label { font-size: 1.2rem; color: #fbbf24; font-weight: 700; letter-spacing: 2px; }

        /* ÏóÖÏ†Å ÏïåÎ¶º UI */
        #achievement-container {
            position: absolute;
            top: 220px; 
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 15;
        }
        
        .achievement-toast {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #3b82f6;
            border-left: 5px solid #3b82f6;
            padding: 10px 15px;
            border-radius: 4px;
            color: white;
            width: 280px;
            animation: slideIn 0.5s ease-out, fadeOut 0.5s ease-in 4.5s forwards;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        @keyframes slideIn { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Ìå®ÏãúÎ∏å Î≥¥ÎÑàÏä§ ÌëúÏãú */
        #passive-stats {
            position: absolute;
            top: 100px;
            left: 20px;
            font-size: 0.8rem;
            color: #94a3b8;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10;
            display: none; 
            line-height: 1.4;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Ïä§ÌÇ¨ Î∞î UI */
        #skill-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto;
            z-index: 10;
        }

        .skill-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.3;
            filter: grayscale(1);
            transition: all 0.3s;
            pointer-events: auto;
            cursor: pointer;
            position: relative;
        }

        .skill-slot.unlocked {
            opacity: 1;
            filter: grayscale(0);
        }
        
        .skill-icon {
            width: 60px; height: 60px;
            border-radius: 16px;
            background: #1e293b;
            border: 2px solid #475569;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .skill-slot.unlocked .skill-icon {
            background: #4f46e5;
            border-color: #818cf8;
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
        }
        
        .skill-overlay {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
        }

        .skill-active-glow {
            position: absolute; top:0; left:0; width:100%; height:100%;
            border: 3px solid #facc15;
            border-radius: 16px;
            box-shadow: 0 0 15px #facc15;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .skill-key {
            margin-top: 5px;
            font-size: 0.8rem; font-weight: bold; color: #cbd5e1;
            background: rgba(0,0,0,0.5); padding: 2px 8px; border-radius: 10px;
        }

        .skill-level-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #facc15;
            color: #0f172a;
            font-size: 0.7rem;
            font-weight: 800;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            display: none; /* Initially hidden */
        }
        .skill-slot.unlocked .skill-level-indicator {
            display: flex;
        }
        
        /* ÏùåÏÜåÍ±∞ Î≤ÑÌäº */
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(30, 41, 59, 0.8);
            color: white;
            border: 1px solid #475569;
            border-radius: 50%;
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }
        #mute-btn:hover { background: #334155; }

        /* ÏùºÏãúÏ†ïÏßÄ Ïò§Î≤ÑÎ†àÏù¥ */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            z-index: 90; display: none;
            flex-direction: column; align-items: center; justify-content: center;
            color: white; font-size: 3rem; font-weight: 900;
        }
        .pause-text { margin-bottom: 20px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .pause-sub { font-size: 1.2rem; font-weight: 400; color: #94a3b8; }

        /* ÏúÑÍ∏∞ Í≤ΩÍ≥† Ïò§Î≤ÑÎ†àÏù¥ */
        #danger-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(239, 68, 68, 0.8);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            mix-blend-mode: overlay;
        }

        /* ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 16, 38, 0.98); 
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            width: 100%;
            max-width: 800px;
        }

        .screen-title { font-size: 2rem; font-weight: 900; color: #f1f5f9; margin: 0; text-shadow: 0 0 20px rgba(124, 58, 237, 0.5); }
        .screen-subtitle { font-size: 0.9rem; color: #94a3b8; margin-bottom: 5px; }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1e293b;
            padding: 10px 20px;
            border-radius: 12px;
            border: 1px solid #334155;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 90%;
            margin-bottom: 15px;
        }

        .money-badge { font-size: 1.2rem; font-weight: 800; color: #fbbf24; }
        .level-badge { font-size: 1rem; font-weight: 700; color: #818cf8; }
        
        .reset-data-btn {
            font-size: 0.7rem; color: #64748b; text-decoration: underline; cursor: pointer;
            transition: color 0.2s;
        }
        .reset-data-btn:hover { color: #94a3b8; }

        .tree-scroll-area {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 100px 20px;
            scrollbar-width: thin;
            scrollbar-color: #475569 #0f172a;
        }

        .tier-section { width: 100%; max-width: 1000px; margin-bottom: 40px; position: relative; }
        .tier-header { display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 5px; border-bottom: 2px solid #334155; }
        .tier-title { font-size: 1.2rem; font-weight: 800; color: #e2e8f0; margin-right: 15px; }
        .tier-lock-msg { font-size: 0.9rem; color: #f87171; font-weight: 600; background: rgba(239, 68, 68, 0.1); padding: 2px 8px; border-radius: 4px; }
        .tier-unlock-msg { font-size: 0.9rem; color: #34d399; font-weight: 600; background: rgba(16, 185, 129, 0.1); padding: 2px 8px; border-radius: 4px; }
        .tier-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; }
        
        .card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; position: relative; min-height: 140px;
        }
        .card:hover:not(.disabled):not(.locked) { transform: translateY(-3px); box-shadow: 0 10px 15px rgba(0,0,0,0.3); border-color: #8b5cf6; background: #273549; }
        .card.disabled { opacity: 0.6; filter: grayscale(0.8); }
        .card.locked { background: #0f172a; border: 1px dashed #334155; cursor: not-allowed; opacity: 0.7; align-items: center; justify-content: center; color: #64748b; }
        .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .card-icon { font-size: 24px; }
        .card-name { font-weight: 800; font-size: 0.85rem; color: #f1f5f9; line-height: 1.2; }
        .card-desc { font-size: 0.7rem; color: #94a3b8; margin-bottom: 8px; flex-grow: 1; line-height: 1.3; }
        .card-footer { margin-top: auto; border-top: 1px solid #334155; padding-top: 8px; }
        .card-stat { font-size: 0.7rem; color: #a78bfa; font-weight: 600; margin-bottom: 2px; }
        .card-cost { font-weight: 700; color: #60a5fa; font-size: 0.95rem; }
        .card-lvl { position: absolute; top: 10px; right: 10px; font-size: 0.7rem; font-weight: 800; color: #cbd5e1; background: #334155; padding: 2px 6px; border-radius: 4px; }
        .max-lvl { color: #6ee7b7; background: rgba(16, 185, 129, 0.2); }

        .bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; padding: 20px;
            background: linear-gradient(to top, #0b1026, rgba(11, 16, 38, 0));
            display: flex; justify-content: center; pointer-events: none;
        }
        
        .btn-action {
            pointer-events: auto;
            background: linear-gradient(135deg, #7c3aed, #2563eb);
            color: white; padding: 15px 80px; border-radius: 50px; font-size: 1.2rem; font-weight: 800; border: none;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 0 20px rgba(124, 58, 237, 0.4);
        }
        .btn-action:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(124, 58, 237, 0.6); }

        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0b1026; display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s; color: white;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="danger-overlay"></div>

    <div id="ingame-ui">
        <div id="passive-stats"></div>
        <div class="top-row">
            <div class="timer-box">
                <span id="timer-display">10.0</span>s
            </div>
            <div class="score-val" id="score-display">$0</div>
        </div>
        <div class="combo-box" id="combo-box">
            <div class="combo-val" id="combo-val">x1.0</div>
            <div class="combo-label">COMBO!</div>
        </div>
        <div id="achievement-container"></div>
    </div>
    
    <div id="skill-bar">
        <div class="skill-slot" id="slot-bomb" onclick="activateSkill('bomb')">
            <div class="skill-icon">üí£<div class="skill-overlay" id="cd-bomb"></div><div class="skill-active-glow" id="glow-bomb"></div></div>
            <div class="skill-key">Q</div>
            <div class="skill-level-indicator" id="lvl-bomb">1</div>
        </div>
        <div class="skill-slot" id="slot-stasis" onclick="activateSkill('stasis')">
            <div class="skill-icon">‚ùÑÔ∏è<div class="skill-overlay" id="cd-stasis"></div><div class="skill-active-glow" id="glow-stasis"></div></div>
            <div class="skill-key">W</div>
            <div class="skill-level-indicator" id="lvl-stasis">1</div>
        </div>
        <div class="skill-slot" id="slot-surge" onclick="activateSkill('surge')">
            <div class="skill-icon">‚öõÔ∏è<div class="skill-overlay" id="cd-surge"></div><div class="skill-active-glow" id="glow-surge"></div></div>
            <div class="skill-key">E</div>
            <div class="skill-level-indicator" id="lvl-surge">1</div>
        </div>
        <div class="skill-slot" id="slot-storm" onclick="activateSkill('storm')">
            <div class="skill-icon">‚ö°<div class="skill-overlay" id="cd-storm"></div><div class="skill-active-glow" id="glow-storm"></div></div>
            <div class="skill-key">R</div>
            <div class="skill-level-indicator" id="lvl-storm">1</div>
        </div>
    </div>
    
    <div id="pause-overlay">
        <div class="pause-text">PAUSED</div>
        <div class="pause-sub">Press ESC to Resume</div>
    </div>

    <button id="mute-btn" onclick="toggleMute()">üîä</button>

    <div id="upgrade-screen">
        <div class="upgrade-header">
            <h1 class="screen-title">RESEARCH LAB</h1>
            <p class="screen-subtitle">Ïö∞Ï£ºÏùò ÌûòÏùÑ Ïó∞Íµ¨ÌïòÏó¨ Î∏îÎûôÌôÄÏùÑ ÏßÑÌôîÏãúÌÇ§ÏÑ∏Ïöî.</p>
        </div>
        <div class="status-bar">
            <div class="level-badge" id="total-level-display">Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: 0</div>
            <div class="money-badge" id="upgrade-money">$0</div>
        </div>
        <div style="margin-bottom: 10px;">
             <span class="reset-data-btn" onclick="resetSaveData()">[Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî]</span>
        </div>
        <div class="tree-scroll-area" id="tree-container"></div>
        <div class="bottom-bar">
            <button class="btn-action" onclick="startGame()">Start Loop</button>
        </div>
    </div>

    <div id="start-overlay">
        <h1 class="text-5xl font-black mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-blue-500">Void Harvester:<br>Planetary Devourer</h1>
        <p class="text-gray-400 mb-8 text-xl">ÌñâÏÑ±ÏùÑ ÌååÍ¥¥ÌïòÍ≥† Ìù°ÏàòÌïòÏó¨ ÎÅùÏóÜÏù¥ ÏÑ±Ïû•ÌïòÏÑ∏Ïöî.</p>
        <button class="btn-action" onclick="firstStart()">Í≤åÏûÑ ÏãúÏûë</button>
    </div>

    <script>
        // --- 1. GLOBAL VARIABLES ---
        let canvas, ctx;
        let scoreEl, timerEl, upgradeScreen, upgradeMoneyEl, totalLevelEl, treeContainer, startOverlay, ingameUi, comboBox, comboValEl, passiveStatsEl, pauseOverlay;
        let slotBomb, slotStasis, slotSurge, slotStorm;
        let cdBomb, cdStasis, cdSurge, cdStorm;
        let glowBomb, glowStasis, glowSurge, glowStorm;
        let lvlBombEl, lvlStasisEl, lvlSurgeEl, lvlStormEl;

        const VALUE_MULTIPLIER = 0.4; 
        const BASE_RESOLUTION = 1080;
        const TIER_UNLOCKS = [0, 4, 12, 24, 40, 60, 90, 130, 180, 240, 310, 390, 480, 580, 700, 850, 1050, 1300, 1600, 2000, 2500];

        const UPGRADES = [
            // Tier 0
            { id: 'force', name: 'Ï§ëÎ†•Ïû• Í∞ïÎèÑ', desc: 'ÌååÌé∏ÏùÑ ÎãπÍ∏∞Îäî Ìûò.', icon: 'üß≤', tier: 0, level: 1, maxLevel: 99, baseCost: 15, mult: 1.4, val: 0.12, inc: 0.03 },
            { id: 'radius', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ†', desc: 'ÏòÅÌñ• Î≤îÏúÑ ÌôïÏû•.', icon: '‚≠ï', tier: 0, level: 1, maxLevel: 99, baseCost: 15, mult: 1.4, val: 80, inc: 4 }, 
            { id: 'friction', name: 'Í≥µÍ∞Ñ Ï†êÏÑ±', desc: 'ÌååÌé∏Ïù¥ Îçú ÎØ∏ÎÅÑÎü¨Ïßê.', icon: 'üï∏Ô∏è', tier: 0, level: 1, maxLevel: 10, baseCost: 50, mult: 1.5, val: 0.92, inc: -0.01 },

            // Tier 1
            { id: 'density', name: 'Ï¥àÍ∏∞ Î∞ÄÎèÑ', desc: 'ÏãúÏûë ÌñâÏÑ± Ïàò Ï¶ùÍ∞Ä.', icon: 'üåå', tier: 1, level: 0, maxLevel: 20, baseCost: 100, mult: 1.5, val: 30, inc: 10 },
            { id: 'respawn', name: 'ÌñâÏÑ± Î≤àÏãù', desc: 'Ìù°Ïàò Ïãú Ïû¨ÏÉùÏÑ± ÌôïÎ•†.', icon: 'üå±', tier: 1, level: 0, maxLevel: 20, baseCost: 150, mult: 1.5, val: 0, inc: 5 },
            { id: 'time', name: 'ÏãúÍ∞Ñ ÏôúÍ≥°', desc: 'Ï†úÌïú ÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚è≥', tier: 1, level: 0, maxLevel: 50, baseCost: 200, mult: 1.5, val: 10, inc: 1.5 }, // ÏãúÍ∞Ñ Í∏∞Î≥∏Í∞í 10Ï¥à Í≥†Ï†ï

            // Tier 2
            { id: 'value', name: 'Ï±ÑÍµ¥ Ìö®Ïú®', desc: 'ÌñâÏÑ± Í∞ÄÏπò ÏÉÅÏäπ.', icon: 'üíé', tier: 2, level: 0, maxLevel: 99, baseCost: 300, mult: 1.5, val: 1.0, inc: 0.5 },
            // Skill Bomb: Levelable
            { id: 'unlock_bomb', name: 'Ï§ëÎ†• Ìè≠ÌÉÑ [Skill]', desc: '[Q] Ï£ºÎ≥Ä ÌñâÏÑ± ÎãπÍ∏∞Í∏∞. Î†àÎ≤®ÏóÖ Ïãú ÏúÑÎ†• Ï¶ùÍ∞Ä/Ïø®ÌÉÄÏûÑ Í∞êÏÜå.', icon: 'üí£', type: 'skill', tier: 2, level: 0, maxLevel: 10, baseCost: 1000, mult: 1.5, val: 0, inc: 1 },
            { id: 'heavy', name: 'Í≥†Ï§ëÎ†•', desc: 'Î¨¥Í±∞Ïö¥ ÌñâÏÑ± Î¨¥Í≤å Î¨¥Ïãú.', icon: '‚öì', tier: 2, level: 0, maxLevel: 20, baseCost: 350, mult: 1.5, val: 1.0, inc: 0.2 },

            // Tier 3
            { id: 'attract_range', name: 'ÏûêÏó∞ Ï§ëÎ†•', desc: 'Î∏îÎûôÌôÄ Í∏∞Î≥∏ Ìù°ÏûÖ Î≤îÏúÑ.', icon: 'üåë', tier: 3, level: 0, maxLevel: 20, baseCost: 800, mult: 1.5, val: 150, inc: 20 },
            { id: 'tier_unlock', name: 'Ïã¨Ïö∞Ï£º ÌÉêÏÇ¨', desc: 'Îçî ÎÜíÏùÄ Îì±Í∏â ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üî≠', tier: 3, level: 0, maxLevel: 5, baseCost: 2000, mult: 3.0, val: 1, inc: 1 },
            { id: 'lightning_unlock', name: 'ÎáåÏ†Ñ ÌñâÏÑ±', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌñâÏÑ± Îì±Ïû•.', icon: '‚ö°', tier: 3, level: 0, maxLevel: 1, baseCost: 3000, mult: 1, val: 0, inc: 1 },
            
            // Tier 4
            // Skill Stasis: Levelable
            { id: 'unlock_stasis', name: 'ÌÉÄÏûÑ ÌîÑÎ¶¨Ï¶à [Skill]', desc: '[W] ÏãúÍ∞Ñ Ï†ïÏßÄ. Î†àÎ≤®ÏóÖ Ïãú ÏßÄÏÜçÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚ùÑÔ∏è', type: 'skill', tier: 4, level: 0, maxLevel: 10, baseCost: 8000, mult: 1.5, val: 0, inc: 1 },
            { id: 'l_force', name: 'Ï†ÑÏûêÍ∏∞Ïû•', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏ÎãùÏùò ÎãπÍ∏∞Îäî Ìûò Ï¶ùÍ∞Ä.', icon: 'üß≤', tier: 4, level: 0, maxLevel: 20, baseCost: 5000, mult: 1.5, val: 40, inc: 10 },
            { id: 'crit', name: 'ÌñâÏÑ± Î∂ïÍ¥¥', desc: 'Í∞ÄÏπò 2Î∞∞ ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•†.', icon: 'üí•', tier: 4, level: 0, maxLevel: 20, baseCost: 2500, mult: 1.5, val: 0, inc: 2 },
            { id: 'l_range', name: 'Ï†ÑÏù¥ Î≤îÏúÑ', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù Í±∞Î¶¨.', icon: 'üì°', tier: 4, level: 0, maxLevel: 10, baseCost: 4000, mult: 1.6, val: 150, inc: 20 }, 
            { id: 'l_count', name: 'Í≥ºÎ∂ÄÌïò', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌÉÄÍ≤ü Ïàò.', icon: 'üîó', tier: 4, level: 0, maxLevel: 10, baseCost: 4500, mult: 1.8, val: 3, inc: 1 },

            // Tier 5
            // Skill Surge: Levelable
            { id: 'unlock_surge', name: 'Î∏îÎûôÌôÄ Í∞úÎ∞© [Skill]', desc: '[E] Ìù°ÏûÖÎ†•/Î≤îÏúÑ Í∞ïÌôî. Î†àÎ≤®ÏóÖ Ïãú ÏßÄÏÜçÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚öõÔ∏è', type: 'skill', tier: 5, level: 0, maxLevel: 10, baseCost: 25000, mult: 1.6, val: 0, inc: 1 },
            { id: 'luck', name: 'ÌñâÏö¥Ïùò Î≥Ñ', desc: 'Ìù¨Í∑Ä ÌñâÏÑ± ÌôïÎ•† Ï¶ùÍ∞Ä.', icon: 'üçÄ', tier: 5, level: 0, maxLevel: 10, baseCost: 5000, mult: 1.6, val: 1.0, inc: 0.2 },
            { id: 'blackhole_size', name: 'Í±∞ÎåÄ Î∏îÎûôÌôÄ', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä.', icon: '‚ö´', tier: 5, level: 0, maxLevel: 10, baseCost: 10000, mult: 2.5, val: 35, inc: 3 },
            
            // Tier 6
            { id: 'expansion', name: 'Ïö∞Ï£º ÌôïÏû•', desc: 'ÏãúÏïºÎ•º ÎÑìÌòÄ Í±∞ÎåÄ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üî≠', tier: 6, level: 0, maxLevel: 10, baseCost: 30000, mult: 2.0, val: 1.0, inc: 0.1 },
            { id: 'siphon', name: 'ÏãúÍ∞Ñ Ìù°Ïàò', desc: 'Ìù°Ïàò Ïãú ÏãúÍ∞Ñ Ïó∞Ïû• ÌôïÎ•†.', icon: '‚è≥', tier: 6, level: 0, maxLevel: 20, baseCost: 30000, mult: 1.8, val: 0, inc: 2 },
            { id: 'unlock_magnet', name: 'ÏûêÏÑ± ÌñâÏÑ±', desc: 'Ìù°Ïàò Ïãú Ï£ºÎ≥Ä ÌñâÏÑ±ÏùÑ Í∞ïÎ†•ÌïòÍ≤å ÎãπÍπÅÎãàÎã§.', icon: 'üß≤', tier: 6, level: 0, maxLevel: 1, baseCost: 60000, mult: 1, val: 0, inc: 1 },
            { id: 'frenzy', name: 'ÏΩîÏä§ÎØπ ÌîÑÎ†åÏßÄ', desc: '3Ï¥à Ïù¥ÌïòÏùº Îïå Ï§ëÎ†• 2Î∞∞.', icon: 'üî•', tier: 6, level: 0, maxLevel: 1, baseCost: 50000, mult: 1, val: 0, inc: 1 },

            // Tier 7
            // NEW SKILL: Void Storm
            { id: 'unlock_storm', name: 'Í≥µÌóàÏùò Ìè≠Ìíç [Skill]', desc: '[R] ÌôîÎ©¥ Ï†ÑÏ≤¥ Î¨¥ÏûëÏúÑ ÌÉÄÍ≤©. Î†àÎ≤®ÏóÖ Ïãú ÏúÑÎ†• Ï¶ùÍ∞Ä.', icon: '‚ö°', type: 'skill', tier: 7, level: 0, maxLevel: 10, baseCost: 150000, mult: 1.7, val: 0, inc: 1 },
            { id: 'unlock_ring', name: 'Í≥†Î¶¨ ÌñâÏÑ±', desc: 'Í±∞ÎåÄÌïú Í≥†Î¶¨ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'ü™ê', tier: 7, level: 0, maxLevel: 1, baseCost: 100000, mult: 1, val: 0, inc: 1 },
            { id: 'interest', name: 'ÏïîÌùë Î¨ºÏßà Î∞òÏùë', desc: 'ÎùºÏö¥Îìú Ï¢ÖÎ£å Ïãú Î≥¥Ïú†Í∏à Ïù¥Ïûê.', icon: 'üìà', tier: 7, level: 0, maxLevel: 10, baseCost: 15000, mult: 2.0, val: 0, inc: 1 },
            
            // Tier 8 ~ 20 (Expanded)
            { id: 'singularity', name: 'ÌäπÏù¥Ï†ê', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥ ÏïΩÌïú Ï§ëÎ†•Ïû• ÏÉùÏÑ±.', icon: '‚öõÔ∏è', tier: 8, level: 0, maxLevel: 5, baseCost: 80000, mult: 3.0, val: 0, inc: 1 },
            { id: 'neutron_unlock', name: 'Ï§ëÏÑ±ÏûêÎ≥Ñ', desc: 'Ï¥àÍ≥†Î∞ÄÎèÑ ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üåü', tier: 8, level: 0, maxLevel: 1, baseCost: 200000, mult: 1, val: 0, inc: 1 },
            { id: 'unlock_nova', name: 'ÎÖ∏Î∞î ÏΩîÏñ¥', desc: 'Ìù°Ïàò Ïãú Ìè≠Î∞úÏ†ÅÏù∏ Ìù°ÏûÖÎ†•ÏùÑ Î∞úÏÉùÏãúÌÇµÎãàÎã§.', icon: 'üéá', tier: 8, level: 0, maxLevel: 1, baseCost: 180000, mult: 1, val: 0, inc: 1 },
            
            { id: 'gravity_lens', name: 'Ï§ëÎ†• Î†åÏ¶à', desc: 'Ìù°ÏûÖ Î≤îÏúÑ Ï∂îÍ∞Ä ÌôïÏû•.', icon: 'üîç', tier: 9, level: 0, maxLevel: 20, baseCost: 120000, mult: 1.8, val: 1.0, inc: 0.1 },
            { id: 'chrono_battery', name: 'ÌÅ¨Î°úÎÖ∏ Î∞∞ÌÑ∞Î¶¨', desc: 'ÏµúÎåÄ ÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: 'üîã', tier: 9, level: 0, maxLevel: 20, baseCost: 250000, mult: 1.6, val: 5, inc: 1 },
            
            { id: 'skill_mastery', name: 'Ïä§ÌÇ¨ ÎßàÏä§ÌÑ∞Î¶¨', desc: 'Î™®Îì† Ïä§ÌÇ¨ Ïø®ÌÉÄÏûÑ Í∞êÏÜå.', icon: 'üéì', tier: 10, level: 0, maxLevel: 10, baseCost: 300000, mult: 2.0, val: 0, inc: 5 }, // %
            { id: 'star_unlock', name: 'Ìï≠ÏÑ± Î∞úÍ≤¨', desc: 'Ïä§Ïä§Î°ú ÎπõÎÇòÎäî Î≥Ñ Î∞úÍ≤¨.', icon: '‚òÄÔ∏è', tier: 10, level: 0, maxLevel: 1, baseCost: 500000, mult: 1, val: 0, inc: 1 },
            
            { id: 'nucleosynthesis', name: 'ÌïµÏúµÌï©', desc: 'Î™®Îì† ÌñâÏÑ± Í∞ÄÏπò ÎåÄÌè≠ Ï¶ùÍ∞Ä.', icon: '‚ò¢Ô∏è', tier: 11, level: 0, maxLevel: 50, baseCost: 400000, mult: 1.5, val: 1.0, inc: 0.5 },
            { id: 'void_hunger', name: 'Ï§ëÎ†• Ïö∞Î¨º', desc: 'ÏûêÏó∞ Ï§ëÎ†• Ìù°ÏûÖÎ†• Í∞ïÌôî.', icon: 'üëø', tier: 11, level: 0, maxLevel: 10, baseCost: 600000, mult: 2.0, val: 1.0, inc: 0.5 },
            
            { id: 'event_horizon_ex', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ† II', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï∂îÍ∞Ä ÌôïÏû•.', icon: '‚ö´', tier: 12, level: 0, maxLevel: 10, baseCost: 700000, mult: 2.0, val: 0, inc: 5 },
            { id: 'antimatter', name: 'Î∞òÎ¨ºÏßà ÏÉùÏÑ±', desc: 'ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•† Ï∂îÍ∞Ä.', icon: 'üí†', tier: 12, level: 0, maxLevel: 20, baseCost: 800000, mult: 1.6, val: 0, inc: 2 },
            
            { id: 'warp_drive', name: 'ÏõåÌîÑ ÎìúÎùºÏù¥Î∏å', desc: 'ÎßàÏ∞∞Î†• Ï∂îÍ∞Ä Í∞êÏÜå.', icon: 'üöÄ', tier: 13, level: 0, maxLevel: 10, baseCost: 900000, mult: 2.0, val: 0, inc: 0.005 },
            { id: 'federation', name: 'ÏùÄÌïò Ïó∞Ìï©', desc: 'ÌñâÏÑ± Î∞ÄÎèÑ ÎåÄÌè≠ Ï¶ùÍ∞Ä.', icon: 'üõ∏', tier: 13, level: 0, maxLevel: 10, baseCost: 1200000, mult: 1.8, val: 0, inc: 20 },
            
            { id: 'dyson_sphere', name: 'Îã§Ïù¥Ïä® Ïä§ÌîºÏñ¥', desc: 'ÎùºÏö¥Îìú Ï¢ÖÎ£å Ïù¥Ïûê Ï¶ùÍ∞Ä.', icon: 'üåê', tier: 14, level: 0, maxLevel: 10, baseCost: 1500000, mult: 2.0, val: 0, inc: 2 },
            { id: 'dark_energy', name: 'ÏïîÌùë ÏóêÎÑàÏßÄ', desc: 'Ï§ëÎ†•Ïû• Ìûò Í∑πÎåÄÌôî.', icon: 'üü£', tier: 14, level: 0, maxLevel: 20, baseCost: 2000000, mult: 1.6, val: 1.0, inc: 0.2 },
            
            { id: 'expansion_2', name: 'Ïö∞Ï£º ÌôïÏû• II', desc: 'ÏãúÏïº Ï∂îÍ∞Ä ÌôïÏû• (Ï§åÏïÑÏõÉ).', icon: 'üî≠', tier: 15, level: 0, maxLevel: 5, baseCost: 2500000, mult: 3.0, val: 0, inc: 0.1 },
            { id: 'gamma_ray', name: 'Í∞êÎßàÏÑ† Ìè≠Î∞ú', desc: 'Ïä§ÌÇ¨ Ìö®Í≥º Ï¶ùÌè≠.', icon: 'üîÜ', tier: 15, level: 0, maxLevel: 5, baseCost: 3000000, mult: 2.5, val: 1.0, inc: 0.2 },

            { id: 'multiverse', name: 'Îã§Ï§ëÏö∞Ï£º Ï±ÑÍµ¥', desc: 'Í∞ÄÏπò Í∑πÎåÄÌôî.', icon: 'üåå', tier: 16, level: 0, maxLevel: 20, baseCost: 4000000, mult: 1.7, val: 1.0, inc: 1.0 },
            { id: 'reality_anchor', name: 'ÌòÑÏã§ Í≥†Ï†ï', desc: 'ÏãúÍ∞Ñ ÏôúÍ≥° Ìö®Ïú® Ï¶ùÍ∞Ä.', icon: '‚öì', tier: 16, level: 0, maxLevel: 10, baseCost: 5000000, mult: 2.0, val: 0, inc: 2.0 },

            { id: 'supermassive', name: 'Ï¥àÍ±∞ÎåÄ ÏßàÎüâ', desc: 'Í≥†Ï§ëÎ†• Ìö®Í≥º Í∞ïÌôî.', icon: 'üèãÔ∏è', tier: 17, level: 0, maxLevel: 10, baseCost: 7000000, mult: 2.0, val: 1.0, inc: 0.5 },
            
            { id: 'quasar_unlock', name: 'ÌÄòÏù¥ÏÇ¨ ÌååÌé∏', desc: 'Ï†ÑÏÑ§Ï†ÅÏù∏ Î¨ºÏßà Î∞úÍ≤¨.', icon: '‚ú®', tier: 18, level: 0, maxLevel: 1, baseCost: 10000000, mult: 1, val: 0, inc: 1 },
            { id: 'time_dilation', name: 'ÏãúÍ∞Ñ ÏßÄÏó∞', desc: 'ÌñâÏÑ± ÏÜçÎèÑ Í∞êÏÜå.', icon: 'üêå', tier: 18, level: 0, maxLevel: 5, baseCost: 9000000, mult: 2.0, val: 1.0, inc: 0.1 },

            { id: 'omega_point', name: 'Ïò§Î©îÍ∞Ä Ìè¨Ïù∏Ìä∏', desc: 'Î™®Îì† Îä•Î†•Ïπò ÏÜåÌè≠ Ï¶ùÍ∞Ä.', icon: 'Œ©', tier: 19, level: 0, maxLevel: 50, baseCost: 15000000, mult: 1.4, val: 0, inc: 0.05 },
            
            { id: 'big_bang', name: 'ÎπÖÎ±Ö', desc: 'Í∂ÅÍ∑πÏùò Ìûò.', icon: 'üí•', tier: 20, level: 0, maxLevel: 1, baseCost: 100000000, mult: 1, val: 0, inc: 1 },
        ];

        // Achievements
        const ACHIEVEMENTS = [
            { id: 'novice', name: 'Ï¥àÎ≥¥ Ìè¨ÏãùÏûê', desc: 'ÌñâÏÑ± 100Í∞ú Ìù°Ïàò', req: { type: 'count', val: 100 }, bonus: 'force', amount: 0.05 },
            { id: 'skilled', name: 'ÏàôÎ†®Îêú Ìè¨ÏãùÏûê', desc: 'ÌñâÏÑ± 1000Í∞ú Ìù°Ïàò', req: { type: 'count', val: 1000 }, bonus: 'force', amount: 0.1 },
            { id: 'master', name: 'Ïö∞Ï£ºÏùò ÏßÄÎ∞∞Ïûê', desc: 'ÌñâÏÑ± 5000Í∞ú Ìù°Ïàò', req: { type: 'count', val: 5000 }, bonus: 'force', amount: 0.15 },
            { id: 'rich', name: 'Î∂ÄÏûê', desc: 'ÎàÑÏ†Å $100,000 Îã¨ÏÑ±', req: { type: 'money', val: 100000 }, bonus: 'value', amount: 0.2 },
            { id: 'combo', name: 'ÏΩ§Î≥¥ ÎßàÏä§ÌÑ∞', desc: '50 ÏΩ§Î≥¥ Îã¨ÏÑ±', req: { type: 'combo', val: 50 }, bonus: 'crit', amount: 5 } 
        ];

        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 5,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 15,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 40,  valMult: 20, weight: 5 },
            { id: 'electric', color: '#facc15', minR: 15, maxR: 20, mass: 10, valMult: 15, weight: 0, isLightning: true },
            { id: 'giant',    color: '#ef4444', minR: 40, maxR: 60, mass: 80,  valMult: 50, weight: 0 },
            { id: 'ringed',   color: '#d97706', minR: 50, maxR: 70, mass: 150, valMult: 100, weight: 0, hasRings: true },
            { id: 'neutron',  color: '#ffffff', minR: 8,  maxR: 12, mass: 200, valMult: 300, weight: 0, glow: '#0ea5e9' },
            { id: 'star',     color: '#f59e0b', minR: 80, maxR: 120, mass: 500, valMult: 200, weight: 0, isStar: true },
            { id: 'quasar',   color: '#ec4899', minR: 30, maxR: 40, mass: 300, valMult: 500, weight: 0, pulse: true },
            { id: 'comet', color: '#fbbf24', minR: 15, maxR: 20, mass: 20, valMult: 100, weight: 0, isComet: true },
            { id: 'flux', color: '#3b82f6', minR: 15, maxR: 20, mass: 10, valMult: 10, weight: 0, isFlux: true },
            { id: 'magnet', color: '#94a3b8', minR: 15, maxR: 20, mass: 30, valMult: 20, weight: 0, isMagnet: true },
            { id: 'nova', color: '#f97316', minR: 20, maxR: 25, mass: 50, valMult: 40, weight: 0, isNova: true }
        ];

        // Global State
        let GAME = {
            running: false, paused: false, phase: 'start', money: 0, scoreInRound: 0, timeLeft: 10.0, maxTime: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0, lastTime: 0,
            combo: 0, comboTimer: 0, shakeX: 0, shakeY: 0, shakeTime: 0, shakeAmount: 0,
            zoom: 1.0, bhAngle: 0, bhPulse: 0,
            skills: { 
                bomb: { cd: 0, max: 15 }, 
                stasis: { cd: 0, max: 30, dur: 0 }, 
                surge: { cd: 0, max: 60, dur: 0 },
                storm: { cd: 0, max: 45 } 
            },
            bgStars: [], nebulae: [], pixelScale: 1.0,
            stats: { totalAbsorbed: 0, totalMoney: 0, maxCombo: 0, achievements: [] } 
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        let entities = [];
        let texts = [];
        let particles = []; 
        let bolts = []; 
        const blackHole = { radius: 22, angle: 0 }; // Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï§ÑÏûÑ (35 -> 22)

        // 2. HELPER FUNCTIONS
        function getUpgrade(id) { return UPGRADES.find(u => u.id === id); }
        function getTotalLevels() { 
            return UPGRADES.reduce((sum, u) => {
                if(u.tier === 0) return sum + Math.max(0, u.level - 1);
                return sum + u.level;
            }, 0); 
        } 
        function rand(min, max) { return Math.random() * (max - min) + min; }

        function saveGame() {
            const data = { 
                money: GAME.money, 
                upgrades: UPGRADES.map(u => ({ id: u.id, level: u.level })),
                stats: GAME.stats 
            };
            localStorage.setItem('void_harvester_save_v10', JSON.stringify(data));
        }

        function loadGame() {
            const str = localStorage.getItem('void_harvester_save_v10');
            if(!str) return;
            try {
                const data = JSON.parse(str);
                GAME.money = data.money || 0;
                if(data.stats) GAME.stats = data.stats;
                if(data.upgrades) {
                    data.upgrades.forEach(saved => {
                        const u = UPGRADES.find(x => x.id === saved.id);
                        if(u) {
                            u.level = saved.level;
                            const startLvl = u.tier === 0 ? 1 : 0;
                            const gained = Math.max(0, u.level - startLvl);
                            if(gained > 0) {
                                u.val += u.inc * gained;
                                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));
                            }
                        }
                    });
                }
            } catch(e) { console.error("Save load failed", e); }
        }

        function resetSaveData() {
            if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
                localStorage.removeItem('void_harvester_save_v10');
                location.reload();
            }
        }

        function checkAchievements() {
            let newlyUnlocked = false;
            ACHIEVEMENTS.forEach(ach => {
                if (!GAME.stats.achievements.includes(ach.id)) {
                    let unlocked = false;
                    if (ach.req.type === 'count' && GAME.stats.totalAbsorbed >= ach.req.val) unlocked = true;
                    if (ach.req.type === 'money' && GAME.stats.totalMoney >= ach.req.val) unlocked = true;
                    if (ach.req.type === 'combo' && GAME.stats.maxCombo >= ach.req.val) unlocked = true;
                    
                    if (unlocked) {
                        GAME.stats.achievements.push(ach.id);
                        showAchievementToast(ach.name);
                        newlyUnlocked = true;
                    }
                }
            });
            if(newlyUnlocked) updatePassiveStats();
        }

        function showAchievementToast(name) {
            const el = document.createElement('div');
            el.className = 'achievement-toast';
            el.innerHTML = `<strong>üèÜ ÏóÖÏ†Å Îã¨ÏÑ±!</strong><br>${name}`;
            document.getElementById('achievement-container').appendChild(el);
            setTimeout(() => el.remove(), 4000);
        }

        function updatePassiveStats() {
            let forceBonus = 0;
            let valueBonus = 0;
            let critBonus = 0;
            
            GAME.stats.achievements.forEach(id => {
                const ach = ACHIEVEMENTS.find(a => a.id === id);
                if(ach) {
                    if(ach.bonus === 'force') forceBonus += ach.amount;
                    if(ach.bonus === 'value') valueBonus += ach.amount;
                    if(ach.bonus === 'crit') critBonus += ach.amount;
                }
            });
            
            const el = document.getElementById('passive-stats');
            if (forceBonus > 0 || valueBonus > 0 || critBonus > 0) {
                el.style.display = 'block';
                el.innerHTML = `ÏóÖÏ†Å Î≥¥ÎÑàÏä§:<br>Ìûò +${(forceBonus*100).toFixed(0)}%<br>Í∞ÄÏπò +${(valueBonus*100).toFixed(0)}%<br>ÏπòÎ™ÖÌÉÄ +${critBonus}%`;
            }
        }

        function getAchievementMultiplier(type) {
            let mult = 1.0;
            let add = 0;
            GAME.stats.achievements.forEach(id => {
                const ach = ACHIEVEMENTS.find(a => a.id === id);
                if(ach) {
                    if(type === 'force' && ach.bonus === 'force') mult += ach.amount;
                    if(type === 'value' && ach.bonus === 'value') mult += ach.amount;
                    if(type === 'crit' && ach.bonus === 'crit') add += ach.amount;
                }
            });
            return { mult, add };
        }

        // 3. CLASSES 
        class SoundManager {
            constructor() { this.ctx = null; this.muted = false; }
            init() { 
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }
            playTone(freq, type, duration, vol=0.1) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + duration);
            }
            playPop() { this.playTone(300 + Math.random()*200, 'triangle', 0.1); }
            playSkill(type) { this.playTone(100, 'sawtooth', 0.5); }
            playBuy() { this.playTone(1200, 'sine', 0.1); }
            playStart() { this.playTone(100, 'sawtooth', 1.0); }
            playBonus(type) { this.playTone(1500, 'sine', 0.5, 0.2); }
            playDamage() { this.playTone(150, 'sawtooth', 0.3, 0.5); }
            startGravityHum() {} 
            stopGravityHum() {}
            playSuck() {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine'; // Ï°∞Í∏à Îçî Î∂ÄÎìúÎüΩÍ≥† Î¨µÏßÅÌïòÍ≤å Î≥ÄÍ≤Ω
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.2); // Îçî ÎÇÆÍ≤å Îñ®Ïñ¥Ïßê
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            }
        }
        const audio = new SoundManager();

        class EffectParticle {
            constructor(x, y, color, type) {
                this.x = x; this.y = y; this.color = color; this.type = type; this.life = 1.0;
                if (type === 'explode') {
                    const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 3 + 1;
                    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                    this.decay = 0.05; this.size = Math.random() * 3 + 1;
                } else if (type === 'gravity_suck') {
                    this.vx = 0; this.vy = 0; this.decay = 0.05; this.size = Math.random() * 2 + 1;
                } else if (type === 'trail') {
                    this.vx = 0; this.vy = 0; this.decay = 0.05; this.size = Math.random() * 2 + 2; 
                } else if (type === 'time_bonus') {
                    this.vx = 0; this.vy = -2; this.decay = 0.03; this.size = 0; 
                } else if (type === 'comet_trail') {
                    this.vx = 0; this.vy = 0; this.decay = 0.1; this.size = Math.random() * 3 + 2;
                } else if (type === 'spiral_in') {
                    this.angle = Math.random() * Math.PI * 2;
                    this.dist = Math.random() * 40 + 20; 
                    this.speed = Math.random() * 0.1 + 0.05;
                    this.size = Math.random() * 2 + 1;
                    this.decay = 0.05;
                } else if (type === 'shockwave') {
                    this.vx = 0; this.vy = 0; this.decay = 0.02; this.size = 10;
                    this.maxSize = 300; 
                } else if (type === 'spark') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = 0.1; this.size = Math.random() * 2 + 1;
                } else if (type === 'implode') { // ÎÇ¥Ìåå Ïù¥ÌéôÌä∏
                    this.vx = 0; this.vy = 0;
                    this.decay = 0.1;
                    this.size = 50; // Î∏îÎûôÌôÄÎ≥¥Îã§ ÏïΩÍ∞Ñ ÌÅ∞ ÌÅ¨Í∏∞ÏóêÏÑú ÏãúÏûë
                    this.life = 1.0;
                }
            }
            update(dt) {
                const timeScale = dt * 60;
                if(this.type === 'gravity_suck') {
                    const dx = 0 - this.x; const dy = 0 - this.y;
                    const angle = Math.atan2(dy, dx);
                    this.vx += Math.cos(angle) * 50 * 0.1; this.vy += Math.sin(angle) * 50 * 0.1;
                    this.x += this.vx * timeScale; this.y += this.vy * timeScale;
                } else if (this.type === 'spiral_in') {
                    this.angle += 0.3 * timeScale;
                    this.dist -= 5 * timeScale; // Îπ®Î†§ÎìúÎäî ÏÜçÎèÑ
                    this.x = Math.cos(this.angle) * this.dist;
                    this.y = Math.sin(this.angle) * this.dist;
                    if(this.dist <= 2) this.life = 0; 
                } else if (this.type === 'shockwave') {
                    this.size += 15 * timeScale;
                    if (this.size > this.maxSize) this.life = 0;
                } else if (this.type === 'implode') {
                    this.size -= 15 * timeScale; // Îπ†Î•¥Í≤å ÏûëÏïÑÏßê
                    if (this.size <= 0) this.life = 0;
                } else {
                    this.x += this.vx * timeScale; this.y += this.vy * timeScale;
                }
                this.life -= this.decay * timeScale;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life); 
                if(this.type === 'time_bonus') { 
                    ctx.fillStyle = this.color;
                    ctx.font = 'bold 16px sans-serif'; ctx.fillText(this.color === '#ef4444' ? "-5.0s" : "+0.5s", this.x, this.y); 
                } else if (this.type === 'shockwave') {
                    ctx.strokeStyle = this.color || 'white';
                    ctx.lineWidth = 5 * this.life;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.stroke();
                } else if (this.type === 'implode') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, Math.max(0, this.size), 0, Math.PI * 2); ctx.stroke();
                } else { 
                    ctx.fillStyle = this.color;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); 
                }
                ctx.globalAlpha = 1.0;
            }
        }

        class PopText {
            constructor(x, y, val, isCrit) {
                // x, y ÏúÑÏπòÎ•º ÎûúÎç§ÌïòÍ≤å Î∂ÑÏÇ∞ÏãúÏºú Í≤πÏπ® Î∞©ÏßÄ
                this.x = x + (Math.random() - 0.5) * 60; 
                this.y = y - Math.random() * 40; 
                this.text = "+$" + val; 
                this.life = 1.0; 
                this.vy = -4.0; // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî ÏÜçÎèÑ Ï¶ùÍ∞Ä (Í∏∞Ï°¥ -1.5)
                this.isCrit = isCrit;
                this.vx = (Math.random() - 0.5) * 3; // Ï¢åÏö∞ ÌçºÏßê Ï†ïÎèÑ Ï¶ùÍ∞Ä
            }
            update(dt) { 
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60; 
                this.life -= 0.015 * dt * 60; // ÏÇ¨ÎùºÏßÄÎäî ÏÜçÎèÑ Ï°∞Í∏à Îä¶Ï∂§
                this.vy *= 0.96; // ÎßàÏ∞∞Î†• Ï°∞Ï†à
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.isCrit ? '#ef4444' : '#4ade80';
                if(parseInt(this.text.substring(2)) > 1000) ctx.fillStyle = '#facc15'; 
                
                // Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÎåÄÌè≠ ÌôïÎåÄ
                ctx.font = this.isCrit ? '900 45px "Pretendard"' : '800 32px "Pretendard"';
                ctx.textAlign = "center"; // ÌÖçÏä§Ìä∏ Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨
                
                // Scale effect for pop text
                const scale = this.life > 0.8 ? 1.2 : 1.0;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(scale, scale);
                
                // Í∏ÄÏûê ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä (Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ)
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 5;
                ctx.strokeText(this.text, 0, 0);
                
                ctx.fillText(this.text, 0, 0); 
                ctx.restore();
                
                ctx.globalAlpha = 1.0;
                ctx.textAlign = "start"; // Ï†ïÎ†¨ Ï¥àÍ∏∞Ìôî
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2) { 
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2; 
                this.life = 1.0; 
                this.segments = [];
                this.generateSegments();
            }

            generateSegments() {
                const dist = Math.sqrt((this.x2-this.x1)**2 + (this.y2-this.y1)**2);
                const steps = Math.floor(dist / 10);
                let cx = this.x1;
                let cy = this.y1;
                
                this.segments.push({x: cx, y: cy});

                for(let i=1; i<steps; i++) {
                    const t = i / steps;
                    // Linear interpolation
                    let lx = this.x1 + (this.x2 - this.x1) * t;
                    let ly = this.y1 + (this.y2 - this.y1) * t;
                    
                    // Jitter
                    const jitter = (Math.random() - 0.5) * 20;
                    lx += jitter * (this.y2 - this.y1) / dist; // Perpendicular offset approx
                    ly += jitter * (this.x1 - this.x2) / dist;

                    this.segments.push({x: lx, y: ly});
                    cx = lx; cy = ly;
                }
                this.segments.push({x: this.x2, y: this.y2});
            }

            update(dt) { this.life -= 0.1 * dt * 60; }
            
            draw(ctx) { 
                if(this.life<=0) return; 
                ctx.globalAlpha = this.life; 
                ctx.strokeStyle = '#facc15'; 
                ctx.lineWidth = 3; 
                
                // Outer glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#facc15';

                ctx.beginPath(); 
                ctx.moveTo(this.segments[0].x, this.segments[0].y);
                for(let i=1; i<this.segments.length; i++) {
                    ctx.lineTo(this.segments[i].x, this.segments[i].y);
                }
                ctx.stroke(); 
                
                // Reset shadow
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0; 
            }
        }

        class Shard {
            constructor(forceType) {
                const expansion = getUpgrade('expansion').val + (getUpgrade('expansion_2') ? getUpgrade('expansion_2').val : 0);
                GAME.zoom = 0.7 / Math.max(1, expansion);
                const angle = Math.random() * Math.PI * 2;
                
                // ** Spawn Distance Reduced **
                const minDist = 300 / GAME.zoom; // Was 600
                const dist = minDist + Math.random() * 300;
                
                this.x = Math.cos(angle) * dist;
                this.y = Math.sin(angle) * dist;
                this.orbitSpeed = 0.003 * (Math.random() < 0.5 ? 1 : -1);
                
                this.vx = 0; this.vy = 0;
                let frictionBase = getUpgrade('friction').val;
                if(getUpgrade('warp_drive')) frictionBase -= getUpgrade('warp_drive').val;
                this.friction = frictionBase;

                if (forceType) {
                    let t = SHARD_TYPES.find(x => x.id === forceType);
                    this.type = t; this.color = t.color; this.radius = rand(t.minR, t.maxR);
                    this.mass = t.mass; this.sides = 3; 
                    this.value = Math.floor(this.radius * 2 * t.valMult * VALUE_MULTIPLIER);
                    this.orbitSpeed *= 5; return;
                }

                let available = [SHARD_TYPES[0]]; 
                const tierLvl = getUpgrade('tier_unlock').val; 
                if (tierLvl >= 2) available.push(SHARD_TYPES[1]);
                if (tierLvl >= 3) available.push(SHARD_TYPES[2]);
                if (tierLvl >= 4) available.push(SHARD_TYPES[3]);
                
                const lightningUnlocked = getUpgrade('lightning_unlock').level > 0;
                const ringUnlocked = getUpgrade('unlock_ring').level > 0;
                const magnetUnlocked = getUpgrade('unlock_magnet').level > 0;
                const novaUnlocked = getUpgrade('unlock_nova').level > 0;
                const neutronUnlocked = getUpgrade('neutron_unlock') && getUpgrade('neutron_unlock').level > 0;
                const starUnlocked = getUpgrade('star_unlock') && getUpgrade('star_unlock').level > 0;
                const quasarUnlocked = getUpgrade('quasar_unlock') && getUpgrade('quasar_unlock').level > 0;
                
                if (expansion >= 1.2) available.push(SHARD_TYPES[5]); 
                if (ringUnlocked && expansion >= 1.4) available.push(SHARD_TYPES[6]);
                if (neutronUnlocked && expansion >= 1.6) available.push(SHARD_TYPES[7]);
                if (starUnlocked && expansion >= 2.0) available.push(SHARD_TYPES[8]);
                if (quasarUnlocked && expansion >= 2.5) available.push(SHARD_TYPES[9]);
                if (magnetUnlocked) available.push(SHARD_TYPES[12]);
                if (novaUnlocked) available.push(SHARD_TYPES[13]);

                const luckBonus = getUpgrade('luck') ? getUpgrade('luck').val : 1;

                let type = null;
                if (lightningUnlocked && Math.random() < 0.05 * luckBonus) type = SHARD_TYPES[4];
                else {
                    const totalW = available.reduce((a,b)=>a+(b.weight || 10), 0);
                    let r = Math.random() * totalW;
                    type = available[0];
                    for(let t of available){
                        if(r < (t.weight || 10)) { type = t; break; }
                        r -= (t.weight || 10);
                    }
                }
                
                this.type = type; this.color = type.color; this.radius = rand(type.minR, type.maxR);
                this.mass = type.mass; this.sides = 3;
                const valueBonus = getUpgrade('value').val;
                this.value = Math.floor(this.radius * 2 * type.valMult * valueBonus * VALUE_MULTIPLIER);
            }

            update(dt) {
                const timeScale = dt * 60;
                let globalSpeed = 1.0;
                let playerSuctionMult = 1.0;

                if (GAME.skills.stasis.dur > 0) {
                    globalSpeed = 0.0;
                    playerSuctionMult = 3.0;
                }
                
                // Anomaly moves anyway
                if (this.type.isComet || this.type.isFlux) {
                      globalSpeed = 1.0; 
                      particles.push(new EffectParticle(this.x, this.y, this.color, 'comet_trail'));
                }

                const currentOrbitSpeed = this.orbitSpeed * timeScale * globalSpeed;
                const cos = Math.cos(currentOrbitSpeed); const sin = Math.sin(currentOrbitSpeed);
                const nx = this.x * cos - this.y * sin; const ny = this.x * sin + this.y * cos;
                this.x = nx; this.y = ny;

                const distSq = this.x*this.x + this.y*this.y;
                const dist = Math.sqrt(distSq);

                // Natural Gravity
                let naturalRange = getUpgrade('attract_range').val / GAME.zoom;
                let naturalG = 1000;
                const wellMult = getUpgrade('void_hunger') ? getUpgrade('void_hunger').val : 1.0;
                naturalG *= wellMult;
                if (GAME.skills.surge.dur > 0) { naturalRange = 10000; naturalG *= 3; }

                if (dist < naturalRange) {
                    const g = naturalG / distSq;
                    let force = g / this.mass;
                    if(GAME.skills.stasis.dur > 0) force = 0;
                    if (globalSpeed > 0 || GAME.skills.surge.dur > 0) {
                        this.vx += (-this.x/dist) * force * timeScale;
                        this.vy += (-this.y/dist) * force * timeScale;
                    }
                }

                if (INPUT.isDown) {
                    const radius = getUpgrade('radius').val / GAME.zoom;
                    let power = getUpgrade('force').val;
                    if(getUpgrade('dark_energy')) power *= getUpgrade('dark_energy').val;
                    
                    const heavyBonus = getUpgrade('heavy').val + (getUpgrade('supermassive') ? getUpgrade('supermassive').val : 0);
                    const frenzy = getUpgrade('frenzy') && getUpgrade('frenzy').level > 0;
                    if(frenzy && GAME.timeLeft <= 3.0) power *= 2;

                    // Mouse Logic Coordinates
                    const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                    const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                    const mdx = worldMouseX - this.x; const mdy = worldMouseY - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        let effectiveMass = this.mass;
                        if (GAME.skills.stasis.dur > 0) effectiveMass *= 0.5;
                        else if(effectiveMass > 8) effectiveMass /= heavyBonus; 

                        const accel = (2.0 * power * playerSuctionMult) / effectiveMass;

                        this.vx += (-this.x / Math.sqrt(this.x*this.x+this.y*this.y)) * accel * timeScale;
                        this.vy += (-this.y / Math.sqrt(this.x*this.x+this.y*this.y)) * accel * timeScale;
                    }
                }
                
                const sForce = (getUpgrade('singularity').val * 0.05) / this.mass;
                if (sForce > 0) {
                    this.vx += (-this.x/dist) * sForce * timeScale;
                    this.vy += (-this.y/dist) * sForce * timeScale;
                }

                // Tunneling Prevention (High speed collision)
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy) * timeScale;
                // Dot product < 0 means moving towards center
                if (speed > dist && (this.x * this.vx + this.y * this.vy) < 0) {
                     this.x = 0; this.y = 0; // Force capture
                     return true;
                }

                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.vx *= Math.pow(this.friction, timeScale);
                this.vy *= Math.pow(this.friction, timeScale);

                // Re-calculate distance for collision
                const newDist = Math.sqrt(this.x*this.x + this.y*this.y);
                const bhSize = blackHole.radius + 10; 
                if (newDist < bhSize) return true;
                return false;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                
                if (this.type.isComet) {
                    ctx.shadowColor = this.color; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.ellipse(0, 0, this.radius*1.5, this.radius*0.8, 0, 0, Math.PI*2); ctx.fill();
                } else if (this.type.isStar) {
                    ctx.shadowColor = this.color; ctx.shadowBlur = 30;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                } else if (this.type.isMagnet) {
                    ctx.shadowColor = '#cbd5e1'; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#475569'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.fillStyle = '#1e293b'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
                    ctx.fillText('U', 0, 0); // Magnet shape
                } else if (this.type.isNova) {
                    ctx.shadowColor = '#f97316'; ctx.shadowBlur = 25;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    // Pulse animation
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(Date.now()/100)*0.5})`;
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, this.radius*1.2, 0, Math.PI*2); ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                }
                
                if (this.type.hasRings) {
                    ctx.beginPath(); ctx.ellipse(0, 0, this.radius * 2.2, this.radius * 0.6, -0.2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)'; ctx.lineWidth = this.radius * 0.3; ctx.stroke();
                }
                ctx.restore();
            }
        }

        // 4. LOGIC
        function triggerChainLightning(source) {
             const range = getUpgrade('l_range').val / GAME.zoom;
             const count = getUpgrade('l_count').val;
             const lForce = getUpgrade('l_force').val;

             let candidates = entities.filter(e => e !== source && (e.x-source.x)**2 + (e.y-source.y)**2 < range**2);
             for(let i=0; i<count && candidates.length>0; i++) {
                 const idx = Math.floor(Math.random()*candidates.length);
                 const e = candidates[idx]; candidates.splice(idx,1);
                 
                 // Improved Lightning Visual
                 bolts.push(new LightningBolt(source.x, source.y, e.x, e.y));
                 GAME.shakeTime = 0.2; GAME.shakeAmount = 5;

                 // Spawn Sparks
                 for(let k=0; k<5; k++) particles.push(new EffectParticle(e.x, e.y, '#facc15', 'spark'));

                 // Apply Pull Force
                 const force = lForce / e.mass; 
                 e.vx += (-e.x / Math.sqrt(e.x*e.x+e.y*e.y)) * force;
                 e.vy += (-e.y / Math.sqrt(e.x*e.x+e.y*e.y)) * force;
             }
        }

        function updateGame(dt) {
            if (GAME.paused) return;

            GAME.bhAngle += dt; // Spin the black hole
            GAME.bhPulse += dt * 2; // Pulse effect

            if (GAME.skills.stasis.dur > 0) GAME.skills.stasis.dur -= dt;
            if (GAME.skills.surge.dur > 0) GAME.skills.surge.dur -= dt;
            if (GAME.skills.bomb.cd > 0) GAME.skills.bomb.cd -= dt;
            
            // Skill Cooldowns
            if (GAME.skills.stasis.cd > 0) GAME.skills.stasis.cd -= dt;
            if (GAME.skills.surge.cd > 0) GAME.skills.surge.cd -= dt;
            if (GAME.skills.storm.cd > 0) GAME.skills.storm.cd -= dt;

            // Combo Timer
            if (GAME.combo > 0) {
                GAME.comboTimer -= dt;
                if (GAME.comboTimer <= 0) {
                    GAME.combo = 0;
                    updateComboUI();
                }
            }

            if (GAME.skills.stasis.dur <= 0) GAME.timeLeft -= dt;
            if (GAME.timeLeft <= 0) { GAME.timeLeft = 0; endGame(); return; }

            if (Math.random() < 0.005) {
                 if(Math.random() < 0.5) entities.push(new Shard('comet'));
                 else entities.push(new Shard('flux'));
            }

            if (entities.length < 5) entities.push(new Shard());
            if (INPUT.isDown) {
                const radius = getUpgrade('radius').val / GAME.zoom;
                for(let i=0; i<2; i++) {
                    const angle = Math.random() * Math.PI * 2; const dist = Math.random() * radius;
                    const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                    const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                    const px = worldMouseX + Math.cos(angle) * dist;
                    const py = worldMouseY + Math.sin(angle) * dist;
                    particles.push(new EffectParticle(px, py, '#22d3ee', 'gravity_suck'));
                }
            }

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update(dt)) {
                    // Logic when absorbed
                    if (e.type.isLightning) triggerChainLightning(e);
                    
                    if (e.type.isMagnet) {
                        audio.playSkill('bomb'); // Use bomb sound
                        GAME.shakeTime = 0.5; GAME.shakeAmount = 15;
                        particles.push(new EffectParticle(0,0, '#94a3b8', 'shockwave'));
                        entities.forEach(target => {
                             const dist = Math.sqrt(target.x*target.x + target.y*target.y);
                             target.vx += (-target.x/dist) * 200;
                             target.vy += (-target.y/dist) * 200;
                        });
                    }

                    if (e.type.isNova) {
                        audio.playSkill('bomb');
                        GAME.shakeTime = 1.0; GAME.shakeAmount = 30;
                        particles.push(new EffectParticle(0,0, '#f97316', 'shockwave'));
                          // Massive suction
                          entities.forEach(target => {
                             const distSq = target.x*target.x + target.y*target.y;
                             if(distSq < 400*400) { // Range
                                 const dist = Math.sqrt(distSq);
                                 target.vx += (-target.x/dist) * 800;
                                 target.vy += (-target.y/dist) * 800;
                             }
                        });
                    }

                    if (e.type.isComet) { audio.playBonus('comet'); GAME.scoreInRound += e.value*5; GAME.money += e.value*5; texts.push(new PopText(0, -60, e.value*5, true)); }
                    if (e.type.isFlux) { 
                        audio.playBonus('flux'); 
                        GAME.scoreInRound += e.value; // Add score
                        GAME.money += e.value;       // Add money
                        texts.push(new PopText(0, -60, e.value, true)); // Visual feedback for money
                        
                        if(GAME.timeLeft < GAME.maxTime) GAME.timeLeft += 3; 
                        particles.push(new EffectParticle(0, -50, '#3b82f6', 'time_bonus')); 
                    }
                    
                    if (!e.type.isComet && !e.type.isFlux) {
                        GAME.scoreInRound += e.value; GAME.money += e.value;
                        
                        // Combo Logic
                        GAME.combo++;
                        GAME.comboTimer = 2.0;
                        if(GAME.combo > GAME.stats.maxCombo) GAME.stats.maxCombo = GAME.combo;
                        updateComboUI();

                        texts.push(new PopText(0, -30, e.value, false));
                        audio.playPop();
                        audio.playSuck(); // Îπ®ÏïÑÎì§Ïù¥Îäî ÏÜåÎ¶¨ Ï∂îÍ∞Ä
                        
                        // Spawn suck-in particles (ÌôïÏã§ÌïòÍ≤å Ï∂îÍ∞Ä)
                        for(let k=0; k<3; k++) particles.push(new EffectParticle(0,0, e.color, 'spiral_in'));
                        
                        // Implosion Effect (ÏÉàÎ°ú Ï∂îÍ∞Ä)
                        particles.push(new EffectParticle(0,0, e.color, 'implode'));
                        
                        // Small Shake
                        GAME.shakeTime = 0.1; GAME.shakeAmount = 3;

                        // Giant Shockwave
                        if(e.type.id === 'giant' || e.type.id === 'star' || e.type.id === 'quasar') {
                             particles.push(new EffectParticle(0,0, e.color, 'shockwave'));
                             GAME.shakeTime = 0.3; GAME.shakeAmount = 10;
                        }

                        GAME.stats.totalAbsorbed++;
                        GAME.stats.totalMoney += e.value;
                        checkAchievements();
                    }
                    
                    entities.splice(i, 1);
                    if(!e.type.isComet && !e.type.isFlux && Math.random()*100 < getUpgrade('respawn').val) entities.push(new Shard());
                }
            }

            for(let i=bolts.length-1; i>=0; i--) { bolts[i].update(dt); if(bolts[i].life<=0) bolts.splice(i,1); }
            for(let i=particles.length-1; i>=0; i--) { particles[i].update(dt); if(particles[i].life<=0) particles.splice(i,1); }
            for(let i=texts.length-1; i>=0; i--) { texts[i].update(dt); if(texts[i].life<=0) texts.splice(i,1); }
            
            if(timerEl) timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(timerEl) {
                if(GAME.timeLeft <= 5.0) {
                    timerEl.classList.add('timer-warn');
                    document.getElementById('danger-overlay').style.opacity = (Math.sin(Date.now() / 150) + 1) * 0.4;
                } else {
                    timerEl.classList.remove('timer-warn');
                    document.getElementById('danger-overlay').style.opacity = 0;
                }
            }

            if(scoreEl) scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();

            updateSkillUI();
        }

        function drawGame() {
            // Screen Shake
            let dx = 0, dy = 0;
            if (GAME.shakeTime > 0) {
                GAME.shakeTime -= 0.016;
                const amt = GAME.shakeAmount || 5;
                dx = (Math.random()-0.5) * amt; dy = (Math.random()-0.5) * amt;
            }

            ctx.setTransform(1,0,0,1,0,0);
            ctx.clearRect(0,0,GAME.width, GAME.height);

            // Draw Background (Static Stars)
            ctx.save();
            ctx.fillStyle = "#ffffff";
            GAME.bgStars.forEach(s => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
            });
            ctx.restore();

            // Setup Camera
            ctx.translate(GAME.centerX + dx, GAME.centerY + dy);
            ctx.scale(GAME.zoom * GAME.pixelScale, GAME.zoom * GAME.pixelScale);
            
            // Draw Range Indicators
            if (INPUT.isDown) {
                const radius = getUpgrade('radius').val / GAME.zoom;
                const worldMouseX = (INPUT.x - GAME.centerX) / (GAME.zoom * GAME.pixelScale);
                const worldMouseY = (INPUT.y - GAME.centerY) / (GAME.zoom * GAME.pixelScale);
                
                ctx.beginPath();
                ctx.arc(worldMouseX, worldMouseY, radius, 0, Math.PI*2);
                ctx.fillStyle = "rgba(100, 150, 255, 0.1)";
                ctx.fill();
                ctx.strokeStyle = "rgba(100, 150, 255, 0.3)";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw Black Hole (Revised Effect)
            const bhSize = (blackHole.radius + (getUpgrade('blackhole_size') ? getUpgrade('blackhole_size').val : 0) + (getUpgrade('event_horizon_ex') ? getUpgrade('event_horizon_ex').val : 0));
            const pulse = Math.sin(GAME.bhPulse * 2) * 2;
            
            // 1. Outer Glow (Aura)
            const grad = ctx.createRadialGradient(0, 0, bhSize, 0, 0, bhSize * 3 + pulse);
            grad.addColorStop(0, "rgba(0, 0, 0, 0)"); 
            grad.addColorStop(0.2, "rgba(124, 58, 237, 0.2)"); // Purple weak
            grad.addColorStop(0.5, "rgba(139, 92, 246, 0.1)"); // Purple even weaker
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, bhSize * 4, 0, Math.PI*2); ctx.fill();

            // 2. Accretion Disk Swirls (Cleaner lines)
            ctx.save();
            ctx.rotate(GAME.bhAngle);
            ctx.strokeStyle = "rgba(167, 139, 250, 0.3)"; // Soft Purple Lines
            ctx.lineWidth = 3;
            for(let i=0; i<4; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, bhSize * (1.3 + i*0.25) + pulse/2, i * Math.PI/2, i * Math.PI/2 + Math.PI);
                ctx.stroke();
            }
            ctx.restore();

            // 3. Event Horizon (Sharp Black Circle)
            ctx.save();
            ctx.shadowColor = "#8b5cf6"; // Violet Glow
            ctx.shadowBlur = 20 + pulse;
            ctx.fillStyle = "#000000";
            ctx.beginPath(); ctx.arc(0, 0, bhSize, 0, Math.PI*2); ctx.fill();
            
            // 4. Photon Ring (White Rim)
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Draw Game Objects
            entities.forEach(e => e.draw(ctx));
            bolts.forEach(b => b.draw(ctx));
            particles.forEach(p => p.draw(ctx));
            texts.forEach(t => t.draw());
        }

        function gameLoop() {
            if (GAME.running) {
                const now = performance.now();
                const dt = Math.min((now - GAME.lastTime) / 1000, 0.1);
                GAME.lastTime = now;
                updateGame(dt);
                drawGame();
                requestAnimationFrame(gameLoop);
            }
        }

        // 5. UI & CONTROL
        function startGame() {
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            document.getElementById('skill-bar').style.display = 'flex';
            
            GAME.timeLeft = getUpgrade('time').val + (getUpgrade('chrono_battery') ? getUpgrade('chrono_battery').val : 0);
            GAME.maxTime = GAME.timeLeft;
            GAME.scoreInRound = 0;
            GAME.combo = 0;
            updateComboUI();
            
            // Reset Skill CD partially or fully? Let's reset durations but keep CD?
            // Usually roguelikes reset skills per round or keep state. Let's keep state for strategy.
            // Reset durations though.
            GAME.skills.stasis.dur = 0;
            GAME.skills.surge.dur = 0;

            GAME.running = true;
            GAME.lastTime = performance.now();
            
            // Reset Entities based on density
            entities = [];
            const density = 5 + getUpgrade('density').val + (getUpgrade('federation') ? getUpgrade('federation').val : 0);
            for(let i=0; i<density; i++) entities.push(new Shard());
            
            gameLoop();
            audio.playStart();
        }

        function endGame() {
            GAME.running = false;
            ingameUi.style.display = 'none';
            document.getElementById('skill-bar').style.display = 'none';
            upgradeScreen.style.display = 'flex';

            // Interest
            const interest = getUpgrade('interest').level * 0.05 + (getUpgrade('dyson_sphere') ? getUpgrade('dyson_sphere').level * 0.02 : 0);
            if(interest > 0) {
                 const bonus = Math.floor(GAME.money * interest);
                 GAME.money += bonus;
                 // maybe show toast?
            }

            saveGame();
            renderTree();
            upgradeMoneyEl.innerText = '$' + Math.floor(GAME.money).toLocaleString();
            totalLevelEl.innerText = "Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: " + getTotalLevels();
        }

        function firstStart() {
            audio.init();
            startOverlay.style.opacity = 0;
            setTimeout(() => { 
                startOverlay.style.display = 'none'; 
                renderTree(); // Ensure tree is ready
                startGame(); // Start immediately
            }, 500);
        }

        function toggleMute() {
            audio.muted = !audio.muted;
            document.getElementById('mute-btn').innerText = audio.muted ? 'üîá' : 'üîä';
        }

        // Upgrade Tree System
        function renderTree() {
            treeContainer.innerHTML = '';
            upgradeMoneyEl.innerText = '$' + Math.floor(GAME.money).toLocaleString();
            totalLevelEl.innerText = "Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: " + getTotalLevels();

            const currentTotalLevels = getTotalLevels();
            
            // Group by tier
            const maxTier = Math.max(...UPGRADES.map(u => u.tier));

            for (let t = 0; t <= maxTier; t++) {
                const tierUpgrades = UPGRADES.filter(u => u.tier === t);
                if (tierUpgrades.length === 0) continue;

                const section = document.createElement('div');
                section.className = 'tier-section';
                
                const req = TIER_UNLOCKS[t];
                const locked = currentTotalLevels < req;
                
                let headerHTML = `<div class="tier-header"><span class="tier-title">TIER ${t}</span>`;
                if(locked) headerHTML += `<span class="tier-lock-msg">üîí ÌïÑÏöî Î†àÎ≤®: ${req}</span>`;
                else headerHTML += `<span class="tier-unlock-msg">üîì UNLOCKED</span>`;
                headerHTML += `</div>`;
                
                section.innerHTML = headerHTML;

                const grid = document.createElement('div');
                grid.className = 'tier-grid';

                tierUpgrades.forEach(u => {
                    const el = document.createElement('div');
                    el.className = `card ${locked ? 'locked' : ''}`;
                    const isMax = u.level >= u.maxLevel;
                    const cost = Math.floor(u.baseCost * Math.pow(u.mult, u.level));
                    
                    if (locked) {
                        el.innerHTML = `üîí Tier ${t}`;
                    } else {
                        if (GAME.money < cost && !isMax) el.classList.add('disabled');
                        
                        el.onclick = () => buyUpgrade(u);
                        
                        el.innerHTML = `
                            <div class="card-lvl ${isMax ? 'max-lvl' : ''}">Lv.${u.level}</div>
                            <div class="card-header">
                                <span class="card-icon">${u.icon}</span>
                                <span class="card-name">${u.name}</span>
                            </div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-footer">
                                <div class="card-stat">ÌòÑÏû¨: ${Number.isInteger(u.val) ? u.val : u.val.toFixed(2)}</div>
                                <div class="card-cost">${isMax ? 'MAX' : '$' + cost.toLocaleString()}</div>
                            </div>
                        `;
                    }
                    grid.appendChild(el);
                });

                section.appendChild(grid);
                treeContainer.appendChild(section);
            }
        }

        function buyUpgrade(u) {
            if (u.level >= u.maxLevel) return;
            const cost = Math.floor(u.baseCost * Math.pow(u.mult, u.level));
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                // Fix float precision issues
                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));
                
                audio.playBuy();
                saveGame();
                renderTree();
                
                // Unlock check
                if (u.type === 'skill') {
                     // Skill unlcok logic handled in updateSkillUI via level check
                }
            }
        }

        // Skill System
        function activateSkill(id) {
            if (GAME.paused) return;
            
            const skillData = GAME.skills[id];
            const upgrade = UPGRADES.find(u => u.id === `unlock_${id}`);
            
            if (!upgrade || upgrade.level <= 0) return; // Not unlocked
            if (skillData.cd > 0) return; // Cooldown

            const mastery = getUpgrade('skill_mastery') ? getUpgrade('skill_mastery').val : 0; // % reduction
            const gamma = getUpgrade('gamma_ray') ? getUpgrade('gamma_ray').val : 1.0;

            audio.playSkill(id);

            if (id === 'bomb') {
                // Massive Gravity Pulse
                GAME.shakeTime = 0.5; GAME.shakeAmount = 20;
                particles.push(new EffectParticle(0,0, '#ef4444', 'shockwave'));
                
                // Î∞∏Îü∞Ïä§ Ï°∞Ï†ï: Ï¥àÍ∏∞ ÏúÑÎ†• 50, Î†àÎ≤®Îãπ +15 (Í∏∞Ï°¥ 150 Í≥†Ï†ïÏóêÏÑú Î≥ÄÍ≤Ω)
                const baseForce = 50 + (upgrade.level * 15);
                const finalForce = baseForce * gamma;

                entities.forEach(e => {
                     const dist = Math.sqrt(e.x*e.x + e.y*e.y);
                     e.vx += (-e.x/dist) * finalForce; 
                     e.vy += (-e.y/dist) * finalForce;
                });
                
                // Ïø®ÌÉÄÏûÑ Í∞êÏÜå: Î†àÎ≤®Îãπ 0.5Ï¥à Í∞êÏÜå
                const baseCd = Math.max(5, skillData.max - (upgrade.level * 0.5));
                skillData.cd = baseCd * (1 - mastery/100);
            } 
            else if (id === 'stasis') {
                skillData.dur = (3.0 + upgrade.level * 0.5) * gamma;
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            else if (id === 'surge') {
                skillData.dur = (5.0 + upgrade.level * 0.5) * gamma;
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            else if (id === 'storm') {
                // Destroy random targets
                const count = (15 + upgrade.level * 3) * gamma; // Î≤ÑÌîÑ: Í∏∞Î≥∏ 15Ìöå, Î†àÎ≤®Îãπ +3Ìöå
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                         if(entities.length > 0) {
                             const target = entities[Math.floor(Math.random()*entities.length)];
                             triggerChainLightning(target); // Reuse logic
                         }
                    }, i * 50); // Î≤ÑÌîÑ: Î∞úÎèô ÏÜçÎèÑ 2Î∞∞ (100ms -> 50ms)
                }
                skillData.cd = skillData.max * (1 - mastery/100);
            }
            
            updateSkillUI();
        }

        function updateSkillUI() {
            const list = ['bomb', 'stasis', 'surge', 'storm'];
            list.forEach(id => {
                const upgrade = UPGRADES.find(u => u.id === `unlock_${id}`);
                const slot = document.getElementById(`slot-${id}`);
                const cdOverlay = document.getElementById(`cd-${id}`);
                const glow = document.getElementById(`glow-${id}`);
                const lvlInd = document.getElementById(`lvl-${id}`);

                if (upgrade && upgrade.level > 0) {
                    slot.classList.add('unlocked');
                    lvlInd.innerText = upgrade.level;
                    
                    const data = GAME.skills[id];
                    if (data.cd > 0) {
                        const pct = (data.cd / data.max) * 100;
                        cdOverlay.style.height = `${pct}%`;
                        slot.style.cursor = 'default';
                    } else {
                        cdOverlay.style.height = '0%';
                        slot.style.cursor = 'pointer';
                    }

                    if (data.dur > 0) glow.style.opacity = 1;
                    else glow.style.opacity = 0;

                } else {
                    slot.classList.remove('unlocked');
                }
            });
        }

        function updateComboUI() {
            if (GAME.combo > 1) {
                comboBox.style.opacity = 1;
                comboBox.style.transform = `scale(${1 + GAME.combo*0.02})`;
                comboValEl.innerText = `x${GAME.combo}`;
            } else {
                comboBox.style.opacity = 0;
                comboBox.style.transform = 'scale(1)';
            }
        }

        // Initialization
        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            scoreEl = document.getElementById('score-display');
            timerEl = document.getElementById('timer-display');
            upgradeScreen = document.getElementById('upgrade-screen');
            upgradeMoneyEl = document.getElementById('upgrade-money');
            totalLevelEl = document.getElementById('total-level-display');
            treeContainer = document.getElementById('tree-container');
            startOverlay = document.getElementById('start-overlay');
            ingameUi = document.getElementById('ingame-ui');
            comboBox = document.getElementById('combo-box');
            comboValEl = document.getElementById('combo-val');
            passiveStatsEl = document.getElementById('passive-stats');
            pauseOverlay = document.getElementById('pause-overlay');

            lvlBombEl = document.getElementById('lvl-bomb');
            lvlStasisEl = document.getElementById('lvl-stasis');
            lvlSurgeEl = document.getElementById('lvl-surge');
            lvlStormEl = document.getElementById('lvl-storm');

            window.addEventListener('resize', resize);
            resize();
            
            // Input Handlers
            canvas.addEventListener('mousedown', e => { INPUT.isDown = true; INPUT.x = e.clientX; INPUT.y = e.clientY; audio.startGravityHum(); });
            window.addEventListener('mouseup', () => { INPUT.isDown = false; audio.stopGravityHum(); });
            canvas.addEventListener('mousemove', e => { INPUT.x = e.clientX; INPUT.y = e.clientY; });
            
            canvas.addEventListener('touchstart', e => { 
                INPUT.isDown = true; 
                INPUT.x = e.touches[0].clientX; INPUT.y = e.touches[0].clientY; 
                e.preventDefault();
            }, {passive: false});
            window.addEventListener('touchend', () => INPUT.isDown = false);
            canvas.addEventListener('touchmove', e => {
                 INPUT.x = e.touches[0].clientX; INPUT.y = e.touches[0].clientY;
                 e.preventDefault();
            }, {passive: false});

            // Keyboard
            window.addEventListener('keydown', e => {
                if (e.key === 'q' || e.key === 'Q') activateSkill('bomb');
                if (e.key === 'w' || e.key === 'W') activateSkill('stasis');
                if (e.key === 'e' || e.key === 'E') activateSkill('surge');
                if (e.key === 'r' || e.key === 'R') activateSkill('storm');
                if (e.key === 'Escape') togglePause();
            });

            // Load Data
            loadGame();
            
            // Generate BG Stars
            for(let i=0; i<200; i++) {
                GAME.bgStars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2
                });
            }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
            GAME.pixelScale = Math.min(canvas.width, canvas.height) / BASE_RESOLUTION * 1.5; 
            // Regenerate BG stars
             GAME.bgStars = [];
             for(let i=0; i<200; i++) {
                GAME.bgStars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2
                });
            }
        }

        function togglePause() {
            if (GAME.phase !== 'start' && upgradeScreen.style.display !== 'flex') {
                GAME.paused = !GAME.paused;
                pauseOverlay.style.display = GAME.paused ? 'flex' : 'none';
            }
        }

    </script>
</body>
</html>
