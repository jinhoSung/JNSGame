<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Harvester: Planetary Devourer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f2;
            color: #333;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ïù∏Í≤åÏûÑ UI */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #333;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        
        .timer-warn { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #222;
        }
        
        /* ÏùåÏÜåÍ±∞ Î≤ÑÌäº */
        #mute-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255,255,255,0.8);
            border: 1px solid #ccc;
            border-radius: 50%;
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            pointer-events: auto;
        }

        /* ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 240, 242, 0.98);
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            width: 100%;
            max-width: 800px;
        }

        .screen-title { font-size: 2rem; font-weight: 900; color: #111; margin: 0; }
        .screen-subtitle { font-size: 0.9rem; color: #666; margin-bottom: 5px; }
        
        /* ÏÉÅÎã® ÏÉÅÌÉúÎ∞î */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            width: 90%;
            margin-bottom: 15px;
        }

        .money-badge {
            font-size: 1.2rem; font-weight: 800; color: #d97706;
        }
        .level-badge {
            font-size: 1rem; font-weight: 700; color: #4f46e5;
        }
        
        /* Îç∞Ïù¥ÌÑ∞ Î¶¨ÏÖã Î≤ÑÌäº */
        .reset-data-btn {
            font-size: 0.7rem; color: #999; text-decoration: underline; cursor: pointer;
        }

        /* Ìä∏Î¶¨ Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ */
        .tree-scroll-area {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 100px 20px;
            scrollbar-width: thin;
        }

        /* Ìã∞Ïñ¥ ÏÑπÏÖò */
        .tier-section {
            width: 100%;
            max-width: 1000px;
            margin-bottom: 40px;
            position: relative;
        }

        .tier-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tier-title {
            font-size: 1.2rem; font-weight: 800; color: #334155; margin-right: 15px;
        }
        
        .tier-lock-msg {
            font-size: 0.9rem; color: #ef4444; font-weight: 600; background: #fee2e2; padding: 2px 8px; border-radius: 4px;
        }
        .tier-unlock-msg {
            font-size: 0.9rem; color: #10b981; font-weight: 600; background: #d1fae5; padding: 2px 8px; border-radius: 4px;
        }

        .tier-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
        }
        
        /* Ïπ¥Îìú Ïä§ÌÉÄÏùº */
        .card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 140px;
        }

        .card:hover:not(.disabled):not(.locked) {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0,0,0,0.08);
            border-color: #3b82f6;
        }
        
        .card.disabled { opacity: 0.6; filter: grayscale(1); }
        .card.locked { 
            background: #f8fafc; 
            border: 1px dashed #cbd5e1; 
            cursor: not-allowed; 
            opacity: 0.8;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
        }
        
        .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .card-icon { font-size: 24px; }
        .card-name { font-weight: 800; font-size: 0.85rem; color: #1e293b; line-height: 1.2; }
        .card-desc { font-size: 0.7rem; color: #64748b; margin-bottom: 8px; flex-grow: 1; line-height: 1.3; }
        
        .card-footer { margin-top: auto; border-top: 1px solid #f1f5f9; padding-top: 8px; }
        .card-stat { font-size: 0.7rem; color: #7c3aed; font-weight: 600; margin-bottom: 2px; }
        .card-cost { font-weight: 700; color: #2563eb; font-size: 0.95rem; }
        
        .card-lvl { 
            position: absolute; top: 10px; right: 10px; 
            font-size: 0.7rem; font-weight: 800; color: #94a3b8; 
            background: #f1f5f9; padding: 2px 6px; border-radius: 4px;
        }
        .max-lvl { color: #10b981; background: #d1fae5; }

        /* ÌïòÎã® Í≥†Ï†ï Î≤ÑÌäº */
        .bottom-bar {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            padding: 20px;
            background: linear-gradient(to top, white, rgba(255,255,255,0));
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        
        .btn-action {
            pointer-events: auto;
            background: #111;
            color: white;
            padding: 15px 80px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 800;
            border: none;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .btn-action:hover { transform: scale(1.05); background: #222; }

        /* ÏãúÏûë Ïò§Î≤ÑÎ†àÏù¥ */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Ïù∏Í≤åÏûÑ UI -->
    <div id="ingame-ui">
        <div class="timer-box">
            <span id="timer-display">10.0</span>s
        </div>
        <div class="score-val" id="score-display">$0</div>
    </div>
    
    <button id="mute-btn" onclick="toggleMute()">üîä</button>

    <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ -->
    <div id="upgrade-screen">
        <div class="upgrade-header">
            <h1 class="screen-title">RESEARCH LAB</h1>
            <p class="screen-subtitle">Í≥®Í≥†Î£® Ìà¨ÏûêÌïòÏó¨ ÏÉÅÏúÑ Í∏∞Ïà†ÏùÑ Ìï¥Í∏àÌïòÏÑ∏Ïöî.</p>
        </div>

        <div class="status-bar">
            <div class="level-badge" id="total-level-display">Ï¥ù Ïó∞Íµ¨ Î†àÎ≤®: 0</div>
            <div class="money-badge" id="upgrade-money">$0</div>
        </div>
        
        <div style="margin-bottom: 10px;">
             <span class="reset-data-btn" onclick="resetSaveData()">[Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî]</span>
        </div>

        <div class="tree-scroll-area" id="tree-container">
            <!-- JS ÏÉùÏÑ± -->
        </div>

        <div class="bottom-bar">
            <button class="btn-action" onclick="startGame()">Start Loop</button>
        </div>
    </div>

    <!-- ÏãúÏûë ÌôîÎ©¥ -->
    <div id="start-overlay">
        <h1 class="text-5xl font-black mb-2 text-center">Void Harvester:<br>Planetary Devourer</h1>
        <p class="text-gray-500 mb-8 text-xl">10Ï¥à ÎèôÏïà ÌñâÏÑ±ÏùÑ Ìù°ÏàòÌïòÏó¨ ÏÑ±Ïû•ÌïòÏÑ∏Ïöî.</p>
        <button class="btn-action" onclick="firstStart()">Í≤åÏûÑ ÏãúÏûë</button>
    </div>

    <script>
        // --- ÏÇ¨Ïö¥Îìú Îß§ÎãàÏ†Ä (Ï†àÏ∞®Ï†Å Ïò§ÎîîÏò§) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.muted = false;
                this.osc = null; // Ï§ëÎ†•Ïû• Î£®ÌîÑ ÏÜåÎ¶¨Ïö©
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            playTone(freq, type, duration, vol=0.1) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playPop() {
                // ÎΩÅ ÏÜåÎ¶¨ (Îπ†Î•∏ frequency drop)
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(400 + Math.random()*200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playBuy() {
                // ÏΩîÏù∏ ÏÜåÎ¶¨ (Îùµ~ Îù†ÎßÅ)
                this.playTone(1200, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(1600, 'sine', 0.3, 0.1), 50);
            }
            
            playStart() {
                // ÏõÖÏû•Ìïú ÏãúÏûë (Ï†ÄÏùå)
                this.playTone(100, 'sawtooth', 1.0, 0.1);
            }

            startGravityHum() {
                if (this.muted || !this.ctx || this.osc) return;
                this.osc = this.ctx.createOscillator();
                this.oscGain = this.ctx.createGain();
                
                this.osc.type = 'sawtooth';
                this.osc.frequency.value = 50; // Ï†ÄÏùå
                this.oscGain.gain.value = 0.02; // Îß§Ïö∞ ÏûëÍ≤å

                // Ï†ÄÏó≠ ÌÜµÍ≥º ÌïÑÌÑ∞ (Î∂ÄÎìúÎüΩÍ≤å)
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = "lowpass";
                this.filter.frequency.value = 200;

                this.osc.connect(this.filter);
                this.filter.connect(this.oscGain);
                this.oscGain.connect(this.ctx.destination);
                this.osc.start();
            }

            stopGravityHum() {
                if (this.osc) {
                    this.osc.stop();
                    this.osc.disconnect();
                    this.osc = null;
                }
            }
        }
        
        const audio = new SoundManager();

        function toggleMute() {
            audio.muted = !audio.muted;
            document.getElementById('mute-btn').innerText = audio.muted ? 'üîá' : 'üîä';
        }

        // --- Î©îÏù∏ Í≤åÏûÑ ÏΩîÎìú ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const timerEl = document.getElementById('timer-display');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const upgradeMoneyEl = document.getElementById('upgrade-money');
        const totalLevelEl = document.getElementById('total-level-display');
        const treeContainer = document.getElementById('tree-container');
        const startOverlay = document.getElementById('start-overlay');
        const ingameUi = document.getElementById('ingame-ui');

        // --- Í≤åÏûÑ ÏÉÅÏàò Î∞è ÏÑ§Ï†ï ---
        const VALUE_MULTIPLIER = 0.3; 

        let GAME = {
            running: false,
            phase: 'start',
            money: 0,
            scoreInRound: 0,
            timeLeft: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0,
            lastTime: 0
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        const entities = [];
        const texts = [];
        const particles = []; // ÏãúÍ∞Å Ìö®Í≥ºÏö© ÌååÌã∞ÌÅ¥
        const blackHole = { radius: 35, angle: 0 };

        // --- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏãúÏä§ÌÖú (Ìã∞Ïñ¥ Í∏∞Î∞ò) ---
        const TIER_UNLOCKS = [0, 4, 12, 24, 40, 60, 85]; 

        const UPGRADES = [
            // [Tier 0] 
            {
                id: 'force', name: 'Ï§ëÎ†•Ïû• Í∞ïÎèÑ', desc: 'ÌååÌé∏ÏùÑ ÎãπÍ∏∞Îäî Ìûò.', icon: 'üß≤',
                tier: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, val: 0.08, inc: 0.03
            },
            {
                id: 'radius', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ†', desc: 'ÏòÅÌñ• Î≤îÏúÑ ÌôïÏû•.', icon: '‚≠ï',
                tier: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, val: 40, inc: 4
            },
            {
                id: 'friction', name: 'Í≥µÍ∞Ñ Ï†êÏÑ±', desc: 'ÌååÌé∏Ïù¥ Îçú ÎØ∏ÎÅÑÎü¨Ïßê.', icon: 'üï∏Ô∏è',
                tier: 0, level: 1, maxLevel: 10, baseCost: 100, mult: 1.5, val: 0.94, inc: -0.01 
            },

            // [Tier 1]
            {
                id: 'density', name: 'Ï¥àÍ∏∞ Î∞ÄÎèÑ', desc: 'ÏãúÏûë ÌñâÏÑ± Ïàò Ï¶ùÍ∞Ä.', icon: 'üåå',
                tier: 1, level: 0, maxLevel: 20, baseCost: 200, mult: 1.5, val: 30, inc: 10 
            },
            {
                id: 'respawn', name: 'ÌñâÏÑ± Î≤àÏãù', desc: 'Ìù°Ïàò Ïãú Ïû¨ÏÉùÏÑ± ÌôïÎ•†.', icon: 'üå±',
                tier: 1, level: 0, maxLevel: 20, baseCost: 300, mult: 1.5, val: 0, inc: 5 
            },
             {
                id: 'time', name: 'ÏãúÍ∞Ñ ÏôúÍ≥°', desc: 'Ï†úÌïú ÏãúÍ∞Ñ Ï¶ùÍ∞Ä.', icon: '‚è≥',
                tier: 1, level: 0, maxLevel: 50, baseCost: 400, mult: 1.5, val: 10, inc: 1.5 
            },

            // [Tier 2] 
            {
                id: 'value', name: 'Ï±ÑÍµ¥ Ìö®Ïú®', desc: 'ÌñâÏÑ± Í∞ÄÏπò ÏÉÅÏäπ.', icon: 'üíé',
                tier: 2, level: 0, maxLevel: 99, baseCost: 600, mult: 1.5, val: 1.0, inc: 0.5
            },
            {
                id: 'heavy', name: 'Í≥†Ï§ëÎ†•', desc: 'Î¨¥Í±∞Ïö¥ ÌñâÏÑ± Î¨¥Í≤å Î¨¥Ïãú.', icon: '‚öì',
                tier: 2, level: 0, maxLevel: 20, baseCost: 700, mult: 1.5, val: 1.0, inc: 0.2
            },
            {
                id: 'auto', name: 'ÏûêÎèô Ïù∏Î†•', desc: 'ÌÅ¥Î¶≠ ÏóÜÏù¥ÎèÑ ÎãπÍπÄ.', icon: 'üåÄ',
                tier: 2, level: 0, maxLevel: 10, baseCost: 1000, mult: 2.0, val: 0, inc: 0.1
            },
            {
                id: 'attract_range', name: 'ÏûêÏó∞ Ï§ëÎ†•', desc: 'Î∏îÎûôÌôÄ Í∏∞Î≥∏ Ìù°ÏûÖ Î≤îÏúÑ.', icon: 'üåë',
                tier: 2, level: 0, maxLevel: 20, baseCost: 800, mult: 1.5, val: 150, inc: 20
            },

            // [Tier 3] 
            {
                id: 'tier_unlock', name: 'Ïã¨Ïö∞Ï£º ÌÉêÏÇ¨', desc: 'Îçî ÎÜíÏùÄ Îì±Í∏â ÌñâÏÑ± Î∞úÍ≤¨.', icon: 'üî≠',
                tier: 3, level: 0, maxLevel: 5, baseCost: 2000, mult: 3.0, val: 1, inc: 1
            },
            {
                id: 'lightning_unlock', name: 'ÎáåÏ†Ñ ÌñâÏÑ±', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌñâÏÑ± Îì±Ïû•.', icon: '‚ö°',
                tier: 3, level: 0, maxLevel: 1, baseCost: 3000, mult: 1, val: 0, inc: 1
            },
            {
                id: 'crit', name: 'ÌñâÏÑ± Î∂ïÍ¥¥', desc: 'Í∞ÄÏπò 2Î∞∞ ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•†.', icon: 'üí•',
                tier: 3, level: 0, maxLevel: 20, baseCost: 2500, mult: 1.5, val: 0, inc: 2
            },

            // [Tier 4]
            {
                id: 'l_range', name: 'Ï†ÑÏù¥ Î≤îÏúÑ', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù Í±∞Î¶¨.', icon: 'üì°',
                tier: 4, level: 0, maxLevel: 10, baseCost: 4000, mult: 1.6, val: 60, inc: 15
            },
            {
                id: 'l_count', name: 'Í≥ºÎ∂ÄÌïò', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌÉÄÍ≤ü Ïàò.', icon: 'üîó',
                tier: 4, level: 0, maxLevel: 10, baseCost: 4500, mult: 1.8, val: 3, inc: 1
            },
             {
                id: 'luck', name: 'ÌñâÏö¥Ïùò Î≥Ñ', desc: 'ÌñâÏÑ± Î¶¨Ï†† Ïãú Ìù¨Í∑Ä ÌôïÎ•† Ï¶ùÍ∞Ä.', icon: 'üçÄ',
                tier: 4, level: 0, maxLevel: 10, baseCost: 5000, mult: 1.6, val: 1.0, inc: 0.2
            },

            // [Tier 5]
            {
                id: 'blackhole_size', name: 'Í±∞ÎåÄ Î∏îÎûôÌôÄ', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä.', icon: '‚ö´',
                tier: 5, level: 0, maxLevel: 10, baseCost: 10000, mult: 2.5, val: 35, inc: 3
            },
            {
                id: 'interest', name: 'ÏïîÌùë Î¨ºÏßà Î∞òÏùë', desc: 'ÎùºÏö¥Îìú Ï¢ÖÎ£å Ïãú Î≥¥Ïú†Í∏à Ïù¥Ïûê.', icon: 'üìà',
                tier: 5, level: 0, maxLevel: 10, baseCost: 15000, mult: 2.0, val: 0, inc: 1
            },
            {
                id: 'singularity', name: 'ÌäπÏù¥Ï†ê', desc: 'ÌôîÎ©¥ Ï†ÑÏ≤¥ ÏïΩÌïú ÏßÄÏÜç Îç∞ÎØ∏ÏßÄ.', icon: '‚öõÔ∏è',
                tier: 5, level: 0, maxLevel: 5, baseCost: 20000, mult: 3.0, val: 0, inc: 1
            }
        ];

        // --- Local Storage Save/Load ---
        function saveGame() {
            const data = {
                money: GAME.money,
                upgrades: UPGRADES.map(u => ({ id: u.id, level: u.level }))
            };
            localStorage.setItem('void_harvester_save_v2', JSON.stringify(data));
        }

        function loadGame() {
            const str = localStorage.getItem('void_harvester_save_v2');
            if(!str) return;
            try {
                const data = JSON.parse(str);
                GAME.money = data.money || 0;
                
                if(data.upgrades) {
                    data.upgrades.forEach(saved => {
                        const u = UPGRADES.find(x => x.id === saved.id);
                        if(u) {
                            // ÌòÑÏû¨ Î†àÎ≤® ÏÑ§Ï†ï
                            u.level = saved.level;
                            
                            // Í∞í(val) Ïû¨Í≥ÑÏÇ∞ (Ï¥àÍ∏∞Í∞í + Ï¶ùÍ∞ÄÎüâ * Î†àÎ≤®ÏóÖÌöüÏàò)
                            // Í∏∞Î≥∏ Î†àÎ≤®(tier0ÏùÄ 1, Í∑∏Ïô∏ 0)
                            const startLvl = u.tier === 0 ? 1 : 0;
                            const gained = Math.max(0, u.level - startLvl);
                            
                            // Ï¥àÍ∏∞Í∞íÏùÄ UPGRADES Ï†ïÏùòÏóê ÏûàÎäî Í∞í.
                            // ÌïòÏßÄÎßå JS Í∞ùÏ≤¥ Ï∞∏Ï°∞Îùº Ïù¥ÎØ∏ ÏàòÏ†ïÎêòÏóàÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú...
                            // Ïó¨Í∏∞ÏÑúÎäî Ï†ïÏùòÎåÄÎ°ú Ï¥àÍ∏∞ÌôîÌïòÍ≥† Ï¶ùÍ∞ÄÎ∂Ñ ÎçîÌïòÎäîÍ≤å ÏïàÏ†ÑÌïòÏßÄÎßå,
                            // ÏΩîÎìúÍ∞Ä Î≥µÏû°Ìï¥ÏßÄÎØÄÎ°ú Í∑∏ÎÉ• ÌòÑÏû¨ valÏóêÎã§ ÎàÑÏ†ÅÏãúÌÇ§Îäî Î∞©Ïãù ÎåÄÏã†
                            // ÏõêÎûò Î°úÏßÅÎåÄÎ°ú level up Ïãú Ï¶ùÍ∞ÄÏãúÌÇ§Îäî Î∞©ÏãùÏùÑ ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌïòÍ±∞ÎÇò
                            // Í∞ÑÎã®Ìûà: Ï¥àÍ∏∞Í∞íÏù¥ ÌïòÎìúÏΩîÎî© ÎêòÏñ¥ÏûàÏúºÎØÄÎ°ú, ÏÇ¨Ïã§ ÏÉàÎ°úÍ≥†Ïπ®ÌïòÎ©¥ Ï¥àÍ∏∞Í∞íÏúºÎ°ú ÎèåÏïÑÏò¥.
                            // Îî∞ÎùºÏÑú gained ÎßåÌÅº incÎ•º ÎçîÌï¥Ï£ºÎ©¥ Îê®.
                            
                            if(gained > 0) {
                                u.val += u.inc * gained;
                                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));
                            }
                        }
                    });
                }
            } catch(e) { console.error("Save load failed", e); }
        }

        function resetSaveData() {
            if(confirm("Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
                localStorage.removeItem('void_harvester_save_v2');
                location.reload();
            }
        }

        // --- ÌñâÏÑ± Îç∞Ïù¥ÌÑ∞ ---
        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 5,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 15,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 40,  valMult: 20, weight: 5 },
            { id: 'electric', color: '#facc15', minR: 15, maxR: 20, mass: 8, valMult: 10, weight: 0, isLightning: true } 
        ];

        // --- Ïú†Ìã∏ ---
        const rand = (min, max) => Math.random() * (max - min) + min;
        function getUpgrade(id) { return UPGRADES.find(u => u.id === id); }
        function getTotalLevels() { 
            return UPGRADES.reduce((sum, u) => {
                if(u.tier === 0) return sum + Math.max(0, u.level - 1);
                return sum + u.level;
            }, 0); 
        } 

        // --- ÌÅ¥ÎûòÏä§ ---
        class EffectParticle {
            constructor(x, y, color, type) {
                this.x = x; this.y = y;
                this.color = color;
                this.type = type; // 'explode', 'gravity', 'trail'
                this.life = 1.0;
                
                if (type === 'explode') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = 0.05;
                    this.size = Math.random() * 3 + 1;
                } else if (type === 'gravity') {
                    // Ï§ëÎ†•Ïû• ÌååÌã∞ÌÅ¥: ÎßàÏö∞Ïä§ -> Î∏îÎûôÌôÄ Î∞©Ìñ•
                    const angle = Math.atan2(GAME.centerY - y, GAME.centerX - x);
                    const speed = Math.random() * 5 + 5;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.decay = 0.1;
                    this.size = 2;
                } else if (type === 'trail') {
                    this.vx = 0; this.vy = 0;
                    this.decay = 0.1;
                    this.size = Math.random() * 2 + 1;
                }
            }

            update(dt) {
                const timeScale = dt * 60;
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.life -= this.decay * timeScale;
            }

            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Shard {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (Math.min(GAME.width, GAME.height)/2 - 80) + 150;
                this.x = GAME.centerX + Math.cos(angle) * dist;
                this.y = GAME.centerY + Math.sin(angle) * dist;
                
                const speedBase = 0.003; 
                this.orbitSpeed = (speedBase * (150/dist)) * (Math.random() < 0.5 ? 1 : -1);

                const tierLvl = getUpgrade('tier_unlock').val; 
                const lightningUnlocked = getUpgrade('lightning_unlock').level > 0;
                const luckBonus = getUpgrade('luck') ? getUpgrade('luck').val : 1;

                let available = [SHARD_TYPES[0]]; 
                if (tierLvl >= 2) available.push(SHARD_TYPES[1]);
                if (tierLvl >= 3) available.push(SHARD_TYPES[2]);
                if (tierLvl >= 4) available.push(SHARD_TYPES[3]);
                
                let type = null;
                if (lightningUnlocked && Math.random() < 0.05 * luckBonus) { 
                    type = SHARD_TYPES[4]; 
                } else {
                    const totalW = available.reduce((a,b)=>a+b.weight,0);
                    let r = Math.random() * totalW;
                    type = available[0];
                    for(let t of available){
                        if(r < t.weight) { type = t; break; }
                        r -= t.weight;
                    }
                }

                this.type = type;
                this.color = type.color;
                this.radius = rand(type.minR, type.maxR);
                this.mass = type.mass;
                this.sides = type.isLightning ? 3 : Math.floor(rand(4, 7)); 
                
                const valueBonus = getUpgrade('value').val; 
                this.value = Math.floor(this.radius * 2 * type.valMult * valueBonus * VALUE_MULTIPLIER);
                
                this.vx = 0; this.vy = 0;
                this.friction = getUpgrade('friction').val;
            }

            update(dt) {
                const timeScale = dt * 60;
                
                // Ìä∏Î†àÏùº Ìö®Í≥º (Îπ†Î•¥Î©¥ ÏÉùÏÑ±)
                const speedSq = this.vx*this.vx + this.vy*this.vy;
                if(speedSq > 5 && Math.random() < 0.3) {
                    particles.push(new EffectParticle(this.x, this.y, this.color, 'trail'));
                }

                // 1. Í≥µÏ†Ñ
                const currentOrbitSpeed = this.orbitSpeed * timeScale;
                const dx0 = this.x - GAME.centerX;
                const dy0 = this.y - GAME.centerY;
                const cos = Math.cos(currentOrbitSpeed);
                const sin = Math.sin(currentOrbitSpeed);
                this.x = GAME.centerX + (dx0 * cos - dy0 * sin);
                this.y = GAME.centerY + (dx0 * sin + dy0 * cos);

                // 2. Î¨ºÎ¶¨
                const dx = GAME.centerX - this.x;
                const dy = GAME.centerY - this.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);

                // Î∏îÎûôÌôÄ ÏûêÏó∞ Ï§ëÎ†•
                const naturalRange = getUpgrade('attract_range').val;
                if (dist < naturalRange) {
                    const g = 1000 / distSq;
                    const force = g / this.mass;
                    this.vx += (dx/dist) * force * timeScale;
                    this.vy += (dy/dist) * force * timeScale;
                }

                // ÏûêÎèô Ïù∏Î†•
                const autoRate = getUpgrade('auto').val; 
                if (autoRate > 0 && dist < 600) {
                     const force = getUpgrade('force').val * autoRate * 0.5;
                     const accel = force / this.mass;
                     this.vx += (dx/dist) * accel * timeScale;
                     this.vy += (dy/dist) * accel * timeScale;
                }

                // ÌîåÎ†àÏù¥Ïñ¥ Ïä§Ïúï
                if (INPUT.isDown) {
                    const radius = getUpgrade('radius').val;
                    const power = getUpgrade('force').val;
                    const heavyBonus = getUpgrade('heavy').val;

                    const mdx = INPUT.x - this.x;
                    const mdy = INPUT.y - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        const pushX = GAME.centerX - this.x;
                        const pushY = GAME.centerY - this.y;
                        const pushLen = Math.sqrt(pushX*pushX + pushY*pushY);
                        
                        let effectiveMass = this.mass;
                        if(effectiveMass > 8) effectiveMass /= heavyBonus; 

                        const accel = (2.0 * power) / effectiveMass;

                        this.vx += (pushX / pushLen) * accel * timeScale;
                        this.vy += (pushY / pushLen) * accel * timeScale;
                        
                        const gatherForce = 0.2 / effectiveMass;
                        this.vx += (mdx / mDist) * gatherForce * timeScale;
                        this.vy += (mdy / mDist) * gatherForce * timeScale;
                    }
                }

                // ÌäπÏù¥Ï†ê (Ï†ÑÏ≤¥ ÏïΩÌïú Ïù∏Î†•)
                const singularityLvl = getUpgrade('singularity') ? getUpgrade('singularity').level : 0;
                if(singularityLvl > 0) {
                    const sForce = singularityLvl * 0.05 / this.mass;
                    this.vx += (dx/dist) * sForce * timeScale;
                    this.vy += (dy/dist) * sForce * timeScale;
                }

                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                
                this.vx *= Math.pow(this.friction, timeScale);
                this.vy *= Math.pow(this.friction, timeScale);
                
                this.rotation = (this.rotation || 0) + (this.vx + this.vy) * 0.1 * timeScale + this.orbitSpeed * 3 * timeScale;

                const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
                if (dist < bhSize) return true;
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.beginPath();
                if(this.type.isLightning) {
                    ctx.shadowColor = '#facc15';
                    ctx.shadowBlur = 10;
                    ctx.moveTo(this.radius, 0);
                    ctx.lineTo(-this.radius/2, this.radius);
                    ctx.lineTo(-this.radius/2, -this.radius);
                } else {
                    ctx.moveTo(this.radius, 0);
                    for (let i = 1; i < this.sides; i++) {
                        const angle = (i * 2 * Math.PI) / this.sides;
                        ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                    }
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class PopText {
            constructor(x, y, val, isCrit) {
                this.x = x; this.y = y; 
                this.text = "+$" + val;
                this.life = 1.0; this.vy = -1;
                this.isCrit = isCrit;
            }
            update(dt) {
                const timeScale = dt * 60;
                this.y += this.vy * timeScale; 
                this.life -= 0.03 * timeScale; 
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.isCrit ? '#ef4444' : '#10b981';
                ctx.font = this.isCrit ? '900 20px "Pretendard"' : '800 14px "Pretendard"';
                if(this.isCrit && !this.text.includes('!')) this.text += "!";
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
                this.life = 1.0;
            }
            update(dt) { 
                const timeScale = dt * 60;
                this.life -= 0.1 * timeScale; 
            }
            draw() {
                if(this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#facc15';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ÏãúÏä§ÌÖú Ìï®Ïàò ---
        const bolts = [];

        function init() {
            window.addEventListener('resize', resize);
            resize();
            
            canvas.addEventListener('mousedown', (e) => { 
                INPUT.isDown = true; 
                move(e); 
                audio.init(); 
                audio.startGravityHum();
            });
            canvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', () => { 
                INPUT.isDown = false;
                audio.stopGravityHum();
            });
            
            canvas.addEventListener('touchstart', (e) => { 
                INPUT.isDown = true; move(e.touches[0]); e.preventDefault(); 
                audio.init();
                audio.startGravityHum();
            }, {passive:false});
            canvas.addEventListener('touchmove', (e) => { move(e.touches[0]); e.preventDefault(); }, {passive:false});
            window.addEventListener('touchend', () => {
                INPUT.isDown = false;
                audio.stopGravityHum();
            });

            // Î°úÎìú
            loadGame();

            GAME.lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
        }
        function move(e) { INPUT.x = e.clientX; INPUT.y = e.clientY; }

        function firstStart() {
            startOverlay.style.display = 'none';
            audio.init();
            startGame();
        }

        function startGame() {
            audio.playStart();
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            
            GAME.running = true;
            GAME.phase = 'playing';
            GAME.scoreInRound = 0;
            scoreEl.innerText = "$0";
            
            const timeBonus = getUpgrade('time').val;
            GAME.timeLeft = timeBonus; 
            
            entities.length = 0;
            bolts.length = 0;
            particles.length = 0;
            
            const initCount = getUpgrade('density').val;
            for(let i=0; i<initCount; i++) entities.push(new Shard());
            
            GAME.lastTime = performance.now();
        }

        function endGame() {
            audio.stopGravityHum();
            GAME.phase = 'upgrade';
            GAME.running = false;
            
            const interestRate = getUpgrade('interest') ? getUpgrade('interest').val : 0; 
            if(interestRate > 0) {
                const interest = Math.floor(GAME.money * (interestRate / 100));
                if(interest > 0) {
                    GAME.money += interest;
                }
            }

            // ÏûêÎèô Ï†ÄÏû•
            saveGame();

            ingameUi.style.display = 'none';
            upgradeScreen.style.display = 'flex';
            renderUpgrades();
        }

        function loop(timestamp) {
            let dt = (timestamp - GAME.lastTime) / 1000;
            GAME.lastTime = timestamp;

            if (dt > 0.1) dt = 0.1;

            if (GAME.phase === 'playing') {
                updateGame(dt);
            }
            drawGame(dt); // dt for visual updates
            requestAnimationFrame(loop);
        }

        function triggerChainLightning(sourceShard) {
            const range = getUpgrade('l_range').val;
            const count = getUpgrade('l_count').val;
            
            let targets = [];
            for(let other of entities) {
                if(other === sourceShard) continue;
                const dx = other.x - sourceShard.x;
                const dy = other.y - sourceShard.y;
                if(dx*dx + dy*dy < range*range) {
                    targets.push({ entity: other, dist: dx*dx+dy*dy });
                }
            }
            
            targets.sort((a,b) => a.dist - b.dist);
            targets = targets.slice(0, count);

            targets.forEach(t => {
                const e = t.entity;
                bolts.push(new LightningBolt(sourceShard.x, sourceShard.y, e.x, e.y));
                
                const pushX = GAME.centerX - e.x;
                const pushY = GAME.centerY - e.y;
                const len = Math.sqrt(pushX*pushX + pushY*pushY);
                const force = 15; 
                
                e.vx += (pushX/len) * force;
                e.vy += (pushY/len) * force;
            });
        }

        function updateGame(dt) {
            GAME.timeLeft -= dt; 
            if (GAME.timeLeft <= 0) {
                GAME.timeLeft = 0;
                endGame();
                return;
            }

            timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(GAME.timeLeft <= 3) timerEl.parentElement.classList.add('timer-warn');
            else timerEl.parentElement.classList.remove('timer-warn');

            for(let i=bolts.length-1; i>=0; i--) {
                bolts[i].update(dt);
                if(bolts[i].life <= 0) bolts.splice(i, 1);
            }

            for(let i=particles.length-1; i>=0; i--) {
                particles[i].update(dt);
                if(particles[i].life <= 0) particles.splice(i, 1);
            }

            const critChance = getUpgrade('crit').val; 
            const respawnChance = getUpgrade('respawn').val;

            if (entities.length < 5) entities.push(new Shard());

            // ÎßàÏö∞Ïä§ ÎàÑÎ•¥Í≥† ÏûàÏùÑ Îïå ÏãúÍ∞Å Ìö®Í≥º ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
            if(INPUT.isDown) {
                const radius = getUpgrade('radius').val;
                if(Math.random() < 0.5) {
                    // ÏõêÏ£ºÏÉÅÏóêÏÑú ÎûúÎç§ ÏúÑÏπò
                    const angle = Math.random() * Math.PI * 2;
                    const px = INPUT.x + Math.cos(angle) * radius;
                    const py = INPUT.y + Math.sin(angle) * radius;
                    particles.push(new EffectParticle(px, py, 'rgba(100,200,255,0.5)', 'gravity'));
                }
            }

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update(dt)) {
                    if(e.type.isLightning) triggerChainLightning(e);

                    if (Math.random() * 100 < respawnChance) entities.push(new Shard());

                    let finalVal = e.value;
                    let isCrit = false;
                    if(Math.random() * 100 < critChance) {
                        finalVal *= 2;
                        isCrit = true;
                    }

                    GAME.scoreInRound += finalVal;
                    GAME.money += finalVal; 
                    
                    texts.push(new PopText(GAME.centerX, GAME.centerY - 30, finalVal, isCrit));
                    // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
                    for(let k=0; k<5; k++) {
                        particles.push(new EffectParticle(e.x, e.y, e.color, 'explode'));
                    }
                    audio.playPop();

                    entities.splice(i, 1);
                }
            }
            
            scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();

            for (let i = texts.length - 1; i >= 0; i--) {
                texts[i].update(dt);
                if (texts[i].life <= 0) texts.splice(i, 1);
            }
        }

        function drawGame(dt) {
            ctx.clearRect(0, 0, GAME.width, GAME.height);

            // Î∏îÎûôÌôÄ ÏãúÍ∞ÅÌôî (ÌöåÏ†Ñ & Îß•Îèô)
            const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
            blackHole.angle += dt;
            
            // Accretion Disk
            const grd = ctx.createRadialGradient(GAME.centerX, GAME.centerY, bhSize*0.8, GAME.centerX, GAME.centerY, bhSize*2.5);
            grd.addColorStop(0, "rgba(0,0,0,1)");
            grd.addColorStop(0.3, "rgba(76, 29, 149, 0.8)"); // purple-900
            grd.addColorStop(0.6, "rgba(139, 92, 246, 0.4)"); // violet-500
            grd.addColorStop(1, "rgba(0,0,0,0)");
            
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, bhSize*2.5, 0, Math.PI*2);
            ctx.fill();

            // Core
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, bhSize, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            // Event Horizon Glow
            ctx.strokeStyle = 'rgba(200,200,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, bhSize, 0, Math.PI*2);
            ctx.stroke();

            // ÌååÌã∞ÌÅ¥
            particles.forEach(p => p.draw(ctx));

            if (INPUT.isDown && GAME.phase === 'playing') {
                const radius = getUpgrade('radius').val;
                ctx.beginPath();
                ctx.arc(INPUT.x, INPUT.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 150, 255, 0.05)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.4)';
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ï§ëÏã¨ Ïó∞Í≤∞ÏÑ†
                ctx.beginPath();
                ctx.moveTo(INPUT.x, INPUT.y);
                ctx.lineTo(GAME.centerX, GAME.centerY);
                ctx.strokeStyle = 'rgba(100,150,255,0.1)';
                ctx.lineWidth = 10;
                ctx.stroke();
            }

            entities.forEach(e => e.draw());
            bolts.forEach(b => b.draw());
            texts.forEach(t => t.draw());
        }

        // --- ÏóÖÍ∑∏Î†àÏù¥Îìú UI Î°úÏßÅ ---
        function getCost(u) {
            return Math.floor(u.baseCost * Math.pow(u.mult, u.level - 1));
        }

        function renderUpgrades() {
            upgradeMoneyEl.innerText = '$' + GAME.money.toLocaleString();
            
            const totalLevels = getTotalLevels(); 
            totalLevelEl.innerText = `Ïó∞Íµ¨ Î†àÎ≤®: ${totalLevels}`;

            treeContainer.innerHTML = '';

            const tiers = {};
            UPGRADES.forEach(u => {
                if(!tiers[u.tier]) tiers[u.tier] = [];
                tiers[u.tier].push(u);
            });

            const maxTier = Math.max(...Object.keys(tiers).map(Number));

            for (let t = 0; t <= maxTier; t++) {
                if (!tiers[t]) continue;

                const reqLevels = TIER_UNLOCKS[t] || 0;
                const isTierUnlocked = totalLevels >= reqLevels;

                const tierSection = document.createElement('div');
                tierSection.className = 'tier-section';
                
                const header = document.createElement('div');
                header.className = 'tier-header';
                
                const title = document.createElement('div');
                title.className = 'tier-title';
                title.innerText = `TIER ${t}`;
                header.appendChild(title);

                if(!isTierUnlocked) {
                    const msg = document.createElement('div');
                    msg.className = 'tier-lock-msg';
                    msg.innerText = `üîí Ïû†ÍπÄ (ÌïÑÏöî Ïó∞Íµ¨ Î†àÎ≤®: ${reqLevels})`;
                    header.appendChild(msg);
                } else if (reqLevels > 0) {
                     const msg = document.createElement('div');
                     msg.className = 'tier-unlock-msg';
                     msg.innerText = `‚úì Ìï¥Í∏àÎê®`;
                     header.appendChild(msg);
                }

                tierSection.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'tier-grid';

                tiers[t].forEach(u => {
                    const cost = getCost(u);
                    const canBuy = GAME.money >= cost;
                    const isMax = u.level >= u.maxLevel;
                    
                    const card = document.createElement('div');
                    
                    if (isTierUnlocked) {
                        card.className = `card ${canBuy && !isMax ? '' : 'disabled'}`;
                        if (!isMax && canBuy) card.onclick = () => buyUpgrade(u.id);
                        
                        let statText = '';
                        if(u.id.includes('unlock')) statText = u.level > 0 ? "Î≥¥Ïú†Ï§ë" : "ÎØ∏Î≥¥Ïú†";
                        else if(u.id === 'radius' || u.id === 'l_range') statText = `${Math.floor(u.val)}px`;
                        else if(u.id === 'time') statText = `${u.val.toFixed(1)}s`;
                        else if(u.id === 'crit' || u.id === 'respawn' || u.id === 'interest') statText = `${u.val}%`;
                        else if(u.id === 'friction') statText = `${(1-u.val).toFixed(2)} ÎßàÏ∞∞`;
                        else statText = `x${u.val.toFixed(2)}`;

                        let incText = '';
                        if(isMax) incText = '(MAX)';
                        else if(u.inc > 0) incText = `(+${u.inc})`;
                        else incText = `(${u.inc})`;

                        card.innerHTML = `
                            <div class="card-lvl ${isMax ? 'max-lvl' : ''}">${isMax ? 'MAX' : 'Lv.' + u.level}</div>
                            <div class="card-header">
                                <div class="card-icon">${u.icon}</div>
                                <div class="card-name">${u.name}</div>
                            </div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-footer">
                                <div class="card-stat">${statText} <span class="text-gray-400 text-xs">${incText}</span></div>
                                <div class="card-cost">${isMax ? '-' : '$' + cost.toLocaleString()}</div>
                            </div>
                        `;
                    } else {
                        card.className = 'card locked';
                        card.innerHTML = `
                            <div class="card-icon">üîí</div>
                            <div style="font-size:0.8rem; font-weight:bold; margin-top:5px;">Ïó∞Íµ¨ ÌïÑÏöî</div>
                        `;
                    }
                    grid.appendChild(card);
                });

                tierSection.appendChild(grid);
                treeContainer.appendChild(tierSection);
            }
        }

        function buyUpgrade(id) {
            const u = UPGRADES.find(x => x.id === id);
            if (u.level >= u.maxLevel) return;

            const cost = getCost(u);
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                
                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));

                audio.playBuy(); // ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
                saveGame();      // Ï†ÄÏû•
                renderUpgrades();
            }
        }

        init();
    </script>
</body>
</html>
