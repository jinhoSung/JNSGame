<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Harvester: Planetary Devourer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f2;
            color: #333;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Ïù∏Í≤åÏûÑ UI */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #333;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        
        .timer-warn { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #222;
        }

        /* ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 240, 242, 0.98);
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px 0;
            box-sizing: border-box;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .screen-title { font-size: 2.5rem; font-weight: 900; color: #111; margin: 0; line-height: 1.2; }
        .screen-subtitle { font-size: 1rem; color: #666; margin-bottom: 10px; }
        .money-badge {
            background: #111; color: #fbbf24; padding: 8px 30px; border-radius: 50px;
            font-size: 1.5rem; font-weight: bold; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: inline-block;
        }

        /* Ìä∏Î¶¨ Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ */
        .tree-scroll-area {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            overflow-x: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            /* Ïä§ÌÅ¨Î°§Î∞î Ïª§Ïä§ÌÖÄ */
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 transparent;
        }

        .tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px; /* Ï§Ñ Í∞ÑÍ≤© */
            padding-bottom: 100px; /* ÌïòÎã® Ïó¨Î∞± */
        }

        .tree-row {
            display: flex;
            justify-content: center;
            gap: 20px; /* Ïπ¥Îìú Í∞ÑÍ≤© */
            position: relative;
        }
        
        /* Ïó∞Í≤∞ÏÑ† */
        .connector {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 25px;
            background: #cbd5e1;
            z-index: 0;
        }

        .card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 15px;
            width: 180px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        .card:hover:not(.disabled):not(.locked) {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0,0,0,0.08);
            border-color: #3b82f6;
        }
        
        .card.disabled { opacity: 0.7; filter: grayscale(1); }
        .card.locked { 
            background: #f1f5f9; 
            border: 1px dashed #cbd5e1; 
            cursor: not-allowed; 
            opacity: 0.5;
        }
        
        .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .card-icon { font-size: 20px; }
        .card-name { font-weight: 800; font-size: 0.85rem; color: #1e293b; line-height: 1.2; }
        .card-desc { font-size: 0.7rem; color: #64748b; margin-bottom: 8px; height: 28px; overflow: hidden; line-height: 1.3; }
        
        .card-footer { margin-top: auto; border-top: 1px solid #f1f5f9; padding-top: 8px; }
        .card-stat { font-size: 0.7rem; color: #7c3aed; font-weight: 600; margin-bottom: 2px; }
        .card-cost { font-weight: 700; color: #2563eb; font-size: 0.95rem; }
        .card-lvl { 
            position: absolute; top: 10px; right: 10px; 
            font-size: 0.7rem; font-weight: 800; color: #94a3b8; 
            background: #f8fafc; padding: 2px 6px; border-radius: 4px;
        }

        .max-lvl { color: #10b981; background: #d1fae5; }

        /* ÌïòÎã® Í≥†Ï†ï Î≤ÑÌäº */
        .bottom-bar {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            padding: 20px;
            background: linear-gradient(to top, white, rgba(255,255,255,0));
            display: flex;
            justify-content: center;
            pointer-events: none; /* ÌÅ¥Î¶≠ Ìà¨Í≥º */
        }
        
        .btn-action {
            pointer-events: auto;
            background: #111;
            color: white;
            padding: 15px 80px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 800;
            border: none;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .btn-action:hover { transform: scale(1.05); background: #222; }

        /* ÏãúÏûë Ïò§Î≤ÑÎ†àÏù¥ */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Ïù∏Í≤åÏûÑ UI -->
    <div id="ingame-ui">
        <div class="timer-box">
            <span id="timer-display">10.0</span>s
        </div>
        <div class="score-val" id="score-display">$0</div>
    </div>

    <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÌôîÎ©¥ -->
    <div id="upgrade-screen">
        <div class="upgrade-header">
            <h1 class="screen-title">PLANETARY DEVOURER</h1>
            <p class="screen-subtitle">Tech Tree System</p>
            <div class="money-badge" id="upgrade-money">$0</div>
        </div>

        <div class="tree-scroll-area">
            <div class="tree-container" id="tree-root">
                <!-- JS ÏÉùÏÑ± -->
            </div>
        </div>

        <div class="bottom-bar">
            <button class="btn-action" onclick="startGame()">Start Loop</button>
        </div>
    </div>

    <!-- ÏãúÏûë ÌôîÎ©¥ -->
    <div id="start-overlay">
        <h1 class="text-5xl font-black mb-2 text-center">Void Harvester:<br>Planetary Devourer</h1>
        <p class="text-gray-500 mb-8 text-xl">10Ï¥à ÎèôÏïà ÏµúÎåÄÌïú ÎßéÏùÄ ÌñâÏÑ±ÏùÑ ÌååÍ¥¥ÌïòÍ≥† Ìù°ÏàòÌïòÏÑ∏Ïöî.</p>
        <button class="btn-action" onclick="firstStart()">Í≤åÏûÑ ÏãúÏûë</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const timerEl = document.getElementById('timer-display');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const upgradeMoneyEl = document.getElementById('upgrade-money');
        const treeRoot = document.getElementById('tree-root');
        const startOverlay = document.getElementById('start-overlay');
        const ingameUi = document.getElementById('ingame-ui');

        // --- Í≤åÏûÑ ÏÉÅÏàò Î∞è ÏÑ§Ï†ï ---
        const VALUE_MULTIPLIER = 0.3; 

        let GAME = {
            running: false,
            phase: 'start',
            money: 0,
            scoreInRound: 0,
            timeLeft: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0,
            lastTime: 0
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        const entities = [];
        const texts = [];
        const blackHole = { radius: 35 };

        // --- ÏóÖÍ∑∏Î†àÏù¥Îìú Ìä∏Î¶¨ Îç∞Ïù¥ÌÑ∞ ---
        const UPGRADES = [
            // Row 0: ÏãúÏûë
            {
                id: 'force', name: 'Ï§ëÎ†•Ïû• Í∞ïÎèÑ', desc: 'ÌååÌé∏ÏùÑ ÎãπÍ∏∞Îäî ÌûòÏùÑ Í∞ïÌôîÌï©ÎãàÎã§.', icon: 'üß≤',
                row: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, 
                // [Î∞∏Îü∞Ïä§ ÏàòÏ†ï] 0.4 -> 0.08 (20%), Ï¶ùÍ∞ÄÎüâÎèÑ ÎåÄÌè≠ ÌïòÌñ•
                val: 0.08, inc: 0.03, 
                req: null
            },
            {
                id: 'radius', name: 'ÏÇ¨Í±¥Ïùò ÏßÄÌèâÏÑ†', desc: 'ÏòÅÌñ• Î≤îÏúÑÍ∞Ä ÎÑìÏñ¥ÏßëÎãàÎã§.', icon: '‚≠ï',
                row: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, 
                val: 40, inc: 4, 
                req: null
            },

            // Row 1: Í∏∞Î≥∏ ÌôïÏû•
            {
                id: 'density', name: 'Ï¥àÍ∏∞ Î∞ÄÎèÑ', desc: 'ÏãúÏûë Ïãú ÏÉùÏÑ±ÎêòÎäî ÌñâÏÑ± Ïàò Ï¶ùÍ∞Ä.', icon: 'üåå',
                row: 1, level: 1, maxLevel: 20, baseCost: 200, mult: 1.5, val: 50, inc: 10,
                req: { id: 'force', level: 1 }
            },
            {
                id: 'respawn', name: 'ÌñâÏÑ± Î≤àÏãù', desc: 'ÌñâÏÑ± Ìù°Ïàò Ïãú Ïû¨ÏÉùÏÑ± ÌôïÎ•† Ï¶ùÍ∞Ä.', icon: 'üå±',
                row: 1, level: 1, maxLevel: 20, baseCost: 300, mult: 1.5, val: 20, inc: 5, // val = ÌôïÎ•†(%)
                req: { id: 'radius', level: 1 }
            },

            // Row 2: Ïú†Ìã∏Î¶¨Ìã∞ Î∞è ÏãúÍ∞Ñ
            {
                id: 'time', name: 'ÏãúÍ∞Ñ ÏôúÍ≥°', desc: 'Ï†úÌïú ÏãúÍ∞ÑÏù¥ ÎäòÏñ¥ÎÇ©ÎãàÎã§.', icon: '‚è≥',
                row: 2, level: 1, maxLevel: 30, baseCost: 400, mult: 1.6, val: 10, inc: 1.5,
                req: { id: 'density', level: 1 }
            },
            {
                id: 'value', name: 'Ï±ÑÍµ¥ Ìö®Ïú®', desc: 'ÌñâÏÑ±Ïùò Í∞ÄÏπòÍ∞Ä ÏÉÅÏäπÌï©ÎãàÎã§.', icon: 'üíé',
                row: 2, level: 1, maxLevel: 99, baseCost: 500, mult: 1.5, val: 1, inc: 0.5,
                req: { id: 'respawn', level: 1 }
            },

            // Row 3: Ïã¨Ìôî Î¨ºÎ¶¨
            {
                id: 'heavy', name: 'Í≥†Ï§ëÎ†•', desc: 'Î¨¥Í±∞Ïö¥ ÌñâÏÑ±ÏùÑ Îçî Ïûò ÎãπÍπÅÎãàÎã§.', icon: '‚öì',
                row: 3, level: 1, maxLevel: 20, baseCost: 600, mult: 1.5, val: 1.0, inc: 0.2,
                req: { id: 'time', level: 1 }
            },
            {
                id: 'auto', name: 'ÏûêÎèô Ïù∏Î†•', desc: 'ÌÅ¥Î¶≠ÌïòÏßÄ ÏïäÏïÑÎèÑ ÏïΩÌïòÍ≤å ÎãπÍπÅÎãàÎã§.', icon: 'üåÄ',
                row: 3, level: 1, maxLevel: 10, baseCost: 800, mult: 2.0, val: 0, inc: 0.1, 
                req: { id: 'value', level: 1 }
            },

            // Row 4: ÌäπÏàò ÌñâÏÑ± Î∞è Ìã∞Ïñ¥
            {
                id: 'tier_unlock', name: 'Ïã¨Ïö∞Ï£º ÌÉêÏÇ¨', desc: 'Îçî ÎÜíÏùÄ Îì±Í∏âÏùò ÌñâÏÑ±ÏùÑ Î∞úÍ≤¨Ìï©ÎãàÎã§.', icon: 'üî≠',
                row: 4, level: 1, maxLevel: 5, baseCost: 1500, mult: 3.0, val: 1, inc: 1, 
                req: { id: 'value', level: 1 }
            },
            {
                id: 'lightning_unlock', name: 'ÎáåÏ†Ñ ÌñâÏÑ±', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù ÌñâÏÑ±Ïù¥ Îì±Ïû•Ìï©ÎãàÎã§.', icon: '‚ö°',
                row: 4, level: 0, maxLevel: 1, baseCost: 2500, mult: 1, val: 0, inc: 1, 
                req: { id: 'heavy', level: 1 }
            },

            // Row 5: ÌäπÏàò Îä•Î†• Í∞ïÌôî
            {
                id: 'crit', name: 'ÌñâÏÑ± Î∂ïÍ¥¥', desc: 'ÏùºÏ†ï ÌôïÎ•†Î°ú ÌñâÏÑ± Í∞ÄÏπòÍ∞Ä 2Î∞∞Í∞Ä Îê©ÎãàÎã§.', icon: 'üí•',
                row: 5, level: 1, maxLevel: 20, baseCost: 3000, mult: 1.5, val: 0, inc: 2, 
                req: { id: 'tier_unlock', level: 1 }
            },
            {
                id: 'l_range', name: 'Ï†ÑÏù¥ Î≤îÏúÑ', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù Í∞êÏ†Ñ Î≤îÏúÑ Ï¶ùÍ∞Ä.', icon: 'üì°',
                row: 5, level: 1, maxLevel: 10, baseCost: 3500, mult: 1.6, val: 50, inc: 10,
                req: { id: 'lightning_unlock', level: 1 }
            },
            {
                id: 'l_count', name: 'Í≥ºÎ∂ÄÌïò', desc: 'Ï≤¥Ïù∏ ÎùºÏù¥Ìä∏Îãù Ï†ÑÏù¥ ÌöüÏàò Ï¶ùÍ∞Ä.', icon: 'üîó',
                row: 5, level: 1, maxLevel: 10, baseCost: 4000, mult: 1.8, val: 2, inc: 1,
                req: { id: 'lightning_unlock', level: 1 }
            },

            // Row 6: Í∂ÅÍ∑π Îä•Î†•
            {
                id: 'blackhole_size', name: 'Í±∞ÎåÄ Î∏îÎûôÌôÄ', desc: 'Î∏îÎûôÌôÄ ÌÅ¨Í∏∞Í∞Ä Ïª§Ï†∏ Ìù°Ïàò ÌåêÏ†ïÏù¥ Ï¢ãÏïÑÏßëÎãàÎã§.', icon: '‚ö´',
                row: 6, level: 1, maxLevel: 10, baseCost: 10000, mult: 2.5, val: 35, inc: 2,
                req: { id: 'tier_unlock', level: 3 }
            }
        ];

        // --- ÌñâÏÑ± Îç∞Ïù¥ÌÑ∞ ---
        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 5,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 15,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 40,  valMult: 20, weight: 5 },
            // ÌäπÏàò ÌñâÏÑ±
            { id: 'electric', color: '#facc15', minR: 15, maxR: 20, mass: 8, valMult: 10, weight: 0, isLightning: true } 
        ];

        // --- Ïú†Ìã∏ ---
        const rand = (min, max) => Math.random() * (max - min) + min;
        function getUpgrade(id) { return UPGRADES.find(u => u.id === id); }

        // --- ÌÅ¥ÎûòÏä§ ---
        class Shard {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (Math.min(GAME.width, GAME.height)/2 - 80) + 150;
                this.x = GAME.centerX + Math.cos(angle) * dist;
                this.y = GAME.centerY + Math.sin(angle) * dist;
                
                // Í≥µÏ†Ñ ÏÜçÎèÑ
                const speedBase = 0.003; 
                this.orbitSpeed = (speedBase * (150/dist)) * (Math.random() < 0.5 ? 1 : -1);

                // Ìã∞Ïñ¥ Í≤∞Ï†ï
                const tierLvl = getUpgrade('tier_unlock').val; // 1 ~ 5
                const lightningUnlocked = getUpgrade('lightning_unlock').level > 0;

                let available = [SHARD_TYPES[0]]; // Í∏∞Î≥∏
                if (tierLvl >= 2) available.push(SHARD_TYPES[1]);
                if (tierLvl >= 3) available.push(SHARD_TYPES[2]);
                if (tierLvl >= 4) available.push(SHARD_TYPES[3]);
                
                // ÎáåÏ†Ñ ÌñâÏÑ± Ï∂îÍ∞Ä (ÌôïÎ•†)
                let type = null;
                if (lightningUnlocked && Math.random() < 0.05) { 
                    type = SHARD_TYPES[4]; 
                } else {
                    const totalW = available.reduce((a,b)=>a+b.weight,0);
                    let r = Math.random() * totalW;
                    type = available[0];
                    for(let t of available){
                        if(r < t.weight) { type = t; break; }
                        r -= t.weight;
                    }
                }

                this.type = type;
                this.color = type.color;
                this.radius = rand(type.minR, type.maxR);
                this.mass = type.mass;
                this.sides = type.isLightning ? 3 : Math.floor(rand(4, 7)); 
                
                // Í∞ÄÏπò Í≥ÑÏÇ∞
                const valueBonus = getUpgrade('value').val; 
                this.value = Math.floor(this.radius * 2 * type.valMult * valueBonus * VALUE_MULTIPLIER);
                
                this.vx = 0; this.vy = 0;
                this.friction = 0.94;
            }

            update() {
                // 1. Í≥µÏ†Ñ
                const dx0 = this.x - GAME.centerX;
                const dy0 = this.y - GAME.centerY;
                const cos = Math.cos(this.orbitSpeed);
                const sin = Math.sin(this.orbitSpeed);
                this.x = GAME.centerX + (dx0 * cos - dy0 * sin);
                this.y = GAME.centerY + (dx0 * sin + dy0 * cos);

                // 2. Î¨ºÎ¶¨
                const dx = GAME.centerX - this.x;
                const dy = GAME.centerY - this.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);

                // Î∏îÎûôÌôÄ Í∏∞Î≥∏ Ï§ëÎ†•
                if (dist < 200) {
                    const g = 1000 / distSq;
                    this.vx += (dx/dist) * g / this.mass;
                    this.vy += (dy/dist) * g / this.mass;
                }

                // ÏûêÎèô Ïù∏Î†• (Auto Pull)
                const autoRate = getUpgrade('auto').val; // 0.0 ~ 
                if (autoRate > 0 && dist < 500) {
                     const force = getUpgrade('force').val * autoRate * 0.5;
                     const accel = force / this.mass;
                     this.vx += (dx/dist) * accel;
                     this.vy += (dy/dist) * accel;
                }

                // ÌîåÎ†àÏù¥Ïñ¥ Ïä§Ïúï
                if (INPUT.isDown) {
                    const radius = getUpgrade('radius').val;
                    const power = getUpgrade('force').val;
                    const heavyBonus = getUpgrade('heavy').val;

                    const mdx = INPUT.x - this.x;
                    const mdy = INPUT.y - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        const pushX = GAME.centerX - this.x;
                        const pushY = GAME.centerY - this.y;
                        const pushLen = Math.sqrt(pushX*pushX + pushY*pushY);
                        
                        let effectiveMass = this.mass;
                        if(effectiveMass > 8) effectiveMass /= heavyBonus; 

                        const accel = (2.0 * power) / effectiveMass;

                        this.vx += (pushX / pushLen) * accel;
                        this.vy += (pushY / pushLen) * accel;
                        this.vx += (mdx / mDist) * (0.2 / effectiveMass);
                        this.vy += (mdy / mDist) * (0.2 / effectiveMass);
                    }
                }

                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                this.rotation = (this.rotation || 0) + (this.vx + this.vy) * 0.1 + this.orbitSpeed * 3;

                // Ìù°Ïàò ÌåêÏ†ï
                const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
                if (dist < bhSize) return true;
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.beginPath();
                if(this.type.isLightning) {
                    ctx.shadowColor = '#facc15';
                    ctx.shadowBlur = 10;
                    ctx.moveTo(this.radius, 0);
                    ctx.lineTo(-this.radius/2, this.radius);
                    ctx.lineTo(-this.radius/2, -this.radius);
                } else {
                    ctx.moveTo(this.radius, 0);
                    for (let i = 1; i < this.sides; i++) {
                        const angle = (i * 2 * Math.PI) / this.sides;
                        ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                    }
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class PopText {
            constructor(x, y, val, isCrit) {
                this.x = x; this.y = y; 
                this.text = "+$" + val;
                this.life = 1.0; this.vy = -1;
                this.isCrit = isCrit;
            }
            update() { this.y += this.vy; this.life -= 0.03; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.isCrit ? '#ef4444' : '#10b981';
                ctx.font = this.isCrit ? '900 20px "Pretendard"' : '800 14px "Pretendard"';
                if(this.isCrit) this.text += "!";
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
                this.life = 1.0;
            }
            update() { this.life -= 0.1; }
            draw() {
                if(this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#facc15';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ÏãúÏä§ÌÖú Ìï®Ïàò ---
        const bolts = []; // Î≤àÍ∞ú Ìö®Í≥º Î∞∞Ïó¥

        function init() {
            window.addEventListener('resize', resize);
            resize();
            
            canvas.addEventListener('mousedown', (e) => { INPUT.isDown = true; move(e); });
            canvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', () => INPUT.isDown = false);
            
            canvas.addEventListener('touchstart', (e) => { INPUT.isDown = true; move(e.touches[0]); e.preventDefault(); }, {passive:false});
            canvas.addEventListener('touchmove', (e) => { move(e.touches[0]); e.preventDefault(); }, {passive:false});
            window.addEventListener('touchend', () => INPUT.isDown = false);

            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
        }
        function move(e) { INPUT.x = e.clientX; INPUT.y = e.clientY; }

        function firstStart() {
            startOverlay.style.display = 'none';
            startGame();
        }

        function startGame() {
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            
            GAME.running = true;
            GAME.phase = 'playing';
            GAME.scoreInRound = 0;
            scoreEl.innerText = "$0";
            
            const timeBonus = getUpgrade('time').val;
            GAME.timeLeft = timeBonus; 
            
            entities.length = 0;
            bolts.length = 0;
            
            // Ï¥àÍ∏∞ ÌååÌé∏ (spawn -> densityÎ°ú Ïù¥Î¶Ñ Î≥ÄÍ≤ΩÎê®)
            const initCount = getUpgrade('density').val;
            for(let i=0; i<initCount; i++) entities.push(new Shard());

            // ÏßÄÏÜçÏ†Å ÏÉùÏÑ± Î°úÏßÅ Ï†úÍ±∞Îê®. Ïù¥Ï†ú Î®πÏñ¥Ïïº ÏÉùÏÑ±Îê®.
        }

        function endGame() {
            GAME.phase = 'upgrade';
            GAME.running = false;
            ingameUi.style.display = 'none';
            upgradeScreen.style.display = 'flex';
            renderUpgrades();
        }

        function loop(timestamp) {
            const dt = (timestamp - GAME.lastTime) / 1000;
            GAME.lastTime = timestamp;

            if (GAME.phase === 'playing') {
                updateGame(dt);
            }
            drawGame();
            requestAnimationFrame(loop);
        }

        function triggerChainLightning(sourceShard) {
            const range = getUpgrade('l_range').val;
            const count = getUpgrade('l_count').val;
            
            let targets = [];
            for(let other of entities) {
                if(other === sourceShard) continue;
                const dx = other.x - sourceShard.x;
                const dy = other.y - sourceShard.y;
                if(dx*dx + dy*dy < range*range) {
                    targets.push({ entity: other, dist: dx*dx+dy*dy });
                }
            }
            
            targets.sort((a,b) => a.dist - b.dist);
            targets = targets.slice(0, count);

            targets.forEach(t => {
                const e = t.entity;
                bolts.push(new LightningBolt(sourceShard.x, sourceShard.y, e.x, e.y));
                
                const pushX = GAME.centerX - e.x;
                const pushY = GAME.centerY - e.y;
                const len = Math.sqrt(pushX*pushX + pushY*pushY);
                const force = 15; 
                e.vx += (pushX/len) * force;
                e.vy += (pushY/len) * force;
            });
        }

        function updateGame(dt) {
            GAME.timeLeft -= 0.016;
            if (GAME.timeLeft <= 0) {
                GAME.timeLeft = 0;
                endGame();
                return;
            }

            timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(GAME.timeLeft <= 3) timerEl.parentElement.classList.add('timer-warn');
            else timerEl.parentElement.classList.remove('timer-warn');

            for(let i=bolts.length-1; i>=0; i--) {
                bolts[i].update();
                if(bolts[i].life <= 0) bolts.splice(i, 1);
            }

            const critChance = getUpgrade('crit').val; 
            const respawnChance = getUpgrade('respawn').val; // Î¶¨Ï†† ÌôïÎ•†

            // ÌñâÏÑ± Í≥†Í∞à Î∞©ÏßÄ: ÎÑàÎ¨¥ Ï†ÅÏúºÎ©¥ Í∞ïÏ†ú Î¶¨ÌïÑ
            if (entities.length < 5) {
                entities.push(new Shard());
            }

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update()) {
                    // Ìù°ÏàòÎê®
                    if(e.type.isLightning) {
                        triggerChainLightning(e);
                    }

                    // ÌôïÎ•†Ï†Å Î¶¨Ï††
                    if (Math.random() * 100 < respawnChance) {
                        entities.push(new Shard());
                    }

                    let finalVal = e.value;
                    let isCrit = false;
                    if(Math.random() * 100 < critChance) {
                        finalVal *= 2;
                        isCrit = true;
                    }

                    GAME.scoreInRound += finalVal;
                    GAME.money += finalVal; 
                    
                    texts.push(new PopText(GAME.centerX, GAME.centerY - 30, finalVal, isCrit));
                    entities.splice(i, 1);
                }
            }
            
            scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();

            for (let i = texts.length - 1; i >= 0; i--) {
                texts[i].update();
                if (texts[i].life <= 0) texts.splice(i, 1);
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, GAME.width, GAME.height);

            const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, bhSize, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 5;
            ctx.stroke();

            if (INPUT.isDown && GAME.phase === 'playing') {
                const radius = getUpgrade('radius').val;
                ctx.beginPath();
                ctx.arc(INPUT.x, INPUT.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            entities.forEach(e => e.draw());
            bolts.forEach(b => b.draw());
            texts.forEach(t => t.draw());
        }

        // --- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏãúÏä§ÌÖú ---
        
        function getCost(u) {
            return Math.floor(u.baseCost * Math.pow(u.mult, u.level - 1));
        }

        function checkUnlock(u) {
            if (!u.req) return true;
            const parent = UPGRADES.find(p => p.id === u.req.id);
            return parent.level >= u.req.level; 
        }

        function renderUpgrades() {
            upgradeMoneyEl.innerText = '$' + GAME.money.toLocaleString();
            treeRoot.innerHTML = '';

            const rows = {};
            UPGRADES.forEach(u => {
                if(!rows[u.row]) rows[u.row] = [];
                rows[u.row].push(u);
            });

            const maxRow = Math.max(...Object.keys(rows).map(Number));

            for (let r = 0; r <= maxRow; r++) {
                if(!rows[r]) continue;

                const rowDiv = document.createElement('div');
                rowDiv.className = 'tree-row';
                
                if (r > 0) {
                     const connector = document.createElement('div');
                     connector.className = 'connector';
                     rowDiv.appendChild(connector);
                }

                rows[r].forEach(u => {
                    const isUnlocked = checkUnlock(u);
                    const cost = getCost(u);
                    const canBuy = GAME.money >= cost;
                    const isMax = u.level > u.maxLevel;
                    
                    const card = document.createElement('div');
                    
                    if (isUnlocked) {
                        card.className = `card ${canBuy && !isMax ? '' : 'disabled'}`;
                        if (!isMax) card.onclick = () => buyUpgrade(u.id);

                        let statText = '';
                        if(u.id === 'radius' || u.id === 'l_range') statText = `${Math.floor(u.val)}px (+${u.inc})`;
                        else if(u.id === 'time') statText = `${u.val.toFixed(1)}s (+${u.inc})`;
                        else if(u.id === 'crit' || u.id === 'respawn') statText = `${u.val}% (+${u.inc}%)`;
                        else if(u.id === 'lightning_unlock') statText = u.level > 0 ? "Unlocked" : "Locked";
                        else if(u.id.includes('unlock')) statText = `Tier ${u.val}`;
                        else if(u.id === 'density') statText = `${u.val}Í∞ú (+${u.inc})`;
                        else statText = `x${u.val.toFixed(2)} (+${u.inc})`;

                        card.innerHTML = `
                            <div class="card-lvl ${isMax ? 'max-lvl' : ''}">${isMax ? 'MAX' : 'Lv.' + u.level}</div>
                            <div class="card-header">
                                <div class="card-icon">${u.icon}</div>
                                <div class="card-name">${u.name}</div>
                            </div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-footer">
                                <div class="card-stat">ÌòÑÏû¨: ${statText}</div>
                                <div class="card-cost">${isMax ? '-' : '$' + cost.toLocaleString()}</div>
                            </div>
                        `;
                    } else {
                        const reqParent = UPGRADES.find(p => p.id === u.req.id);
                        card.className = 'card locked';
                        card.innerHTML = `
                            <div class="card-header" style="opacity:0.5">
                                <div class="card-icon">üîí</div>
                                <div class="card-name">???</div>
                            </div>
                            <div class="card-desc" style="display:flex; align-items:center; justify-content:center; height:100%; color:#94a3b8; font-weight:bold;">
                                ${reqParent.name}<br>ÌïÑÏöî
                            </div>
                        `;
                    }
                    rowDiv.appendChild(card);
                });

                treeRoot.appendChild(rowDiv);
            }
        }

        function buyUpgrade(id) {
            const u = UPGRADES.find(x => x.id === id);
            if (u.level > u.maxLevel) return;

            const cost = getCost(u);
            
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                
                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));

                renderUpgrades();
            }
        }

        init();
    </script>
</body>
</html>
