<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Harvester: Planetary Devourer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f2;
            color: #333;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* ì¸ê²Œì„ UI */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #333;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        
        .timer-warn { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #222;
        }

        /* ì—…ê·¸ë ˆì´ë“œ í™”ë©´ */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 240, 242, 0.98);
            z-index: 20;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 10px;
            flex-shrink: 0;
            width: 100%;
            max-width: 800px;
        }

        .screen-title { font-size: 2rem; font-weight: 900; color: #111; margin: 0; }
        .screen-subtitle { font-size: 0.9rem; color: #666; margin-bottom: 5px; }
        
        /* ìƒë‹¨ ìƒíƒœë°” */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 10px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            width: 90%;
            margin-bottom: 15px;
        }

        .money-badge {
            font-size: 1.2rem; font-weight: 800; color: #d97706;
        }
        .level-badge {
            font-size: 1rem; font-weight: 700; color: #4f46e5;
        }

        /* íŠ¸ë¦¬ ìŠ¤í¬ë¡¤ ì˜ì—­ */
        .tree-scroll-area {
            flex-grow: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px 100px 20px;
            scrollbar-width: thin;
        }

        /* í‹°ì–´ ì„¹ì…˜ */
        .tier-section {
            width: 100%;
            max-width: 1000px;
            margin-bottom: 40px;
            position: relative;
        }

        .tier-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tier-title {
            font-size: 1.2rem; font-weight: 800; color: #334155; margin-right: 15px;
        }
        
        .tier-lock-msg {
            font-size: 0.9rem; color: #ef4444; font-weight: 600; background: #fee2e2; padding: 2px 8px; border-radius: 4px;
        }
        .tier-unlock-msg {
            font-size: 0.9rem; color: #10b981; font-weight: 600; background: #d1fae5; padding: 2px 8px; border-radius: 4px;
        }

        .tier-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
        }
        
        /* ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 140px;
        }

        .card:hover:not(.disabled):not(.locked) {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px rgba(0,0,0,0.08);
            border-color: #3b82f6;
        }
        
        .card.disabled { opacity: 0.6; filter: grayscale(1); }
        .card.locked { 
            background: #f8fafc; 
            border: 1px dashed #cbd5e1; 
            cursor: not-allowed; 
            opacity: 0.8;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
        }
        
        .card-header { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; }
        .card-icon { font-size: 24px; }
        .card-name { font-weight: 800; font-size: 0.85rem; color: #1e293b; line-height: 1.2; }
        .card-desc { font-size: 0.7rem; color: #64748b; margin-bottom: 8px; flex-grow: 1; line-height: 1.3; }
        
        .card-footer { margin-top: auto; border-top: 1px solid #f1f5f9; padding-top: 8px; }
        .card-stat { font-size: 0.7rem; color: #7c3aed; font-weight: 600; margin-bottom: 2px; }
        .card-cost { font-weight: 700; color: #2563eb; font-size: 0.95rem; }
        
        .card-lvl { 
            position: absolute; top: 10px; right: 10px; 
            font-size: 0.7rem; font-weight: 800; color: #94a3b8; 
            background: #f1f5f9; padding: 2px 6px; border-radius: 4px;
        }
        .max-lvl { color: #10b981; background: #d1fae5; }

        /* í•˜ë‹¨ ê³ ì • ë²„íŠ¼ */
        .bottom-bar {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            padding: 20px;
            background: linear-gradient(to top, white, rgba(255,255,255,0));
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        
        .btn-action {
            pointer-events: auto;
            background: #111;
            color: white;
            padding: 15px 80px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 800;
            border: none;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .btn-action:hover { transform: scale(1.05); background: #222; }

        /* ì‹œì‘ ì˜¤ë²„ë ˆì´ */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- ì¸ê²Œì„ UI -->
    <div id="ingame-ui">
        <div class="timer-box">
            <span id="timer-display">10.0</span>s
        </div>
        <div class="score-val" id="score-display">$0</div>
    </div>

    <!-- ì—…ê·¸ë ˆì´ë“œ í™”ë©´ -->
    <div id="upgrade-screen">
        <div class="upgrade-header">
            <h1 class="screen-title">RESEARCH LAB</h1>
            <p class="screen-subtitle">ê³¨ê³ ë£¨ íˆ¬ìí•˜ì—¬ ìƒìœ„ ê¸°ìˆ ì„ í•´ê¸ˆí•˜ì„¸ìš”.</p>
        </div>

        <div class="status-bar">
            <div class="level-badge" id="total-level-display">ì´ ì—°êµ¬ ë ˆë²¨: 0</div>
            <div class="money-badge" id="upgrade-money">$0</div>
        </div>

        <div class="tree-scroll-area" id="tree-container">
            <!-- JS ìƒì„± -->
        </div>

        <div class="bottom-bar">
            <button class="btn-action" onclick="startGame()">Start Loop</button>
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="start-overlay">
        <h1 class="text-5xl font-black mb-2 text-center">Void Harvester:<br>Planetary Devourer</h1>
        <p class="text-gray-500 mb-8 text-xl">10ì´ˆ ë™ì•ˆ í–‰ì„±ì„ í¡ìˆ˜í•˜ì—¬ ì„±ì¥í•˜ì„¸ìš”.</p>
        <button class="btn-action" onclick="firstStart()">ê²Œì„ ì‹œì‘</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const timerEl = document.getElementById('timer-display');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const upgradeMoneyEl = document.getElementById('upgrade-money');
        const totalLevelEl = document.getElementById('total-level-display');
        const treeContainer = document.getElementById('tree-container');
        const startOverlay = document.getElementById('start-overlay');
        const ingameUi = document.getElementById('ingame-ui');

        // --- ê²Œì„ ìƒìˆ˜ ë° ì„¤ì • ---
        const VALUE_MULTIPLIER = 0.3; 

        let GAME = {
            running: false,
            phase: 'start',
            money: 0,
            scoreInRound: 0,
            timeLeft: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0,
            lastTime: 0
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        const entities = [];
        const texts = [];
        const blackHole = { radius: 35 };

        // --- ì—…ê·¸ë ˆì´ë“œ ì‹œìŠ¤í…œ (í‹°ì–´ ê¸°ë°˜) ---
        // tier: 0ë¶€í„° ì‹œì‘
        // ê° í‹°ì–´ í•´ê¸ˆ ì¡°ê±´: minTotalLevels (ì´ ì—°êµ¬ ë ˆë²¨ í•©ê³„)
        const TIER_UNLOCKS = [0, 4, 12, 24, 40, 60, 85]; 

        const UPGRADES = [
            // [Tier 0] - ê¸°ë³¸ ë¬¼ë¦¬ (ì‹œì‘)
            {
                id: 'force', name: 'ì¤‘ë ¥ì¥ ê°•ë„', desc: 'íŒŒí¸ì„ ë‹¹ê¸°ëŠ” í˜.', icon: 'ğŸ§²',
                tier: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, val: 0.08, inc: 0.03
            },
            {
                id: 'radius', name: 'ì‚¬ê±´ì˜ ì§€í‰ì„ ', desc: 'ì˜í–¥ ë²”ìœ„ í™•ì¥.', icon: 'â­•',
                tier: 0, level: 1, maxLevel: 99, baseCost: 50, mult: 1.4, val: 40, inc: 4
            },
            {
                id: 'friction', name: 'ê³µê°„ ì ì„±', desc: 'íŒŒí¸ì´ ëœ ë¯¸ë„ëŸ¬ì§.', icon: 'ğŸ•¸ï¸',
                tier: 0, level: 1, maxLevel: 10, baseCost: 100, mult: 1.5, val: 0.94, inc: -0.01 // ë‚®ì„ìˆ˜ë¡ ë§ˆì°° í¼
            },

            // [Tier 1] - í™•ì¥ (í•„ìš” ì´ë ™: 4)
            {
                id: 'density', name: 'ì´ˆê¸° ë°€ë„', desc: 'ì‹œì‘ í–‰ì„± ìˆ˜ ì¦ê°€.', icon: 'ğŸŒŒ',
                tier: 1, level: 1, maxLevel: 20, baseCost: 200, mult: 1.5, val: 50, inc: 10
            },
            {
                id: 'respawn', name: 'í–‰ì„± ë²ˆì‹', desc: 'í¡ìˆ˜ ì‹œ ì¬ìƒì„± í™•ë¥ .', icon: 'ğŸŒ±',
                tier: 1, level: 1, maxLevel: 20, baseCost: 300, mult: 1.5, val: 20, inc: 5 // %
            },
             {
                id: 'time', name: 'ì‹œê°„ ì™œê³¡', desc: 'ì œí•œ ì‹œê°„ ì¦ê°€.', icon: 'â³',
                tier: 1, level: 1, maxLevel: 50, baseCost: 400, mult: 1.5, val: 10, inc: 1.5
            },

            // [Tier 2] - ê²½ì œ ë° ì‹¬í™” (í•„ìš” ì´ë ™: 12)
            {
                id: 'value', name: 'ì±„êµ´ íš¨ìœ¨', desc: 'í–‰ì„± ê°€ì¹˜ ìƒìŠ¹.', icon: 'ğŸ’',
                tier: 2, level: 1, maxLevel: 99, baseCost: 600, mult: 1.5, val: 1, inc: 0.5
            },
            {
                id: 'heavy', name: 'ê³ ì¤‘ë ¥', desc: 'ë¬´ê±°ìš´ í–‰ì„± ë¬´ê²Œ ë¬´ì‹œ.', icon: 'âš“',
                tier: 2, level: 1, maxLevel: 20, baseCost: 700, mult: 1.5, val: 1.0, inc: 0.2
            },
            {
                id: 'auto', name: 'ìë™ ì¸ë ¥', desc: 'í´ë¦­ ì—†ì´ë„ ë‹¹ê¹€.', icon: 'ğŸŒ€',
                tier: 2, level: 1, maxLevel: 10, baseCost: 1000, mult: 2.0, val: 0, inc: 0.1
            },
            {
                id: 'attract_range', name: 'ìì—° ì¤‘ë ¥', desc: 'ë¸”ë™í™€ ê¸°ë³¸ í¡ì… ë²”ìœ„.', icon: 'ğŸŒ‘',
                tier: 2, level: 1, maxLevel: 20, baseCost: 800, mult: 1.5, val: 180, inc: 20
            },

            // [Tier 3] - íŠ¹ìˆ˜ í–‰ì„± ë° í‹°ì–´ (í•„ìš” ì´ë ™: 24)
            {
                id: 'tier_unlock', name: 'ì‹¬ìš°ì£¼ íƒì‚¬', desc: 'ë” ë†’ì€ ë“±ê¸‰ í–‰ì„± ë°œê²¬.', icon: 'ğŸ”­',
                tier: 3, level: 1, maxLevel: 5, baseCost: 2000, mult: 3.0, val: 1, inc: 1
            },
            {
                id: 'lightning_unlock', name: 'ë‡Œì „ í–‰ì„±', desc: 'ì²´ì¸ ë¼ì´íŠ¸ë‹ í–‰ì„± ë“±ì¥.', icon: 'âš¡',
                tier: 3, level: 0, maxLevel: 1, baseCost: 3000, mult: 1, val: 0, inc: 1
            },
            {
                id: 'crit', name: 'í–‰ì„± ë¶•ê´´', desc: 'ê°€ì¹˜ 2ë°° í¬ë¦¬í‹°ì»¬ í™•ë¥ .', icon: 'ğŸ’¥',
                tier: 3, level: 1, maxLevel: 20, baseCost: 2500, mult: 1.5, val: 0, inc: 2
            },

            // [Tier 4] - ë²ˆê°œ ê°•í™” (í•„ìš” ì´ë ™: 40)
            {
                id: 'l_range', name: 'ì „ì´ ë²”ìœ„', desc: 'ì²´ì¸ ë¼ì´íŠ¸ë‹ ê±°ë¦¬.', icon: 'ğŸ“¡',
                tier: 4, level: 1, maxLevel: 10, baseCost: 4000, mult: 1.6, val: 60, inc: 15
            },
            {
                id: 'l_count', name: 'ê³¼ë¶€í•˜', desc: 'ì²´ì¸ ë¼ì´íŠ¸ë‹ íƒ€ê²Ÿ ìˆ˜.', icon: 'ğŸ”—',
                tier: 4, level: 1, maxLevel: 10, baseCost: 4500, mult: 1.8, val: 3, inc: 1
            },
             {
                id: 'luck', name: 'í–‰ìš´ì˜ ë³„', desc: 'í–‰ì„± ë¦¬ì   ì‹œ í¬ê·€ í™•ë¥  ì¦ê°€.', icon: 'ğŸ€',
                tier: 4, level: 1, maxLevel: 10, baseCost: 5000, mult: 1.6, val: 1.0, inc: 0.2 // ë°°ìœ¨
            },

            // [Tier 5] - ê¶ê·¹ (í•„ìš” ì´ë ™: 60)
            {
                id: 'blackhole_size', name: 'ê±°ëŒ€ ë¸”ë™í™€', desc: 'ë¸”ë™í™€ í¬ê¸° ì¦ê°€.', icon: 'âš«',
                tier: 5, level: 1, maxLevel: 10, baseCost: 10000, mult: 2.5, val: 35, inc: 3
            },
            {
                id: 'interest', name: 'ì•”í‘ ë¬¼ì§ˆ ë°˜ì‘', desc: 'ë¼ìš´ë“œ ì¢…ë£Œ ì‹œ ë³´ìœ ê¸ˆ ì´ì.', icon: 'ğŸ“ˆ',
                tier: 5, level: 0, maxLevel: 10, baseCost: 15000, mult: 2.0, val: 0, inc: 1 // %
            },
            {
                id: 'singularity', name: 'íŠ¹ì´ì ', desc: 'í™”ë©´ ì „ì²´ ì•½í•œ ì§€ì† ë°ë¯¸ì§€.', icon: 'âš›ï¸',
                tier: 5, level: 0, maxLevel: 5, baseCost: 20000, mult: 3.0, val: 0, inc: 1
            }
        ];

        // --- í–‰ì„± ë°ì´í„° ---
        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 5,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 15,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 40,  valMult: 20, weight: 5 },
            { id: 'electric', color: '#facc15', minR: 15, maxR: 20, mass: 8, valMult: 10, weight: 0, isLightning: true } 
        ];

        // --- ìœ í‹¸ ---
        const rand = (min, max) => Math.random() * (max - min) + min;
        function getUpgrade(id) { return UPGRADES.find(u => u.id === id); }
        function getTotalLevels() { return UPGRADES.reduce((sum, u) => sum + u.level - (u.level>0?0:0), 0); } // 0ë ˆë²¨ ì‹œì‘ì¸ ì• ë“¤ì€ ì œì™¸? ì•„ë‹ˆ ê·¸ëƒ¥ level ë”í•¨. ë‹¨ ì´ˆê¸° 1ë ™ì¸ ì• ë“¤ì€ 1ë¶€í„°. ì´ˆê¸° 0ì¸ì• ë“¤ì€ 0ë¶€í„°.

        // --- í´ë˜ìŠ¤ ---
        class Shard {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (Math.min(GAME.width, GAME.height)/2 - 80) + 150;
                this.x = GAME.centerX + Math.cos(angle) * dist;
                this.y = GAME.centerY + Math.sin(angle) * dist;
                
                const speedBase = 0.003; 
                this.orbitSpeed = (speedBase * (150/dist)) * (Math.random() < 0.5 ? 1 : -1);

                const tierLvl = getUpgrade('tier_unlock').val; 
                const lightningUnlocked = getUpgrade('lightning_unlock').level > 0;
                const luckBonus = getUpgrade('luck') ? getUpgrade('luck').val : 1;

                let available = [SHARD_TYPES[0]]; 
                if (tierLvl >= 2) available.push(SHARD_TYPES[1]);
                if (tierLvl >= 3) available.push(SHARD_TYPES[2]);
                if (tierLvl >= 4) available.push(SHARD_TYPES[3]);
                
                let type = null;
                if (lightningUnlocked && Math.random() < 0.05 * luckBonus) { 
                    type = SHARD_TYPES[4]; 
                } else {
                    // í¬ê·€ë„ ë³´ì • (Luck)
                    // Luckì´ ë†’ìœ¼ë©´ ë¬´ê±°ìš´(ë¹„ì‹¼) í–‰ì„± í™•ë¥  ì¦ê°€ ë¡œì§ì€ ë³µì¡í•˜ë‹ˆ ë‹¨ìˆœ ê°€ì¤‘ì¹˜ ì‚¬ìš©
                    const totalW = available.reduce((a,b)=>a+b.weight,0);
                    let r = Math.random() * totalW;
                    type = available[0];
                    for(let t of available){
                        if(r < t.weight) { type = t; break; }
                        r -= t.weight;
                    }
                }

                this.type = type;
                this.color = type.color;
                this.radius = rand(type.minR, type.maxR);
                this.mass = type.mass;
                this.sides = type.isLightning ? 3 : Math.floor(rand(4, 7)); 
                
                const valueBonus = getUpgrade('value').val; 
                this.value = Math.floor(this.radius * 2 * type.valMult * valueBonus * VALUE_MULTIPLIER);
                
                this.vx = 0; this.vy = 0;
                this.friction = getUpgrade('friction').val;
            }

            update() {
                // 1. ê³µì „
                const dx0 = this.x - GAME.centerX;
                const dy0 = this.y - GAME.centerY;
                const cos = Math.cos(this.orbitSpeed);
                const sin = Math.sin(this.orbitSpeed);
                this.x = GAME.centerX + (dx0 * cos - dy0 * sin);
                this.y = GAME.centerY + (dx0 * sin + dy0 * cos);

                // 2. ë¬¼ë¦¬
                const dx = GAME.centerX - this.x;
                const dy = GAME.centerY - this.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);

                // ë¸”ë™í™€ ìì—° ì¤‘ë ¥
                const naturalRange = getUpgrade('attract_range').val;
                if (dist < naturalRange) {
                    const g = 1000 / distSq;
                    this.vx += (dx/dist) * g / this.mass;
                    this.vy += (dy/dist) * g / this.mass;
                }

                // ìë™ ì¸ë ¥
                const autoRate = getUpgrade('auto').val; 
                if (autoRate > 0 && dist < 600) {
                     const force = getUpgrade('force').val * autoRate * 0.5;
                     const accel = force / this.mass;
                     this.vx += (dx/dist) * accel;
                     this.vy += (dy/dist) * accel;
                }

                // í”Œë ˆì´ì–´ ìŠ¤ìœ•
                if (INPUT.isDown) {
                    const radius = getUpgrade('radius').val;
                    const power = getUpgrade('force').val;
                    const heavyBonus = getUpgrade('heavy').val;

                    const mdx = INPUT.x - this.x;
                    const mdy = INPUT.y - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        const pushX = GAME.centerX - this.x;
                        const pushY = GAME.centerY - this.y;
                        const pushLen = Math.sqrt(pushX*pushX + pushY*pushY);
                        
                        let effectiveMass = this.mass;
                        if(effectiveMass > 8) effectiveMass /= heavyBonus; 

                        const accel = (2.0 * power) / effectiveMass;

                        this.vx += (pushX / pushLen) * accel;
                        this.vy += (pushY / pushLen) * accel;
                        this.vx += (mdx / mDist) * (0.2 / effectiveMass);
                        this.vy += (mdy / mDist) * (0.2 / effectiveMass);
                    }
                }

                // íŠ¹ì´ì  (ì „ì²´ ì•½í•œ ì¸ë ¥)
                const singularityLvl = getUpgrade('singularity') ? getUpgrade('singularity').level : 0;
                if(singularityLvl > 0) {
                    const sForce = singularityLvl * 0.05 / this.mass;
                    this.vx += (dx/dist) * sForce;
                    this.vy += (dy/dist) * sForce;
                }

                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                this.rotation = (this.rotation || 0) + (this.vx + this.vy) * 0.1 + this.orbitSpeed * 3;

                const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
                if (dist < bhSize) return true;
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.beginPath();
                if(this.type.isLightning) {
                    ctx.shadowColor = '#facc15';
                    ctx.shadowBlur = 10;
                    ctx.moveTo(this.radius, 0);
                    ctx.lineTo(-this.radius/2, this.radius);
                    ctx.lineTo(-this.radius/2, -this.radius);
                } else {
                    ctx.moveTo(this.radius, 0);
                    for (let i = 1; i < this.sides; i++) {
                        const angle = (i * 2 * Math.PI) / this.sides;
                        ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                    }
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class PopText {
            constructor(x, y, val, isCrit) {
                this.x = x; this.y = y; 
                this.text = "+$" + val;
                this.life = 1.0; this.vy = -1;
                this.isCrit = isCrit;
            }
            update() { this.y += this.vy; this.life -= 0.03; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.isCrit ? '#ef4444' : '#10b981';
                ctx.font = this.isCrit ? '900 20px "Pretendard"' : '800 14px "Pretendard"';
                if(this.isCrit) this.text += "!";
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        class LightningBolt {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
                this.life = 1.0;
            }
            update() { this.life -= 0.1; }
            draw() {
                if(this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2);
                ctx.strokeStyle = '#facc15';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#facc15';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ì‹œìŠ¤í…œ í•¨ìˆ˜ ---
        const bolts = [];

        function init() {
            window.addEventListener('resize', resize);
            resize();
            
            canvas.addEventListener('mousedown', (e) => { INPUT.isDown = true; move(e); });
            canvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', () => INPUT.isDown = false);
            
            canvas.addEventListener('touchstart', (e) => { INPUT.isDown = true; move(e.touches[0]); e.preventDefault(); }, {passive:false});
            canvas.addEventListener('touchmove', (e) => { move(e.touches[0]); e.preventDefault(); }, {passive:false});
            window.addEventListener('touchend', () => INPUT.isDown = false);

            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
        }
        function move(e) { INPUT.x = e.clientX; INPUT.y = e.clientY; }

        function firstStart() {
            startOverlay.style.display = 'none';
            startGame();
        }

        function startGame() {
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            
            GAME.running = true;
            GAME.phase = 'playing';
            GAME.scoreInRound = 0;
            scoreEl.innerText = "$0";
            
            const timeBonus = getUpgrade('time').val;
            GAME.timeLeft = timeBonus; 
            
            entities.length = 0;
            bolts.length = 0;
            
            // ì´ˆê¸° íŒŒí¸
            const initCount = getUpgrade('density').val;
            for(let i=0; i<initCount; i++) entities.push(new Shard());
        }

        function endGame() {
            GAME.phase = 'upgrade';
            GAME.running = false;
            
            // ì´ì ì§€ê¸‰
            const interestRate = getUpgrade('interest') ? getUpgrade('interest').val : 0; // %
            if(interestRate > 0) {
                const interest = Math.floor(GAME.money * (interestRate / 100));
                if(interest > 0) {
                    GAME.money += interest;
                    // ì´ì íšë“ ì•Œë¦¼ì€ UIì— í‘œì‹œí•˜ë©´ ì¢‹ìŒ (ì—¬ê¸°ì„  ìƒëµ)
                }
            }

            ingameUi.style.display = 'none';
            upgradeScreen.style.display = 'flex';
            renderUpgrades();
        }

        function loop(timestamp) {
            const dt = (timestamp - GAME.lastTime) / 1000;
            GAME.lastTime = timestamp;

            if (GAME.phase === 'playing') {
                updateGame(dt);
            }
            drawGame();
            requestAnimationFrame(loop);
        }

        function triggerChainLightning(sourceShard) {
            const range = getUpgrade('l_range').val;
            const count = getUpgrade('l_count').val;
            
            let targets = [];
            for(let other of entities) {
                if(other === sourceShard) continue;
                const dx = other.x - sourceShard.x;
                const dy = other.y - sourceShard.y;
                if(dx*dx + dy*dy < range*range) {
                    targets.push({ entity: other, dist: dx*dx+dy*dy });
                }
            }
            
            targets.sort((a,b) => a.dist - b.dist);
            targets = targets.slice(0, count);

            targets.forEach(t => {
                const e = t.entity;
                bolts.push(new LightningBolt(sourceShard.x, sourceShard.y, e.x, e.y));
                
                const pushX = GAME.centerX - e.x;
                const pushY = GAME.centerY - e.y;
                const len = Math.sqrt(pushX*pushX + pushY*pushY);
                const force = 15; 
                e.vx += (pushX/len) * force;
                e.vy += (pushY/len) * force;
            });
        }

        function updateGame(dt) {
            GAME.timeLeft -= 0.016;
            if (GAME.timeLeft <= 0) {
                GAME.timeLeft = 0;
                endGame();
                return;
            }

            timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(GAME.timeLeft <= 3) timerEl.parentElement.classList.add('timer-warn');
            else timerEl.parentElement.classList.remove('timer-warn');

            for(let i=bolts.length-1; i>=0; i--) {
                bolts[i].update();
                if(bolts[i].life <= 0) bolts.splice(i, 1);
            }

            const critChance = getUpgrade('crit').val; 
            const respawnChance = getUpgrade('respawn').val;

            if (entities.length < 5) entities.push(new Shard());

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update()) {
                    if(e.type.isLightning) triggerChainLightning(e);

                    if (Math.random() * 100 < respawnChance) entities.push(new Shard());

                    let finalVal = e.value;
                    let isCrit = false;
                    if(Math.random() * 100 < critChance) {
                        finalVal *= 2;
                        isCrit = true;
                    }

                    GAME.scoreInRound += finalVal;
                    GAME.money += finalVal; 
                    
                    texts.push(new PopText(GAME.centerX, GAME.centerY - 30, finalVal, isCrit));
                    entities.splice(i, 1);
                }
            }
            
            scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();

            for (let i = texts.length - 1; i >= 0; i--) {
                texts[i].update();
                if (texts[i].life <= 0) texts.splice(i, 1);
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, GAME.width, GAME.height);

            const bhSize = blackHole.radius + (getUpgrade('blackhole_size').val - 35);
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, bhSize, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 5;
            ctx.stroke();

            if (INPUT.isDown && GAME.phase === 'playing') {
                const radius = getUpgrade('radius').val;
                ctx.beginPath();
                ctx.arc(INPUT.x, INPUT.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            entities.forEach(e => e.draw());
            bolts.forEach(b => b.draw());
            texts.forEach(t => t.draw());
        }

        // --- ì—…ê·¸ë ˆì´ë“œ UI ë¡œì§ ---
        function getCost(u) {
            return Math.floor(u.baseCost * Math.pow(u.mult, u.level - 1));
        }

        function renderUpgrades() {
            upgradeMoneyEl.innerText = '$' + GAME.money.toLocaleString();
            
            const totalLevels = UPGRADES.reduce((sum, u) => sum + (u.level > 0 ? u.level : 0), 0);
            totalLevelEl.innerText = `ì—°êµ¬ ë ˆë²¨: ${totalLevels}`;

            treeContainer.innerHTML = '';

            // Group by Tier
            const tiers = {};
            UPGRADES.forEach(u => {
                if(!tiers[u.tier]) tiers[u.tier] = [];
                tiers[u.tier].push(u);
            });

            const maxTier = Math.max(...Object.keys(tiers).map(Number));

            for (let t = 0; t <= maxTier; t++) {
                if (!tiers[t]) continue;

                // í‹°ì–´ í•´ê¸ˆ ì¡°ê±´ í™•ì¸
                const reqLevels = TIER_UNLOCKS[t] || 0;
                const isTierUnlocked = totalLevels >= reqLevels;

                const tierSection = document.createElement('div');
                tierSection.className = 'tier-section';
                
                // Header
                const header = document.createElement('div');
                header.className = 'tier-header';
                
                const title = document.createElement('div');
                title.className = 'tier-title';
                title.innerText = `TIER ${t}`;
                header.appendChild(title);

                if(!isTierUnlocked) {
                    const msg = document.createElement('div');
                    msg.className = 'tier-lock-msg';
                    msg.innerText = `ğŸ”’ ì ê¹€ (í•„ìš” ì—°êµ¬ ë ˆë²¨: ${reqLevels})`;
                    header.appendChild(msg);
                } else if (reqLevels > 0) {
                     const msg = document.createElement('div');
                     msg.className = 'tier-unlock-msg';
                     msg.innerText = `âœ“ í•´ê¸ˆë¨`;
                     header.appendChild(msg);
                }

                tierSection.appendChild(header);

                // Grid
                const grid = document.createElement('div');
                grid.className = 'tier-grid';

                tiers[t].forEach(u => {
                    const cost = getCost(u);
                    const canBuy = GAME.money >= cost;
                    const isMax = u.level >= u.maxLevel;
                    
                    const card = document.createElement('div');
                    
                    if (isTierUnlocked) {
                        card.className = `card ${canBuy && !isMax ? '' : 'disabled'}`;
                        if (!isMax && canBuy) card.onclick = () => buyUpgrade(u.id);
                        
                        // í¬ë§·íŒ…
                        let statText = '';
                        if(u.id.includes('unlock')) statText = u.level > 0 ? "ë³´ìœ ì¤‘" : "ë¯¸ë³´ìœ ";
                        else if(u.id === 'radius' || u.id === 'l_range') statText = `${Math.floor(u.val)}px`;
                        else if(u.id === 'time') statText = `${u.val.toFixed(1)}s`;
                        else if(u.id === 'crit' || u.id === 'respawn' || u.id === 'interest') statText = `${u.val}%`;
                        else if(u.id === 'friction') statText = `${(1-u.val).toFixed(2)} ë§ˆì°°`;
                        else statText = `x${u.val.toFixed(2)}`;

                        // ì¦ê°€ëŸ‰ í‘œì‹œ
                        let incText = '';
                        if(isMax) incText = '(MAX)';
                        else if(u.inc > 0) incText = `(+${u.inc})`;
                        else incText = `(${u.inc})`;

                        card.innerHTML = `
                            <div class="card-lvl ${isMax ? 'max-lvl' : ''}">${isMax ? 'MAX' : 'Lv.' + u.level}</div>
                            <div class="card-header">
                                <div class="card-icon">${u.icon}</div>
                                <div class="card-name">${u.name}</div>
                            </div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-footer">
                                <div class="card-stat">${statText} <span class="text-gray-400 text-xs">${incText}</span></div>
                                <div class="card-cost">${isMax ? '-' : '$' + cost.toLocaleString()}</div>
                            </div>
                        `;
                    } else {
                        // ì ê¹€ ìƒíƒœ ì¹´ë“œ
                        card.className = 'card locked';
                        card.innerHTML = `
                            <div class="card-icon">ğŸ”’</div>
                            <div style="font-size:0.8rem; font-weight:bold; margin-top:5px;">ì—°êµ¬ í•„ìš”</div>
                        `;
                    }
                    grid.appendChild(card);
                });

                tierSection.appendChild(grid);
                treeContainer.appendChild(tierSection);
            }
        }

        function buyUpgrade(id) {
            const u = UPGRADES.find(x => x.id === id);
            if (u.level >= u.maxLevel) return;

            const cost = getCost(u);
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                
                // ì†Œìˆ˜ì  ë³´ì •
                if(!Number.isInteger(u.val)) u.val = parseFloat(u.val.toFixed(2));

                renderUpgrades();
            }
        }

        init();
    </script>
</body>
</html>
