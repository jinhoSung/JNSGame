<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Harvester - Loop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f2;
            color: #333;
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* ì¸ê²Œì„ UI (í”Œë ˆì´ ì¤‘ì—ë§Œ ë³´ì„) */
        #ingame-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .timer-box {
            display: flex;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: #333;
            text-shadow: 0 0 10px rgba(255,255,255,0.8);
        }
        
        .timer-warn { color: #ef4444; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .score-val {
            font-size: 2.5rem;
            font-weight: 900;
            color: #222;
        }

        /* ì—…ê·¸ë ˆì´ë“œ í™”ë©´ (ê²Œì„ ëë‚˜ë©´ ë³´ì„) */
        #upgrade-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(245, 245, 247, 0.95);
            backdrop-filter: blur(10px);
            z-index: 20;
            display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
            flex-direction: column;
            align-items: center;
            padding: 40px 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .screen-title { font-size: 2.5rem; font-weight: 900; margin-bottom: 10px; color: #111; }
        .screen-subtitle { font-size: 1.2rem; color: #666; margin-bottom: 30px; }
        .money-badge {
            background: #111; color: white; padding: 10px 30px; border-radius: 50px;
            font-size: 1.5rem; font-weight: bold; margin-bottom: 40px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        /* íŠ¸ë¦¬ êµ¬ì¡° ë ˆì´ì•„ì›ƒ */
        .tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 40px;
            margin-bottom: 50px;
        }
        .tree-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        /* í™”ì‚´í‘œ */
        .arrow-down {
            font-size: 24px; color: #ccc; margin: -20px 0;
        }

        .card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 20px;
            width: 220px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card:hover:not(.disabled):not(.locked) {
            transform: translateY(-5px);
            box-shadow: 0 15px 25px rgba(0,0,0,0.1);
            border-color: #3b82f6;
        }
        
        .card.disabled { opacity: 0.6; filter: grayscale(1); }
        .card.locked { background: #f3f4f6; cursor: not-allowed; border-style: dashed; }
        
        .card-icon { font-size: 24px; margin-bottom: 5px; }
        .card-name { font-weight: 800; color: #1f2937; }
        .card-desc { font-size: 0.8rem; color: #6b7280; height: 32px; overflow: hidden;}
        .card-stat { font-size: 0.8rem; color: #8b5cf6; font-weight: 600; }
        .card-cost { font-weight: 700; color: #2563eb; font-size: 1.1rem; margin-top: auto; }
        .card-lvl { position: absolute; top: 15px; right: 15px; font-size: 0.8rem; font-weight: bold; color: #9ca3af; }
        
        .locked-msg {
            position: absolute; inset: 0; background: rgba(243,244,246,0.9);
            display: flex; align-items: center; justify-content: center;
            font-size: 0.9rem; color: #666; font-weight: bold;
            border-radius: 16px; text-align: center; padding: 10px;
        }

        .btn-action {
            background: #2563eb;
            color: white;
            padding: 15px 60px;
            border-radius: 50px;
            font-size: 1.3rem;
            font-weight: 800;
            border: none;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
        }
        .btn-action:hover { transform: scale(1.05); background: #1d4ed8; }

        /* ì‹œì‘ ì˜¤ë²„ë ˆì´ */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- ì¸ê²Œì„ UI -->
    <div id="ingame-ui">
        <div class="timer-box">
            <span id="timer-display">10.0</span>s
        </div>
        <div class="score-val" id="score-display">$0</div>
    </div>

    <!-- ì—…ê·¸ë ˆì´ë“œ í™”ë©´ (ë¼ìš´ë“œ ì¢…ë£Œ í›„) -->
    <div id="upgrade-screen">
        <h1 class="screen-title">RESEARCH LAB</h1>
        <p class="screen-subtitle">ë¸”ë™í™€ì˜ ëŠ¥ë ¥ì„ ê°•í™”í•˜ì„¸ìš”</p>
        <div class="money-badge" id="upgrade-money">$0</div>

        <div class="tree-container" id="tree-root">
            <!-- JSë¡œ ìƒì„±ë¨ -->
        </div>

        <button class="btn-action" onclick="startGame()">ë‹¤ì‹œ ì‹œì‘ (Start Loop)</button>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="start-overlay">
        <h1 style="font-size: 4rem; font-weight: 900; margin-bottom: 10px;">Void Loop</h1>
        <p class="text-gray-500 mb-8 text-xl">10ì´ˆ ë™ì•ˆ ìµœëŒ€í•œ ë§ì€ ë¬¼ì§ˆì„ í¡ìˆ˜í•˜ì„¸ìš”.</p>
        <button class="btn-action" onclick="firstStart()">ê²Œì„ ì‹œì‘</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const timerEl = document.getElementById('timer-display');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const upgradeMoneyEl = document.getElementById('upgrade-money');
        const treeRoot = document.getElementById('tree-root');
        const startOverlay = document.getElementById('start-overlay');
        const ingameUi = document.getElementById('ingame-ui');

        // ê²Œì„ ìƒíƒœ
        let GAME = {
            running: false,
            phase: 'start', // start, playing, upgrade
            money: 0,
            scoreInRound: 0,
            timeLeft: 10.0,
            width: 0, height: 0, centerX: 0, centerY: 0,
            lastTime: 0
        };

        const INPUT = { x: 0, y: 0, isDown: false };
        const entities = [];
        const texts = [];
        const blackHole = { radius: 35 };

        // --- ì—…ê·¸ë ˆì´ë“œ ë°ì´í„° ---
        const UPGRADES = [
            // Row 0: ê¸°ë³¸ ëŠ¥ë ¥ (ë„ˆí”„ëœ ì´ˆê¸°ê°’)
            {
                id: 'force', name: 'ì¤‘ë ¥ì¥ ê°•ë„', desc: 'ë¬´ê±°ìš´ íŒŒí¸ì„ ë‹¹ê¸°ëŠ” í˜.', icon: 'ğŸ§²',
                row: 0, level: 1, baseCost: 100, mult: 1.5, val: 0.6, inc: 0.15, // val 0.8 -> 0.6
                req: null
            },
            {
                id: 'radius', name: 'ì‚¬ê±´ì˜ ì§€í‰ì„ ', desc: 'ì˜í–¥ ë²”ìœ„ê°€ ë„“ì–´ì§‘ë‹ˆë‹¤.', icon: 'â­•',
                row: 0, level: 1, baseCost: 100, mult: 1.5, val: 45, inc: 8, // val 60 -> 45
                req: null
            },
            
            // Row 1: 1ì°¨ ì‹¬í™”
            {
                id: 'spawn', name: 'ë¬¼ì§ˆ ë°€ë„', desc: 'ë” ë§ì€ íŒŒí¸ì´ ìƒì„±ë©ë‹ˆë‹¤.', icon: 'âœ¨',
                row: 1, level: 1, baseCost: 500, mult: 1.6, val: 1, inc: 0.5,
                req: { id: 'force', level: 3 }
            },
            {
                id: 'value', name: 'ì…ì ê°€ì¹˜', desc: 'ë” ë¹„ì‹¼ ì…ìê°€ ì¶œí˜„í•©ë‹ˆë‹¤.', icon: 'ğŸ’',
                row: 1, level: 1, baseCost: 600, mult: 1.8, val: 1, inc: 1, // valMult ì—­í•  ê²¸í•¨, ë ˆë²¨ì´ ì˜¤ë¥´ë©´ í‹°ì–´ í•´ê¸ˆ
                req: { id: 'radius', level: 3 }
            },

            // Row 2: 2ì°¨ ì‹¬í™”
            {
                id: 'time', name: 'ì‹œê°„ ì™œê³¡', desc: 'ì œí•œ ì‹œê°„ì´ ëŠ˜ì–´ë‚©ë‹ˆë‹¤.', icon: 'â³',
                row: 2, level: 1, baseCost: 1500, mult: 2.0, val: 10, inc: 2,
                req: { id: 'spawn', level: 3 } 
            },
             {
                id: 'heavy', name: 'ì¤‘ë ¥ ë¶•ê´´', desc: 'ë¬´ê±°ìš´ íŒŒí¸ ë¬´ê²Œ ë³´ì •.', icon: 'ğŸŒŒ',
                row: 2, level: 1, baseCost: 2000, mult: 1.5, val: 1.0, inc: 0.3,
                req: { id: 'value', level: 3 } 
            }
        ];

        // íŒŒí¸ ì„¤ì • (í‹°ì–´ë³„)
        const SHARD_TYPES = [
            { id: 'blue',   color: '#3b82f6', minR: 6,  maxR: 10, mass: 1,   valMult: 1,  weight: 60 },
            { id: 'green',  color: '#10b981', minR: 12, maxR: 16, mass: 4,   valMult: 3,  weight: 30 }, 
            { id: 'orange', color: '#f59e0b', minR: 18, maxR: 24, mass: 12,  valMult: 8,  weight: 15 }, 
            { id: 'purple', color: '#8b5cf6', minR: 28, maxR: 35, mass: 30,  valMult: 20, weight: 5 }
        ];

        // --- í´ë˜ìŠ¤ ---
        class Shard {
            constructor() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (Math.min(GAME.width, GAME.height)/2 - 80) + 150;
                this.x = GAME.centerX + Math.cos(angle) * dist;
                this.y = GAME.centerY + Math.sin(angle) * dist;
                
                // --- ê³µì „ ì†ë„ ì„¤ì • ---
                // ê±°ë¦¬ê°€ ë©€ìˆ˜ë¡ ëŠë¦¬ê²Œ, ëœë¤ ë°©í–¥
                const speedBase = 0.003; 
                this.orbitSpeed = (speedBase * (150/dist)) * (Math.random() < 0.5 ? 1 : -1);

                // --- í‹°ì–´ í•´ê¸ˆ ë¡œì§ ---
                const valueUpgrade = UPGRADES.find(u => u.id === 'value');
                const lvl = valueUpgrade.level;
                
                // ë ˆë²¨ì— ë”°ë¼ ë“±ì¥ ê°€ëŠ¥í•œ íŒŒí¸ ì œí•œ
                let availableTypes = [];
                availableTypes.push(SHARD_TYPES[0]); // Blue (Always)
                
                if (lvl >= 2) availableTypes.push(SHARD_TYPES[1]); // Green at Lv.2
                if (lvl >= 3) availableTypes.push(SHARD_TYPES[2]); // Orange at Lv.3
                if (lvl >= 5) availableTypes.push(SHARD_TYPES[3]); // Purple at Lv.5

                // ê°€ì¤‘ì¹˜ ëœë¤ ì„ íƒ
                const totalWeight = availableTypes.reduce((sum, t) => sum + t.weight, 0);
                let r = Math.random() * totalWeight;
                let type = availableTypes[0];
                
                for(let t of availableTypes) {
                    if(r < t.weight) { type = t; break; }
                    r -= t.weight;
                }

                this.color = type.color;
                this.radius = Math.random() * (type.maxR - type.minR) + type.minR;
                this.mass = type.mass;
                this.sides = Math.floor(Math.random() * 3) + 3;
                
                // ê°€ì¹˜ ê³„ì‚° (ì—…ê·¸ë ˆì´ë“œ ìˆ˜ì¹˜ ë°˜ì˜)
                // 'value' ì—…ê·¸ë ˆì´ë“œëŠ” í•´ê¸ˆ ìš©ë„ ì™¸ì— ë°°ìœ¨ë¡œë„ ì‘ìš©
                const valMultiplier = 1 + (lvl * 0.2); 
                this.value = Math.floor(this.radius * 2 * type.valMult * valMultiplier);
                
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.93; 
            }

            update() {
                // 1. ê³µì „ (í”Œë ˆì´ì–´ ê°œì… ì—†ì„ ë•Œ ìœ„ì¹˜ íšŒì „)
                // í˜„ì¬ ìœ„ì¹˜ë¥¼ ì„¼í„° ê¸°ì¤€ìœ¼ë¡œ íšŒì „ì‹œí‚´
                const dx0 = this.x - GAME.centerX;
                const dy0 = this.y - GAME.centerY;
                const cos = Math.cos(this.orbitSpeed);
                const sin = Math.sin(this.orbitSpeed);
                
                // íšŒì „ í–‰ë ¬ ì ìš©
                const newX = GAME.centerX + (dx0 * cos - dy0 * sin);
                const newY = GAME.centerY + (dx0 * sin + dy0 * cos);
                
                this.x = newX;
                this.y = newY;

                // 2. ë¬¼ë¦¬ ì—°ì‚° (ì¤‘ë ¥ & ìŠ¤ìœ•)
                const dx = GAME.centerX - this.x;
                const dy = GAME.centerY - this.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);

                // ë¸”ë™í™€ ê¸°ë³¸ ì¸ë ¥
                if (dist < 180) {
                    const g = 1200 / distSq;
                    this.vx += (dx/dist) * g / this.mass;
                    this.vy += (dy/dist) * g / this.mass;
                }

                // í”Œë ˆì´ì–´ ìŠ¤ìœ•
                if (INPUT.isDown) {
                    const radius = UPGRADES.find(u => u.id === 'radius').val;
                    const power = UPGRADES.find(u => u.id === 'force').val;
                    const heavyBonus = UPGRADES.find(u => u.id === 'heavy').val; 

                    const mdx = INPUT.x - this.x;
                    const mdy = INPUT.y - this.y;
                    const mDist = Math.sqrt(mdx*mdx + mdy*mdy);

                    if (mDist < radius) {
                        const pushX = GAME.centerX - this.x;
                        const pushY = GAME.centerY - this.y;
                        const pushLen = Math.sqrt(pushX*pushX + pushY*pushY);
                        
                        let effectiveMass = this.mass;
                        if(effectiveMass > 5) effectiveMass /= heavyBonus; 

                        const accel = (3.0 * power) / effectiveMass; // ê¸°ë³¸ í˜ ìƒìˆ˜ ì¡°ì •

                        this.vx += (pushX / pushLen) * accel;
                        this.vy += (pushY / pushLen) * accel;
                        
                        this.vx += (mdx / mDist) * (0.3 / effectiveMass);
                        this.vy += (mdy / mDist) * (0.3 / effectiveMass);
                    }
                }

                // ë¬¼ë¦¬ ì ìš©
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                this.rotation = (this.rotation || 0) + (this.vx + this.vy) * 0.1 + this.orbitSpeed * 5;

                if (dist < blackHole.radius) return true;
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.beginPath();
                ctx.moveTo(this.radius, 0);
                for (let i = 1; i < this.sides; i++) {
                    const angle = (i * 2 * Math.PI) / this.sides;
                    ctx.lineTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                }
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.restore();
            }
        }

        class PopText {
            constructor(x, y, val) {
                this.x = x; this.y = y; this.text = "+$" + val;
                this.life = 1.0; this.vy = -1;
            }
            update() { this.y += this.vy; this.life -= 0.04; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = '#10b981';
                ctx.font = '800 16px "Pretendard"';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ì‹œìŠ¤í…œ ---
        function init() {
            window.addEventListener('resize', resize);
            resize();
            
            canvas.addEventListener('mousedown', (e) => { INPUT.isDown = true; move(e); });
            canvas.addEventListener('mousemove', move);
            window.addEventListener('mouseup', () => INPUT.isDown = false);
            
            canvas.addEventListener('touchstart', (e) => { INPUT.isDown = true; move(e.touches[0]); e.preventDefault(); }, {passive:false});
            canvas.addEventListener('touchmove', (e) => { move(e.touches[0]); e.preventDefault(); }, {passive:false});
            window.addEventListener('touchend', () => INPUT.isDown = false);

            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            GAME.width = canvas.width;
            GAME.height = canvas.height;
            GAME.centerX = canvas.width / 2;
            GAME.centerY = canvas.height / 2;
        }
        function move(e) { INPUT.x = e.clientX; INPUT.y = e.clientY; }

        function firstStart() {
            startOverlay.style.display = 'none';
            startGame();
        }

        function startGame() {
            upgradeScreen.style.display = 'none';
            ingameUi.style.display = 'flex';
            
            GAME.running = true;
            GAME.phase = 'playing';
            GAME.scoreInRound = 0;
            scoreEl.innerText = "$0";
            
            const timeBonus = UPGRADES.find(u => u.id === 'time').val;
            GAME.timeLeft = timeBonus; 
            
            entities.length = 0;
            // ì´ˆê¸° íŒŒí¸
            for(let i=0; i<60; i++) entities.push(new Shard());

            if(window.spawnInterval) clearInterval(window.spawnInterval);
            window.spawnInterval = setInterval(() => {
                if(GAME.phase !== 'playing') return;
                const density = UPGRADES.find(u => u.id === 'spawn').val;
                if(entities.length < 250) {
                    for(let i=0; i<density; i++) entities.push(new Shard());
                }
            }, 400);
        }

        function endGame() {
            GAME.phase = 'upgrade';
            GAME.running = false;
            ingameUi.style.display = 'none';
            upgradeScreen.style.display = 'flex';
            renderUpgrades();
        }

        function loop(timestamp) {
            const dt = (timestamp - GAME.lastTime) / 1000;
            GAME.lastTime = timestamp;

            if (GAME.phase === 'playing') {
                updateGame(dt);
            }
            drawGame();

            requestAnimationFrame(loop);
        }

        function updateGame(dt) {
            GAME.timeLeft -= 0.016;
            if (GAME.timeLeft <= 0) {
                GAME.timeLeft = 0;
                endGame();
                return;
            }

            timerEl.innerText = GAME.timeLeft.toFixed(1);
            if(GAME.timeLeft <= 3) timerEl.parentElement.classList.add('timer-warn');
            else timerEl.parentElement.classList.remove('timer-warn');

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.update()) {
                    GAME.scoreInRound += e.value;
                    GAME.money += e.value; 
                    scoreEl.innerText = '$' + GAME.scoreInRound.toLocaleString();
                    texts.push(new PopText(GAME.centerX, GAME.centerY - 30, e.value));
                    entities.splice(i, 1);
                }
            }
            
            for (let i = texts.length - 1; i >= 0; i--) {
                texts[i].update();
                if (texts[i].life <= 0) texts.splice(i, 1);
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, GAME.width, GAME.height);

            // ë¸”ë™í™€
            ctx.beginPath();
            ctx.arc(GAME.centerX, GAME.centerY, blackHole.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 5;
            ctx.stroke();

            // í”Œë ˆì´ì–´ ì˜ì—­
            if (INPUT.isDown && GAME.phase === 'playing') {
                const radius = UPGRADES.find(u => u.id === 'radius').val;
                ctx.beginPath();
                ctx.arc(INPUT.x, INPUT.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
                ctx.setLineDash([4, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            entities.forEach(e => e.draw());
            texts.forEach(t => t.draw());
        }

        // --- ì—…ê·¸ë ˆì´ë“œ ì‹œìŠ¤í…œ ---
        
        function getCost(u) {
            return Math.floor(u.baseCost * Math.pow(u.mult, u.level - 1));
        }

        function checkUnlock(u) {
            if (!u.req) return true;
            const parent = UPGRADES.find(p => p.id === u.req.id);
            return parent.level >= u.req.level;
        }

        function renderUpgrades() {
            upgradeMoneyEl.innerText = '$' + GAME.money.toLocaleString();
            treeRoot.innerHTML = '';

            const rows = {};
            UPGRADES.forEach(u => {
                if(!rows[u.row]) rows[u.row] = [];
                rows[u.row].push(u);
            });

            const maxRow = Math.max(...Object.keys(rows).map(Number));

            for (let r = 0; r <= maxRow; r++) {
                if(!rows[r]) continue;

                const rowDiv = document.createElement('div');
                rowDiv.className = 'tree-row';
                
                rows[r].forEach(u => {
                    const isUnlocked = checkUnlock(u);
                    const cost = getCost(u);
                    const canBuy = GAME.money >= cost;
                    
                    const card = document.createElement('div');
                    card.className = `card ${isUnlocked ? (canBuy ? '' : 'disabled') : 'locked'}`;
                    
                    if(isUnlocked) {
                        card.onclick = () => buyUpgrade(u.id);
                        
                        let statText = '';
                        if(u.id === 'radius') statText = `${u.val}px (+${u.inc})`;
                        else if(u.id === 'time') statText = `${u.val}s (+${u.inc})`;
                        else statText = `x${u.val.toFixed(2)} (+${u.inc})`; // toFixed ìˆ˜ì •

                        card.innerHTML = `
                            <div class="card-lvl">Lv.${u.level}</div>
                            <div class="card-icon">${u.icon}</div>
                            <div class="card-name">${u.name}</div>
                            <div class="card-desc">${u.desc}</div>
                            <div class="card-stat">í˜„ì¬: ${statText}</div>
                            <div class="card-cost">$${cost.toLocaleString()}</div>
                        `;
                    } else {
                        const reqParent = UPGRADES.find(p => p.id === u.req.id);
                        card.innerHTML = `
                            <div class="card-icon" style="filter:grayscale(1); opacity:0.3">${u.icon}</div>
                            <div class="card-name" style="opacity:0.5">???</div>
                            <div class="locked-msg">ğŸ”’<br>${reqParent.name}<br>Lv.${u.req.level} í•„ìš”</div>
                        `;
                    }

                    rowDiv.appendChild(card);
                });

                treeRoot.appendChild(rowDiv);
                
                if (r < maxRow) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow-down';
                    arrow.innerText = 'â¬‡';
                    treeRoot.appendChild(arrow);
                }
            }
        }

        function buyUpgrade(id) {
            const u = UPGRADES.find(x => x.id === id);
            const cost = getCost(u);
            
            if (GAME.money >= cost) {
                GAME.money -= cost;
                u.level++;
                u.val += u.inc;
                
                if(u.id === 'force' || u.id === 'heavy' || u.id === 'spawn' || u.id === 'value') {
                    u.val = parseFloat(u.val.toFixed(2));
                }

                renderUpgrades();
            }
        }

        init();
    </script>
</body>
</html>
