<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>distancegame - Firebase 기록</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    :root { --panel: rgba(0,0,0,0.72); --panel2: rgba(0,0,0,0.86); }
    html, body { height: 100%; }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #222;
      font-family: Arial, sans-serif;
      color: #fff;
      user-select: none;
      overflow: hidden;
    }
    #gameWrapper { position: relative; }

    #gameCanvas {
      background: #eee;
      border: 4px solid #000;
      touch-action: none;
      display: block;
    }

    /* ===== 상단 HUD (고정) ===== */
    #hudBar {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      z-index: 12;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      pointer-events: none;
    }
    #uiTop {
      color: #fff;
      font-size: 14px;
      line-height: 1.35;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      white-space: nowrap;
      pointer-events: none;
    }
    #hudButtons {
      display: flex;
      gap: 8px;
      pointer-events: auto;
    }
    .hudBtn {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(0,0,0,0.40);
      color: #fff;
      padding: 8px 10px;
      font-size: 13px;
      cursor: pointer;
      backdrop-filter: blur(2px);
    }
    .hudBtn:active { transform: translateY(1px); }

    /* ===== 조이스틱 ===== */
    #joystickArea {
      position: absolute;
      left: 10px;
      bottom: 10px;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.10);
      display: none;
      touch-action: none;
      z-index: 5;
    }
    #joystickBase, #joystickStick {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    #joystickBase {
      width: 120px;
      height: 120px;
      left: 20px;
      top: 20px;
      background: rgba(0, 0, 0, 0.30);
    }
    #joystickStick {
      width: 60px;
      height: 60px;
      left: 50px;
      top: 50px;
      background: rgba(255, 255, 255, 0.82);
    }

    /* ===== 오버레이(메뉴/기록) ===== */
    #overlay {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 50;
      align-items: center;
      justify-content: center;
      background: var(--panel);
    }
    #overlay.show { display: flex; }

    #panel {
      width: min(680px, 94%);
      max-height: min(560px, 92%);
      background: var(--panel2);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 10px;
      padding: 14px 14px 12px;
      overflow: auto;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
    #panel h2 { margin: 6px 0 10px; font-size: 18px; font-weight: 700; }
    #panel p  { margin: 6px 0 10px; font-size: 13px; opacity: 0.92; line-height: 1.35; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
    button, input, select {
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: #fff;
      padding: 10px 12px;
      font-size: 14px;
    }
    button { cursor: pointer; }
    button.primary { background: rgba(0,170,0,0.55); border-color: rgba(0,170,0,0.6); }
    button.danger  { background: rgba(200,0,0,0.45); border-color: rgba(200,0,0,0.55); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 560px) { .grid { grid-template-columns: 1fr; } }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { border-bottom: 1px solid rgba(255,255,255,0.12); padding: 8px 6px; text-align: left; }
    th { opacity: 0.9; }
    .muted { opacity: 0.75; font-size: 12px; }
    .err { color: #ff8f8f; }

    .lvlGrid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px; margin-top: 10px; }
    @media (max-width: 520px) { .lvlGrid { grid-template-columns: repeat(5, 1fr); } }
    .lvlBtn {
      padding: 10px 0;
      text-align: center;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      font-size: 13px;
    }
    .lvlBtn.unlocked { background: rgba(0,140,255,0.24); }
    .lvlBtn.cleared  { background: rgba(0,200,0,0.35); }
    .lvlBtn.locked   { background: rgba(255,255,255,0.05); opacity: 0.55; }

    /* ===== 모바일 세로 가이드 ===== */
    #rotateHint {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 60;
      background: rgba(0,0,0,0.78);
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }
    #rotateHint.show { display: flex; }
    #rotateHint .box {
      width: min(520px, 92%);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 14px;
    }
    #rotateHint h3 { margin: 6px 0 10px; font-size: 18px; }
    #rotateHint p { margin: 6px 0; font-size: 13px; opacity: 0.92; line-height: 1.35; }
  </style>
</head>
<body>

<div id="hudBar">
  <div id="uiTop">
    <div>
      유저: <span id="userDisplay">-</span> ·
      레벨: <span id="levelDisplay">1</span> / <span id="totalDisplay">50</span> ·
      시간: <span id="timeDisplay">0.000</span>s ·
      죽음: <span id="deathDisplay">0</span>
    </div>
    <div>PC: 방향키, P=일시정지, M=메뉴 · 모바일: 조이스틱/탭</div>
  </div>

  <div id="hudButtons">
    <button id="btnHudMenu" class="hudBtn">메뉴</button>
    <button id="btnHudFullscreen" class="hudBtn">전체화면</button>
  </div>
</div>

<div id="gameWrapper">
  <canvas id="gameCanvas" width="640" height="480"></canvas>

  <div id="joystickArea">
    <div id="joystickBase"></div>
    <div id="joystickStick"></div>
  </div>

  <div id="rotateHint">
    <div class="box">
      <h3>가로 화면을 권장합니다</h3>
      <p>화면이 더 넓은 방향(가로)으로 플레이하면 조작이 편합니다.</p>
      <p class="muted">전체화면 버튼을 누르면 가로 고정을 시도합니다.</p>
      <div class="row" style="justify-content:center; margin-top: 12px;">
        <button id="btnTryFullscreen" class="primary">전체화면 + 가로고정 시도</button>
        <button id="btnCloseRotate">계속(세로)</button>
      </div>
    </div>
  </div>

  <div id="overlay">
    <div id="panel">
      <h2 id="panelTitle">메뉴</h2>
      <p id="panelDesc"></p>
      <div class="row" id="panelButtons"></div>
      <div id="panelBody"></div>
      <div class="muted" id="panelHint"></div>
    </div>
  </div>
</div>

<script type="module">
/* =========================================================
   Firebase 설정(사용자 제공)
   ========================================================= */
const FIREBASE_CONFIG = {
  apiKey: "AIzaSyBUGN1Zlpk-Avfu-5s4G6qQrSfMaq_QXhw",
  authDomain: "distancegame-f4bba.firebaseapp.com",
  projectId: "distancegame-f4bba",
  storageBucket: "distancegame-f4bba.firebasestorage.app",
  messagingSenderId: "180425278674",
  appId: "1:180425278674:web:af07ce51992cb622fc990b"
};

const GAME_NAME = "distancegame";
const COL_USERS = `users_${GAME_NAME}`;
const COL_LEVEL_BEST = `levelBest_${GAME_NAME}`;
const COL_LEVEL_RUNS = `levelRuns_${GAME_NAME}`;

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, setDoc, getDoc, updateDoc, collection, query, where,
  getDocs, orderBy, limit, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"; // [web:153][web:159]

const app = initializeApp(FIREBASE_CONFIG);
const db = getFirestore(app);

/* =========================================================
   DOM/유틸
   ========================================================= */
const $ = (id) => document.getElementById(id);
const wrapper = $("gameWrapper");
const canvas = $("gameCanvas");
const ctx = canvas.getContext("2d");

const overlay = $("overlay");
const panelTitle = $("panelTitle");
const panelDesc = $("panelDesc");
const panelButtons = $("panelButtons");
const panelBody = $("panelBody");
const panelHint = $("panelHint");

const rotateHint = $("rotateHint");
const btnTryFullscreen = $("btnTryFullscreen");
const btnCloseRotate = $("btnCloseRotate");

const btnHudMenu = $("btnHudMenu");
const btnHudFullscreen = $("btnHudFullscreen");

const userDisplay = $("userDisplay");
const levelDisplay = $("levelDisplay");
const totalDisplay = $("totalDisplay");
const timeDisplay = $("timeDisplay");
const deathDisplay = $("deathDisplay");

const joystickArea = $("joystickArea");
const joystickStick = $("joystickStick");

const DESIGN_WIDTH = 640;
const DESIGN_HEIGHT = 480;
const TOTAL_LEVELS = 50;
totalDisplay.textContent = String(TOTAL_LEVELS);

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobi/i.test(navigator.userAgent);

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
}
function sanitizeId(s) {
  return String(s || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, "_")
    .replace(/[^a-z0-9_\-]/g, "")
    .slice(0, 40);
}

/* =========================================================
   Fullscreen 토글 + 가로락 시도
   ========================================================= */
async function enterFullscreen() {
  const elem = wrapper;
  if (elem.requestFullscreen) await elem.requestFullscreen(); // [web:183]
}
async function exitFullscreen() {
  if (document.exitFullscreen) await document.exitFullscreen();
}
async function tryLockLandscape() {
  try {
    if (screen.orientation && screen.orientation.lock) {
      await screen.orientation.lock("landscape"); // [web:169]
      return true;
    }
  } catch (_) {}
  return false;
}
async function toggleFullscreen() {
  try {
    if (document.fullscreenElement) {
      await exitFullscreen();
    } else {
      await enterFullscreen();
      await tryLockLandscape();
    }
  } catch (_) {}
}
function isPortrait() { return window.innerHeight > window.innerWidth; }
function updateRotateHint() {
  if (!isMobile) { rotateHint.classList.remove("show"); return; }
  if (isPortrait()) rotateHint.classList.add("show");
  else rotateHint.classList.remove("show");
}
function updateFullscreenButtonText() {
  btnHudFullscreen.textContent = document.fullscreenElement ? "전체화면 해제" : "전체화면";
}

document.addEventListener("fullscreenchange", () => { // [web:210]
  updateFullscreenButtonText();
  resizeCanvas();
  updateRotateHint();
}); // [web:210]

btnHudFullscreen.addEventListener("click", async () => {
  await toggleFullscreen();
  updateFullscreenButtonText();
});
btnHudMenu.addEventListener("click", () => {
  if (mode === "playing" || mode === "paused" || mode === "menu" || mode === "records" || mode === "levelSelect") {
    openMainMenu();
  }
});

btnTryFullscreen.addEventListener("click", async () => {
  await enterFullscreen();
  await tryLockLandscape();
  updateFullscreenButtonText();
  resizeCanvas();
  updateRotateHint();
});
btnCloseRotate.addEventListener("click", () => rotateHint.classList.remove("show"));

/* =========================================================
   반응형 캔버스(렌더 스케일만 변경, 게임 월드 좌표는 고정)
   ========================================================= */
function resizeCanvas() {
  const maxWidth = window.innerWidth;
  const maxHeight = window.innerHeight;
  const scale = Math.min(maxWidth / DESIGN_WIDTH, maxHeight / DESIGN_HEIGHT);
  const displayWidth = DESIGN_WIDTH * scale;
  const displayHeight = DESIGN_HEIGHT * scale;

  canvas.style.width = displayWidth + "px";
  canvas.style.height = displayHeight + "px";
  wrapper.style.width = displayWidth + "px";
  wrapper.style.height = displayHeight + "px";
}
window.addEventListener("resize", () => { resizeCanvas(); updateRotateHint(); });
resizeCanvas();
updateRotateHint();
updateFullscreenButtonText();

/* =========================================================
   사용자(닉네임 방식 유지)
   ========================================================= */
const LOCAL_USER_KEY = `username_${GAME_NAME}`;
let username = localStorage.getItem(LOCAL_USER_KEY) || "";
let userId = sanitizeId(username);

/* =========================================================
   로컬 진행 저장
   ========================================================= */
const SAVE_KEY = `save_${GAME_NAME}`;
let unlockedUpTo = 0;
let cleared = new Set();
let deaths = 0;

function saveLocalProgress() {
  const data = { unlockedUpTo, cleared: Array.from(cleared), deaths };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
}
function loadLocalProgress() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (typeof data.unlockedUpTo === "number") unlockedUpTo = Math.max(0, Math.min(TOTAL_LEVELS - 1, data.unlockedUpTo));
    if (Array.isArray(data.cleared)) cleared = new Set(data.cleared.filter(n => Number.isInteger(n)));
    if (typeof data.deaths === "number") deaths = Math.max(0, data.deaths | 0);
  } catch {}
}
loadLocalProgress();

/* =========================================================
   타이머
   ========================================================= */
let levelStartMs = 0;
let elapsedMs = 0;
function resetTimer() { levelStartMs = performance.now(); elapsedMs = 0; }
function updateTimer() {
  if (mode === "playing") elapsedMs = performance.now() - levelStartMs;
  timeDisplay.textContent = (elapsedMs / 1000).toFixed(3);
}

/* =========================================================
   Firestore 저장/조회
   ========================================================= */
async function ensureUserDoc() {
  if (!userId) return;
  const ref = doc(db, COL_USERS, userId);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, {
      userId, username,
      createdAt: serverTimestamp(),
      maxLevel: 1,
      updatedAt: serverTimestamp()
    });
  }
}
async function updateUserMaxLevel(levelNumber1Based) {
  if (!userId) return;
  const ref = doc(db, COL_USERS, userId);
  await setDoc(ref, { userId, username, maxLevel: levelNumber1Based, updatedAt: serverTimestamp() }, { merge: true }); // [web:153]
}
function bestDocId(levelNumber1Based) { return `${userId}_${levelNumber1Based}`; }
async function upsertBestTime(levelNumber1Based, timeMs) {
  if (!userId) return false;
  const ref = doc(db, COL_LEVEL_BEST, bestDocId(levelNumber1Based));
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, { userId, username, level: levelNumber1Based, bestTimeMs: timeMs, updatedAt: serverTimestamp(), createdAt: serverTimestamp() });
    return true;
  } else {
    const prev = snap.data()?.bestTimeMs;
    if (typeof prev !== "number" || timeMs < prev) {
      await updateDoc(ref, { bestTimeMs: timeMs, username, updatedAt: serverTimestamp() });
      return true;
    }
  }
  return false;
}
async function logRun(levelNumber1Based, timeMs) {
  if (!userId) return;
  const runId = `${userId}_${Date.now()}_${levelNumber1Based}`;
  const ref = doc(db, COL_LEVEL_RUNS, runId);
  await setDoc(ref, { userId, username, level: levelNumber1Based, timeMs, createdAt: serverTimestamp() });
}
async function fetchMySummary() {
  const userRef = doc(db, COL_USERS, userId);
  const userSnap = await getDoc(userRef);

  const qy = query(
    collection(db, COL_LEVEL_BEST),
    where("userId", "==", userId),
    orderBy("level", "asc")
  ); // [web:159]
  const bestSnap = await getDocs(qy);
  const bestRows = [];
  bestSnap.forEach(d => bestRows.push(d.data()));
  return { user: userSnap.exists() ? userSnap.data() : null, bestRows };
}
async function fetchTopForLevel(levelNumber1Based) {
  const qy = query(
    collection(db, COL_LEVEL_BEST),
    where("level", "==", levelNumber1Based),
    orderBy("bestTimeMs", "asc"),
    limit(10)
  ); // [web:159]
  const snap = await getDocs(qy);
  const rows = [];
  snap.forEach(d => rows.push(d.data()));
  return rows;
}

/* =========================================================
   게임 상태/입력
   ========================================================= */
const keys = {};
let mode = "boot"; // boot | menu | playing | paused | message | levelSelect | records
let messageText = "";
let messageNextAction = null;

window.addEventListener("keydown", (e) => {
  if (e.key === "m" || e.key === "M") { if (mode !== "message") openMainMenu(); return; }
  if (e.key === "p" || e.key === "P") { if (mode === "playing") openPauseMenu(); else if (mode === "paused") resumeFromPause(); return; }
  if (mode === "message") { if (e.key === " " || e.key === "Enter") closeMessageAndContinue(); return; }
  if (mode !== "playing") return;
  keys[e.key] = true;
});
window.addEventListener("keyup", (e) => { keys[e.key] = false; });

canvas.addEventListener("click", () => { if (mode === "message") closeMessageAndContinue(); });
canvas.addEventListener("touchstart", (e) => {
  if (mode === "message") { e.preventDefault(); closeMessageAndContinue(); }
}, { passive: false });

function updateTopUI() {
  userDisplay.textContent = username ? username : "-";
  levelDisplay.textContent = String(currentLevelIndex + 1);
  deathDisplay.textContent = String(deaths);
}

/* =========================================================
   조이스틱(민감도 완화)
   ========================================================= */
let joystickActive = false;
let joystickCenter = { x: 80, y: 80 };
let joystickVector = { x: 0, y: 0 };  // 방향(-1~1)
let joystickPower = 0;               // 세기(0~1)

// 감도 파라미터
const JOY_MAX_DISTANCE = 40;
const JOY_DEAD_ZONE = 10;
const JOY_SENSITIVITY = 0.45; // 더 느리게
const JOY_EASING = 0.16;      // 부드러움(반응 느리게)

// dt 기반 이동 속도(PC/폰 동일 체감) - px/second
const PLAYER_SPEED_PPS = 190;

if (isMobile) {
  joystickArea.style.display = "block";

  function setStickVisual(stickX, stickY) {
    joystickStick.style.left = (stickX - joystickStick.offsetWidth / 2) + "px";
    joystickStick.style.top  = (stickY - joystickStick.offsetHeight / 2) + "px";
  }

  function updateStickFromTouch(clientX, clientY) {
    const rect = joystickArea.getBoundingClientRect();
    const localX = clientX - rect.left;
    const localY = clientY - rect.top;

    const dx = localX - joystickCenter.x;
    const dy = localY - joystickCenter.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const clamped = Math.min(dist, JOY_MAX_DISTANCE);
    const angle = Math.atan2(dy, dx);

    const stickX = joystickCenter.x + Math.cos(angle) * clamped;
    const stickY = joystickCenter.y + Math.sin(angle) * clamped;
    setStickVisual(stickX, stickY);

    const eff = Math.max(0, dist - JOY_DEAD_ZONE);
    const norm = Math.min(1, eff / (JOY_MAX_DISTANCE - JOY_DEAD_ZONE));
    joystickPower = Math.pow(norm, 1.25) * JOY_SENSITIVITY;

    if (dist > JOY_DEAD_ZONE) {
      joystickVector.x = Math.cos(angle);
      joystickVector.y = Math.sin(angle);
    } else {
      joystickVector.x = 0;
      joystickVector.y = 0;
      joystickPower = 0;
    }
  }

  joystickArea.addEventListener("touchstart", (e) => {
    e.preventDefault();
    joystickActive = true;
    const t = e.touches[0];
    updateStickFromTouch(t.clientX, t.clientY);
  }, { passive: false });

  joystickArea.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!joystickActive) return;
    const t = e.touches[0];
    updateStickFromTouch(t.clientX, t.clientY);
  }, { passive: false });

  joystickArea.addEventListener("touchend", (e) => {
    e.preventDefault();
    joystickActive = false;
    joystickVector.x = 0; joystickVector.y = 0;
    joystickPower = 0;
    setStickVisual(joystickCenter.x, joystickCenter.y);
  }, { passive: false });

  setStickVisual(joystickCenter.x, joystickCenter.y);
}

/* =========================================================
   레벨/오브젝트
   ========================================================= */
const player = { x: 0, y: 0, w: 18, h: 18, speed: PLAYER_SPEED_PPS, startX: 0, startY: 0 };
let goal = { x: 0, y: 0, w: 40, h: 80 };
let walls = [];
let enemies = [];
let coins = [];
let currentLevelIndex = 0;

function rectIntersect(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function circleRectCollide(circle, rect) {
  const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
  const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
  const dx = circle.x - closestX;
  const dy = circle.y - closestY;
  return (dx * dx + dy * dy) < (circle.r * circle.r);
}

/* 1~5 수동 + 나머지 자동 생성 */
const baseLevels = [
  { start:{x:50,y:230}, goal:{x:550,y:200,w:60,h:80},
    walls:[{x:0,y:0,w:640,h:120},{x:0,y:360,w:640,h:120}],
    enemies:[
      {x:200,y:150,r:10,dx:0,dy:120,minY:140,maxY:340},
      {x:260,y:340,r:10,dx:0,dy:-120,minY:140,maxY:340},
      {x:320,y:150,r:10,dx:0,dy:120,minY:140,maxY:340},
      {x:380,y:340,r:10,dx:0,dy:-120,minY:140,maxY:340}
    ],
    coins:[]
  },
  { start:{x:40,y:230}, goal:{x:560,y:210,w:50,h:60},
    walls:[{x:0,y:0,w:640,h:160},{x:0,y:320,w:640,h:160}],
    enemies:[
      {x:150,y:170,r:9,dx:0,dy:180,minY:170,maxY:310},
      {x:220,y:310,r:9,dx:0,dy:-180,minY:170,maxY:310},
      {x:290,y:170,r:9,dx:0,dy:180,minY:170,maxY:310},
      {x:360,y:310,r:9,dx:0,dy:-180,minY:170,maxY:310},
      {x:430,y:170,r:9,dx:0,dy:180,minY:170,maxY:310}
    ],
    coins:[{x:120,y:240,r:6,taken:false},{x:320,y:240,r:6,taken:false},{x:520,y:240,r:6,taken:false}]
  },
  { start:{x:50,y:230}, goal:{x:550,y:210,w:60,h:60},
    walls:[{x:0,y:0,w:640,h:120},{x:0,y:360,w:640,h:120},{x:280,y:180,w:80,h:120}],
    enemies:[
      {x:120,y:170,r:9,dx:180,dy:0,minX:120,maxX:520},
      {x:520,y:310,r:9,dx:-180,dy:0,minX:120,maxX:520},
      {x:120,y:285,r:9,dx:180,dy:0,minX:120,maxX:520}
    ],
    coins:[{x:320,y:150,r:6,taken:false},{x:320,y:330,r:6,taken:false}]
  },
  { start:{x:300,y:400}, goal:{x:300,y:40,w:40,h:40},
    walls:[{x:0,y:0,w:640,h:40},{x:0,y:440,w:640,h:40},{x:0,y:0,w:40,h:480},{x:600,y:0,w:40,h:480}],
    enemies:[
      {x:200,y:80,r:9,dx:0,dy:210,minY:80,maxY:400},
      {x:440,y:400,r:9,dx:0,dy:-210,minY:80,maxY:400},
      {x:80,y:260,r:9,dx:210,dy:0,minX:80,maxX:560},
      {x:560,y:220,r:9,dx:-210,dy:0,minX:80,maxX:560}
    ],
    coins:[{x:320,y:260,r:6,taken:false}]
  },
  { start:{x:60,y:400}, goal:{x:560,y:60,w:40,h:40},
    walls:[
      {x:0,y:0,w:640,h:40},{x:0,y:440,w:640,h:40},
      {x:0,y:80,w:200,h:40},{x:440,y:80,w:200,h:40},
      {x:200,y:80,w:40,h:240},{x:400,y:200,w:40,h:240},
      {x:240,y:280,w:60,h:40},{x:340,y:280,w:60,h:40}
    ],
    enemies:[
      {x:120,y:120,r:8,dx:150,dy:0,minX:60,maxX:340},
      {x:520,y:160,r:8,dx:-150,dy:0,minX:300,maxX:580},
      {x:220,y:360,r:8,dx:180,dy:0,minX:60,maxX:380},
      {x:420,y:240,r:8,dx:0,dy:180,minY:120,maxY:360}
    ],
    coins:[{x:320,y:260,r:6,taken:false},{x:100,y:420,r:6,taken:false}]
  }
];

const levels = [...baseLevels];

function generateAutoLevels() {
  for (let lvl = levels.length + 1; lvl <= TOTAL_LEVELS; lvl++) {
    const progress = (lvl - 1) / (TOTAL_LEVELS - 1);
    const enemyCount = 4 + Math.floor(progress * 7);
    const coinCount = Math.floor(progress * 4);
    const speedBase = 140 + progress * 200; // enemy px/s
    const isHorizontal = (lvl % 2 === 1);

    const start = isHorizontal ? { x: 40, y: 240 } : { x: 320, y: 420 };
    const goal  = isHorizontal ? { x: 560, y: 220, w: 50, h: 80 } : { x: 320, y: 40, w: 50, h: 50 };

    const walls = [];
    const pad = 40 + 20 * (lvl % 3);
    walls.push({ x: 0, y: 0, w: 640, h: pad });
    walls.push({ x: 0, y: 480 - pad, w: 640, h: pad });

    if (isHorizontal) {
      for (let i = 0; i < 3; i++) {
        walls.push({ x: 200 + i * 80, y: pad + 30 + (i % 2) * 80, w: 28, h: 150 });
        walls.push({ x: 200 + i * 80, y: 320 - (i % 2) * 60, w: 28, h: 60 });
      }
    } else {
      for (let i = 0; i < 3; i++) {
        const y = 130 + i * 70;
        walls.push({ x: 80, y, w: 190, h: 26 });
        walls.push({ x: 370, y, w: 190, h: 26 });
      }
    }

    const enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const speed = speedBase + (i % 3) * 35;
      if (i % 2 === 0) {
        const yMin = pad + 20, yMax = 480 - pad - 20;
        enemies.push({ x: 110 + (i * 43) % 420, y: (yMin + yMax) / 2, r: 8, dx: 0, dy: (i % 4 < 2 ? speed : -speed), minY: yMin, maxY: yMax });
      } else {
        const xMin = 70, xMax = 570;
        enemies.push({ x: (xMin + xMax) / 2, y: pad + 30 + (i * 29) % (480 - pad * 2 - 60), r: 8, dx: (i % 4 < 2 ? speed : -speed), dy: 0, minX: xMin, maxX: xMax });
      }
    }

    const coins = [];
    for (let i = 0; i < coinCount; i++) coins.push({ x: 140 + i * 120, y: 130 + ((i + lvl) % 3) * 110, r: 6, taken: false });
    levels.push({ start, goal, walls, enemies, coins });
  }
}
generateAutoLevels();

/* =========================================================
   메뉴 UI
   ========================================================= */
function showOverlay(title, desc, buttons, bodyHtml = "", hint = "") {
  panelTitle.textContent = title;
  panelDesc.textContent = desc || "";
  panelButtons.innerHTML = "";
  panelBody.innerHTML = bodyHtml || "";
  panelHint.textContent = hint || "";
  buttons.forEach(b => {
    const el = document.createElement("button");
    el.textContent = b.text;
    if (b.kind) el.classList.add(b.kind);
    if (b.disabled) el.disabled = true;
    el.addEventListener("click", b.onClick);
    panelButtons.appendChild(el);
  });
  overlay.classList.add("show");
}
function hideOverlay() { overlay.classList.remove("show"); }

function openUserSetup() {
  mode = "menu";
  showOverlay(
    "사용자 정보 입력",
    "닉네임만으로 기록을 저장/조회합니다.",
    [
      { text: "시작", kind: "primary", onClick: async () => {
        const input = document.getElementById("nameInput");
        const name = (input?.value || "").trim();
        if (!name) { panelHint.textContent = "닉네임을 입력하세요."; return; }
        username = name;
        localStorage.setItem(LOCAL_USER_KEY, username);
        userId = sanitizeId(username);
        if (!userId) { panelHint.textContent = "닉네임이 유효하지 않습니다."; return; }

        try { await ensureUserDoc(); } catch (e) { panelHint.textContent = "DB 오류: " + (e?.message || e); }
        hideOverlay();
        openMainMenu();
      }}
    ],
    `
      <div class="grid">
        <div>
          <p class="muted">컬렉션: ${COL_USERS}, ${COL_LEVEL_BEST}, ${COL_LEVEL_RUNS}</p>
          <p class="muted">모바일은 가로 화면 권장</p>
        </div>
        <div>
          <p>닉네임</p>
          <input id="nameInput" placeholder="예: player01" value="${escapeHtml(username)}" />
        </div>
      </div>
    `,
    isMobile ? "모바일: 조이스틱 감도 낮춤 + 속도 동일(dt) 적용" : "PC: 방향키 이동 + 속도 동일(dt) 적용"
  );
}

function openMainMenu() {
  mode = "menu";
  showOverlay(
    "메뉴",
    "레벨 선택, DB 기록 보기, 랭킹 조회 등을 할 수 있습니다.",
    [
      { text: "이어하기", kind: "primary", onClick: () => { hideOverlay(); startFromSavedOr1(); } },
      { text: "레벨 선택", onClick: () => openLevelSelect() },
      { text: "내 기록(DB)", disabled: !userId, onClick: () => openMyRecords() },
      { text: "레벨 랭킹(Top10)", disabled: !userId, onClick: () => openLevelRanking() },
      { text: "닉네임 변경", onClick: () => openUserSetup() },
      { text: "로컬 리셋", kind: "danger", onClick: () => { resetLocal(); openMainMenu(); } }
    ],
    `<p class="muted">유저: <b>${escapeHtml(username || "-")}</b> · 해금: ${unlockedUpTo + 1}레벨까지</p>`,
    ""
  );
}

function openPauseMenu() {
  if (mode !== "playing") return;
  mode = "paused";
  showOverlay("일시정지", "게임이 멈췄습니다.", [
    { text: "계속하기", kind: "primary", onClick: () => resumeFromPause() },
    { text: "메뉴", onClick: () => openMainMenu() }
  ], `<p class="muted">현재 레벨: ${currentLevelIndex + 1}</p>`, "");
}
function resumeFromPause() { hideOverlay(); mode = "playing"; }

function resetLocal() {
  unlockedUpTo = 0;
  cleared = new Set();
  deaths = 0;
  saveLocalProgress();
  updateTopUI();
}

function openLevelSelect() {
  mode = "levelSelect";
  showOverlay("레벨 선택", "클리어=초록 · 해금=파랑 · 잠김=회색", [
    { text: "뒤로", onClick: () => openMainMenu() }
  ], `<div id="lvlGrid" class="lvlGrid"></div>`, `해금: ${unlockedUpTo + 1}레벨까지`);

  const grid = document.getElementById("lvlGrid");
  grid.innerHTML = "";
  for (let i = 0; i < TOTAL_LEVELS; i++) {
    const btn = document.createElement("button");
    btn.className = "lvlBtn";
    btn.textContent = String(i + 1);

    const isCleared = cleared.has(i);
    const isUnlocked = i <= unlockedUpTo;

    btn.classList.add(isCleared ? "cleared" : (isUnlocked ? "unlocked" : "locked"));
    btn.disabled = !isUnlocked;

    btn.addEventListener("click", () => {
      hideOverlay();
      loadLevel(i);
      mode = "playing";
    });
    grid.appendChild(btn);
  }
}

async function openMyRecords() {
  mode = "records";
  showOverlay("내 기록", "불러오는 중...", [{ text: "뒤로", onClick: () => openMainMenu() }], "", "");
  try {
    const { user, bestRows } = await fetchMySummary();
    const maxLevel = user?.maxLevel ?? "-";
    let rowsHtml = bestRows.map(r => `<tr><td>${r.level}</td><td>${(r.bestTimeMs/1000).toFixed(3)}s</td></tr>`).join("");
    if (!rowsHtml) rowsHtml = `<tr><td colspan="2" class="muted">기록이 없습니다.</td></tr>`;

    showOverlay(
      "내 기록",
      `최고 도달 스테이지: ${maxLevel}`,
      [{ text: "뒤로", onClick: () => openMainMenu() }],
      `<table><thead><tr><th>레벨</th><th>최고 기록</th></tr></thead><tbody>${rowsHtml}</tbody></table>`,
      "클리어 시 자동 저장됩니다."
    );
  } catch (e) {
    showOverlay("내 기록", "불러오기 실패", [{ text: "뒤로", onClick: () => openMainMenu() }],
      `<p class="err">오류: ${String(e?.message || e)}</p>`,
      "Firestore 규칙/인덱스 설정을 확인하세요."
    );
  }
}

async function openLevelRanking() {
  mode = "records";
  const defaultLvl = Math.min(unlockedUpTo + 1, TOTAL_LEVELS);
  showOverlay(
    "레벨 랭킹(Top10)",
    "레벨을 선택하고 Top10을 조회합니다.",
    [
      { text: "뒤로", onClick: () => openMainMenu() },
      { text: "조회", kind: "primary", onClick: async () => {
        const sel = document.getElementById("rankLevelSel");
        const levelNum = parseInt(sel.value, 10);
        await renderRanking(levelNum);
      }}
    ],
    `
      <div class="row">
        <span>레벨</span>
        <select id="rankLevelSel">
          ${Array.from({length: TOTAL_LEVELS}, (_,i)=>`<option value="${i+1}" ${i+1===defaultLvl?'selected':''}>${i+1}</option>`).join("")}
        </select>
      </div>
      <div id="rankTable"></div>
    `,
    "Top10은 레벨별 최고기록(bestTimeMs) 기준입니다."
  );
  await renderRanking(defaultLvl);
}

async function renderRanking(levelNum) {
  const box = document.getElementById("rankTable");
  box.innerHTML = `<p class="muted">불러오는 중...</p>`;
  try {
    const rows = await fetchTopForLevel(levelNum);
    let html = rows.map((r, idx) =>
      `<tr><td>${idx+1}</td><td>${escapeHtml(r.username || r.userId)}</td><td>${(r.bestTimeMs/1000).toFixed(3)}s</td></tr>`
    ).join("");
    if (!html) html = `<tr><td colspan="3" class="muted">기록이 없습니다.</td></tr>`;
    box.innerHTML = `<table><thead><tr><th>#</th><th>유저</th><th>기록</th></tr></thead><tbody>${html}</tbody></table>`;
  } catch (e) {
    box.innerHTML = `<p class="err">오류: ${String(e?.message || e)}</p>`;
  }
}

/* =========================================================
   메시지/진행
   ========================================================= */
function openMessage(text, nextAction) { mode = "message"; messageText = text; messageNextAction = nextAction || null; }
function closeMessageAndContinue() {
  if (mode !== "message") return;
  const action = messageNextAction;
  messageText = "";
  messageNextAction = null;
  mode = "playing";
  if (action) action();
}
function startFromSavedOr1() {
  const idx = Math.min(unlockedUpTo, TOTAL_LEVELS - 1);
  loadLevel(idx);
  mode = "playing";
}

/* =========================================================
   레벨 로드/클리어 저장
   ========================================================= */
function loadLevel(index) {
  const level = levels[index];
  currentLevelIndex = index;

  player.x = level.start.x; player.y = level.start.y;
  player.startX = level.start.x; player.startY = level.start.y;

  goal = { ...level.goal };
  walls = level.walls.map(w => ({ ...w }));
  enemies = level.enemies.map(e => ({ ...e }));
  coins = level.coins.map(c => ({ ...c }));

  for (const k in keys) keys[k] = false;
  joystickVector.x = 0; joystickVector.y = 0; joystickPower = 0; joystickActive = false;
  joyVx = 0; joyVy = 0;
  resetTimer();
  updateTopUI();
}

async function onLevelCleared() {
  const levelNum = currentLevelIndex + 1;
  const tMs = Math.max(0, Math.round(elapsedMs));

  cleared.add(currentLevelIndex);
  unlockedUpTo = Math.max(unlockedUpTo, Math.min(TOTAL_LEVELS - 1, currentLevelIndex + 1));
  saveLocalProgress();

  try {
    if (userId) {
      await updateUserMaxLevel(unlockedUpTo + 1);
      await upsertBestTime(levelNum, tMs);
      await logRun(levelNum, tMs);
    }
  } catch (e) {
    console.warn("Firestore save failed:", e);
  }

  const next = currentLevelIndex + 1;
  if (next >= TOTAL_LEVELS) openMessage("축하합니다! 마지막 레벨 클리어!\n탭/스페이스로 메뉴", () => openMainMenu());
  else openMessage(`레벨 ${levelNum} 클리어! (${(tMs/1000).toFixed(3)}s)\n탭/스페이스로 다음`, () => loadLevel(next));
}

/* =========================================================
   이동(충돌 포함) - dt 기반(px/s * dt) => PC/폰 동일 체감
   ========================================================= */
function movePlayerWithCollision(vx, vy) {
  if (vx !== 0) {
    player.x += vx;
    for (const w of walls) if (rectIntersect(player, w)) player.x = (vx > 0) ? (w.x - player.w) : (w.x + w.w);
  }
  if (vy !== 0) {
    player.y += vy;
    for (const w of walls) if (rectIntersect(player, w)) player.y = (vy > 0) ? (w.y - player.h) : (w.y + w.h);
  }
  player.x = Math.max(0, Math.min(DESIGN_WIDTH - player.w, player.x));
  player.y = Math.max(0, Math.min(DESIGN_HEIGHT - player.h, player.y));
}

let joyVx = 0, joyVy = 0;

/* =========================================================
   업데이트/렌더
   ========================================================= */
function update(dt) {
  updateTimer();
  if (mode !== "playing") return;

  // ===== 플레이어 입력 벡터(정규화 후 speed*dt) =====
  if (isMobile) {
    let targetVx = 0, targetVy = 0;
    if (joystickActive) {
      targetVx = joystickVector.x * player.speed * joystickPower;
      targetVy = joystickVector.y * player.speed * joystickPower;
    }

    // dt가 달라도 비슷한 반응이 되게 지수감쇠 형태로 보정
    const ease = 1 - Math.pow(1 - JOY_EASING, dt * 60);
    joyVx += (targetVx - joyVx) * ease;
    joyVy += (targetVy - joyVy) * ease;

    movePlayerWithCollision(joyVx * dt, joyVy * dt);
  } else {
    let vx = 0, vy = 0;
    if (keys["ArrowUp"]) vy -= 1;
    if (keys["ArrowDown"]) vy += 1;
    if (keys["ArrowLeft"]) vx -= 1;
    if (keys["ArrowRight"]) vx += 1;

    const len = Math.hypot(vx, vy);
    if (len > 0) { vx /= len; vy /= len; }

    movePlayerWithCollision(vx * player.speed * dt, vy * player.speed * dt);
  }

  // ===== 적 이동(dt 기반) =====
  for (const e of enemies) {
    e.x += (e.dx || 0) * dt;
    e.y += (e.dy || 0) * dt;
    if (e.minX !== undefined && (e.x < e.minX || e.x > e.maxX)) e.dx *= -1;
    if (e.minY !== undefined && (e.y < e.minY || e.y > e.maxY)) e.dy *= -1;
  }

  // ===== 충돌 =====
  for (const e of enemies) {
    if (circleRectCollide(e, player)) {
      deaths++;
      player.x = player.startX;
      player.y = player.startY;
      updateTopUI();
      break;
    }
  }

  // ===== 코인 =====
  for (const c of coins) {
    if (c.taken) continue;
    const dx = (player.x + player.w / 2) - c.x;
    const dy = (player.y + player.h / 2) - c.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < c.r + Math.min(player.w, player.h) / 2) c.taken = true;
  }

  if (rectIntersect(player, goal) && coins.every(c => c.taken)) onLevelCleared();
}

function draw() {
  ctx.clearRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);
  ctx.fillStyle = "#88dd88";
  ctx.fillRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);

  ctx.fillStyle = "#888888";
  for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);

  ctx.fillStyle = "#cccc00";
  ctx.fillRect(player.startX - 20, player.startY - 20, 40, 40);

  ctx.fillStyle = "#00aa00";
  ctx.fillRect(goal.x, goal.y, goal.w, goal.h);

  for (const c of coins) {
    if (c.taken) continue;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
    ctx.fillStyle = "#ffcc00";
    ctx.fill();
  }

  ctx.fillStyle = "#ff0000";
  ctx.fillRect(player.x, player.y, player.w, player.h);

  for (const e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fillStyle = "#0077ff";
    ctx.fill();
  }

  if (mode === "message") {
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.fillRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.font = "24px Arial";
    const lines = String(messageText || "").split("\n");
    let baseY = DESIGN_HEIGHT / 2 - (lines.length - 1) * 18;
    lines.forEach((line, i) => ctx.fillText(line, DESIGN_WIDTH / 2, baseY + i * 30));
  }
}

/* =========================================================
   requestAnimationFrame 루프(dt 기반)
   - 모니터 주사율/기기 성능이 달라도 속도 일정하게[web:200]
   ========================================================= */
let lastTs = 0;
function loop(ts) {
  if (!lastTs) lastTs = ts;
  let dt = (ts - lastTs) / 1000;
  lastTs = ts;

  // 탭 전환/렉 후 순간 이동 방지
  dt = Math.min(dt, 0.05);

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* =========================================================
   로컬 진행 저장/불러오기 보조
   ========================================================= */
function resetLocal() {
  unlockedUpTo = 0;
  cleared = new Set();
  deaths = 0;
  saveLocalProgress();
  updateTopUI();
}

/* =========================================================
   기본 진행/메뉴 진입
   ========================================================= */
function openBoot() {
  updateTopUI();
  if (!username) {
    openUserSetup();
  } else {
    ensureUserDoc().catch(()=>{});
    openMainMenu();
  }
}

/* =========================================================
   메시지 클릭 진행을 위해 canvas touch 이벤트 유지
   ========================================================= */

/* =========================================================
   (필수) 남은 함수들: UI에서 사용하는데 위에 이미 선언됨
   - openMainMenu/openUserSetup/openLevelSelect/openMyRecords/openLevelRanking 등
   ========================================================= */

/* =========================================================
   level select/records에서 필요한 함수가 이미 위에 있으므로 start
   ========================================================= */
openBoot();
requestAnimationFrame(loop);
</script>
</body>
</html>
