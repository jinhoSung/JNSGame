<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>세상에서 가장 어려운 게임 - 50레벨 (레벨 선택/저장/모바일)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    :root { --panel: rgba(0,0,0,0.72); --panel2: rgba(0,0,0,0.86); }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #222;
      font-family: Arial, sans-serif;
      color: #fff;
      user-select: none;
      overflow: hidden;
    }
    #gameWrapper { position: relative; }
    #gameCanvas {
      background: #eee;
      border: 4px solid #000;
      touch-action: none;
      display: block;
    }
    #uiTop {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      text-align: center;
      z-index: 10;
      line-height: 1.35;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }

    /* 조이스틱 */
    #joystickArea {
      position: absolute;
      left: 10px;
      bottom: 10px;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      display: none;
      touch-action: none;
      z-index: 5;
    }
    #joystickBase, #joystickStick {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    #joystickBase {
      width: 120px;
      height: 120px;
      left: 20px;
      top: 20px;
      background: rgba(0, 0, 0, 0.3);
    }
    #joystickStick {
      width: 60px;
      height: 60px;
      left: 50px;
      top: 50px;
      background: rgba(255, 255, 255, 0.82);
    }

    /* 오버레이(메뉴/레벨 선택/일시정지) */
    #overlay {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 20;
      align-items: center;
      justify-content: center;
      background: var(--panel);
    }
    #overlay.show { display: flex; }

    #panel {
      width: min(560px, 92%);
      max-height: min(420px, 86%);
      background: var(--panel2);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 10px;
      padding: 14px 14px 12px;
      overflow: auto;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
    #panel h2 {
      margin: 6px 0 10px;
      font-size: 18px;
      font-weight: 700;
    }
    #panel p {
      margin: 6px 0 10px;
      font-size: 13px;
      opacity: 0.92;
      line-height: 1.35;
    }
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin: 10px 0 10px;
    }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.12);
      color: #fff;
      border-radius: 8px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.18); }
    button:active { transform: translateY(1px); }
    button.primary { background: rgba(0,170,0,0.55); border-color: rgba(0,170,0,0.6); }
    button.danger { background: rgba(200,0,0,0.45); border-color: rgba(200,0,0,0.55); }
    button:disabled { opacity: 0.45; cursor: not-allowed; }

    #levelGrid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    @media (max-width: 520px) {
      #levelGrid { grid-template-columns: repeat(5, 1fr); }
    }
    .lvlBtn {
      padding: 10px 0;
      text-align: center;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      font-size: 13px;
    }
    .lvlBtn.unlocked { background: rgba(0,140,255,0.24); }
    .lvlBtn.cleared  { background: rgba(0,200,0,0.35); }
    .lvlBtn.locked   { background: rgba(255,255,255,0.05); opacity: 0.55; }

    .hint {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 8px;
    }
  </style>
</head>
<body>
<div id="uiTop">
  <div>레벨: <span id="levelDisplay">1</span> / 50 · 죽은 횟수: <span id="deathDisplay">0</span></div>
  <div>PC: 방향키, P=일시정지, M=메뉴 · 모바일: 조이스틱/탭</div>
</div>

<div id="gameWrapper">
  <canvas id="gameCanvas" width="640" height="480"></canvas>

  <div id="joystickArea">
    <div id="joystickBase"></div>
    <div id="joystickStick"></div>
  </div>

  <div id="overlay">
    <div id="panel">
      <h2 id="panelTitle">메뉴</h2>
      <p id="panelDesc"></p>
      <div class="row" id="panelButtons"></div>
      <div id="levelGrid" style="display:none;"></div>
      <div class="hint" id="panelHint"></div>
    </div>
  </div>
</div>

<script>
/* ==========================
   환경/상태/저장 (localStorage)
   ========================== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const overlay = document.getElementById("overlay");
const panelTitle = document.getElementById("panelTitle");
const panelDesc = document.getElementById("panelDesc");
const panelButtons = document.getElementById("panelButtons");
const panelHint = document.getElementById("panelHint");
const levelGrid = document.getElementById("levelGrid");

const levelDisplay = document.getElementById("levelDisplay");
const deathDisplay = document.getElementById("deathDisplay");

const joystickArea = document.getElementById("joystickArea");
const joystickStick = document.getElementById("joystickStick");

const keys = {};
const DESIGN_WIDTH = 640;
const DESIGN_HEIGHT = 480;
const TOTAL_LEVELS = 50;

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobi/i.test(navigator.userAgent);

let currentLevelIndex = 0; // 0-based
let deaths = 0;

// 진행 저장: unlockedUpTo(0-based index), clearedSet
const SAVE_KEY = "whg_save_v2";
let unlockedUpTo = 0;
let cleared = new Set();

// 게임 상태
let mode = "menu"; // "menu" | "playing" | "paused" | "message" | "levelSelect"
let messageText = "";
let messageNextAction = null;

function saveProgress() {
  const data = { unlockedUpTo, cleared: Array.from(cleared), deaths };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data)); // [web:128][web:127]
}

function loadProgress() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (typeof data.unlockedUpTo === "number") unlockedUpTo = Math.max(0, Math.min(TOTAL_LEVELS - 1, data.unlockedUpTo));
    if (Array.isArray(data.cleared)) cleared = new Set(data.cleared.filter(n => Number.isInteger(n)));
    if (typeof data.deaths === "number") deaths = Math.max(0, data.deaths | 0);
  } catch (_) {}
}

function resetProgress() {
  unlockedUpTo = 0;
  cleared = new Set();
  deaths = 0;
  localStorage.removeItem(SAVE_KEY);
  updateTopUI();
}

loadProgress();

/* ==========================
   반응형 캔버스
   ========================== */
function resizeCanvas() {
  const wrapper = document.getElementById("gameWrapper");
  const maxWidth = window.innerWidth;
  const maxHeight = window.innerHeight;

  const scaleX = maxWidth / DESIGN_WIDTH;
  const scaleY = maxHeight / DESIGN_HEIGHT;
  const scale = Math.min(scaleX, scaleY);

  const displayWidth = DESIGN_WIDTH * scale;
  const displayHeight = DESIGN_HEIGHT * scale;

  canvas.style.width = displayWidth + "px";
  canvas.style.height = displayHeight + "px";

  wrapper.style.width = displayWidth + "px";
  wrapper.style.height = displayHeight + "px";
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* ==========================
   입력: 키보드/터치
   ========================== */
window.addEventListener("keydown", (e) => {
  if (e.key === "m" || e.key === "M") {
    if (mode === "playing" || mode === "paused") openMainMenu();
    return;
  }
  if (e.key === "p" || e.key === "P") {
    if (mode === "playing") openPauseMenu();
    else if (mode === "paused") resumeFromPause();
    return;
  }

  if (mode === "message") {
    if (e.key === " " || e.key === "Enter") closeMessageAndContinue();
    return;
  }

  if (mode === "menu" || mode === "levelSelect" || mode === "paused") return;
  keys[e.key] = true;
});
window.addEventListener("keyup", (e) => {
  keys[e.key] = false;
});

// 메시지 화면에서: 탭/클릭으로 진행 (Touch events)[web:102]
canvas.addEventListener("click", () => { if (mode === "message") closeMessageAndContinue(); });
canvas.addEventListener("touchstart", (e) => {
  if (mode === "message") {
    e.preventDefault();
    closeMessageAndContinue();
  }
}, { passive: false }); // preventDefault 필요 시 passive:false가 필요할 수 있음[web:147][web:145]

/* ==========================
   조이스틱(모바일)
   ========================== */
let joystickActive = false;
let joystickCenter = { x: 80, y: 80 };
let joystickVector = { x: 0, y: 0 };

if (isMobile) {
  joystickArea.style.display = "block";
  const maxDistance = 40;

  function updateStickPosition(clientX, clientY) {
    const rect = joystickArea.getBoundingClientRect();
    const localX = clientX - rect.left;
    const localY = clientY - rect.top;

    const dx = localX - joystickCenter.x;
    const dy = localY - joystickCenter.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const clamped = Math.min(dist, maxDistance);
    const angle = Math.atan2(dy, dx);

    const stickX = joystickCenter.x + Math.cos(angle) * clamped;
    const stickY = joystickCenter.y + Math.sin(angle) * clamped;

    joystickStick.style.left = (stickX - joystickStick.offsetWidth / 2) + "px";
    joystickStick.style.top  = (stickY - joystickStick.offsetHeight / 2) + "px";

    if (dist > 5) {
      joystickVector.x = Math.cos(angle);
      joystickVector.y = Math.sin(angle);
    } else {
      joystickVector.x = 0;
      joystickVector.y = 0;
    }
  }

  joystickArea.addEventListener("touchstart", (e) => {
    e.preventDefault();
    joystickActive = true;
    const t = e.touches[0];
    updateStickPosition(t.clientX, t.clientY);
  }, { passive: false });

  joystickArea.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (!joystickActive) return;
    const t = e.touches[0];
    updateStickPosition(t.clientX, t.clientY);
  }, { passive: false });

  joystickArea.addEventListener("touchend", (e) => {
    e.preventDefault();
    joystickActive = false;
    joystickVector.x = 0;
    joystickVector.y = 0;
    joystickStick.style.left = (joystickCenter.x - joystickStick.offsetWidth / 2) + "px";
    joystickStick.style.top  = (joystickCenter.y - joystickStick.offsetHeight / 2) + "px";
  }, { passive: false });
}

/* ==========================
   게임 오브젝트
   ========================== */
const player = { x: 0, y: 0, w: 18, h: 18, speed: 3, startX: 0, startY: 0 };
let goal = { x: 0, y: 0, w: 40, h: 80 };
let walls = [];
let enemies = [];
let coins = [];

/* ==========================
   레벨 1~10 수동(5번 통로 수정) + 11~50 자동
   ========================== */
const baseLevels = [
  // 1
  {
    start: { x: 50, y: 230 },
    goal:  { x: 550, y: 200, w: 60, h: 80 },
    walls: [{ x: 0, y: 0, w: 640, h: 120 }, { x: 0, y: 360, w: 640, h: 120 }],
    enemies: [
      { x: 200, y: 150, r: 10, dx: 0, dy: 2,  minY: 140, maxY: 340 },
      { x: 260, y: 340, r: 10, dx: 0, dy: -2, minY: 140, maxY: 340 },
      { x: 320, y: 150, r: 10, dx: 0, dy: 2,  minY: 140, maxY: 340 },
      { x: 380, y: 340, r: 10, dx: 0, dy: -2, minY: 140, maxY: 340 }
    ],
    coins: []
  },
  // 2
  {
    start: { x: 40, y: 230 },
    goal:  { x: 560, y: 210, w: 50, h: 60 },
    walls: [{ x: 0, y: 0, w: 640, h: 160 }, { x: 0, y: 320, w: 640, h: 160 }],
    enemies: [
      { x: 150, y: 170, r: 9, dx: 0, dy: 3,  minY: 170, maxY: 310 },
      { x: 220, y: 310, r: 9, dx: 0, dy: -3, minY: 170, maxY: 310 },
      { x: 290, y: 170, r: 9, dx: 0, dy: 3,  minY: 170, maxY: 310 },
      { x: 360, y: 310, r: 9, dx: 0, dy: -3, minY: 170, maxY: 310 },
      { x: 430, y: 170, r: 9, dx: 0, dy: 3,  minY: 170, maxY: 310 }
    ],
    coins: [
      { x: 120, y: 240, r: 6, taken: false },
      { x: 320, y: 240, r: 6, taken: false },
      { x: 520, y: 240, r: 6, taken: false }
    ]
  },
  // 3
  {
    start: { x: 50, y: 230 },
    goal:  { x: 550, y: 210, w: 60, h: 60 },
    walls: [
      { x: 0, y: 0, w: 640, h: 120 },
      { x: 0, y: 360, w: 640, h: 120 },
      { x: 280, y: 180, w: 80, h: 120 }
    ],
    enemies: [
      { x: 120, y: 170, r: 9, dx: 2.5, dy: 0, minX: 120, maxX: 520 },
      { x: 520, y: 310, r: 9, dx: -2.5, dy: 0, minX: 120, maxX: 520 },
      { x: 120, y: 285, r: 9, dx: 2.5, dy: 0, minX: 120, maxX: 520 }
    ],
    coins: [{ x: 320, y: 150, r: 6, taken: false }, { x: 320, y: 330, r: 6, taken: false }]
  },
  // 4
  {
    start: { x: 300, y: 400 },
    goal:  { x: 300, y: 40, w: 40, h: 40 },
    walls: [
      { x: 0, y: 0, w: 640, h: 40 }, { x: 0, y: 440, w: 640, h: 40 },
      { x: 0, y: 0, w: 40, h: 480 }, { x: 600, y: 0, w: 40, h: 480 }
    ],
    enemies: [
      { x: 200, y: 80, r: 9, dx: 0, dy: 3, minY: 80, maxY: 400 },
      { x: 440, y: 400, r: 9, dx: 0, dy: -3, minY: 80, maxY: 400 },
      { x: 80,  y: 260, r: 9, dx: 3, dy: 0, minX: 80, maxX: 560 },
      { x: 560, y: 220, r: 9, dx: -3, dy: 0, minX: 80, maxX: 560 }
    ],
    coins: [{ x: 320, y: 260, r: 6, taken: false }]
  },
  // 5 (통로 수정)
  {
    start: { x: 60, y: 400 },
    goal:  { x: 560, y: 60, w: 40, h: 40 },
    walls: [
      { x: 0, y: 0, w: 640, h: 40 }, { x: 0, y: 440, w: 640, h: 40 },
      { x: 0, y: 80, w: 200, h: 40 }, { x: 440, y: 80, w: 200, h: 40 },
      { x: 200, y: 80, w: 40, h: 240 }, { x: 400, y: 200, w: 40, h: 240 },
      { x: 240, y: 280, w: 60, h: 40 }, { x: 340, y: 280, w: 60, h: 40 }
    ],
    enemies: [
      { x: 120, y: 120, r: 8, dx: 2, dy: 0, minX: 60, maxX: 340 },
      { x: 520, y: 160, r: 8, dx: -2, dy: 0, minX: 300, maxX: 580 },
      { x: 220, y: 360, r: 8, dx: 2.5, dy: 0, minX: 60, maxX: 380 },
      { x: 420, y: 240, r: 8, dx: 0, dy: 2.5, minY: 120, maxY: 360 }
    ],
    coins: [{ x: 320, y: 260, r: 6, taken: false }, { x: 100, y: 420, r: 6, taken: false }]
  },
  // 6
  {
    start: { x: 40, y: 220 },
    goal:  { x: 580, y: 220, w: 40, h: 40 },
    walls: [{ x: 0, y: 0, w: 640, h: 80 }, { x: 0, y: 400, w: 640, h: 80 }, { x: 280, y: 80, w: 80, h: 240 }],
    enemies: [
      { x: 160, y: 120, r: 9, dx: 0, dy: 3, minY: 100, maxY: 380 },
      { x: 480, y: 380, r: 9, dx: 0, dy: -3, minY: 100, maxY: 380 },
      { x: 160, y: 380, r: 9, dx: 0, dy: -3, minY: 100, maxY: 380 },
      { x: 480, y: 100, r: 9, dx: 0, dy: 3, minY: 100, maxY: 380 }
    ],
    coins: [
      { x: 120, y: 120, r: 6, taken: false }, { x: 520, y: 120, r: 6, taken: false },
      { x: 120, y: 360, r: 6, taken: false }, { x: 520, y: 360, r: 6, taken: false }
    ]
  },
  // 7
  {
    start: { x: 40, y: 230 },
    goal:  { x: 560, y: 230, w: 60, h: 60 },
    walls: [{ x: 0, y: 0, w: 640, h: 100 }, { x: 0, y: 380, w: 640, h: 100 }],
    enemies: [
      { x: 160, y: 150, r: 8, dx: 3.5, dy: 0, minX: 80, maxX: 560 },
      { x: 160, y: 330, r: 8, dx: 3.5, dy: 0, minX: 80, maxX: 560 },
      { x: 560, y: 190, r: 8, dx: -3.5, dy: 0, minX: 80, maxX: 560 },
      { x: 80,  y: 290, r: 8, dx: 3.5, dy: 0, minX: 80, maxX: 560 },
      { x: 320, y: 150, r: 8, dx: 0, dy: 3.5, minY: 120, maxY: 360 }
    ],
    coins: [{ x: 320, y: 230, r: 6, taken: false }]
  },
  // 8
  {
    start: { x: 40, y: 230 },
    goal:  { x: 560, y: 230, w: 60, h: 60 },
    walls: [
      { x: 0, y: 0, w: 640, h: 80 }, { x: 0, y: 400, w: 640, h: 80 },
      { x: 280, y: 80, w: 80, h: 140 }, { x: 280, y: 260, w: 80, h: 140 }
    ],
    enemies: [
      { x: 160, y: 120, r: 9, dx: 0, dy: 3, minY: 100, maxY: 380 },
      { x: 480, y: 380, r: 9, dx: 0, dy: -3, minY: 100, maxY: 380 },
      { x: 160, y: 380, r: 9, dx: 0, dy: -3, minY: 100, maxY: 380 },
      { x: 480, y: 100, r: 9, dx: 0, dy: 3, minY: 100, maxY: 380 },
      { x: 320, y: 120, r: 9, dx: 3, dy: 0, minX: 80, maxX: 560 },
      { x: 320, y: 360, r: 9, dx: -3, dy: 0, minX: 80, maxX: 560 }
    ],
    coins: [{ x: 100, y: 240, r: 6, taken: false }, { x: 540, y: 240, r: 6, taken: false }]
  },
  // 9
  {
    start: { x: 60, y: 420 },
    goal:  { x: 560, y: 60, w: 40, h: 40 },
    walls: [{ x: 0, y: 0, w: 640, h: 40 }, { x: 0, y: 440, w: 640, h: 40 }, { x: 200, y: 80, w: 40, h: 320 }, { x: 400, y: 80, w: 40, h: 320 }],
    enemies: [
      { x: 120, y: 120, r: 8, dx: 3.2, dy: 0, minX: 60, maxX: 180 },
      { x: 320, y: 200, r: 8, dx: -3.2, dy: 0, minX: 220, maxX: 420 },
      { x: 520, y: 360, r: 8, dx: -3.3, dy: 0, minX: 460, maxX: 580 },
      { x: 320, y: 360, r: 8, dx: 0, dy: -3.2, minY: 120, maxY: 360 }
    ],
    coins: [{ x: 120, y: 420, r: 6, taken: false }, { x: 320, y: 60, r: 6, taken: false }, { x: 520, y: 420, r: 6, taken: false }]
  },
  // 10
  {
    start: { x: 40, y: 230 },
    goal:  { x: 580, y: 40, w: 40, h: 40 },
    walls: [
      { x: 0, y: 0, w: 640, h: 40 }, { x: 0, y: 440, w: 640, h: 40 },
      { x: 200, y: 80, w: 40, h: 320 }, { x: 400, y: 80, w: 40, h: 320 },
      { x: 0, y: 200, w: 200, h: 40 }, { x: 440, y: 280, w: 200, h: 40 }
    ],
    enemies: [
      { x: 120, y: 120, r: 9, dx: 0, dy: 3.6, minY: 80, maxY: 400 },
      { x: 520, y: 400, r: 9, dx: 0, dy: -3.6, minY: 80, maxY: 400 },
      { x: 220, y: 120, r: 9, dx: 3.6, dy: 0, minX: 220, maxX: 380 },
      { x: 420, y: 400, r: 9, dx: -3.6, dy: 0, minX: 260, maxX: 580 },
      { x: 320, y: 240, r: 9, dx: 3.2, dy: 0, minX: 220, maxX: 420 }
    ],
    coins: [
      { x: 100, y: 60, r: 6, taken: false }, { x: 100, y: 420, r: 6, taken: false },
      { x: 540, y: 60, r: 6, taken: false }, { x: 540, y: 420, r: 6, taken: false },
      { x: 320, y: 240, r: 6, taken: false }
    ]
  }
];

const levels = [...baseLevels];

function generateAutoLevels() {
  for (let lvl = 11; lvl <= TOTAL_LEVELS; lvl++) {
    const progress = (lvl - 11) / (TOTAL_LEVELS - 11);
    const enemyCount = 4 + Math.floor(progress * 7); // 4~11
    const coinCount  = Math.floor(progress * 4);     // 0~4
    const speedBase  = 2 + progress * 3;             // 2~5

    const isHorizontal = (lvl % 2 === 1);
    const start = isHorizontal ? { x: 40, y: 240 } : { x: 320, y: 420 };
    const goal  = isHorizontal ? { x: 560, y: 220, w: 50, h: 80 } : { x: 320, y: 40, w: 50, h: 50 };

    const walls = [];
    const pad = 40 + 20 * (lvl % 3);
    walls.push({ x: 0, y: 0, w: 640, h: pad });
    walls.push({ x: 0, y: 480 - pad, w: 640, h: pad });

    // 자동 레벨도 “길이 막히지 않도록” 중앙 통로를 남기는 구조
    if (isHorizontal) {
      for (let i = 0; i < 3; i++) {
        walls.push({ x: 200 + i * 80, y: pad + 30 + (i % 2) * 80, w: 28, h: 150 });
        walls.push({ x: 200 + i * 80, y: 320 - (i % 2) * 60, w: 28, h: 60 });
      }
    } else {
      for (let i = 0; i < 3; i++) {
        const y = 130 + i * 70;
        walls.push({ x: 80, y, w: 190, h: 26 });
        walls.push({ x: 370, y, w: 190, h: 26 });
      }
    }

    const enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      const speed = speedBase + (i % 3) * 0.55;
      if (i % 2 === 0) {
        const yMin = pad + 20;
        const yMax = 480 - pad - 20;
        enemies.push({ x: 110 + (i * 43) % 420, y: (yMin + yMax) / 2, r: 8, dx: 0, dy: (i % 4 < 2 ? speed : -speed), minY: yMin, maxY: yMax });
      } else {
        const xMin = 70, xMax = 570;
        enemies.push({ x: (xMin + xMax) / 2, y: pad + 30 + (i * 29) % (480 - pad * 2 - 60), r: 8, dx: (i % 4 < 2 ? speed : -speed), dy: 0, minX: xMin, maxX: xMax });
      }
    }

    const coins = [];
    for (let i = 0; i < coinCount; i++) coins.push({ x: 140 + i * 120, y: 130 + ((i + lvl) % 3) * 110, r: 6, taken: false });

    levels.push({ start, goal, walls, enemies, coins });
  }
}
generateAutoLevels();

/* ==========================
   충돌/레벨 로드
   ========================== */
function rectIntersect(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function circleRectCollide(circle, rect) {
  const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
  const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
  const dx = circle.x - closestX;
  const dy = circle.y - closestY;
  return (dx * dx + dy * dy) < (circle.r * circle.r);
}
function updateTopUI() {
  levelDisplay.textContent = String(currentLevelIndex + 1);
  deathDisplay.textContent = String(deaths);
}
function loadLevel(index) {
  const level = levels[index];
  currentLevelIndex = index;

  player.x = level.start.x;
  player.y = level.start.y;
  player.startX = level.start.x;
  player.startY = level.start.y;

  goal = { ...level.goal };
  walls = level.walls.map(w => ({ ...w }));
  enemies = level.enemies.map(e => ({ ...e }));
  coins = level.coins.map(c => ({ ...c }));

  for (const k in keys) keys[k] = false;
  joystickVector.x = 0; joystickVector.y = 0; joystickActive = false;

  updateTopUI();
}

/* ==========================
   메뉴 UI
   ========================== */
function showOverlay(title, desc, buttons, gridMode=false) {
  panelTitle.textContent = title;
  panelDesc.textContent = desc || "";
  panelButtons.innerHTML = "";
  levelGrid.style.display = gridMode ? "grid" : "none";
  panelHint.textContent = "";

  buttons.forEach(btn => {
    const b = document.createElement("button");
    b.textContent = btn.text;
    if (btn.kind) b.classList.add(btn.kind);
    if (btn.disabled) b.disabled = true;
    b.addEventListener("click", btn.onClick);
    panelButtons.appendChild(b);
  });

  overlay.classList.add("show");
}
function hideOverlay() { overlay.classList.remove("show"); }

function openMainMenu() {
  mode = "menu";
  showOverlay(
    "메뉴",
    "레벨 선택/진행 저장/리셋을 할 수 있습니다.",
    [
      { text: "이어하기", kind: "primary", onClick: () => { hideOverlay(); startFromSavedOr1(); } },
      { text: "레벨 선택", onClick: () => openLevelSelect() },
      { text: "진행 저장", onClick: () => { saveProgress(); panelHint.textContent = "저장 완료."; } },
      { text: "진행 리셋", kind: "danger", onClick: () => { resetProgress(); openMainMenu(); } }
    ],
    false
  );
  panelHint.textContent = isMobile
    ? "모바일: 조이스틱 이동 · 메시지는 탭으로 진행"
    : "PC: 방향키 이동 · P 일시정지 · M 메뉴";
}

function openPauseMenu() {
  if (mode !== "playing") return;
  mode = "paused";
  showOverlay(
    "일시정지",
    "게임이 멈췄습니다.",
    [
      { text: "계속하기", kind: "primary", onClick: () => resumeFromPause() },
      { text: "레벨 선택", onClick: () => openLevelSelect() },
      { text: "메뉴", onClick: () => openMainMenu() }
    ],
    false
  );
  panelHint.textContent = isMobile ? "모바일: 버튼 탭" : "PC: P로도 재개 가능";
}
function resumeFromPause() { hideOverlay(); mode = "playing"; }

function startFromSavedOr1() {
  const idx = Math.min(unlockedUpTo, TOTAL_LEVELS - 1);
  loadLevel(idx);
  mode = "playing";
}

function openLevelSelect() {
  mode = "levelSelect";
  showOverlay(
    "레벨 선택",
    "클리어=초록 · 해금=파랑 · 잠김=회색",
    [
      { text: "뒤로", onClick: () => openMainMenu() },
      { text: "저장", onClick: () => { saveProgress(); panelHint.textContent = "저장 완료."; } }
    ],
    true
  );

  levelGrid.innerHTML = "";
  for (let i = 0; i < TOTAL_LEVELS; i++) {
    const btn = document.createElement("button");
    btn.className = "lvlBtn";
    btn.textContent = String(i + 1);

    const isCleared = cleared.has(i);
    const isUnlocked = i <= unlockedUpTo;

    btn.classList.add(isCleared ? "cleared" : (isUnlocked ? "unlocked" : "locked"));
    btn.disabled = !isUnlocked;

    btn.addEventListener("click", () => {
      hideOverlay();
      loadLevel(i);
      mode = "playing";
    });

    levelGrid.appendChild(btn);
  }
  panelHint.textContent = "해금: 현재 " + (unlockedUpTo + 1) + "레벨까지";
}

/* ==========================
   메시지 모드(클리어/완료)
   ========================== */
function openMessage(text, nextAction) {
  mode = "message";
  messageText = text;
  messageNextAction = nextAction || null;
}
function closeMessageAndContinue() {
  if (mode !== "message") return;
  const action = messageNextAction;
  messageText = "";
  messageNextAction = null;
  mode = "playing";
  if (action) action();
}

/* ==========================
   게임 루프
   ========================== */
function movePlayerWithCollision(vx, vy) {
  if (vx !== 0) {
    player.x += vx;
    for (const w of walls) {
      if (rectIntersect(player, w)) player.x = (vx > 0) ? (w.x - player.w) : (w.x + w.w);
    }
  }
  if (vy !== 0) {
    player.y += vy;
    for (const w of walls) {
      if (rectIntersect(player, w)) player.y = (vy > 0) ? (w.y - player.h) : (w.y + w.h);
    }
  }
  player.x = Math.max(0, Math.min(DESIGN_WIDTH - player.w, player.x));
  player.y = Math.max(0, Math.min(DESIGN_HEIGHT - player.h, player.y));
}

function update() {
  if (mode !== "playing") return;

  let vx = 0, vy = 0;
  if (isMobile && joystickActive) {
    vx = joystickVector.x * player.speed;
    vy = joystickVector.y * player.speed;
  } else {
    if (keys["ArrowUp"]) vy -= player.speed;
    if (keys["ArrowDown"]) vy += player.speed;
    if (keys["ArrowLeft"]) vx -= player.speed;
    if (keys["ArrowRight"]) vx += player.speed;
  }

  movePlayerWithCollision(vx, vy);

  for (const e of enemies) {
    e.x += e.dx || 0;
    e.y += e.dy || 0;
    if (e.minX !== undefined && (e.x < e.minX || e.x > e.maxX)) e.dx *= -1;
    if (e.minY !== undefined && (e.y < e.minY || e.y > e.maxY)) e.dy *= -1;
  }

  for (const e of enemies) {
    if (circleRectCollide(e, player)) {
      deaths++;
      deathDisplay.textContent = String(deaths);
      player.x = player.startX;
      player.y = player.startY;
      break;
    }
  }

  for (const c of coins) {
    if (c.taken) continue;
    const dx = (player.x + player.w / 2) - c.x;
    const dy = (player.y + player.h / 2) - c.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < c.r + Math.min(player.w, player.h) / 2) c.taken = true;
  }

  const allCoinsTaken = coins.every(c => c.taken);
  if (rectIntersect(player, goal) && allCoinsTaken) {
    cleared.add(currentLevelIndex);
    unlockedUpTo = Math.max(unlockedUpTo, Math.min(TOTAL_LEVELS - 1, currentLevelIndex + 1));
    saveProgress();

    const nextIndex = currentLevelIndex + 1;
    if (nextIndex >= TOTAL_LEVELS) {
      openMessage(
        "축하합니다! 50레벨 모두 클리어!\nPC: Enter/Space 또는 클릭 · 모바일: 탭\n(메뉴로 이동합니다)",
        () => openMainMenu()
      );
    } else {
      openMessage(
        "레벨 " + (currentLevelIndex + 1) + " 클리어!\nPC: Space/Enter 또는 클릭 · 모바일: 탭",
        () => loadLevel(nextIndex)
      );
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);

  ctx.fillStyle = "#88dd88";
  ctx.fillRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);

  ctx.fillStyle = "#888888";
  for (const w of walls) ctx.fillRect(w.x, w.y, w.w, w.h);

  ctx.fillStyle = "#cccc00";
  ctx.fillRect(player.startX - 20, player.startY - 20, 40, 40);

  ctx.fillStyle = "#00aa00";
  ctx.fillRect(goal.x, goal.y, goal.w, goal.h);

  for (const c of coins) {
    if (c.taken) continue;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
    ctx.fillStyle = "#ffcc00";
    ctx.fill();
  }

  ctx.fillStyle = "#ff0000";
  ctx.fillRect(player.x, player.y, player.w, player.h);

  for (const e of enemies) {
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
    ctx.fillStyle = "#0077ff";
    ctx.fill();
  }

  // 메시지(캔버스 오버레이)
  if (mode === "message") {
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.fillRect(0, 0, DESIGN_WIDTH, DESIGN_HEIGHT);
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.font = "24px Arial";

    const lines = String(messageText || "").split("\n");
    let baseY = DESIGN_HEIGHT / 2 - (lines.length - 1) * 18;
    lines.forEach((line, i) => ctx.fillText(line, DESIGN_WIDTH / 2, baseY + i * 30));
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

/* 시작: 메뉴부터 */
updateTopUI();
openMainMenu();
loop();
</script>
</body>
</html>
