<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini City Tycoon: Pro Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #263238;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #263238;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .pointer-auto {
            pointer-events: auto;
        }

        /* ìƒë‹¨ ì •ë³´ì°½ */
        .top-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ìš°ì¸¡ ë„ë¡œ ì„ íƒ ë©”ë‰´ */
        .road-menu {
            position: absolute;
            right: 10px;
            top: 60px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .road-btn {
            width: 55px;
            height: 55px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            background: #fff;
            transition: all 0.2s;
        }
        
        .road-btn span { font-size: 20px; margin-bottom: 2px; }
        .road-btn:hover { background: #f0f0f0; }
        .road-btn.active { border-color: #2196F3; background: #E3F2FD; }

        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ë°” */
        .control-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(33, 33, 33, 0.9);
            padding: 10px;
            border-radius: 24px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .main-btn {
            background: #eee;
            border: none;
            padding: 10px 20px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: bold;
            color: #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 80px;
            justify-content: center;
        }

        .main-btn.active { background: #FFC107; color: #000; }
        .main-btn.move-mode.active { background: #4CAF50; color: white; }
        .main-btn.erase-mode.active { background: #F44336; color: white; }

        /* ê±´ì„¤ í™•ì¸ íŒì—… */
        #confirm-popup {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: none;
            flex-direction: column;
            gap: 10px;
            text-align: center;
            z-index: 20;
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popUp {
            from { transform: translateX(-50%) scale(0.8); opacity: 0; }
            to { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        .popup-buttons { display: flex; gap: 10px; justify-content: center; }
        .pop-btn { padding: 8px 16px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
        .btn-yes { background: #4CAF50; color: white; }
        .btn-no { background: #F44336; color: white; }

        .zoom-controls {
            position: absolute; right: 10px; bottom: 100px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .zoom-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: white; border: none; font-size: 20px; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .float-text {
            position: absolute; font-weight: bold; font-size: 20px; pointer-events: none;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        
        #instruction {
            position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            background: white; padding: 20px; border-radius: 10px; max-width: 320px;
            text-align: center; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="top-panel pointer-auto">
            <div class="info-box">
                <span>ğŸ’°</span>
                <span id="moneyDisplay">1000</span>
            </div>
            <div class="info-box">
                <span>ğŸ‘·</span>
                <span id="scoreDisplay">0</span>
            </div>
        </div>

        <!-- ë„ë¡œ ì„ íƒ ë©”ë‰´ -->
        <div class="road-menu pointer-auto" id="roadMenu">
            <button class="road-btn active" onclick="setRoadType(1)">
                <span>ğŸ›£ï¸</span>ì¼ë°˜($10)
            </button>
            <button class="road-btn" onclick="setRoadType(2)">
                <span>ğŸš€</span>ê³ ì†($20)
            </button>
            <button class="road-btn" onclick="setRoadType(3)">
                <span>ğŸš¦</span>êµì°¨ë¡œ($30)
            </button>
            <button class="road-btn" onclick="setRoadType(4)">
                <span>ğŸ”„</span>íšŒì „($50)
            </button>
        </div>

        <div class="zoom-controls pointer-auto">
            <button class="zoom-btn" onclick="gameInstance.zoomIn()">+</button>
            <button class="zoom-btn" onclick="gameInstance.zoomOut()">-</button>
        </div>

        <div class="control-bar pointer-auto">
            <button class="main-btn active" id="btn-build" onclick="setMode('build')">
                ğŸš§ ê±´ì„¤
            </button>
            <button class="main-btn move-mode" id="btn-move" onclick="setMode('move')">
                âœ‹ ì´ë™
            </button>
            <button class="main-btn erase-mode" id="btn-erase" onclick="setMode('erase')">
                ğŸ§¹ ì² ê±°
            </button>
        </div>

        <div id="confirm-popup" class="pointer-auto">
            <div id="popup-msg">ê±´ì„¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
            <div style="font-weight:bold; color:#E91E63; margin-bottom:5px;" id="popup-cost">ë¹„ìš©: $0</div>
            <div class="popup-buttons">
                <button class="pop-btn btn-yes" onclick="gameInstance.confirmBuild()">í™•ì¸</button>
                <button class="pop-btn btn-no" onclick="gameInstance.cancelBuild()">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <div id="instruction" class="pointer-auto">
        <h3>ğŸ™ï¸ ì‹œí‹° íƒ€ì´ì¿¤ í”„ë¡œ</h3>
        <p style="text-align:left; font-size:13px; color:#555; line-height:1.6;">
            1. <strong>ì¸ì ‘ ì—°ê²°</strong>: ë„ë¡œë¥¼ ëŠì–´ ì§€ì–´ë„ ì˜†ì— ë„ë¡œê°€ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ì—°ê²°ë©ë‹ˆë‹¤.<br>
            2. <strong>êµ¬ì¡°ë¬¼ ë°°ì¹˜</strong>: êµì°¨ë¡œì™€ íšŒì „êµì°¨ë¡œëŠ” ë“œë˜ê·¸ê°€ ì•„ë‹Œ <strong>í´ë¦­í•˜ì—¬ ë°°ì¹˜</strong>í•©ë‹ˆë‹¤.<br>
            3. <strong>ê³ ì†ë„ë¡œ ì—…ê·¸ë ˆì´ë“œ</strong>: ì¼ë°˜ ë„ë¡œ ìœ„ì— ê³ ì†ë„ë¡œë¥¼ ì§€ìœ¼ë©´ ê¸°ì¡´ ë„ë¡œëŠ” <strong>ìë™ íŒë§¤</strong>ë©ë‹ˆë‹¤.<br>
            4. <strong>ìƒ‰ìƒ ë§¤ì¹­</strong>: ì§‘ê³¼ ê°™ì€ ìƒ‰ì˜ íšŒì‚¬ë¡œë§Œ ì¶œê·¼í•©ë‹ˆë‹¤.
        </p>
        <button onclick="document.getElementById('instruction').style.display='none'" style="padding:10px 20px; background:#2196F3; color:white; border:none; border-radius:5px; cursor:pointer;">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script>
    const TILE_SIZE = 40;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;
    const SALARY = 5;
    const INIT_MONEY = 1000;
    const WORK_DURATION = 300;

    const ROAD_TYPES = {
        1: { name: 'ì¼ë°˜ ë„ë¡œ', cost: 10, speed: 1.0, color: '#546e7a', type: 'drag' },
        2: { name: 'ê³ ì†ë„ë¡œ', cost: 20, speed: 2.0, color: '#37474F', type: 'drag' },
        3: { name: 'êµì°¨ë¡œ', cost: 30, speed: 0.8, color: '#607D8B', type: 'stamp', w:1, h:1 },
        4: { name: 'íšŒì „êµì°¨ë¡œ', cost: 50, speed: 1.2, color: '#78909C', type: 'stamp', w:2, h:2 }
    };

    const TYPE = { EMPTY: 0, ROAD: 1, HOUSE: 2, COMPANY: 3, COMPANY_PART: 4 };
    const TEAM_COLORS = ['#ef5350', '#42a5f5', '#fdd835'];

    const STATE = {
        IDLE: 0, TO_WORK: 1, PARKING: 2, TO_ENTRANCE: 3, 
        WORKING: 4, TO_CAR: 5, TO_HOME: 6, RESTING: 7
    };

    const DIRS = [
        {dx:0,dy:-1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1},
        {dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1}
    ];

    let gameInstance = null;
    let currentMode = 'build';
    let selectedRoadType = 1;

    function setMode(mode) {
        currentMode = mode;
        document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${mode}`).classList.add('active');
        document.getElementById('roadMenu').style.display = (mode === 'build') ? 'flex' : 'none';
        if (gameInstance) gameInstance.resetInteraction();
    }

    function setRoadType(type) {
        selectedRoadType = type;
        document.querySelectorAll('.road-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.road-btn')[type-1].classList.add('active');
    }

    class Game {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.money = INIT_MONEY;
            this.trips = 0;
            this.camera = { x: 0, y: 0, zoom: 1.0 };
            
            this.grid = [];
            this.agents = [];
            this.buildings = [];
            
            this.isDragging = false;
            this.dragStart = null;
            this.dragEnd = null;
            this.previewPath = [];
            this.waitingConfirm = false;
            
            this.lastMouse = {x:0, y:0};
            this.isPanDragging = false;
            this.stampPos = null; // êµ¬ì¡°ë¬¼ ê±´ì„¤ìš© ì¢Œí‘œ

            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            this.initGrid();
            this.spawnInitialBuildings();
            this.addInputListeners();
            
            this.updateUI();
            this.loop();
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera.x === 0) {
                this.camera.x = (this.canvas.width - GRID_WIDTH*TILE_SIZE)/2;
                this.camera.y = (this.canvas.height - GRID_HEIGHT*TILE_SIZE)/2;
            }
        }

        initGrid() {
            for(let x=0; x<GRID_WIDTH; x++) {
                this.grid[x] = [];
                for(let y=0; y<GRID_HEIGHT; y++) {
                    this.grid[x][y] = { 
                        type: TYPE.EMPTY, 
                        roadType: 0, 
                        isFixedRoad: false,
                        connections: new Array(8).fill(false) 
                    };
                }
            }
        }

        spawnInitialBuildings() {
            this.spawnBuilding(TYPE.HOUSE, 0);   
            this.spawnBuilding(TYPE.COMPANY, 0); 
            this.spawnBuilding(TYPE.HOUSE, 1);   
            this.spawnBuilding(TYPE.COMPANY, 1); 
        }

        addInputListeners() {
            const getPos = (e) => e.touches ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY};
            
            const start = (e) => {
                if (this.waitingConfirm) return;
                const p = getPos(e);
                this.handleStart(p.x, p.y, e.button === 2);
            };
            const move = (e) => {
                if (this.waitingConfirm) return;
                const p = getPos(e);
                this.handleMove(p.x, p.y);
            };
            const end = () => {
                if (this.waitingConfirm) return;
                this.handleEnd();
            };

            this.canvas.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', end);
            this.canvas.addEventListener('touchstart', (e)=>{e.preventDefault(); start(e);}, {passive:false});
            window.addEventListener('touchmove', (e)=>{e.preventDefault(); move(e);}, {passive:false});
            window.addEventListener('touchend', end);
            this.canvas.addEventListener('contextmenu', e=>e.preventDefault());
            
             this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const newZoom = this.camera.zoom - Math.sign(e.deltaY) * 0.1;
                this.setZoom(newZoom, e.clientX, e.clientY);
            }, {passive: false});
        }

        screenToGrid(sx, sy) {
            const wx = (sx - this.camera.x) / this.camera.zoom;
            const wy = (sy - this.camera.y) / this.camera.zoom;
            return { x: Math.floor(wx/TILE_SIZE), y: Math.floor(wy/TILE_SIZE) };
        }

        handleStart(x, y, isRight) {
            this.lastMouse = {x, y};
            if (currentMode === 'move' || isRight) {
                this.isPanDragging = true;
                return;
            }
            const g = this.screenToGrid(x, y);
            if (!this.isValid(g.x, g.y)) return;

            // ì§‘ íšŒì „
            const cell = this.grid[g.x][g.y];
            if (cell.type === TYPE.HOUSE && cell.ref) {
                this.rotateBuilding(cell.ref);
                return;
            }

            // ê±´ì„¤ ëª¨ë“œ ë¶„ê¸° (ë“œë˜ê·¸ vs ìŠ¤íƒ¬í”„)
            const rInfo = ROAD_TYPES[selectedRoadType];
            
            if (currentMode === 'build' && rInfo.type === 'stamp') {
                // ìŠ¤íƒ¬í”„ ëª¨ë“œ: í´ë¦­ ì‹œì ì˜ ì¢Œí‘œë¥¼ ì €ì¥í•˜ê³  ì¦‰ì‹œ í™•ì¸ íŒì—…
                this.stampPos = g;
                this.previewPath = []; // íŒ¨ìŠ¤ ëŒ€ì‹  stampPos ì‚¬ìš©
                this.showConfirmPopup();
            } else {
                // ë“œë˜ê·¸ ëª¨ë“œ (ì¼ë°˜/ê³ ì†ë„ë¡œ/ì² ê±°)
                this.isDragging = true;
                this.dragStart = g;
                this.dragEnd = g;
                this.updateDragPath();
            }
        }

        handleMove(x, y) {
            if (this.isPanDragging) {
                this.camera.x += x - this.lastMouse.x;
                this.camera.y += y - this.lastMouse.y;
                this.lastMouse = {x, y};
                return;
            }

            const g = this.screenToGrid(x, y);
            
            // ìŠ¤íƒ¬í”„ ëª¨ë“œì¼ ë•ŒëŠ” ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë§Œ ì¶”ì í•˜ì—¬ í”„ë¦¬ë·° ë Œë”ë§ì— ì‚¬ìš©
            if (currentMode === 'build' && ROAD_TYPES[selectedRoadType].type === 'stamp') {
                this.stampPos = g;
                return;
            }

            if (this.isDragging) {
                if (this.isValid(g.x, g.y) && (g.x !== this.dragEnd.x || g.y !== this.dragEnd.y)) {
                    this.dragEnd = g;
                    this.updateDragPath();
                }
            }
        }

        handleEnd() {
            this.isPanDragging = false;
            if (this.isDragging) {
                this.isDragging = false;
                if (this.previewPath.length > 0) {
                    this.showConfirmPopup();
                }
            }
        }

        updateDragPath() {
            this.previewPath = [];
            if (!this.dragStart || !this.dragEnd) return;
            const x0 = this.dragStart.x, y0 = this.dragStart.y;
            const x1 = this.dragEnd.x, y1 = this.dragEnd.y;
            const dx = x1-x0, dy = y1-y0;
            const dist = Math.max(Math.abs(dx), Math.abs(dy));
            for(let i=0; i<=dist; i++) {
                const t = (dist===0) ? 0 : i/dist;
                this.previewPath.push({ x: Math.round(x0 + dx*t), y: Math.round(y0 + dy*t) });
            }
        }

        showConfirmPopup() {
            let cost = 0;
            let msg = "";
            let valid = false;

            if (currentMode === 'build') {
                const rInfo = ROAD_TYPES[selectedRoadType];
                if (rInfo.type === 'stamp') {
                    // ìŠ¤íƒ¬í”„ ëª¨ë“œ ë¹„ìš© (1íšŒ)
                    // ìœ íš¨ì„± ê²€ì‚¬ (ë¹ˆ ë•… í˜¹ì€ ë„ë¡œì¸ì§€)
                    let w=rInfo.w, h=rInfo.h;
                    let canBuild = true;
                    if(this.stampPos) {
                        for(let i=0; i<w; i++) for(let j=0; j<h; j++) {
                            const nx=this.stampPos.x+i, ny=this.stampPos.y+j;
                            if(!this.isValid(nx,ny)) { canBuild=false; break; }
                            const c=this.grid[nx][ny];
                            if(c.type!==TYPE.EMPTY && c.type!==TYPE.ROAD) { canBuild=false; break; }
                        }
                    }
                    if(canBuild) {
                        cost = rInfo.cost;
                        msg = `${rInfo.name} ê±´ì„¤`;
                        valid = true;
                    }
                } else {
                    // ë“œë˜ê·¸ ëª¨ë“œ ë¹„ìš©
                    this.previewPath.forEach(p => {
                        const cell = this.grid[p.x][p.y];
                        if (cell.type === TYPE.EMPTY) {
                            cost += rInfo.cost;
                            valid = true;
                        } else if (cell.type === TYPE.ROAD && !cell.isFixedRoad) {
                             // ê¸°ì¡´ ë„ë¡œ ìœ„ì— ë®ì–´ì“°ê¸° (ì—…ê·¸ë ˆì´ë“œ)
                             if (cell.roadType !== selectedRoadType) {
                                 cost += rInfo.cost - 5; // ìƒˆ ë¹„ìš© - í™˜ë¶ˆ
                                 valid = true;
                             }
                        }
                    });
                    msg = `${rInfo.name} ê±´ì„¤`;
                }
            } else if (currentMode === 'erase') {
                this.previewPath.forEach(p => {
                    const c = this.grid[p.x][p.y];
                    if (c.type === TYPE.ROAD && !c.isFixedRoad) {
                        cost -= 5; 
                        valid = true;
                    }
                });
                msg = "ë„ë¡œ ì² ê±°";
            }

            if (!valid) { this.cancelBuild(); return; }

            this.waitingConfirm = true;
            document.getElementById('popup-msg').innerText = msg;
            document.getElementById('popup-cost').innerText = cost > 0 ? `ë¹„ìš©: $${cost}` : `í™˜ë¶ˆ: +$${Math.abs(cost)}`;
            document.getElementById('popup-cost').style.color = cost > 0 ? '#E91E63' : '#4CAF50';
            document.getElementById('confirm-popup').style.display = 'flex';
        }

        confirmBuild() {
            let totalCost = 0;
            let changed = false;
            const rInfo = ROAD_TYPES[selectedRoadType];

            // 1. ìŠ¤íƒ¬í”„ ê±´ì„¤ (êµì°¨ë¡œ, íšŒì „êµì°¨ë¡œ)
            if (currentMode === 'build' && rInfo.type === 'stamp' && this.stampPos) {
                if (this.money >= rInfo.cost) {
                    this.money -= rInfo.cost;
                    totalCost += rInfo.cost;
                    for(let i=0; i<rInfo.w; i++) for(let j=0; j<rInfo.h; j++) {
                        const nx=this.stampPos.x+i, ny=this.stampPos.y+j;
                        const cell = this.grid[nx][ny];
                        if(cell.type===TYPE.ROAD && !cell.isFixedRoad) this.money += 5; // ê¸°ì¡´ ë„ë¡œ í™˜ë¶ˆ
                        cell.type = TYPE.ROAD;
                        cell.roadType = selectedRoadType;
                        cell.connections.fill(true); // êµ¬ì¡°ë¬¼ ë‚´ë¶€ëŠ” ëª¨ë‘ ì—°ê²°
                        this.refreshConnections(nx, ny);
                    }
                    changed = true;
                }
            }
            // 2. ë“œë˜ê·¸ ê±´ì„¤/ì² ê±°
            else if (this.previewPath.length > 0) {
                this.previewPath.forEach(p => {
                    const cell = this.grid[p.x][p.y];
                    if (currentMode === 'build') {
                        if (cell.type === TYPE.EMPTY || (cell.type === TYPE.ROAD && !cell.isFixedRoad && cell.roadType !== selectedRoadType)) {
                             // ë¹„ìš© ì²´í¬
                             let cost = rInfo.cost;
                             let refund = 0;
                             if(cell.type === TYPE.ROAD) refund = 5;
                             
                             if (this.money + refund >= cost) {
                                 this.money = this.money + refund - cost;
                                 totalCost += (cost - refund);
                                 cell.type = TYPE.ROAD;
                                 cell.roadType = selectedRoadType;
                                 changed = true;
                                 // ì¸ì ‘ ì—°ê²°
                                 this.refreshConnections(p.x, p.y);
                             }
                        }
                    } else if (currentMode === 'erase') {
                        if (cell.type === TYPE.ROAD && !cell.isFixedRoad) {
                            cell.type = TYPE.EMPTY;
                            cell.connections.fill(false);
                            this.money += 5;
                            totalCost -= 5;
                            changed = true;
                            this.disconnectNeighbors(p.x, p.y);
                        }
                    }
                });
            }

            if (changed) {
                const center = (currentMode==='build' && rInfo.type==='stamp') ? this.gridToScreen(this.stampPos.x, this.stampPos.y) : this.gridToScreen(this.previewPath[0].x, this.previewPath[0].y);
                if (totalCost > 0) this.showFloatText(`-$${totalCost}`, center.x, center.y, '#E91E63');
                else if (totalCost < 0) this.showFloatText(`+$${Math.abs(totalCost)}`, center.x, center.y, '#4CAF50');
                
                this.triggerCommute();
            }

            this.resetInteraction();
            this.updateUI();
        }

        cancelBuild() { this.resetInteraction(); }
        
        resetInteraction() {
            this.previewPath = [];
            this.stampPos = null;
            this.waitingConfirm = false;
            document.getElementById('confirm-popup').style.display = 'none';
        }

        // ì¸ì ‘ ë„ë¡œ ìë™ ì—°ê²° ë¡œì§
        refreshConnections(x, y) {
            const cell = this.grid[x][y];
            if(cell.type !== TYPE.ROAD) return;
            
            // 8ë°©í–¥ ì²´í¬
            for(let i=0; i<8; i++) {
                const nx=x+DIRS[i].dx, ny=y+DIRS[i].dy;
                if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                    // ì„œë¡œ ì—°ê²°
                    cell.connections[i] = true;
                    this.grid[nx][ny].connections[(i+4)%8] = true;
                }
            }
        }
        
        disconnectNeighbors(x, y) {
            for(let i=0; i<8; i++) {
                const nx=x+DIRS[i].dx, ny=y+DIRS[i].dy;
                if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                    this.grid[nx][ny].connections[(i+4)%8] = false;
                }
            }
        }

        // --- ì—ì´ì „íŠ¸/ê±´ë¬¼ ---
        spawnBuilding(type, colorIdx = -1) {
            let placed = false, attempts=0;
            const w = (type===TYPE.COMPANY)?4:1;
            const h = (type===TYPE.COMPANY)?3:1;
            while(!placed && attempts<100) {
                attempts++;
                const x = Math.floor(Math.random()*(GRID_WIDTH-2-w))+1;
                const y = Math.floor(Math.random()*(GRID_HEIGHT-2-h))+1;
                let ok = true;
                for(let i=-1; i<=w; i++) for(let j=-1; j<=h; j++) {
                    const cx=x+i, cy=y+j;
                    if(cx>=0 && cy>=0 && cx<GRID_WIDTH && cy<GRID_HEIGHT) {
                        if(this.grid[cx][cy].type !== TYPE.EMPTY) ok=false;
                    }
                }
                if(ok) {
                    const cIdx = (colorIdx === -1) ? Math.floor(Math.random()*3) : colorIdx;
                    const b = { x,y,type,w,h, color: TEAM_COLORS[cIdx], colorIdx: cIdx, rotation:0, parkingSlots:[], entranceRoadPos:null };
                    for(let i=0;i<w;i++) for(let j=0;j<h;j++) this.grid[x+i][y+j] = { type:(i===0&&j===0)?type:TYPE.COMPANY_PART, ref:b, connections:[], roadType:0 };
                    this.setupEntrance(b);
                    if(type===TYPE.COMPANY) this.setupParking(b);
                    else {
                        b.entrance={x:0.5, y:0.5};
                        this.agents.push(this.createAgent(b));
                    }
                    this.buildings.push(b);
                    placed=true;
                }
            }
        }

        setupEntrance(b) {
            // [ìˆ˜ì •] ê¸°ì¡´ ë„ë¡œ ì œê±° ë¡œì§ (ì”ìƒ í•´ê²°)
            if (b.entranceRoadPos) {
                const ox = b.entranceRoadPos.x, oy = b.entranceRoadPos.y;
                if (this.isValid(ox, oy)) {
                    const old = this.grid[ox][oy];
                    // ê³ ì • ë„ë¡œì˜€ê³  ë‹¤ë¥¸ ì—°ê²°ì´ ì—†ë‹¤ë©´ ì‚­ì œ. ì—°ê²°ì´ ìˆì–´ë„ ì§‘ íšŒì „ì´ë‹ˆ ëŠì–´ì•¼ í•¨.
                    if (old.isFixedRoad) {
                        old.type = TYPE.EMPTY;
                        old.connections.fill(false);
                        this.disconnectNeighbors(ox, oy); // ì£¼ë³€ ì—°ê²° ëŠê¸°
                    }
                }
            }

            let rx, ry;
            if (b.type === TYPE.COMPANY) { rx=b.x+1; ry=b.y+3; }
            else {
                if(b.rotation===0){rx=b.x;ry=b.y+1;}
                else if(b.rotation===1){rx=b.x-1;ry=b.y;}
                else if(b.rotation===2){rx=b.x;ry=b.y-1;}
                else {rx=b.x+1;ry=b.y;}
            }

            if (this.isValid(rx,ry)) {
                const cell = this.grid[rx][ry];
                if(cell.type===TYPE.EMPTY) { 
                    cell.type=TYPE.ROAD; 
                    cell.roadType=1; 
                    cell.connections.fill(false); 
                }
                cell.isFixedRoad=true;
                b.entranceRoadPos={x:rx, y:ry};
                this.refreshConnections(rx, ry); // ìƒˆ ìœ„ì¹˜ ì—°ê²°
            }
        }

        setupParking(b) {
            b.entranceLocal = {x:1, y:2.8};
            b.parkingSlots = [];
            [{x:2.5,y:0.5},{x:3.5,y:0.5},{x:2.5,y:1.5},{x:3.5,y:1.5},{x:2.5,y:2.5},{x:3.5,y:2.5}].forEach(p=>{
                b.parkingSlots.push({rx:p.x, ry:p.y, occupiedBy:null});
            });
        }

        rotateBuilding(b) {
            b.rotation = (b.rotation + 1) % 4;
            this.setupEntrance(b);
            // íšŒì „ í›„ ê²½ë¡œ ì¬íƒìƒ‰ íŠ¸ë¦¬ê±°
            this.triggerCommute();
        }

        triggerCommute() {
            this.agents.forEach(a => {
                if (a.state === STATE.IDLE || (a.state === STATE.TO_WORK && a.path.length === 0)) {
                    if(a.work) this.planRoute(a, a.work, STATE.TO_WORK);
                }
            });
        }

        createAgent(home) {
            return {
                x: home.x+0.5, y: home.y+0.5,
                home: home, work: null, color: home.color, colorIdx: home.colorIdx,
                state: STATE.IDLE, path: [], pathIndex: 0,
                speed: 0, maxSpeed: 0.1, walking: false, targetSlot: null, angle: 0, workTimer: 0
            };
        }

        planRoute(a, dest, mode) {
            if (mode === STATE.TO_WORK && dest.colorIdx !== a.colorIdx) return;
            let start = (mode===STATE.TO_WORK) ? a.home.entranceRoadPos : a.work.entranceRoadPos;
            let target = (mode===STATE.TO_WORK) ? dest.entranceRoadPos : dest.entranceRoadPos; // ì§‘ ì…êµ¬ ë„ë¡œë¡œ
            if(!start || !target) return;

            let slot = null;
            if (mode === STATE.TO_WORK) {
                slot = dest.parkingSlots.find(s => !s.occupiedBy);
                if (!slot) return;
                slot.occupiedBy = a;
                a.targetSlot = slot;
            }

            const path = this.findPath(start.x, start.y, target.x, target.y);
            if(path) {
                a.path = path;
                a.pathIndex = 0;
                a.state = mode;
                if(mode===STATE.TO_WORK) { a.x=start.x+0.5; a.y=start.y+0.5; a.walking=false; }
            } else {
                if(slot) { slot.occupiedBy = null; a.targetSlot = null; }
            }
        }

        findPath(sx, sy, tx, ty) {
            const startNode = {x:sx, y:sy};
            const open = [{x:sx, y:sy, g:0, h:0, f:0, p:null}];
            const closed = new Set();
            while(open.length > 0) {
                open.sort((a,b)=>a.f-b.f);
                const curr = open.shift();
                if(curr.x===tx && curr.y===ty) {
                    const path=[]; let t=curr;
                    while(t){path.unshift({x:t.x,y:t.y}); t=t.p;}
                    return path;
                }
                const k = `${curr.x},${curr.y}`;
                if(closed.has(k)) continue;
                closed.add(k);

                for(let i=0; i<8; i++) {
                    if(!this.grid[curr.x][curr.y].connections[i]) continue;
                    const nx=curr.x+DIRS[i].dx, ny=curr.y+DIRS[i].dy;
                    if(this.isValid(nx,ny) && !closed.has(`${nx},${ny}`)) {
                        const cell = this.grid[nx][ny];
                        const rType = ROAD_TYPES[cell.roadType] || ROAD_TYPES[1];
                        const dist = (i%2===0)?1:1.414;
                        const weight = dist / rType.speed; 
                        const g = curr.g + weight;
                        const h = Math.hypot(nx-tx, ny-ty);
                        open.push({x:nx, y:ny, g, h, f:g+h, p:curr});
                    }
                }
            }
            return null;
        }

        update() {
             // ìë™ ê±´ë¬¼ ìƒì„± (ê°€ë”)
            if(Math.random()<0.002 && this.buildings.length<40) {
                this.spawnBuilding(Math.random()>0.6?TYPE.COMPANY:TYPE.HOUSE);
            }
            this.agents.forEach(a => {
                switch(a.state) {
                    case STATE.IDLE:
                        if (!a.work) {
                            const comps = this.buildings.filter(b => b.type===TYPE.COMPANY && b.colorIdx===a.colorIdx);
                            if(comps.length>0) a.work = comps[Math.floor(Math.random()*comps.length)];
                        }
                        if(a.work) this.planRoute(a, a.work, STATE.TO_WORK);
                        break;
                    case STATE.TO_WORK:
                        this.moveCar(a);
                        if(a.pathIndex >= a.path.length) a.state = STATE.PARKING;
                        break;
                    case STATE.PARKING:
                        const s = a.targetSlot;
                        const tx = a.work.x+s.rx, ty = a.work.y+s.ry;
                        if(Math.hypot(tx-a.x, ty-a.y) < 0.1) {
                            a.x=tx; a.y=ty; a.state = STATE.TO_ENTRANCE; a.walking = true;
                        } else {
                            a.x += (tx-a.x)*0.08; a.y += (ty-a.y)*0.08;
                            a.angle = Math.atan2(ty-a.y, tx-a.x);
                        }
                        break;
                    case STATE.TO_ENTRANCE:
                        const ex = a.work.x+a.work.entranceLocal.x, ey = a.work.y+a.work.entranceLocal.y;
                        this.moveWalk(a, ex, ey, STATE.WORKING);
                        break;
                    case STATE.WORKING:
                        a.workTimer++;
                        if(a.workTimer > WORK_DURATION) {
                            a.workTimer=0; a.state = STATE.TO_CAR; a.walking = true;
                        }
                        break;
                    case STATE.TO_CAR:
                        const cx = a.work.x+a.targetSlot.rx, cy = a.work.y+a.targetSlot.ry;
                        this.moveWalk(a, cx, cy, STATE.TO_HOME);
                        break;
                    case STATE.TO_HOME:
                        if(a.path.length===0) { a.walking=false; this.planRoute(a, a.home, STATE.TO_HOME); }
                        this.moveCar(a);
                        if(a.path.length>0 && a.pathIndex>=a.path.length) {
                            if(a.targetSlot) { a.targetSlot.occupiedBy=null; a.targetSlot=null; }
                            a.state = STATE.RESTING;
                            this.money += SALARY; this.trips++; this.updateUI();
                            const sc = this.gridToScreen(a.x, a.y);
                            this.showFloatText(`+$${SALARY}`, sc.x, sc.y, '#4CAF50');
                        }
                        break;
                    case STATE.RESTING:
                        a.workTimer++;
                        if(a.workTimer > 100) { a.workTimer=0; a.state = STATE.IDLE; }
                        break;
                }
            });
        }

        moveCar(a) {
            if(!a.path || !a.path[a.pathIndex]) return;
            const t = a.path[a.pathIndex];
            const rType = this.grid[t.x][t.y].roadType || 1;
            const speed = a.maxSpeed * ROAD_TYPES[rType].speed;
            const dx = t.x+0.5 - a.x, dy = t.y+0.5 - a.y;
            const d = Math.hypot(dx, dy);
            if(d < speed) { a.x=t.x+0.5; a.y=t.y+0.5; a.pathIndex++; }
            else { a.x += (dx/d)*speed; a.y += (dy/d)*speed; a.angle = Math.atan2(dy, dx); }
        }

        moveWalk(a, tx, ty, next) {
            const dx=tx-a.x, dy=ty-a.y;
            const d=Math.hypot(dx,dy);
            if(d<0.05) { a.x=tx; a.y=ty; a.state=next; if(next===STATE.TO_HOME) a.path=[]; }
            else { a.x += (dx/d)*0.03; a.y += (dy/d)*0.03; }
        }

        draw() {
            this.ctx.fillStyle = '#a5d6a7';
            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
            this.ctx.save();
            this.ctx.translate(this.camera.x, this.camera.y);
            this.ctx.scale(this.camera.zoom, this.camera.zoom);

            this.ctx.fillStyle = '#81c784';
            this.ctx.fillRect(0,0,GRID_WIDTH*TILE_SIZE, GRID_HEIGHT*TILE_SIZE);

            // ë„ë¡œ & ê±´ë¬¼
            for(let x=0; x<GRID_WIDTH; x++) for(let y=0; y<GRID_HEIGHT; y++) {
                if(this.grid[x][y].type === TYPE.ROAD) this.drawRoad(x, y);
            }
            this.buildings.forEach(b => this.drawBuilding(b));

            // ì—ì´ì „íŠ¸
            this.agents.forEach(a => {
                if(a.state !== STATE.IDLE && a.state !== STATE.RESTING) {
                    this.drawAgent(a);
                    if (a.state === STATE.TO_ENTRANCE || a.state === STATE.WORKING || a.state === STATE.TO_CAR) this.drawParkedCar(a);
                }
            });

            // í”„ë¦¬ë·° (ë“œë˜ê·¸ or ìŠ¤íƒ¬í”„)
            if (currentMode === 'build' || currentMode === 'erase') {
                const rInfo = ROAD_TYPES[selectedRoadType];
                if (currentMode==='build' && rInfo.type==='stamp' && this.stampPos) {
                     // ìŠ¤íƒ¬í”„ í”„ë¦¬ë·°
                     this.ctx.strokeStyle = 'rgba(0,255,0,0.8)';
                     this.ctx.lineWidth = 2;
                     this.ctx.strokeRect(this.stampPos.x*TILE_SIZE, this.stampPos.y*TILE_SIZE, rInfo.w*TILE_SIZE, rInfo.h*TILE_SIZE);
                     this.ctx.fillStyle = 'rgba(0,255,0,0.2)';
                     this.ctx.fillRect(this.stampPos.x*TILE_SIZE, this.stampPos.y*TILE_SIZE, rInfo.w*TILE_SIZE, rInfo.h*TILE_SIZE);
                } else if (this.previewPath.length > 0) {
                     // ë“œë˜ê·¸ í”„ë¦¬ë·°
                     this.ctx.fillStyle = (currentMode==='erase') ? 'rgba(244,67,54,0.5)' : 'rgba(33,150,243,0.5)';
                     this.previewPath.forEach(p => {
                         this.ctx.fillRect(p.x*TILE_SIZE, p.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                     });
                }
            }

            this.ctx.restore();
        }

        drawRoad(x, y) {
            const c = this.grid[x][y];
            const info = ROAD_TYPES[c.roadType] || ROAD_TYPES[1];
            const cx=x*TILE_SIZE+TILE_SIZE/2, cy=y*TILE_SIZE+TILE_SIZE/2;
            
            // ë„ë¡œ ì›í˜•
            this.ctx.fillStyle = info.color;
            let radius = TILE_SIZE*0.4;
            // íšŒì „êµì°¨ë¡œëŠ” ë” í¬ê²Œ ê·¸ë¦¬ê¸° (ì‹œê°ì )
            if (c.roadType === 4) radius = TILE_SIZE * 0.5;

            this.ctx.beginPath(); this.ctx.arc(cx,cy,radius,0,Math.PI*2); this.ctx.fill();
            this.ctx.strokeStyle = info.color;
            this.ctx.lineWidth = TILE_SIZE * (c.roadType===4 ? 0.9 : 0.8);
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(c.connections[i]) {
                    this.ctx.moveTo(cx,cy);
                    this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.6, cy+DIRS[i].dy*TILE_SIZE*0.6);
                }
            }
            this.ctx.stroke();

            // ì°¨ì„  ë° ì¥ì‹
            this.ctx.strokeStyle = (c.roadType===2) ? '#FFEB3B' : 'rgba(255,255,255,0.4)';
            this.ctx.lineWidth = 2;
            if (c.roadType === 3) this.ctx.strokeStyle = 'white'; 
            
            // íšŒì „êµì°¨ë¡œëŠ” ì¤‘ì•™ ì„¬
            if(c.roadType===4) {
                 this.ctx.fillStyle = '#4CAF50';
                 this.ctx.beginPath(); this.ctx.arc(cx,cy,TILE_SIZE*0.2,0,Math.PI*2); this.ctx.fill();
            } else {
                 this.ctx.beginPath();
                 for(let i=0; i<8; i++) {
                     if(c.connections[i]) {
                         this.ctx.moveTo(cx,cy);
                         this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.5, cy+DIRS[i].dy*TILE_SIZE*0.5);
                     }
                 }
                 this.ctx.stroke();
            }
            
            // êµì°¨ë¡œ ì •ì§€ì„ 
            if(c.roadType===3) {
                this.ctx.fillStyle='#fff';
                this.ctx.fillRect(cx-4,cy-4,8,8);
            }
        }

        drawBuilding(b) {
            const bx=b.x*TILE_SIZE, by=b.y*TILE_SIZE;
            if(b.type===TYPE.HOUSE) {
                const cx=bx+TILE_SIZE/2, cy=by+TILE_SIZE/2;
                this.ctx.save();
                this.ctx.translate(cx,cy);
                this.ctx.rotate([0,0.5,1,1.5][b.rotation]*Math.PI);
                const s = TILE_SIZE*0.8;
                this.ctx.fillStyle='#fff'; this.ctx.fillRect(-s/2,-s/2,s,s);
                this.ctx.fillStyle=b.color; 
                this.ctx.beginPath();
                this.ctx.moveTo(-s/2-2,-s/2); this.ctx.lineTo(0,-s/2-10); this.ctx.lineTo(s/2+2,-s/2); this.ctx.fill();
                this.ctx.fillStyle='#795548'; this.ctx.fillRect(-4,s/2-6,8,6);
                this.ctx.restore();
            } else {
                const bw=b.w*TILE_SIZE, bh=b.h*TILE_SIZE;
                this.ctx.fillStyle='#cfd8dc'; this.ctx.fillRect(bx,by,bw,bh);
                this.ctx.fillStyle='#eceff1'; this.ctx.fillRect(bx,by,bw*0.5-2, bh-2);
                this.ctx.fillStyle=b.color; this.ctx.fillRect(bx,by,bw*0.5-2, 10);
                const px=bx+bw*0.5, py=by;
                this.ctx.fillStyle='#90a4ae'; this.ctx.fillRect(px,py,bw*0.5-2, bh-2);
                this.ctx.strokeStyle='white'; this.ctx.lineWidth=1;
                b.parkingSlots.forEach(s => {
                    this.ctx.strokeRect((b.x+s.rx)*TILE_SIZE-12, (b.y+s.ry)*TILE_SIZE-8, 24, 16);
                });
            }
        }

        drawAgent(a) {
            const sx=a.x*TILE_SIZE, sy=a.y*TILE_SIZE;
            if(a.walking) {
                this.ctx.fillStyle='#333'; this.ctx.beginPath(); this.ctx.arc(sx,sy,4,0,Math.PI*2); this.ctx.fill();
                this.ctx.fillStyle=a.color; this.ctx.beginPath(); this.ctx.arc(sx,sy-3,3,0,Math.PI*2); this.ctx.fill();
            } else {
                this.ctx.save(); this.ctx.translate(sx,sy); this.ctx.rotate(a.angle);
                this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
                this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8);
                this.ctx.restore();
            }
        }

        drawParkedCar(a) {
            if(!a.targetSlot) return;
            const sx = (a.work.x + a.targetSlot.rx) * TILE_SIZE;
            const sy = (a.work.y + a.targetSlot.ry) * TILE_SIZE;
            this.ctx.save(); this.ctx.translate(sx,sy);
            this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
            this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8);
            this.ctx.restore();
        }

        isValid(x, y) { return x>=0 && y>=0 && x<GRID_WIDTH && y<GRID_HEIGHT; }
        updateUI() {
            document.getElementById('moneyDisplay').innerText = this.money;
            document.getElementById('scoreDisplay').innerText = this.trips;
        }
        gridToScreen(gx, gy) {
            return { x: gx*TILE_SIZE*this.camera.zoom + this.camera.x, y: gy*TILE_SIZE*this.camera.zoom + this.camera.y };
        }
        zoomIn(){ this.setZoom(this.camera.zoom+0.2); }
        zoomOut(){ this.setZoom(this.camera.zoom-0.2); }
        setZoom(z) {
            const nz = Math.max(0.3, Math.min(z, 3.0));
            const cx = this.canvas.width/2, cy = this.canvas.height/2;
            const wx = (cx - this.camera.x)/this.camera.zoom;
            const wy = (cy - this.camera.y)/this.camera.zoom;
            this.camera.x = cx - wx*nz;
            this.camera.y = cy - wy*nz;
            this.camera.zoom = nz;
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
        
        showFloatText(txt, x, y, col) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            el.style.left = x+'px'; el.style.top = y+'px'; el.style.color = col;
            document.body.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
        }
    }

    window.onload = () => { gameInstance = new Game('gameCanvas'); };

</script>
</body>
</html>
