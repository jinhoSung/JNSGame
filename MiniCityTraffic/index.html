<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini City Traffic - Commute Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e5ec;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
            background-color: #fdfdfd;
            max-width: 98vw;
            max-height: 98vh;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        .score-board {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 6px;
            backdrop-filter: blur(4px);
            pointer-events: auto;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            min-width: 140px;
        }
        
        .status-row {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid #eee;
            font-size: 12px;
            color: #666;
        }

        #tip-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #FF9800;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: auto;
            transition: transform 0.2s, background 0.2s;
        }
        
        #tip-btn:hover {
            transform: scale(1.1);
            background: #F57C00;
        }

        .instruction {
            position: absolute;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 13px;
            pointer-events: none;
            text-align: left;
            line-height: 1.6;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            width: 300px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
            z-index: 101;
        }

        .instruction.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .key-highlight {
            color: #ffeb3b;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score-board">
            <div class="score-row">
                <span>ì¶œê·¼ ì™„ë£Œ:</span>
                <span id="scoreDisplay">0</span>
            </div>
            <div class="score-row">
                <span>ë„ë¡œ íƒ€ì¼:</span>
                <span id="tilesDisplay">100</span>
            </div>
            <div class="status-row" id="timeDisplay">
                ì‹œê°„: 08:00
            </div>
        </div>
    </div>

    <div id="tip-btn" onclick="toggleInstruction()">?</div>

    <div class="instruction" id="instruction">
        <span style="font-size:16px; font-weight:bold; color:#ffeb3b; display:block; margin-bottom:8px;">ğŸ™ï¸ ì‹œí‹° ë¼ì´í”„ ì—…ë°ì´íŠ¸</span>
        <span class="key-highlight">ì¢Œí´ë¦­ ë“œë˜ê·¸</span>: ë„ë¡œ ê±´ì„¤<br>
        <span class="key-highlight">ìš°í´ë¦­ ë“œë˜ê·¸</span>: ë„ë¡œ ì‚­ì œ<br>
        <span class="key-highlight">ê±´ë¬¼ í´ë¦­</span>: ê±´ë¬¼ íšŒì „<br>
        <hr style="border-color:#555; margin:8px 0;">
        ğŸš— <strong>ì¶œí‡´ê·¼ ì‹œìŠ¤í…œ</strong><br>
        ì£¼ë¯¼ë“¤ì€ ì§‘ì—ì„œ ë‚˜ì™€ íšŒì‚¬ ì£¼ì°¨ì¥ì— ì£¼ì°¨í•˜ê³ ,<br>
        ê±¸ì–´ì„œ íšŒì‚¬ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.<br>
        ì—…ë¬´ê°€ ëë‚˜ë©´ ë‹¤ì‹œ ì°¨ë¥¼ íƒ€ê³  ì§‘ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.<br>
        <span style="color:#aaa; font-size:11px;">(ì£¼ì°¨ì¥ ì…êµ¬ì— ë„ë¡œë¥¼ ì—°ê²°í•´ì£¼ì„¸ìš”!)</span>
    </div>
</div>

<script>
    function toggleInstruction() {
        const el = document.getElementById('instruction');
        el.classList.toggle('show');
    }

    const TILE_SIZE = 30; 
    const GRID_WIDTH = 40; 
    const GRID_HEIGHT = 28; 
    
    const TYPE = {
        EMPTY: 0,
        ROAD: 1,
        HOUSE: 2,
        COMPANY: 3,       // íšŒì‚¬ ë³¸ê´€
        COMPANY_PART: 4   // íšŒì‚¬ ë¶€ì† (ì£¼ì°¨ì¥ ë“±)
    };

    const COLORS = {
        RED: '#ef5350',
        BLUE: '#42a5f5',
        YELLOW: '#ffee58',
        ROAD: '#546e7a',
        ROAD_Preview: 'rgba(84, 110, 122, 0.5)',
        PARKING_LOT: '#b0bec5',
        GRASS: '#f1f8e9'
    };

    const AGENT_STATE = {
        IDLE_HOME: 0,
        DRIVING_TO_WORK: 1,
        PARKING: 2,
        WALKING_TO_ENTRANCE: 3,
        WORKING: 4,
        WALKING_TO_CAR: 5,
        DRIVING_HOME: 6
    };

    const DIRS = [
        { dx: 0, dy: -1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 0 }, { dx: 1, dy: 1 },
        { dx: 0, dy: 1 }, { dx: -1, dy: 1 }, { dx: -1, dy: 0 }, { dx: -1, dy: -1 }
    ];

    class Game {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.canvas.width = GRID_WIDTH * TILE_SIZE;
            this.canvas.height = GRID_HEIGHT * TILE_SIZE;

            this.grid = []; 
            this.agents = []; 
            this.buildings = []; 
            this.particles = []; 

            this.score = 0;
            this.roadTiles = 250;
            this.gameTime = 8 * 60; // 08:00 ì‹œì‘
            
            this.isDragging = false;
            this.dragStart = null; 
            this.dragEnd = null;   
            this.dragPath = [];    
            this.isErasing = false;

            this.tickCount = 0;
            
            this.init();
            this.addEventListeners();
            this.loop();
        }

        init() {
            for (let x = 0; x < GRID_WIDTH; x++) {
                this.grid[x] = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    this.grid[x][y] = { 
                        type: TYPE.EMPTY, 
                        connections: new Array(8).fill(false)
                    };
                }
            }
            // ì´ˆê¸° ê±´ë¬¼: ì§‘ 2ì±„, íšŒì‚¬ 1ì±„
            this.spawnBuilding(TYPE.HOUSE);
            this.spawnBuilding(TYPE.HOUSE);
            this.spawnBuilding(TYPE.COMPANY);
        }

        // 4x3 í¬ê¸°ì˜ íšŒì‚¬ (ê±´ë¬¼ 2x3 + ì£¼ì°¨ì¥ 2x3)
        spawnBuilding(type) {
            let placed = false;
            let attempts = 0;
            
            // í¬ê¸° ì •ì˜
            // HOUSE: 1x1
            // COMPANY: 4x3 (ì™¼ìª½ 2x3: ê±´ë¬¼, ì˜¤ë¥¸ìª½ 2x3: ì£¼ì°¨ì¥)
            const width = (type === TYPE.COMPANY) ? 4 : 1;
            const height = (type === TYPE.COMPANY) ? 3 : 1;

            while (!placed && attempts < 200) {
                attempts++;
                const x = Math.floor(Math.random() * (GRID_WIDTH - 2 - width)) + 1;
                const y = Math.floor(Math.random() * (GRID_HEIGHT - 2 - height)) + 1;

                // ê³µê°„ í™•ì¸
                let canPlace = true;
                for(let i=-1; i<=width; i++) { // ì£¼ë³€ 1ì¹¸ ì—¬ìœ 
                    for(let j=-1; j<=height; j++) {
                        const cx = x+i, cy = y+j;
                        if (cx >=0 && cx < GRID_WIDTH && cy >=0 && cy < GRID_HEIGHT) {
                            if (this.grid[cx][cy].type !== TYPE.EMPTY) canPlace = false;
                        }
                    }
                }

                if (canPlace) {
                    const colorKey = Object.keys(COLORS)[Math.floor(Math.random() * 3)]; // RED, BLUE, YELLOW
                    
                    // ê±´ë¬¼ ë°ì´í„° ìƒì„±
                    const building = { 
                        x, y, type, 
                        width, height,
                        color: COLORS[colorKey],
                        rotation: 0, // 0: ê¸°ë³¸, 1: 90ë„, 2: 180ë„, 3: 270ë„
                        parkingSlots: [],
                        entrance: { x: 0, y: 0 } // ìƒëŒ€ ì¢Œí‘œ
                    };

                    // ê·¸ë¦¬ë“œ ì ìœ 
                    for(let i=0; i<width; i++) {
                        for(let j=0; j<height; j++) {
                            this.grid[x+i][y+j] = {
                                type: (i===0 && j===0) ? type : TYPE.COMPANY_PART, // ê¸°ì¤€ì ë§Œ Main Type
                                ref: building, // ê±´ë¬¼ ì°¸ì¡°
                                connections: new Array(8).fill(false)
                            };
                        }
                    }

                    // íšŒì‚¬ì¼ ê²½ìš° ì£¼ì°¨ ìŠ¬ë¡¯ê³¼ ì…êµ¬ ì„¤ì •
                    if (type === TYPE.COMPANY) {
                        this.setupCompanyLayout(building);
                    } else {
                        // ì§‘ ì…êµ¬ëŠ” ì¤‘ì•™
                        building.entrance = { x: 0.5, y: 0.5 };
                        // ì§‘ ìƒì„± ì‹œ ê±°ì£¼ì ìƒì„±
                        this.agents.push(this.createAgent(building));
                    }
                    
                    this.buildings.push(building);
                    placed = true;
                    this.createParticles(x * TILE_SIZE + width*TILE_SIZE/2, y * TILE_SIZE + height*TILE_SIZE/2, building.color);
                }
            }
        }

        setupCompanyLayout(b) {
            // 4x3 êµ¬ì¡°
            // [ê±´ë¬¼][ê±´ë¬¼][ì£¼ì°¨][ì£¼ì°¨]
            // [ê±´ë¬¼][ê±´ë¬¼][ì£¼ì°¨][ì£¼ì°¨]
            // [ê±´ë¬¼][ê±´ë¬¼][ì£¼ì°¨][ì£¼ì°¨]
            
            // ì…êµ¬: ê±´ë¬¼ ë¶€ë¶„(ì™¼ìª½ 2x3)ì˜ í•˜ë‹¨ ì¤‘ì•™ -> (1, 2) íƒ€ì¼ì˜ ì•„ë˜ìª½
            // ì£¼ì°¨ ìŠ¬ë¡¯: ì˜¤ë¥¸ìª½ 2x3 ì˜ì—­ (ìƒëŒ€ì¢Œí‘œ x:2~3, y:0~2)
            
            b.entranceLocal = { x: 1, y: 2.8 }; // ë¡œì»¬ ì¢Œí‘œ (ê±´ë¬¼ ê¸°ì¤€)
            
            b.parkingSlots = [];
            // ì£¼ì°¨ì¥ ì¢Œí‘œ (ìƒëŒ€ ì¢Œí‘œ)
            const parkingRel = [
                {x: 2.5, y: 0.5}, {x: 3.5, y: 0.5},
                {x: 2.5, y: 1.5}, {x: 3.5, y: 1.5},
                {x: 2.5, y: 2.5}, {x: 3.5, y: 2.5}
            ];
            
            parkingRel.forEach(p => {
                b.parkingSlots.push({
                    rx: p.x, ry: p.y,
                    occupiedBy: null
                });
            });
        }

        createAgent(home) {
            return {
                x: home.x + 0.5,
                y: home.y + 0.5,
                home: home,
                work: null, // ë‚˜ì¤‘ì— í• ë‹¹
                state: AGENT_STATE.IDLE_HOME,
                path: [],
                pathIndex: 0,
                speed: 0,
                maxSpeed: 0.08,
                color: home.color,
                walking: false, // ë„ë³´ ëª¨ë“œ ì—¬ë¶€
                targetSlot: null, // í• ë‹¹ëœ ì£¼ì°¨ ìŠ¬ë¡¯
                timer: 0,
                angle: 0
            };
        }

        getGridPos(e) {
            const rect = this.canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) return {x, y};
            return null;
        }

        addEventListeners() {
            this.canvas.addEventListener('mousedown', (e) => {
                const pos = this.getGridPos(e);
                if (!pos) return;

                // ê±´ë¬¼ í´ë¦­ ì‹œ íšŒì „ (íšŒì‚¬ë§Œ)
                // í˜„ì¬ ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ íšŒì „ì€ ë¹„í™œì„±í™”í•˜ê±°ë‚˜ ë‚˜ì¤‘ì— ì¶”ê°€ (ë³µì¡ë„ ë°©ì§€)
                // ë„ë¡œ ê±´ì„¤ ë¡œì§
                this.isDragging = true;
                this.isErasing = e.button === 2;
                this.dragStart = pos;
                this.dragEnd = pos;
                this.updateDragPath();
            });

            this.canvas.addEventListener('mousemove', (e) => {
                if (this.isDragging) {
                    const pos = this.getGridPos(e);
                    if (pos) {
                        this.dragEnd = pos;
                        this.updateDragPath();
                    }
                }
            });

            window.addEventListener('mouseup', () => {
                if (this.isDragging) {
                    this.applyDragPath();
                    this.isDragging = false;
                    this.dragPath = [];
                }
            });

            this.canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        updateDragPath() {
            this.dragPath = [];
            if (!this.dragStart || !this.dragEnd) return;
            const x0 = this.dragStart.x, y0 = this.dragStart.y;
            const x1 = this.dragEnd.x, y1 = this.dragEnd.y;
            const dx = x1 - x0, dy = y1 - y0;
            const distance = Math.max(Math.abs(dx), Math.abs(dy));

            for (let i = 0; i <= distance; i++) {
                const t = (distance === 0) ? 0 : i / distance;
                const tx = Math.round(x0 + dx * t);
                const ty = Math.round(y0 + dy * t);
                if (this.isValid(tx, ty)) this.dragPath.push({x: tx, y: ty});
            }
        }

        applyDragPath() {
            let changed = false;
            this.dragPath.forEach((curr, i) => {
                const cell = this.grid[curr.x][curr.y];
                // ê±´ì„¤
                if (!this.isErasing) {
                    if (cell.type === TYPE.EMPTY && this.roadTiles > 0) {
                        cell.type = TYPE.ROAD;
                        this.roadTiles--;
                        changed = true;
                    }
                    // ì—°ê²° ì²˜ë¦¬
                    if (i > 0) {
                        const prev = this.dragPath[i-1];
                        const prevCell = this.grid[prev.x][prev.y];
                        if (cell.type === TYPE.ROAD && prevCell.type === TYPE.ROAD) {
                            const dx = curr.x - prev.x;
                            const dy = curr.y - prev.y;
                            const dirIdx = DIRS.findIndex(d => d.dx === dx && d.dy === dy);
                            if (dirIdx !== -1) {
                                prevCell.connections[dirIdx] = true;
                                cell.connections[(dirIdx + 4) % 8] = true;
                                changed = true;
                            }
                        }
                    }
                } 
                // ì‚­ì œ
                else {
                    if (cell.type === TYPE.ROAD) {
                        cell.type = TYPE.EMPTY;
                        cell.connections.fill(false);
                        this.roadTiles++;
                        changed = true;
                        // ì£¼ë³€ ì—°ê²° ëŠê¸°
                        for(let d=0; d<8; d++) {
                            const nx = curr.x + DIRS[d].dx;
                            const ny = curr.y + DIRS[d].dy;
                            if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                                this.grid[nx][ny].connections[(d+4)%8] = false;
                            }
                        }
                    }
                }
            });

            if (changed) {
                this.updateUI();
                // ë„ë¡œê°€ ë°”ë€Œë©´ ëª¨ë“  ì—ì´ì „íŠ¸ ê²½ë¡œ ì¬íƒìƒ‰
                this.agents.forEach(a => {
                    if (a.state === AGENT_STATE.DRIVING_TO_WORK) this.planRouteToWork(a);
                    if (a.state === AGENT_STATE.DRIVING_HOME) this.planRouteToHome(a);
                });
            }
        }

        isValid(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }

        updateUI() {
            document.getElementById('scoreDisplay').innerText = this.score;
            document.getElementById('tilesDisplay').innerText = this.roadTiles;
            
            const h = Math.floor(this.gameTime / 60) % 24;
            const m = Math.floor(this.gameTime % 60);
            document.getElementById('timeDisplay').innerText = 
                `ì‹œê°„: ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
        }

        // ê²½ë¡œ íƒìƒ‰ (A*)
        findPath(startX, startY, targetX, targetY) {
            // ëª©í‘œ ì§€ì ì€ ë„ë¡œê°€ ì•„ë‹ ìˆ˜ ìˆìŒ (ì£¼ì°¨ì¥ ì˜† ë„ë¡œë¥¼ ì°¾ì•„ì•¼ í•¨)
            // ë”°ë¼ì„œ targetX, targetY ì£¼ë³€ì˜ 'ë„ë¡œ'ë¥¼ ì‹¤ì œ ëª©í‘œë¡œ ì‚¼ì•„ì•¼ í•¨
            // ë§Œì•½ targetX, targetY ìì²´ê°€ ë„ë¡œë¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            
            let actualTarget = null;
            if (this.grid[targetX][targetY].type === TYPE.ROAD) {
                actualTarget = {x: targetX, y: targetY};
            } else {
                // ì£¼ë³€ ë„ë¡œ ê²€ìƒ‰
                let minD = Infinity;
                for(let i=0; i<8; i++) {
                    const nx = targetX + DIRS[i].dx;
                    const ny = targetY + DIRS[i].dy;
                    if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                        const d = Math.hypot(nx - startX, ny - startY);
                        if(d < minD) {
                            minD = d;
                            actualTarget = {x: nx, y: ny};
                        }
                    }
                }
            }

            if (!actualTarget) return null; // ê°ˆ ìˆ˜ ìˆëŠ” ë„ë¡œê°€ ì—†ìŒ

            // A* ì•Œê³ ë¦¬ì¦˜
            const startNode = { x: startX, y: startY, g: 0, h: 0, f: 0, parent: null };
            const openList = [startNode];
            const closedSet = new Set();

            while(openList.length > 0) {
                openList.sort((a,b) => a.f - b.f);
                const current = openList.shift();
                
                if (current.x === actualTarget.x && current.y === actualTarget.y) {
                    // ê²½ë¡œ ì¬êµ¬ì„±
                    const path = [];
                    let curr = current;
                    while(curr) {
                        path.unshift({x: curr.x, y: curr.y});
                        curr = curr.parent;
                    }
                    return path;
                }

                const key = `${current.x},${current.y}`;
                if (closedSet.has(key)) continue;
                closedSet.add(key);

                for(let i=0; i<8; i++) {
                    // í˜„ì¬ íƒ€ì¼ì—ì„œ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•¨
                    const cell = this.grid[current.x][current.y];
                    if (!cell.connections[i]) continue;

                    const nx = current.x + DIRS[i].dx;
                    const ny = current.y + DIRS[i].dy;

                    if (!this.isValid(nx, ny)) continue;
                    if (closedSet.has(`${nx},${ny}`)) continue;

                    const gScore = current.g + ((i%2===0)?1:1.414);
                    const hScore = Math.hypot(nx - actualTarget.x, ny - actualTarget.y);
                    
                    openList.push({
                        x: nx, y: ny,
                        g: gScore, h: hScore, f: gScore + hScore,
                        parent: current
                    });
                }
            }
            return null; // ê²½ë¡œ ì—†ìŒ
        }

        // ë¡œì§ ì—…ë°ì´íŠ¸
        update() {
            this.tickCount++;
            this.gameTime += 0.5; // ì‹œê°„ íë¦„ ì†ë„

            // ì£¼ê¸°ì ìœ¼ë¡œ ì§‘/íšŒì‚¬ ìƒì„± (ì´ˆë°˜ì—ë§Œ)
            if (this.tickCount % 600 === 0 && this.buildings.length < 15) {
                if (Math.random() > 0.7) this.spawnBuilding(TYPE.COMPANY);
                else this.spawnBuilding(TYPE.HOUSE);
                this.roadTiles += 10;
                this.updateUI();
            }

            const currentHour = Math.floor(this.gameTime / 60) % 24;

            this.agents.forEach(agent => {
                switch (agent.state) {
                    case AGENT_STATE.IDLE_HOME:
                        // ì•„ì¹¨ 7ì‹œ~9ì‹œ ì¶œê·¼
                        if (currentHour >= 7 && currentHour < 10) {
                            if (!agent.work) {
                                // ì§ì¥ ì°¾ê¸° (ê°€ì¥ ê°€ê¹Œìš´ íšŒì‚¬)
                                const companies = this.buildings.filter(b => b.type === TYPE.COMPANY);
                                if (companies.length > 0) {
                                    agent.work = companies[Math.floor(Math.random() * companies.length)];
                                }
                            }
                            
                            if (agent.work) {
                                this.planRouteToWork(agent);
                            }
                        }
                        break;

                    case AGENT_STATE.DRIVING_TO_WORK:
                        this.moveAgentCar(agent);
                        if (agent.pathIndex >= agent.path.length) {
                            // ë„ì°© -> ì£¼ì°¨ ëª¨ë“œ ì „í™˜
                            agent.state = AGENT_STATE.PARKING;
                        }
                        break;

                    case AGENT_STATE.PARKING:
                        // ë¶€ë“œëŸ½ê²Œ ì£¼ì°¨ ìŠ¬ë¡¯ìœ¼ë¡œ ì´ë™ (Lerp)
                        const slot = agent.targetSlot;
                        // slotì€ ìƒëŒ€ ì¢Œí‘œì´ë¯€ë¡œ ì ˆëŒ€ ì¢Œí‘œ ê³„ì‚°
                        const slotX = agent.work.x + slot.rx;
                        const slotY = agent.work.y + slot.ry;
                        
                        const pdx = slotX - agent.x;
                        const pdy = slotY - agent.y;
                        const pdist = Math.hypot(pdx, pdy);
                        
                        if (pdist < 0.1) {
                            agent.x = slotX;
                            agent.y = slotY;
                            agent.state = AGENT_STATE.WALKING_TO_ENTRANCE;
                            agent.walking = true;
                            // í•˜ì°¨ íš¨ê³¼
                        } else {
                            agent.x += pdx * 0.1;
                            agent.y += pdy * 0.1;
                            agent.angle = Math.atan2(pdy, pdx);
                        }
                        break;

                    case AGENT_STATE.WALKING_TO_ENTRANCE:
                        // íšŒì‚¬ ì…êµ¬ë¡œ ê±·ê¸° (ì§ì„  ì´ë™, ë„ë¡œ ë¬´ì‹œ)
                        const entX = agent.work.x + agent.work.entranceLocal.x;
                        const entY = agent.work.y + agent.work.entranceLocal.y;
                        this.moveAgentWalking(agent, entX, entY, AGENT_STATE.WORKING);
                        break;

                    case AGENT_STATE.WORKING:
                        // í‡´ê·¼ ì‹œê°„(18ì‹œ) ì²´í¬
                        if (currentHour >= 18) {
                            agent.state = AGENT_STATE.WALKING_TO_CAR;
                            agent.walking = true;
                            this.score++; // ì¶œê·¼ ì™„ë£Œ ì ìˆ˜ íšë“
                            this.updateUI();
                        }
                        break;

                    case AGENT_STATE.WALKING_TO_CAR:
                        // ì£¼ì°¨ëœ ì°¨ë¡œ ê±·ê¸°
                        const carX = agent.work.x + agent.targetSlot.rx;
                        const carY = agent.work.y + agent.targetSlot.ry;
                        this.moveAgentWalking(agent, carX, carY, AGENT_STATE.DRIVING_HOME);
                        break;

                    case AGENT_STATE.DRIVING_HOME:
                        // ì°¨ì— íƒ”ìœ¼ë‹ˆ ê²½ë¡œ ê³„ì‚°
                        if (agent.path.length === 0) {
                             this.planRouteToHome(agent);
                             agent.walking = false;
                        }
                        this.moveAgentCar(agent);
                        if (agent.path && agent.pathIndex >= agent.path.length) {
                            // ì§‘ ë„ì°©
                            agent.state = AGENT_STATE.IDLE_HOME;
                            // ì£¼ì°¨ ìŠ¬ë¡¯ í•´ì œ
                            if (agent.targetSlot) {
                                agent.targetSlot.occupiedBy = null;
                                agent.targetSlot = null;
                            }
                        }
                        break;
                }
            });

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.life--;
                p.x += p.vx;
                p.y += p.vy;
                if(p.life <= 0) this.particles.splice(i, 1);
            }
            
            this.updateUI();
        }

        planRouteToWork(agent) {
            // ë¹ˆ ì£¼ì°¨ ìŠ¬ë¡¯ ì°¾ê¸°
            const slots = agent.work.parkingSlots;
            let freeSlot = slots.find(s => !s.occupiedBy);
            
            if (!freeSlot) return; // ìë¦¬ ì—†ìŒ (ëŒ€ê¸°)

            freeSlot.occupiedBy = agent;
            agent.targetSlot = freeSlot;

            // ì£¼ì°¨ì¥ ìœ„ì¹˜ (ì ˆëŒ€ ì¢Œí‘œ)
            const tx = Math.floor(agent.work.x + freeSlot.rx);
            const ty = Math.floor(agent.work.y + freeSlot.ry);

            // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì£¼ì°¨ì¥ ê·¼ì²˜ ë„ë¡œê¹Œì§€ ê²½ë¡œ íƒìƒ‰
            const startX = Math.round(agent.x);
            const startY = Math.round(agent.y);
            
            const path = this.findPath(startX, startY, tx, ty);
            if (path) {
                agent.path = path;
                agent.pathIndex = 0;
                agent.state = AGENT_STATE.DRIVING_TO_WORK;
            } else {
                // ê²½ë¡œ ì—†ìœ¼ë©´ ìŠ¬ë¡¯ í•´ì œí•˜ê³  ëŒ€ê¸°
                freeSlot.occupiedBy = null;
                agent.targetSlot = null;
            }
        }

        planRouteToHome(agent) {
            const startX = Math.round(agent.x);
            const startY = Math.round(agent.y);
            const tx = Math.floor(agent.home.x);
            const ty = Math.floor(agent.home.y);
            
            const path = this.findPath(startX, startY, tx, ty);
            if (path) {
                agent.path = path;
                agent.pathIndex = 0;
                agent.state = AGENT_STATE.DRIVING_HOME;
            }
        }

        moveAgentCar(agent) {
            if (!agent.path || agent.path.length === 0) return;

            const targetTile = agent.path[agent.pathIndex];
            if (!targetTile) return;

            const dx = targetTile.x + 0.5 - agent.x; // íƒ€ì¼ ì¤‘ì•™ ëª©í‘œ
            const dy = targetTile.y + 0.5 - agent.y;
            const dist = Math.hypot(dx, dy);

            if (dist < agent.maxSpeed) {
                agent.x = targetTile.x + 0.5;
                agent.y = targetTile.y + 0.5;
                agent.pathIndex++;
            } else {
                agent.x += (dx / dist) * agent.maxSpeed;
                agent.y += (dy / dist) * agent.maxSpeed;
                agent.angle = Math.atan2(dy, dx);
            }
        }

        moveAgentWalking(agent, tx, ty, nextState) {
            const dx = tx - agent.x;
            const dy = ty - agent.y;
            const dist = Math.hypot(dx, dy);
            const walkSpeed = 0.03; // ê±·ëŠ” ì†ë„

            if (dist < walkSpeed) {
                agent.x = tx;
                agent.y = ty;
                agent.state = nextState;
                if (nextState === AGENT_STATE.DRIVING_HOME) {
                    // ì°¨ì— íƒ€ë©´ ê²½ë¡œ ì´ˆê¸°í™” í•„ìš”
                    agent.path = [];
                }
            } else {
                agent.x += (dx / dist) * walkSpeed;
                agent.y += (dy / dist) * walkSpeed;
            }
        }

        createParticles(x, y, color) {
            for(let i=0; i<8; i++) {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 20 + Math.random() * 20,
                    color: color
                });
            }
        }

        draw() {
            // ë°°ê²½
            this.ctx.fillStyle = COLORS.GRASS;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // ê·¸ë¦¬ë“œ
            this.ctx.strokeStyle = '#e0e0e0';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            for(let x=0; x<=GRID_WIDTH; x++) {
                this.ctx.moveTo(x*TILE_SIZE, 0);
                this.ctx.lineTo(x*TILE_SIZE, this.canvas.height);
            }
            for(let y=0; y<=GRID_HEIGHT; y++) {
                this.ctx.moveTo(0, y*TILE_SIZE);
                this.ctx.lineTo(this.canvas.width, y*TILE_SIZE);
            }
            this.ctx.stroke();

            // ë„ë¡œ ê·¸ë¦¬ê¸°
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    if (this.grid[x][y].type === TYPE.ROAD) {
                        this.drawRoadTile(x, y);
                    }
                }
            }

            // ê±´ë¬¼ ê·¸ë¦¬ê¸°
            this.buildings.forEach(b => {
                this.drawBuilding(b);
            });

            // ì—ì´ì „íŠ¸ ê·¸ë¦¬ê¸°
            this.agents.forEach(agent => {
                if (agent.state === AGENT_STATE.WORKING || agent.state === AGENT_STATE.IDLE_HOME) return; // ì•ˆë³´ì„
                
                const sx = agent.x * TILE_SIZE;
                const sy = agent.y * TILE_SIZE;

                if (agent.walking) {
                    // ë³´í–‰ì (ë™ê·¸ë¼ë¯¸)
                    this.ctx.fillStyle = '#333';
                    this.ctx.beginPath();
                    this.ctx.arc(sx, sy, 4, 0, Math.PI*2);
                    this.ctx.fill();
                    // ë¨¸ë¦¬
                    this.ctx.fillStyle = agent.color;
                    this.ctx.beginPath();
                    this.ctx.arc(sx, sy-2, 2, 0, Math.PI*2);
                    this.ctx.fill();
                } else {
                    // ìë™ì°¨
                    this.ctx.save();
                    this.ctx.translate(sx, sy);
                    this.ctx.rotate(agent.angle);
                    
                    this.ctx.fillStyle = agent.color;
                    this.ctx.fillRect(-7, -4, 14, 8); // ì°¨ì²´
                    
                    // ìœ ë¦¬ì°½
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(0, -3, 3, 6);
                    
                    this.ctx.restore();
                }
            });

            // ë“œë˜ê·¸ ë¯¸ë¦¬ë³´ê¸°
            if (this.isDragging && this.dragPath.length > 0) {
                this.ctx.fillStyle = this.isErasing ? 'rgba(239, 83, 80, 0.5)' : COLORS.ROAD_Preview;
                for (let p of this.dragPath) {
                    this.ctx.fillRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
            
            // íŒŒí‹°í´
            this.particles.forEach(p => {
                this.ctx.fillStyle = p.color;
                this.ctx.globalAlpha = p.life / 20;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1.0;
            });
        }

        drawBuilding(b) {
            const bx = b.x * TILE_SIZE;
            const by = b.y * TILE_SIZE;

            if (b.type === TYPE.HOUSE) {
                // ì§‘ (1x1)
                const cx = bx + TILE_SIZE/2;
                const cy = by + TILE_SIZE/2;
                const size = TILE_SIZE * 0.8;
                
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(cx - size/2, cy - size/2, size, size);
                
                // ì§€ë¶•
                this.ctx.fillStyle = b.color;
                this.ctx.beginPath();
                this.ctx.moveTo(cx - size/2 - 2, cy - size/2);
                this.ctx.lineTo(cx, cy - size/2 - 10);
                this.ctx.lineTo(cx + size/2 + 2, cy - size/2);
                this.ctx.fill();

                // ë¬¸ (ì¤‘ì•™)
                this.ctx.fillStyle = '#795548';
                this.ctx.fillRect(cx - 4, cy + size/2 - 8, 8, 8);

            } else if (b.type === TYPE.COMPANY) {
                // íšŒì‚¬ (4x3)
                // ì™¼ìª½ 2x3: ê±´ë¬¼
                const buildW = 2 * TILE_SIZE;
                const buildH = 3 * TILE_SIZE;
                
                // ê·¸ë¦¼ì
                this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                this.ctx.fillRect(bx + 5, by + 5, buildW, buildH);

                // ê±´ë¬¼ ë³¸ì²´
                this.ctx.fillStyle = '#eceff1';
                this.ctx.fillRect(bx, by, buildW - 2, buildH - 2);
                
                // ìœ ë¦¬ì°½ íŒ¨í„´
                this.ctx.fillStyle = b.color; 
                this.ctx.globalAlpha = 0.7;
                for(let i=0; i<3; i++) {
                    for(let j=0; j<8; j++) {
                        this.ctx.fillRect(bx + 10 + i*15, by + 10 + j*10, 10, 6);
                    }
                }
                this.ctx.globalAlpha = 1.0;

                // ì˜¤ë¥¸ìª½ 2x3: ì£¼ì°¨ì¥
                const parkX = bx + buildW;
                const parkW = 2 * TILE_SIZE;
                const parkH = 3 * TILE_SIZE;

                this.ctx.fillStyle = COLORS.PARKING_LOT;
                this.ctx.fillRect(parkX, by, parkW - 2, parkH - 2);

                // ì£¼ì°¨ ë¼ì¸
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 1;
                b.parkingSlots.forEach(slot => {
                    // slot.rx, ryëŠ” ì „ì²´ ê±´ë¬¼ ì›ì  ê¸°ì¤€
                    // í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                    const sx = (b.x + slot.rx) * TILE_SIZE;
                    const sy = (b.y + slot.ry) * TILE_SIZE;
                    
                    // ì£¼ì°¨ ì¹¸ í‘œì‹œ
                    this.ctx.strokeRect(sx - 10, sy - 6, 20, 12);
                });

                // ì…êµ¬ (ì •í™•í•œ ìœ„ì¹˜ ê·¸ë¦¬ê¸°)
                // b.entranceLocal = { x: 1, y: 2.8 }
                // í™”ë©´ ì¢Œí‘œ ê³„ì‚°
                const entScreenX = (b.x + b.entranceLocal.x) * TILE_SIZE;
                const entScreenY = (b.y + b.entranceLocal.y) * TILE_SIZE;
                
                // ì…êµ¬ ì°¨ì–‘ë§‰
                this.ctx.fillStyle = '#37474f';
                this.ctx.fillRect(entScreenX - 15, entScreenY - 5, 30, 5);
                
                // ë¬¸
                this.ctx.fillStyle = '#5d4037';
                this.ctx.fillRect(entScreenX - 8, entScreenY, 16, 10); // ì•„ë˜ë¡œ ì—´ë¦° ë¬¸
                
                // í…ìŠ¤íŠ¸
                this.ctx.fillStyle = 'white';
                this.ctx.font = '9px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText("ENTRANCE", entScreenX, entScreenY - 8);
            }
        }

        drawRoadTile(x, y) {
            const cx = x * TILE_SIZE + TILE_SIZE / 2;
            const cy = y * TILE_SIZE + TILE_SIZE / 2;
            const cell = this.grid[x][y];
            
            this.ctx.fillStyle = COLORS.ROAD;
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, TILE_SIZE * 0.35, 0, Math.PI*2);
            this.ctx.fill();

            this.ctx.strokeStyle = COLORS.ROAD;
            this.ctx.lineWidth = TILE_SIZE * 0.6; 
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(cell.connections[i]) {
                    this.ctx.moveTo(cx, cy);
                    this.ctx.lineTo(cx + DIRS[i].dx * TILE_SIZE * 0.6, cy + DIRS[i].dy * TILE_SIZE * 0.6);
                }
            }
            this.ctx.stroke();

            // ì¤‘ì•™ì„ 
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(cell.connections[i]) {
                    this.ctx.moveTo(cx, cy);
                    this.ctx.lineTo(cx + DIRS[i].dx * TILE_SIZE * 0.5, cy + DIRS[i].dy * TILE_SIZE * 0.5);
                }
            }
            this.ctx.stroke();
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    window.onload = () => {
        const game = new Game('gameCanvas');
    };

</script>
</body>
</html><!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini City Traffic - Advanced Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #e0e5ec;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
            background-color: #fdfdfd;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        .score-board {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 4px;
            backdrop-filter: blur(4px);
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            min-width: 120px;
        }

        /* íŒ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #tip-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: #FF9800;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: auto;
            transition: transform 0.2s, background 0.2s;
        }
        
        #tip-btn:hover {
            transform: scale(1.1);
            background: #F57C00;
        }

        /* ì„¤ëª…ì°½ */
        .instruction {
            position: absolute;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 13px;
            pointer-events: none;
            text-align: left;
            line-height: 1.6;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            width: 280px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
        }

        .instruction.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .key-highlight {
            color: #ffeb3b;
            font-weight: bold;
        }
        
        .title-text {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #ffeb3b;
            display: block;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="score-board">
            <div class="score-row">
                <span>ë°°ë‹¬:</span>
                <span id="scoreDisplay">0</span>
            </div>
            <div class="score-row">
                <span>íƒ€ì¼:</span>
                <span id="tilesDisplay">100</span>
            </div>
        </div>
    </div>

    <!-- Tip ë²„íŠ¼ -->
    <div id="tip-btn" onclick="toggleInstruction()">?</div>

    <!-- ì„¤ëª…ì°½ -->
    <div class="instruction" id="instruction">
        <span class="title-text">ğŸ® ì¡°ì‘ ë°©ë²•</span>
        <span class="key-highlight">ë“œë˜ê·¸</span>: ììœ ë¡œìš´ ì§ì„  ë„ë¡œ ê±´ì„¤<br>
        <span class="key-highlight">ìš°í´ë¦­ ë“œë˜ê·¸</span>: ë„ë¡œ ì‚­ì œ<br>
        <span class="key-highlight">í´ë¦­</span>: ê±´ë¬¼ íšŒì „<br>
        <br>
        ğŸ’¡ <strong>ì—…ë°ì´íŠ¸:</strong><br>
        - <strong>ìš°ì¸¡ í†µí–‰</strong> ì‹œìŠ¤í…œ ì ìš©<br>
        - êµì°¨ë¡œ ìˆœì°¨ ì§„ì… (ê¼¬ë¦¬ë¬¼ê¸° ë°©ì§€)<br>
        - ì•ì°¨ ê°„ê²© ìœ ì§€ ë° ì§ì‚¬ê°í˜• ì°¨ëŸ‰ ëª¨ë¸
    </div>
</div>

<script>
    function toggleInstruction() {
        const el = document.getElementById('instruction');
        el.classList.toggle('show');
    }

    const TILE_SIZE = 40;
    const GRID_WIDTH = 24;
    const GRID_HEIGHT = 18;
    
    const TYPE = {
        EMPTY: 0,
        ROAD: 1,
        HOUSE: 2,
        DESTINATION: 3
    };

    const COLORS = {
        RED: '#ef5350',
        BLUE: '#42a5f5',
        YELLOW: '#ffee58',
        ROAD: '#546e7a',
        ROAD_Preview: 'rgba(84, 110, 122, 0.5)',
        ROAD_LINE: '#cfd8dc'
    };

    const COLOR_KEYS = ['RED', 'BLUE', 'YELLOW'];

    // 8ë°©í–¥ (ì‹œê³„ë°©í–¥: ìƒ, ìš°ìƒ, ìš°, ìš°í•˜, í•˜, ì¢Œí•˜, ì¢Œ, ì¢Œìƒ)
    const DIRS = [
        { dx: 0, dy: -1 },  // 0: N
        { dx: 1, dy: -1 },  // 1: NE
        { dx: 1, dy: 0 },   // 2: E
        { dx: 1, dy: 1 },   // 3: SE
        { dx: 0, dy: 1 },   // 4: S
        { dx: -1, dy: 1 },  // 5: SW
        { dx: -1, dy: 0 },  // 6: W
        { dx: -1, dy: -1 }  // 7: NW
    ];

    // ê±´ë¬¼ íšŒì „ìš© (0, 1, 2, 3) -> DIRS ì¸ë±ìŠ¤ ë§¤í•‘ (0, 2, 4, 6)
    const ROTATION_TO_DIR = [0, 2, 4, 6];

    class Game {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.canvas.width = GRID_WIDTH * TILE_SIZE;
            this.canvas.height = GRID_HEIGHT * TILE_SIZE;

            this.grid = []; 
            this.cars = []; 
            this.buildings = []; 
            this.particles = []; 

            this.score = 0;
            this.roadTiles = 100;
            
            // ë“œë˜ê·¸ ê´€ë ¨ ìƒíƒœ
            this.isDragging = false;
            this.dragStart = null; 
            this.dragEnd = null;   
            this.dragPath = [];    
            this.isErasing = false;

            this.tickCount = 0;
            
            this.init();
            this.addEventListeners();
            this.loop();
        }

        init() {
            // ê·¸ë¦¬ë“œ ì´ˆê¸°í™”
            for (let x = 0; x < GRID_WIDTH; x++) {
                this.grid[x] = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    this.grid[x][y] = { 
                        type: TYPE.EMPTY, 
                        color: null, 
                        rotation: 0,
                        connections: new Array(8).fill(false)
                    };
                }
            }
            // ì´ˆê¸° ê±´ë¬¼
            this.spawnBuilding('RED', TYPE.HOUSE);
            this.spawnBuilding('RED', TYPE.DESTINATION);
        }

        spawnBuilding(colorKey, type) {
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                attempts++;
                const x = Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1;
                const y = Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1;

                if (this.grid[x][y].type === TYPE.EMPTY) {
                    const rotation = Math.floor(Math.random() * 4); // 0~3

                    this.grid[x][y] = { 
                        type: type, 
                        color: COLORS[colorKey], 
                        colorKey: colorKey,
                        rotation: rotation,
                        connections: new Array(8).fill(false)
                    };
                    
                    this.buildings.push({ 
                        x, y, type, 
                        color: COLORS[colorKey], 
                        colorKey: colorKey, 
                        spawnTimer: 0,
                        rotation: rotation
                    });
                    
                    placed = true;
                    this.createParticles(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2, COLORS[colorKey]);
                    this.recalculateAllTraffic();
                }
            }
        }

        addEventListeners() {
            this.canvas.addEventListener('mousedown', (e) => {
                const pos = this.getGridPos(e);
                if (!pos) return;

                // ê±´ë¬¼ í´ë¦­ (íšŒì „)
                if (e.button === 0 && (this.grid[pos.x][pos.y].type === TYPE.HOUSE || this.grid[pos.x][pos.y].type === TYPE.DESTINATION)) {
                    this.rotateBuilding(pos.x, pos.y);
                    return;
                }

                this.isDragging = true;
                this.isErasing = e.button === 2; // ìš°í´ë¦­ì€ ì‚­ì œ
                this.dragStart = pos;
                this.dragEnd = pos;
                this.updateDragPath();
            });

            this.canvas.addEventListener('mousemove', (e) => {
                if (this.isDragging) {
                    const pos = this.getGridPos(e);
                    if (pos) {
                        this.dragEnd = pos;
                        this.updateDragPath();
                    }
                }
            });

            window.addEventListener('mouseup', () => {
                if (this.isDragging) {
                    this.applyDragPath();
                    this.isDragging = false;
                    this.dragPath = [];
                    this.dragStart = null;
                    this.dragEnd = null;
                }
            });

            this.canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        getGridPos(e) {
            const rect = this.canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) return {x, y};
            return null;
        }

        rotateBuilding(x, y) {
            const cell = this.grid[x][y];
            cell.rotation = (cell.rotation + 1) % 4;
            const b = this.buildings.find(b => b.x === x && b.y === y);
            if(b) b.rotation = cell.rotation;
            this.recalculateAllTraffic();
        }

        // ë“œë˜ê·¸ ê²½ë¡œ ê³„ì‚° (ì§ì„  ë³´ê°„)
        updateDragPath() {
            this.dragPath = [];
            if (!this.dragStart || !this.dragEnd) return;

            const x0 = this.dragStart.x;
            const y0 = this.dragStart.y;
            const x1 = this.dragEnd.x;
            const y1 = this.dragEnd.y;

            const dx = x1 - x0;
            const dy = y1 - y0;
            const distance = Math.max(Math.abs(dx), Math.abs(dy));

            if (distance === 0) {
                this.dragPath.push({x: x0, y: y0});
                return;
            }

            for (let i = 0; i <= distance; i++) {
                const t = i / distance;
                const tx = Math.round(x0 + dx * t);
                const ty = Math.round(y0 + dy * t);
                
                if (this.dragPath.length > 0) {
                    const last = this.dragPath[this.dragPath.length - 1];
                    if (last.x === tx && last.y === ty) continue;
                }
                
                if (this.isValid(tx, ty)) {
                    this.dragPath.push({x: tx, y: ty});
                }
            }
        }

        applyDragPath() {
            if (this.dragPath.length < 1) return;

            let changed = false;

            for (let i = 0; i < this.dragPath.length; i++) {
                const curr = this.dragPath[i];
                const cell = this.grid[curr.x][curr.y];

                if (this.isErasing) {
                    if (cell.type === TYPE.ROAD) {
                        cell.type = TYPE.EMPTY;
                        cell.connections.fill(false);
                        this.roadTiles++;
                        for(let d=0; d<8; d++) {
                            const nx = curr.x + DIRS[d].dx;
                            const ny = curr.y + DIRS[d].dy;
                            if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                                const opposite = (d + 4) % 8;
                                this.grid[nx][ny].connections[opposite] = false;
                            }
                        }
                        changed = true;
                    }
                } else {
                    if (cell.type === TYPE.EMPTY && this.roadTiles > 0) {
                        cell.type = TYPE.ROAD;
                        this.roadTiles--;
                        changed = true;
                    }

                    if (i > 0 && cell.type === TYPE.ROAD) {
                        const prev = this.dragPath[i-1];
                        const prevCell = this.grid[prev.x][prev.y];
                        
                        if (prevCell.type === TYPE.ROAD) {
                            const dx = curr.x - prev.x;
                            const dy = curr.y - prev.y;
                            
                            let dirIndex = -1;
                            for (let d = 0; d < 8; d++) {
                                if (DIRS[d].dx === dx && DIRS[d].dy === dy) {
                                    dirIndex = d;
                                    break;
                                }
                            }

                            if (dirIndex !== -1) {
                                const opposite = (dirIndex + 4) % 8;
                                prevCell.connections[dirIndex] = true;
                                cell.connections[opposite] = true;
                                changed = true;
                            }
                        }
                    }
                }
            }

            if (changed) {
                this.updateUI();
                this.recalculateAllTraffic();
            }
        }

        isValid(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }

        updateUI() {
            document.getElementById('scoreDisplay').innerText = this.score;
            document.getElementById('tilesDisplay').innerText = this.roadTiles;
            document.getElementById('tilesDisplay').style.color = this.roadTiles <= 0 ? '#ef5350' : '#333';
        }

        recalculateAllTraffic() {
            this.cars.forEach(car => {
                const startX = Math.round(car.x);
                const startY = Math.round(car.y);
                const newPath = this.findPath(startX, startY, TYPE.DESTINATION, car.colorKey);
                
                if (newPath) {
                    car.path = newPath;
                    car.targetIndex = 0; 
                }
            });
        }

        // ê²½ë¡œ íƒìƒ‰
        findPath(startX, startY, targetType, targetColorKey) {
            if (!this.isValid(startX, startY)) return null;

            const queue = [{ x: startX, y: startY, path: [{x: startX, y: startY}], cost: 0 }];
            const visited = Array.from({ length: GRID_WIDTH }, () => Array(GRID_HEIGHT).fill(Infinity));
            visited[startX][startY] = 0;

            let bestPath = null;
            let minCost = Infinity;

            while (queue.length > 0) {
                queue.sort((a, b) => a.cost - b.cost);
                const current = queue.shift();
                const { x, y, path, cost } = current;

                if (cost > minCost) continue;

                const currentCell = this.grid[x][y];

                // ëª©ì ì§€ ì²´í¬
                for(let b of this.buildings) {
                    if (b.type === targetType && b.colorKey === targetColorKey) {
                        const dirIdx = ROTATION_TO_DIR[b.rotation];
                        const entX = b.x + DIRS[dirIdx].dx;
                        const entY = b.y + DIRS[dirIdx].dy;
                        if (x === entX && y === entY) {
                            if (cost < minCost) {
                                minCost = cost;
                                bestPath = path;
                            }
                        }
                    }
                }

                for (let i = 0; i < 8; i++) {
                    let canGo = false;
                    
                    if (currentCell.type === TYPE.ROAD) {
                        if (currentCell.connections[i]) canGo = true;
                    } else {
                        const building = this.buildings.find(b => b.x === x && b.y === y);
                        if (building && ROTATION_TO_DIR[building.rotation] === i) canGo = true;
                        if (!building && path.length === 1) canGo = true; 
                    }

                    if (canGo) {
                        const nx = x + DIRS[i].dx;
                        const ny = y + DIRS[i].dy;

                        if (this.isValid(nx, ny)) {
                            const nextCell = this.grid[nx][ny];
                            
                            if (nextCell.type === TYPE.ROAD || nextCell.type === targetType) {
                                const stepCost = (i % 2 !== 0) ? 1.414 : 1;
                                // íŠ¸ë˜í”½ íŒ¨ë„í‹° ê°ì†Œ (ìš°íšŒë³´ë‹¤ëŠ” ëŒ€ê¸°ê°€ ë‚˜ì„ ìˆ˜ ìˆìŒ)
                                const carsOnTile = this.cars.filter(c => Math.round(c.x) === nx && Math.round(c.y) === ny).length;
                                const trafficPenalty = carsOnTile * 1.5; 

                                const newCost = cost + stepCost + trafficPenalty;

                                if (newCost < visited[nx][ny]) {
                                    visited[nx][ny] = newCost;
                                    queue.push({ x: nx, y: ny, path: [...path, { x: nx, y: ny }], cost: newCost });
                                }
                            }
                        }
                    }
                }
            }
            return bestPath;
        }

        update() {
            this.tickCount++;

            if (this.tickCount % 300 === 0) {
                const randomColorKey = COLOR_KEYS[Math.floor(Math.random() * COLOR_KEYS.length)];
                if(Math.random() > 0.4) this.spawnBuilding(randomColorKey, TYPE.HOUSE);
                else this.spawnBuilding(randomColorKey, TYPE.DESTINATION);
                this.roadTiles += 5;
                this.updateUI();
            }

            // ê±´ë¬¼ì—ì„œ ì°¨ ìƒì„±
            this.buildings.forEach(b => {
                if (b.type === TYPE.HOUSE) {
                    b.spawnTimer++;
                    if (b.spawnTimer > 180) { 
                        const path = this.findPath(b.x, b.y, TYPE.DESTINATION, b.colorKey);
                        if (path) {
                            this.cars.push({
                                x: b.x, y: b.y, // ì´ˆê¸° ìœ„ì¹˜ëŠ” ê±´ë¬¼ ì„¼í„°
                                path: path,
                                targetIndex: 0,
                                color: b.color,
                                colorKey: b.colorKey,
                                finished: false,
                                speed: 0,
                                maxSpeed: 0.05 + Math.random() * 0.02,
                                angle: 0,
                                // ì‹¤ì œ ë Œë”ë§ ì¢Œí‘œ (ë¶€ë“œëŸ¬ìš´ ì´ë™ìš©)
                                displayX: b.x,
                                displayY: b.y
                            });
                            b.spawnTimer = 0;
                        }
                    }
                }
            });

            // ì°¨ëŸ‰ ì—…ë°ì´íŠ¸
            for (let i = this.cars.length - 1; i >= 0; i--) {
                const car = this.cars[i];
                if (!car.path || car.path.length === 0) continue;

                if (car.targetIndex === 0 && car.path.length > 1) car.targetIndex = 1;

                if (car.targetIndex >= car.path.length) {
                    car.finished = true;
                } else {
                    // ìš°ì¸¡ í†µí–‰ì„ ìœ„í•œ íƒ€ê²Ÿ ì¢Œí‘œ ê³„ì‚°
                    const currentTile = car.path[car.targetIndex - 1] || car.path[0];
                    const nextTile = car.path[car.targetIndex];
                    
                    // ê¸°ë³¸ ë°©í–¥ ë²¡í„°
                    let dx = nextTile.x - currentTile.x;
                    let dy = nextTile.y - currentTile.y;
                    const distTotal = Math.hypot(dx, dy);
                    
                    // ì •ê·œí™”
                    let dirX = dx / (distTotal || 1);
                    let dirY = dy / (distTotal || 1);

                    // ìš°ì¸¡ ë²¡í„° (90ë„ íšŒì „: x,y -> -y,x)
                    // í™”ë©´ ì¢Œí‘œê³„: x+ ìš°, y+ í•˜.
                    // (1,0) -> (0,1) : ìš°ì¸¡ ok
                    // (0,1) -> (-1,0) : ìš°ì¸¡ ok
                    let rightX = -dirY;
                    let rightY = dirX;

                    // ìš°ì¸¡ í†µí–‰ ì˜¤í”„ì…‹ (ë„ë¡œ í­ì˜ ì•½ 20%)
                    const offsetAmount = 0.25; 
                    
                    // ì‹¤ì œ ëª©í‘œ ì§€ì  (íƒ€ì¼ ì¤‘ì‹¬ + ìš°ì¸¡ ì˜¤í”„ì…‹)
                    const targetX = nextTile.x + rightX * offsetAmount;
                    const targetY = nextTile.y + rightY * offsetAmount;

                    // í˜„ì¬ ì°¨ì˜ ì‹¤ì œ ìœ„ì¹˜(íƒ€ì¼ ì¢Œí‘œê³„ + ì˜¤í”„ì…‹)ì—ì„œ ëª©í‘œê¹Œì§€ì˜ ê±°ë¦¬
                    const curDx = targetX - car.x;
                    const curDy = targetY - car.y;
                    const distRemaining = Math.hypot(curDx, curDy);

                    // --- ì•ˆì „ ê±°ë¦¬ ìœ ì§€ ë¡œì§ ---
                    let blocked = false;
                    let blockingCar = null;

                    // 1. ì•ì°¨ì™€ì˜ ê±°ë¦¬ í™•ì¸
                    for (let other of this.cars) {
                        if (car === other) continue;
                        
                        // ë¬¼ë¦¬ì  ê±°ë¦¬ (ë Œë”ë§ ì¢Œí‘œ ê¸°ì¤€ì´ ì•„ë‹ˆë¼ ë…¼ë¦¬ ì¢Œí‘œ ê¸°ì¤€)
                        const d = Math.hypot(car.x - other.x, car.y - other.y);
                        
                        // ê°ì§€ ë²”ìœ„ (ì•½ 0.8íƒ€ì¼)
                        if (d < 0.9) {
                            // ë‚´ ì§„í–‰ ë°©í–¥ì— ìˆëŠ”ì§€ í™•ì¸ (ë‚´ì )
                            const toOtherX = other.x - car.x;
                            const toOtherY = other.y - car.y;
                            const dot = dirX * toOtherX + dirY * toOtherY;
                            
                            // ë‚´ ì•ìª½(dot > 0)ì— ìˆê³  ê°€ê¹Œìš°ë©´ ì •ì²´ë¡œ íŒë‹¨
                            // ìš°ì¸¡í†µí–‰ì´ë¯€ë¡œ ë°˜ëŒ€í¸ ì°¨ì„  ì°¨ëŸ‰ì€ ë¬´ì‹œí•´ì•¼ í•¨ (dot productê°€ ë„ì™€ì¤Œ)
                            // dot > 0.5 (í™•ì‹¤íˆ ì „ë°©)
                            if (dot > 0.5) {
                                blocked = true;
                                blockingCar = other;
                                break;
                            }
                        }
                    }

                    // --- êµì°¨ë¡œ(íƒ€ì¼) ì§„ì… ì œì–´ ---
                    // ë‚´ê°€ ì§„ì…í•˜ë ¤ëŠ” íƒ€ì¼(nextTile)ì— ë‹¤ë¥¸ ì°¨ê°€ ìˆëŠ”ê°€? (ìˆœì°¨ í†µê³¼)
                    // ë‹¨, ë‚˜ë‘ ê°™ì€ ë°©í–¥ìœ¼ë¡œ ê°€ëŠ” ì°¨ëŠ” 'ì•ì°¨ ê±°ë¦¬' ë¡œì§ìœ¼ë¡œ ì²˜ë¦¬ë¨.
                    // ë‚˜ë‘ ë‹¤ë¥¸ ë°©í–¥(êµì°¨í•˜ëŠ”) ì°¨ê°€ ìˆì„ ë•Œë§Œ ë©ˆì¶°ì•¼ í•¨.
                    // íƒ€ì¼ ì§„ì… ì§ì „ (ê±°ë¦¬ 0.5 ë¯¸ë§Œ ë‚¨ì•˜ì„ ë•Œ) ê²€ì‚¬
                    if (distRemaining < 0.8 && !blocked) {
                        for (let other of this.cars) {
                            if (car === other) continue;
                            
                            // ìƒëŒ€ë°©ì´ ë‚´ê°€ ê°€ë ¤ëŠ” íƒ€ì¼(nextTile) ê·¼ì²˜ì— ìˆëŠ”ê°€?
                            const distToNext = Math.hypot(other.x - nextTile.x, other.y - nextTile.y);
                            
                            // êµì°¨ë¡œ ì ìœ  íŒë‹¨ (ì¤‘ì‹¬ë¶€ 0.6 ì´ë‚´)
                            if (distToNext < 0.6) {
                                // ìƒëŒ€ë°©ì˜ ì§„í–‰ ë°©í–¥ í™•ì¸
                                // nextTileì´ otherì˜ pathì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ë“±ìœ¼ë¡œ íŒë‹¨ ê°€ëŠ¥í•˜ì§€ë§Œ,
                                // ê°„ë‹¨í•˜ê²Œ: ìƒëŒ€ë°©ì´ ë‚´ê°€ ê°€ëŠ” ë°©í–¥ê³¼ "í¬ê²Œ ë‹¤ë¥´ë©´" ë©ˆì¶¤ (êµì°¨ ì°¨ëŸ‰)
                                // í˜¹ì€ ë‹¨ìˆœíˆ "êµì°¨ë¡œ ì•ˆì— ëˆ„êµ°ê°€ ìˆìœ¼ë©´ ì§„ì… ê¸ˆì§€" (ê°€ì¥ ì•ˆì „)
                                
                                // ì˜ˆì™¸: ê°™ì€ ë¼ì¸ì—ì„œ ë”°ë¼ê°€ëŠ” ê²½ìš° (ê±°ë¦¬ë‘ê¸°ë¡œ ì²˜ë¦¬ë¨)
                                const otherNextIndex = other.targetIndex;
                                if (other.path && otherNextIndex < other.path.length) {
                                    const oNext = other.path[otherNextIndex];
                                    if (oNext.x === nextTile.x && oNext.y === nextTile.y) {
                                        // ê°™ì€ íƒ€ì¼ì„ í–¥í•´ ê°€ê³  ìˆìŒ -> ìˆœì„œ ì–‘ë³´
                                        // ê±°ë¦¬ê°€ ë” ê°€ê¹Œìš´ ì°¨ê°€ ìš°ì„ 
                                        const otherDistRem = Math.hypot(nextTile.x - other.x, nextTile.y - other.y);
                                        if (otherDistRem < distRemaining) {
                                            blocked = true;
                                            break;
                                        }
                                    } else {
                                        // ì´ë¯¸ íƒ€ì¼ ì•ˆì— ìˆê±°ë‚˜ ë‹¤ë¥¸ ê³³ì—ì„œ ì§„ì… ì¤‘
                                        blocked = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if (blocked) {
                        // ê°ì†
                        car.speed *= 0.9;
                    } else {
                        // ê°€ì†
                        if (car.speed < car.maxSpeed) car.speed += 0.002;
                    }

                    // ì´ë™ ì‹¤í–‰
                    if (distRemaining <= car.speed) {
                        car.x = targetX;
                        car.y = targetY;
                        car.targetIndex++;
                    } else {
                        // ì´ë™ ë²¡í„°
                        car.x += (curDx / distRemaining) * car.speed;
                        car.y += (curDy / distRemaining) * car.speed;
                        
                        // íšŒì „ ê°ë„ ê³„ì‚°
                        car.angle = Math.atan2(curDy, curDx);
                    }
                    
                    // ë””ìŠ¤í”Œë ˆì´ ì¢Œí‘œ ì—…ë°ì´íŠ¸ (ë³´ê°„ ì—†ì´ ì§ì ‘ ì‚¬ìš©)
                    car.displayX = car.x;
                    car.displayY = car.y;
                }

                if (car.finished) {
                    this.score++;
                    this.updateUI();
                    this.createParticles(car.x * TILE_SIZE + TILE_SIZE/2, car.y * TILE_SIZE + TILE_SIZE/2, car.color);
                    this.cars.splice(i, 1);
                }
            }
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.life--;
                p.x += p.vx;
                p.y += p.vy;
                if(p.life <= 0) this.particles.splice(i, 1);
            }
        }

        createParticles(x, y, color) {
            for(let i=0; i<8; i++) {
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 20 + Math.random() * 20,
                    color: color
                });
            }
        }

        draw() {
            this.ctx.fillStyle = '#fdfdfd';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // ê·¸ë¦¬ë“œ ì„ 
            this.ctx.strokeStyle = '#f0f0f0';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            for(let x=0; x<=GRID_WIDTH; x++) {
                this.ctx.moveTo(x*TILE_SIZE, 0);
                this.ctx.lineTo(x*TILE_SIZE, this.canvas.height);
            }
            for(let y=0; y<=GRID_HEIGHT; y++) {
                this.ctx.moveTo(0, y*TILE_SIZE);
                this.ctx.lineTo(this.canvas.width, y*TILE_SIZE);
            }
            this.ctx.stroke();

            // ë„ë¡œ ê·¸ë¦¬ê¸°
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    if (this.grid[x][y].type === TYPE.ROAD) {
                        this.drawRoadTile(x, y);
                    }
                }
            }

            // ë“œë˜ê·¸ ë¯¸ë¦¬ë³´ê¸°
            if (this.isDragging && this.dragPath.length > 0) {
                this.ctx.fillStyle = this.isErasing ? 'rgba(239, 83, 80, 0.5)' : COLORS.ROAD_Preview;
                for (let p of this.dragPath) {
                    this.ctx.fillRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
                this.ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                if (this.dragPath.length > 0) {
                     const start = this.dragPath[0];
                     this.ctx.moveTo(start.x*TILE_SIZE + TILE_SIZE/2, start.y*TILE_SIZE + TILE_SIZE/2);
                     for(let i=1; i<this.dragPath.length; i++) {
                         const p = this.dragPath[i];
                         this.ctx.lineTo(p.x*TILE_SIZE + TILE_SIZE/2, p.y*TILE_SIZE + TILE_SIZE/2);
                     }
                }
                this.ctx.stroke();
            }

            // ê±´ë¬¼ ê·¸ë¦¬ê¸°
            this.buildings.forEach(b => {
                const cx = b.x * TILE_SIZE + TILE_SIZE / 2;
                const cy = b.y * TILE_SIZE + TILE_SIZE / 2;
                
                this.ctx.fillStyle = b.color;
                
                if (b.type === TYPE.HOUSE) {
                    this.ctx.fillRect(cx - 14, cy - 14, 28, 28);
                    this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - 14, cy - 14);
                    this.ctx.lineTo(cx + 14, cy + 14);
                    this.ctx.lineTo(cx - 14, cy + 14);
                    this.ctx.fill();

                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, 16, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }

                // í™”ì‚´í‘œ
                const dirIdx = ROTATION_TO_DIR[b.rotation];
                const dir = DIRS[dirIdx];
                const arrowX = cx + dir.dx * 16;
                const arrowY = cy + dir.dy * 16;
                
                this.ctx.fillStyle = '#333';
                this.ctx.beginPath();
                const perpX = -dir.dy; 
                const perpY = dir.dx;
                this.ctx.moveTo(arrowX, arrowY);
                this.ctx.lineTo(arrowX - dir.dx*6 + perpX*4, arrowY - dir.dy*6 + perpY*4);
                this.ctx.lineTo(arrowX - dir.dx*6 - perpX*4, arrowY - dir.dy*6 - perpY*4);
                this.ctx.fill();
            });

            // ìë™ì°¨ ê·¸ë¦¬ê¸° (ì§ì‚¬ê°í˜• ì°¨ëŸ‰)
            this.cars.forEach(car => {
                const cx = car.displayX * TILE_SIZE + TILE_SIZE / 2;
                const cy = car.displayY * TILE_SIZE + TILE_SIZE / 2;

                this.ctx.save();
                this.ctx.translate(cx, cy);
                this.ctx.rotate(car.angle);

                // ì°¨ì²´ (ì§ì‚¬ê°í˜•)
                this.ctx.fillStyle = car.color;
                // ê¸¸ì´ 14, ë„ˆë¹„ 8
                const len = 14;
                const wid = 8;
                this.ctx.fillRect(-len/2, -wid/2, len, wid);

                // ì•ìœ ë¦¬ (ê²€ì •)
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, -wid/2 + 1, 4, wid - 2);

                // í—¤ë“œë¼ì´íŠ¸ (ë…¸ë‘)
                this.ctx.fillStyle = '#ffeb3b';
                this.ctx.fillRect(len/2 - 2, -wid/2 + 1, 2, 2);
                this.ctx.fillRect(len/2 - 2, wid/2 - 3, 2, 2);

                // í›„ë¯¸ë“± (ë¹¨ê°•)
                this.ctx.fillStyle = '#f44336';
                this.ctx.fillRect(-len/2, -wid/2 + 1, 2, 2);
                this.ctx.fillRect(-len/2, wid/2 - 3, 2, 2);

                this.ctx.restore();
            });

            this.particles.forEach(p => {
                this.ctx.fillStyle = p.color;
                this.ctx.globalAlpha = p.life / 20;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1.0;
            });
        }

        drawRoadTile(x, y) {
            const cx = x * TILE_SIZE + TILE_SIZE / 2;
            const cy = y * TILE_SIZE + TILE_SIZE / 2;
            const cell = this.grid[x][y];
            
            this.ctx.fillStyle = COLORS.ROAD;
            this.ctx.strokeStyle = COLORS.ROAD;
            // ë„ë¡œ í­ í™•ì¥ (0.5 -> 0.75)
            this.ctx.lineWidth = TILE_SIZE * 0.75; 
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';

            this.ctx.beginPath();
            this.ctx.moveTo(cx, cy);

            for(let i=0; i<8; i++) {
                if(cell.connections[i]) {
                    this.ctx.moveTo(cx, cy);
                    if (i % 2 !== 0) {
                        this.ctx.lineTo(cx + DIRS[i].dx * TILE_SIZE * 0.5, cy + DIRS[i].dy * TILE_SIZE * 0.5);
                    } else {
                        this.ctx.lineTo(cx + DIRS[i].dx * TILE_SIZE * 0.5, cy + DIRS[i].dy * TILE_SIZE * 0.5);
                    }
                }
            }
            
            if (!cell.connections.includes(true)) {
                 this.ctx.arc(cx, cy, TILE_SIZE * 0.25, 0, Math.PI*2);
            }

            this.ctx.stroke();

            // ì¤‘ì•™ ì› (êµì°¨ë¡œ)
            this.ctx.beginPath();
            this.ctx.arc(cx, cy, TILE_SIZE * 0.35, 0, Math.PI*2);
            this.ctx.fill();

            // ì°¨ì„  (ì¤‘ì•™ì„ ) - ë…¸ë€ìƒ‰ ì ì„  ë“±ìœ¼ë¡œ ë³€ê²½í•˜ê±°ë‚˜ ì–‡ì€ ì‹¤ì„ 
            this.ctx.strokeStyle = 'rgba(255, 235, 59, 0.4)'; // ë…¸ë€ìƒ‰ ì¤‘ì•™ì„  ëŠë‚Œ
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(cell.connections[i]) {
                    this.ctx.moveTo(cx, cy);
                    this.ctx.lineTo(cx + DIRS[i].dx * TILE_SIZE * 0.5, cy + DIRS[i].dy * TILE_SIZE * 0.5);
                }
            }
            this.ctx.stroke();
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    window.onload = () => {
        const game = new Game('gameCanvas');
    };

</script>

</body>
</html>
