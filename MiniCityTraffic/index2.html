<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini City Tycoon: Advanced</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #263238;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #263238;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .pointer-auto {
            pointer-events: auto;
        }

        /* ìƒë‹¨ ì •ë³´ì°½ */
        .top-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ìš°ì¸¡ ë„ë¡œ ì„ íƒ ë©”ë‰´ */
        .road-menu {
            position: absolute;
            right: 10px;
            top: 60px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .road-btn {
            width: 50px;
            height: 50px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            background: #fff;
            transition: all 0.2s;
        }
        
        .road-btn span { font-size: 20px; margin-bottom: 2px; }
        .road-btn:hover { background: #f0f0f0; }
        .road-btn.active { border-color: #2196F3; background: #E3F2FD; }

        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ë°” */
        .control-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(33, 33, 33, 0.9);
            padding: 10px;
            border-radius: 24px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .main-btn {
            background: #eee;
            border: none;
            padding: 10px 20px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: bold;
            color: #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 80px;
            justify-content: center;
        }

        .main-btn.active {
            background: #FFC107;
            color: #000;
        }
        .main-btn.move-mode.active { background: #4CAF50; color: white; }
        .main-btn.erase-mode.active { background: #F44336; color: white; }

        /* ê±´ì„¤ í™•ì¸ íŒì—… */
        #confirm-popup {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            display: none;
            flex-direction: column;
            gap: 10px;
            text-align: center;
            z-index: 20;
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popUp {
            from { transform: translateX(-50%) scale(0.8); opacity: 0; }
            to { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        .popup-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .pop-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }
        .btn-yes { background: #4CAF50; color: white; }
        .btn-no { background: #F44336; color: white; }

        /* ì¤Œ ì»¨íŠ¸ë¡¤ */
        .zoom-controls {
            position: absolute;
            right: 10px;
            bottom: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .zoom-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: white; border: none; font-size: 20px; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* í”Œë¡œíŒ… í…ìŠ¤íŠ¸ */
        .float-text {
            position: absolute;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        
        #instruction {
            position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            background: white; padding: 20px; border-radius: 10px; max-width: 300px;
            text-align: center; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .color-dot { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:5px;}
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="top-panel pointer-auto">
            <div class="info-box">
                <span>ğŸ’°</span>
                <span id="moneyDisplay">1000</span>
            </div>
            <div class="info-box">
                <span>ğŸ‘·</span>
                <span id="scoreDisplay">0</span>
            </div>
        </div>

        <!-- ë„ë¡œ ì„ íƒ ë©”ë‰´ -->
        <div class="road-menu pointer-auto" id="roadMenu">
            <button class="road-btn active" onclick="setRoadType(1)">
                <span>ğŸ›£ï¸</span>ì¼ë°˜($10)
            </button>
            <button class="road-btn" onclick="setRoadType(2)">
                <span>ğŸš€</span>ê³ ì†($20)
            </button>
            <button class="road-btn" onclick="setRoadType(3)">
                <span>ğŸš¦</span>êµì°¨ë¡œ($30)
            </button>
            <button class="road-btn" onclick="setRoadType(4)">
                <span>ğŸ”„</span>íšŒì „($50)
            </button>
        </div>

        <div class="zoom-controls pointer-auto">
            <button class="zoom-btn" onclick="gameInstance.zoomIn()">+</button>
            <button class="zoom-btn" onclick="gameInstance.zoomOut()">-</button>
        </div>

        <div class="control-bar pointer-auto">
            <button class="main-btn active" id="btn-build" onclick="setMode('build')">
                ğŸš§ ê±´ì„¤
            </button>
            <button class="main-btn move-mode" id="btn-move" onclick="setMode('move')">
                âœ‹ ì´ë™
            </button>
            <button class="main-btn erase-mode" id="btn-erase" onclick="setMode('erase')">
                ğŸ§¹ ì² ê±°
            </button>
        </div>

        <!-- ê±´ì„¤ í™•ì¸ íŒì—… -->
        <div id="confirm-popup" class="pointer-auto">
            <div id="popup-msg">ë„ë¡œë¥¼ ê±´ì„¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
            <div style="font-weight:bold; color:#E91E63; margin-bottom:5px;" id="popup-cost">ë¹„ìš©: $50</div>
            <div class="popup-buttons">
                <button class="pop-btn btn-yes" onclick="gameInstance.confirmBuild()">í™•ì¸</button>
                <button class="pop-btn btn-no" onclick="gameInstance.cancelBuild()">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <div id="instruction" class="pointer-auto">
        <h3>ğŸš¦ ê³ ê¸‰ êµí†µ ì‹œë®¬ë ˆì´ì…˜</h3>
        <p style="text-align:left; font-size:13px; color:#555;">
            1. <strong>ìƒ‰ìƒ ë§¤ì¹­</strong>: ì‹œë¯¼ì€ <span style="color:#ef5350">â—</span><span style="color:#42a5f5">â—</span><span style="color:#fdd835">â—</span> ê°™ì€ ìƒ‰ì˜ íšŒì‚¬ë¡œë§Œ ì¶œê·¼í•©ë‹ˆë‹¤.<br>
            2. <strong>ê±´ì„¤ í™•ì¸</strong>: ë“œë˜ê·¸ í›„ [í™•ì¸]ì„ ëˆŒëŸ¬ì•¼ ê±´ì„¤ë©ë‹ˆë‹¤.<br>
            3. <strong>ë„ë¡œ ì¢…ë¥˜</strong>: ê³ ì†ë„ë¡œëŠ” ì´ë™ ì†ë„ê°€ ë¹ ë¦…ë‹ˆë‹¤.<br>
            4. <strong>ì›”ê¸‰</strong>: 1íšŒ ì¶œê·¼ ì‹œ <strong>$5</strong>ë¥¼ ë²•ë‹ˆë‹¤.
        </p>
        <button onclick="document.getElementById('instruction').style.display='none'" style="padding:10px 20px; background:#2196F3; color:white; border:none; border-radius:5px; cursor:pointer;">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script>
    // === ì„¤ì • ìƒìˆ˜ ===
    const TILE_SIZE = 40;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;

    const SALARY = 5; // ì›”ê¸‰
    const INIT_MONEY = 1000; // ì´ˆê¸° ìê¸ˆ
    const WORK_DURATION = 300; // ì•½ 5ì´ˆ ê·¼ë¬´

    // ë„ë¡œ íƒ€ì… ë° ë¹„ìš©/ì†ë„
    const ROAD_TYPES = {
        1: { name: 'NORMAL', cost: 10, speed: 1.0, color: '#546e7a' },
        2: { name: 'HIGHWAY', cost: 20, speed: 2.0, color: '#37474F' }, // ê³ ì†ë„ë¡œ: ì§™ì€ìƒ‰
        3: { name: 'CROSS', cost: 30, speed: 0.8, color: '#607D8B' },   // êµì°¨ë¡œ: ì•½ê°„ ëŠë¦¼
        4: { name: 'ROUND', cost: 50, speed: 1.2, color: '#78909C' }    // íšŒì „êµì°¨ë¡œ
    };

    const TYPE = { EMPTY: 0, ROAD: 1, HOUSE: 2, COMPANY: 3, COMPANY_PART: 4 };

    // ê±´ë¬¼/ì—ì´ì „íŠ¸ ìƒ‰ìƒ (ë¹¨ê°•, íŒŒë‘, ë…¸ë‘)
    const TEAM_COLORS = ['#ef5350', '#42a5f5', '#fdd835'];

    const STATE = {
        IDLE: 0, TO_WORK: 1, PARKING: 2, TO_ENTRANCE: 3, 
        WORKING: 4, TO_CAR: 5, TO_HOME: 6, RESTING: 7
    };

    const DIRS = [
        {dx:0,dy:-1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1},
        {dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1}
    ];

    let gameInstance = null;
    let currentMode = 'build';
    let selectedRoadType = 1;

    // === ì „ì—­ í•¨ìˆ˜ ===
    function setMode(mode) {
        currentMode = mode;
        // ë²„íŠ¼ UI ì—…ë°ì´íŠ¸
        document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${mode}`).classList.add('active');
        
        // ë©”ë‰´ í‘œì‹œ/ìˆ¨ê¹€
        const roadMenu = document.getElementById('roadMenu');
        roadMenu.style.display = (mode === 'build') ? 'flex' : 'none';
        
        if (gameInstance) gameInstance.resetInteraction();
    }

    function setRoadType(type) {
        selectedRoadType = type;
        document.querySelectorAll('.road-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.road-btn')[type-1].classList.add('active');
    }

    // === ê²Œì„ í´ë˜ìŠ¤ ===
    class Game {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.money = INIT_MONEY;
            this.trips = 0;

            this.camera = { x: 0, y: 0, zoom: 1.0 };
            
            this.grid = [];
            this.agents = [];
            this.buildings = [];
            
            // ì¸í„°ë™ì…˜ ìƒíƒœ
            this.isDragging = false;
            this.dragStart = null;
            this.dragEnd = null;
            this.previewPath = []; // ê±´ì„¤ ëŒ€ê¸°ì¤‘ì¸ ê²½ë¡œ
            this.waitingConfirm = false; // í™•ì¸ íŒì—… ëŒ€ê¸°ì¤‘
            
            this.lastMouse = {x:0, y:0};
            this.isPanDragging = false;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            this.initGrid();
            this.spawnInitialBuildings();
            this.addInputListeners();
            
            this.updateUI();
            this.loop();
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera.x === 0) {
                this.camera.x = (this.canvas.width - GRID_WIDTH*TILE_SIZE)/2;
                this.camera.y = (this.canvas.height - GRID_HEIGHT*TILE_SIZE)/2;
            }
        }

        initGrid() {
            for(let x=0; x<GRID_WIDTH; x++) {
                this.grid[x] = [];
                for(let y=0; y<GRID_HEIGHT; y++) {
                    this.grid[x][y] = { 
                        type: TYPE.EMPTY, 
                        roadType: 0, 
                        isFixedRoad: false,
                        connections: new Array(8).fill(false) 
                    };
                }
            }
        }

        spawnInitialBuildings() {
            // ìƒ‰ìƒë³„ë¡œ í•˜ë‚˜ì”© ìƒì„± ë³´ì¥
            this.spawnBuilding(TYPE.HOUSE, 0);   // Red House
            this.spawnBuilding(TYPE.COMPANY, 0); // Red Company
            this.spawnBuilding(TYPE.HOUSE, 1);   // Blue House
            this.spawnBuilding(TYPE.COMPANY, 1); // Blue Company
        }

        // --- ì…ë ¥ ì²˜ë¦¬ ---
        addInputListeners() {
            const getPos = (e) => e.touches ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY};
            
            const start = (e) => {
                if (this.waitingConfirm) return; // íŒì—… ë– ìˆìœ¼ë©´ ì¡°ì‘ ê¸ˆì§€
                const p = getPos(e);
                this.handleStart(p.x, p.y, e.button === 2);
            };
            const move = (e) => {
                if (this.waitingConfirm) return;
                const p = getPos(e);
                this.handleMove(p.x, p.y);
            };
            const end = () => {
                if (this.waitingConfirm) return;
                this.handleEnd();
            };

            this.canvas.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', end);
            this.canvas.addEventListener('touchstart', (e)=>{e.preventDefault(); start(e);}, {passive:false});
            window.addEventListener('touchmove', (e)=>{e.preventDefault(); move(e);}, {passive:false});
            window.addEventListener('touchend', end);
            this.canvas.addEventListener('contextmenu', e=>e.preventDefault());
        }

        screenToGrid(sx, sy) {
            const wx = (sx - this.camera.x) / this.camera.zoom;
            const wy = (sy - this.camera.y) / this.camera.zoom;
            return { x: Math.floor(wx/TILE_SIZE), y: Math.floor(wy/TILE_SIZE) };
        }

        handleStart(x, y, isRight) {
            this.lastMouse = {x, y};
            if (currentMode === 'move' || isRight) {
                this.isPanDragging = true;
                return;
            }
            const g = this.screenToGrid(x, y);
            if (!this.isValid(g.x, g.y)) return;

            // ê±´ë¬¼ íšŒì „ (ì§‘ë§Œ)
            const cell = this.grid[g.x][g.y];
            if (cell.type === TYPE.HOUSE && cell.ref) {
                this.rotateBuilding(cell.ref);
                return;
            }

            this.isDragging = true;
            this.dragStart = g;
            this.dragEnd = g;
            this.updateDragPath();
        }

        handleMove(x, y) {
            if (this.isPanDragging) {
                this.camera.x += x - this.lastMouse.x;
                this.camera.y += y - this.lastMouse.y;
                this.lastMouse = {x, y};
                return;
            }
            if (this.isDragging) {
                const g = this.screenToGrid(x, y);
                if (this.isValid(g.x, g.y) && (g.x !== this.dragEnd.x || g.y !== this.dragEnd.y)) {
                    this.dragEnd = g;
                    this.updateDragPath();
                }
            }
        }

        handleEnd() {
            this.isPanDragging = false;
            if (this.isDragging) {
                this.isDragging = false;
                // ë“œë˜ê·¸ê°€ ëë‚¬ìœ¼ë©´ í™•ì¸ íŒì—… ë„ìš°ê¸° (ê±´ì„¤/ì² ê±° ë‚´ìš©ì´ ìˆì„ ë•Œë§Œ)
                if (this.previewPath.length > 0) {
                    this.showConfirmPopup();
                }
            }
        }

        updateDragPath() {
            this.previewPath = [];
            if (!this.dragStart || !this.dragEnd) return;
            
            const x0 = this.dragStart.x, y0 = this.dragStart.y;
            const x1 = this.dragEnd.x, y1 = this.dragEnd.y;
            const dx = x1-x0, dy = y1-y0;
            const dist = Math.max(Math.abs(dx), Math.abs(dy));

            for(let i=0; i<=dist; i++) {
                const t = (dist===0) ? 0 : i/dist;
                this.previewPath.push({
                    x: Math.round(x0 + dx*t),
                    y: Math.round(y0 + dy*t)
                });
            }
        }

        // --- ê±´ì„¤ ì‹œìŠ¤í…œ ---
        showConfirmPopup() {
            // ë¹„ìš© ê³„ì‚°
            let cost = 0;
            let msg = "";
            let validCells = 0;

            if (currentMode === 'build') {
                this.previewPath.forEach(p => {
                    if (this.grid[p.x][p.y].type === TYPE.EMPTY) {
                        cost += ROAD_TYPES[selectedRoadType].cost;
                        validCells++;
                    }
                });
                msg = `${ROAD_TYPES[selectedRoadType].name} ë„ë¡œ ê±´ì„¤`;
            } else if (currentMode === 'erase') {
                this.previewPath.forEach(p => {
                    const c = this.grid[p.x][p.y];
                    if (c.type === TYPE.ROAD && !c.isFixedRoad) {
                        cost -= 5; // í™˜ë¶ˆ (ìŒìˆ˜ë¡œ í‘œí˜„)
                        validCells++;
                    }
                });
                msg = "ë„ë¡œ ì² ê±°";
            }

            if (validCells === 0) {
                this.cancelBuild(); // ë³€ê²½ì‚¬í•­ ì—†ìœ¼ë©´ ì·¨ì†Œ
                return;
            }

            // UI í‘œì‹œ
            this.waitingConfirm = true;
            const popup = document.getElementById('confirm-popup');
            document.getElementById('popup-msg').innerText = msg;
            document.getElementById('popup-cost').innerText = cost > 0 ? `ë¹„ìš©: $${cost}` : `í™˜ë¶ˆ: +$${Math.abs(cost)}`;
            document.getElementById('popup-cost').style.color = cost > 0 ? '#E91E63' : '#4CAF50';
            popup.style.display = 'flex';
        }

        confirmBuild() {
            let totalCost = 0;
            let changed = false;

            // ì‹¤ì œ ì ìš©
            this.previewPath.forEach((p, i) => {
                const cell = this.grid[p.x][p.y];
                
                if (currentMode === 'build') {
                    if (this.money >= ROAD_TYPES[selectedRoadType].cost || cell.type === TYPE.ROAD) { // ì´ë¯¸ ë„ë¡œë©´ ì—…ê·¸ë ˆì´ë“œ? ì¼ë‹¨ ë¹ˆë•…ë§Œ
                         if (cell.type === TYPE.EMPTY) {
                             if (this.money >= ROAD_TYPES[selectedRoadType].cost) {
                                 cell.type = TYPE.ROAD;
                                 cell.roadType = selectedRoadType;
                                 this.money -= ROAD_TYPES[selectedRoadType].cost;
                                 totalCost += ROAD_TYPES[selectedRoadType].cost;
                                 changed = true;
                             }
                         }
                    }
                    // ì—°ê²° ë¡œì§ (ì´ì „ íƒ€ì¼ê³¼ ì—°ê²°)
                    if (i > 0 && cell.type === TYPE.ROAD) {
                        const prev = this.previewPath[i-1];
                        const prevCell = this.grid[prev.x][prev.y];
                        if (prevCell.type === TYPE.ROAD) {
                            const dx = p.x - prev.x, dy = p.y - prev.y;
                            const dir = DIRS.findIndex(d => d.dx===dx && d.dy===dy);
                            if (dir !== -1) {
                                prevCell.connections[dir] = true;
                                cell.connections[(dir+4)%8] = true;
                            }
                        }
                    }
                } else if (currentMode === 'erase') {
                    if (cell.type === TYPE.ROAD && !cell.isFixedRoad) {
                        cell.type = TYPE.EMPTY;
                        cell.connections.fill(false);
                        this.money += 5;
                        totalCost -= 5;
                        changed = true;
                        // ì£¼ë³€ ëŠê¸°
                        for(let d=0; d<8; d++) {
                            const nx=p.x+DIRS[d].dx, ny=p.y+DIRS[d].dy;
                            if(this.isValid(nx,ny) && this.grid[nx][ny].type===TYPE.ROAD) {
                                this.grid[nx][ny].connections[(d+4)%8] = false;
                            }
                        }
                    }
                }
            });

            if (changed) {
                // í”Œë¡œíŒ… í…ìŠ¤íŠ¸
                const center = this.gridToScreen(this.previewPath[0].x, this.previewPath[0].y);
                if (totalCost > 0) this.showFloatText(`-$${totalCost}`, center.x, center.y, '#E91E63');
                else if (totalCost < 0) this.showFloatText(`+$${Math.abs(totalCost)}`, center.x, center.y, '#4CAF50');
                
                // ëª¨ë“  ëŒ€ê¸°ì¤‘ì¸ ì—ì´ì „íŠ¸ì—ê²Œ ì¦‰ì‹œ ê¸¸ì°¾ê¸° ëª…ë ¹
                this.triggerCommute();
            }

            this.resetInteraction();
            this.updateUI();
        }

        cancelBuild() {
            this.resetInteraction();
        }

        resetInteraction() {
            this.previewPath = [];
            this.waitingConfirm = false;
            document.getElementById('confirm-popup').style.display = 'none';
        }

        triggerCommute() {
            // IDLE ìƒíƒœê±°ë‚˜, ê¸¸ì„ ëª»ì°¾ì•„ ëŒ€ê¸°ì¤‘ì¸ ì—ì´ì „íŠ¸ë“¤ì„ ê¹¨ì›€
            this.agents.forEach(a => {
                if (a.state === STATE.IDLE || (a.state === STATE.TO_WORK && a.path.length === 0)) {
                    // ì¦‰ì‹œ ì¬ì‹œë„
                    if(a.work) this.planRoute(a, a.work, STATE.TO_WORK);
                }
            });
        }

        // --- ì—ì´ì „íŠ¸ ë° ë¡œì§ ---
        spawnBuilding(type, colorIdx = -1) {
            let placed = false, attempts=0;
            const w = (type===TYPE.COMPANY)?4:1;
            const h = (type===TYPE.COMPANY)?3:1;
            
            while(!placed && attempts<100) {
                attempts++;
                const x = Math.floor(Math.random()*(GRID_WIDTH-2-w))+1;
                const y = Math.floor(Math.random()*(GRID_HEIGHT-2-h))+1;
                let ok = true;
                for(let i=-1; i<=w; i++) for(let j=-1; j<=h; j++) {
                    const cx=x+i, cy=y+j;
                    if(cx>=0 && cy>=0 && cx<GRID_WIDTH && cy<GRID_HEIGHT) {
                        if(this.grid[cx][cy].type !== TYPE.EMPTY) ok=false;
                    }
                }
                if(ok) {
                    const cIdx = (colorIdx === -1) ? Math.floor(Math.random()*3) : colorIdx;
                    const b = { 
                        x,y,type,w,h, 
                        color: TEAM_COLORS[cIdx], 
                        colorIdx: cIdx,
                        rotation:0, parkingSlots:[], entranceRoadPos:null 
                    };

                    for(let i=0;i<w;i++) for(let j=0;j<h;j++) {
                        this.grid[x+i][y+j] = { type:(i===0&&j===0)?type:TYPE.COMPANY_PART, ref:b, connections:[], roadType:0 };
                    }
                    this.setupEntrance(b);
                    if(type===TYPE.COMPANY) this.setupParking(b);
                    else {
                        b.entrance={x:0.5, y:0.5};
                        this.agents.push(this.createAgent(b));
                    }
                    this.buildings.push(b);
                    placed=true;
                }
            }
        }

        setupEntrance(b) {
            // ... (ê¸°ì¡´ê³¼ ë™ì¼, íšŒì „ ë° ê³ ì • ë„ë¡œ ì²˜ë¦¬)
            let rx, ry;
            if (b.type === TYPE.COMPANY) { rx=b.x+1; ry=b.y+3; }
            else {
                if(b.rotation===0){rx=b.x;ry=b.y+1;}
                else if(b.rotation===1){rx=b.x-1;ry=b.y;}
                else if(b.rotation===2){rx=b.x;ry=b.y-1;}
                else {rx=b.x+1;ry=b.y;}
            }
            if (this.isValid(rx,ry)) {
                // ì´ì „ ìœ„ì¹˜ í•´ì œ ìƒëµ(ê°„ë‹¨í™”), ìƒˆ ìœ„ì¹˜ ìƒì„±
                const cell = this.grid[rx][ry];
                if(cell.type===TYPE.EMPTY) { cell.type=TYPE.ROAD; cell.roadType=1; cell.connections.fill(false); }
                cell.isFixedRoad=true;
                b.entranceRoadPos={x:rx, y:ry};
            }
        }

        setupParking(b) {
            b.entranceLocal = {x:1, y:2.8};
            b.parkingSlots = [];
            // 6ê°œ ìŠ¬ë¡¯
            [{x:2.5,y:0.5},{x:3.5,y:0.5},{x:2.5,y:1.5},{x:3.5,y:1.5},{x:2.5,y:2.5},{x:3.5,y:2.5}].forEach(p=>{
                b.parkingSlots.push({rx:p.x, ry:p.y, occupiedBy:null});
            });
        }

        createAgent(home) {
            return {
                x: home.x+0.5, y: home.y+0.5,
                home: home, work: null,
                color: home.color, colorIdx: home.colorIdx,
                state: STATE.IDLE,
                path: [], pathIndex: 0,
                speed: 0, maxSpeed: 0.1,
                walking: false, targetSlot: null, angle: 0,
                workTimer: 0
            };
        }

        // ê²½ë¡œ ê³„íš
        planRoute(a, dest, mode) {
            // ìƒ‰ìƒ ë§¤ì¹­ ì²´í¬
            if (mode === STATE.TO_WORK && dest.colorIdx !== a.colorIdx) return;

            let start = (mode===STATE.TO_WORK) ? a.home.entranceRoadPos : a.work.entranceRoadPos;
            let target = (mode===STATE.TO_WORK) ? dest.entranceRoadPos : dest.entranceRoadPos;
            
            if(!start || !target) return;

            // ì£¼ì°¨ ìŠ¬ë¡¯ ì°¾ê¸° (ìˆœì°¨ì )
            let slot = null;
            if (mode === STATE.TO_WORK) {
                slot = dest.parkingSlots.find(s => !s.occupiedBy);
                if (!slot) return; // ìë¦¬ ì—†ìŒ
                slot.occupiedBy = a;
                a.targetSlot = slot;
            }

            // ê¸¸ì°¾ê¸°
            const path = this.findPath(start.x, start.y, target.x, target.y);
            if(path) {
                a.path = path;
                a.pathIndex = 0;
                a.state = mode;
                if(mode===STATE.TO_WORK) { a.x=start.x+0.5; a.y=start.y+0.5; a.walking=false; }
            } else {
                if(slot) { slot.occupiedBy = null; a.targetSlot = null; }
            }
        }

        findPath(sx, sy, tx, ty) {
            // A* with Road Costs
            const startNode = {x:sx, y:sy};
            const open = [{x:sx, y:sy, g:0, h:0, f:0, p:null}];
            const closed = new Set();

            while(open.length > 0) {
                open.sort((a,b)=>a.f-b.f);
                const curr = open.shift();
                
                if(curr.x===tx && curr.y===ty) {
                    const path=[]; let t=curr;
                    while(t){path.unshift({x:t.x,y:t.y}); t=t.p;}
                    return path;
                }
                
                const k = `${curr.x},${curr.y}`;
                if(closed.has(k)) continue;
                closed.add(k);

                for(let i=0; i<8; i++) {
                    if(!this.grid[curr.x][curr.y].connections[i]) continue;
                    const nx=curr.x+DIRS[i].dx, ny=curr.y+DIRS[i].dy;
                    
                    if(this.isValid(nx,ny) && !closed.has(`${nx},${ny}`)) {
                        const cell = this.grid[nx][ny];
                        const rType = ROAD_TYPES[cell.roadType] || ROAD_TYPES[1];
                        
                        // ë¹„ìš© ê³„ì‚°: ê±°ë¦¬ë¥¼ ì†ë„ë¡œ ë‚˜ëˆ” (ê³ ì†ë„ë¡œ ì„ í˜¸)
                        const dist = (i%2===0)?1:1.414;
                        const weight = dist / rType.speed; 
                        
                        const g = curr.g + weight;
                        const h = Math.hypot(nx-tx, ny-ty);
                        open.push({x:nx, y:ny, g, h, f:g+h, p:curr});
                    }
                }
            }
            return null;
        }

        update() {
            // ìë™ ê±´ë¬¼ ìƒì„± (ê°€ë”)
            if(Math.random()<0.002 && this.buildings.length<30) {
                this.spawnBuilding(Math.random()>0.6?TYPE.COMPANY:TYPE.HOUSE);
            }

            this.agents.forEach(a => {
                switch(a.state) {
                    case STATE.IDLE:
                        if (!a.work) {
                            // ê°™ì€ ìƒ‰ íšŒì‚¬ ì°¾ê¸°
                            const comps = this.buildings.filter(b => b.type===TYPE.COMPANY && b.colorIdx===a.colorIdx);
                            if(comps.length>0) a.work = comps[Math.floor(Math.random()*comps.length)];
                        }
                        if(a.work) this.planRoute(a, a.work, STATE.TO_WORK);
                        break;
                    
                    case STATE.TO_WORK:
                        this.moveCar(a);
                        if(a.pathIndex >= a.path.length) a.state = STATE.PARKING;
                        break;

                    case STATE.PARKING:
                        const s = a.targetSlot;
                        const tx = a.work.x+s.rx, ty = a.work.y+s.ry;
                        // ë¶€ë“œëŸ¬ìš´ ì£¼ì°¨
                        if(Math.hypot(tx-a.x, ty-a.y) < 0.1) {
                            a.x=tx; a.y=ty;
                            a.state = STATE.TO_ENTRANCE;
                            a.walking = true; 
                        } else {
                            a.x += (tx-a.x)*0.08; a.y += (ty-a.y)*0.08;
                            a.angle = Math.atan2(ty-a.y, tx-a.x);
                        }
                        break;

                    case STATE.TO_ENTRANCE:
                        const ex = a.work.x+a.work.entranceLocal.x, ey = a.work.y+a.work.entranceLocal.y;
                        this.moveWalk(a, ex, ey, STATE.WORKING);
                        break;

                    case STATE.WORKING:
                        a.workTimer++;
                        if(a.workTimer > WORK_DURATION) {
                            a.workTimer=0;
                            a.state = STATE.TO_CAR;
                            a.walking = true;
                        }
                        break;

                    case STATE.TO_CAR:
                        const cx = a.work.x+a.targetSlot.rx, cy = a.work.y+a.targetSlot.ry;
                        this.moveWalk(a, cx, cy, STATE.TO_HOME);
                        break;

                    case STATE.TO_HOME:
                        if(a.path.length===0) {
                            a.walking=false;
                            this.planRoute(a, a.home, STATE.TO_HOME);
                        }
                        this.moveCar(a);
                        if(a.path.length>0 && a.pathIndex>=a.path.length) {
                            // ë„ì°©
                            if(a.targetSlot) { a.targetSlot.occupiedBy=null; a.targetSlot=null; }
                            a.state = STATE.RESTING;
                            this.money += SALARY;
                            this.trips++;
                            this.updateUI();
                            const sc = this.gridToScreen(a.x, a.y);
                            this.showFloatText(`+$${SALARY}`, sc.x, sc.y, '#4CAF50');
                        }
                        break;
                    
                    case STATE.RESTING:
                        a.workTimer++;
                        if(a.workTimer > 100) { a.workTimer=0; a.state = STATE.IDLE; }
                        break;
                }
            });
        }

        moveCar(a) {
            if(!a.path || !a.path[a.pathIndex]) return;
            const t = a.path[a.pathIndex];
            // ë„ë¡œ íƒ€ì…ì— ë”°ë¥¸ ì†ë„ ë³´ì •
            const rType = this.grid[t.x][t.y].roadType || 1;
            const speed = a.maxSpeed * ROAD_TYPES[rType].speed;
            
            const dx = t.x+0.5 - a.x, dy = t.y+0.5 - a.y;
            const d = Math.hypot(dx, dy);
            
            if(d < speed) { a.x=t.x+0.5; a.y=t.y+0.5; a.pathIndex++; }
            else { a.x += (dx/d)*speed; a.y += (dy/d)*speed; a.angle = Math.atan2(dy, dx); }
        }

        moveWalk(a, tx, ty, next) {
            const dx=tx-a.x, dy=ty-a.y;
            const d=Math.hypot(dx,dy);
            if(d<0.05) { a.x=tx; a.y=ty; a.state=next; if(next===STATE.TO_HOME) a.path=[]; }
            else { a.x += (dx/d)*0.03; a.y += (dy/d)*0.03; }
        }

        // --- ë Œë”ë§ ---
        draw() {
            this.ctx.fillStyle = '#a5d6a7';
            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

            this.ctx.save();
            this.ctx.translate(this.camera.x, this.camera.y);
            this.ctx.scale(this.camera.zoom, this.camera.zoom);

            this.ctx.fillStyle = '#81c784';
            this.ctx.fillRect(0,0,GRID_WIDTH*TILE_SIZE, GRID_HEIGHT*TILE_SIZE);

            // ë„ë¡œ
            for(let x=0; x<GRID_WIDTH; x++) for(let y=0; y<GRID_HEIGHT; y++) {
                if(this.grid[x][y].type === TYPE.ROAD) this.drawRoad(x, y);
            }

            // ê±´ë¬¼
            this.buildings.forEach(b => this.drawBuilding(b));

            // ì—ì´ì „íŠ¸ & ì£¼ì°¨ëœ ì°¨
            this.agents.forEach(a => {
                if(a.state !== STATE.IDLE && a.state !== STATE.RESTING) {
                    this.drawAgent(a);
                    // ì°¨ê°€ ì£¼ì°¨ì¥ì— ëŒ€ê¸°í•˜ëŠ” ëª¨ìŠµ (ì‚¬ëŒì´ ë‚˜ì™€ìˆì„ ë•Œ)
                    if (a.state === STATE.TO_ENTRANCE || a.state === STATE.WORKING || a.state === STATE.TO_CAR) {
                        this.drawParkedCar(a);
                    }
                }
            });

            // í”„ë¦¬ë·° (ê±´ì„¤ ëŒ€ê¸°)
            if(this.previewPath.length > 0) {
                this.ctx.fillStyle = (currentMode==='erase') ? 'rgba(244,67,54,0.5)' : 'rgba(33,150,243,0.5)';
                this.previewPath.forEach(p => {
                    this.ctx.fillRect(p.x*TILE_SIZE, p.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                });
            }

            this.ctx.restore();
        }

        drawRoad(x, y) {
            const c = this.grid[x][y];
            const info = ROAD_TYPES[c.roadType] || ROAD_TYPES[1];
            const cx=x*TILE_SIZE+TILE_SIZE/2, cy=y*TILE_SIZE+TILE_SIZE/2;
            
            this.ctx.fillStyle = info.color;
            this.ctx.beginPath(); this.ctx.arc(cx,cy,TILE_SIZE*0.4,0,Math.PI*2); this.ctx.fill();
            this.ctx.strokeStyle = info.color;
            this.ctx.lineWidth = TILE_SIZE * 0.8;
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(c.connections[i]) {
                    this.ctx.moveTo(cx,cy);
                    this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.6, cy+DIRS[i].dy*TILE_SIZE*0.6);
                }
            }
            this.ctx.stroke();

            // ì°¨ì„  (ê³ ì†ë„ë¡œëŠ” ë…¸ë€ìƒ‰, ì¼ë°˜ì€ í°ìƒ‰)
            this.ctx.strokeStyle = (c.roadType===2) ? '#FFEB3B' : 'rgba(255,255,255,0.4)';
            this.ctx.lineWidth = 2;
            if (c.roadType === 3) this.ctx.strokeStyle = 'white'; // êµì°¨ë¡œ

            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(c.connections[i]) {
                    this.ctx.moveTo(cx,cy);
                    this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.5, cy+DIRS[i].dy*TILE_SIZE*0.5);
                }
            }
            this.ctx.stroke();

            // êµì°¨ë¡œ/íšŒì „êµì°¨ë¡œ ì¥ì‹
            if(c.roadType===3) {
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(cx-4,cy-4,8,8); // ì •ì§€ì„  ëŠë‚Œ
            } else if(c.roadType===4) {
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath(); this.ctx.arc(cx,cy,6,0,Math.PI*2); this.ctx.fill();
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.beginPath(); this.ctx.arc(cx,cy,4,0,Math.PI*2); this.ctx.fill();
            }
        }

        drawBuilding(b) {
            const bx=b.x*TILE_SIZE, by=b.y*TILE_SIZE;
            if(b.type===TYPE.HOUSE) {
                // ì§‘: ìƒ‰ìƒ ì§€ë¶•
                const cx=bx+TILE_SIZE/2, cy=by+TILE_SIZE/2;
                this.ctx.save();
                this.ctx.translate(cx,cy);
                this.ctx.rotate([0,0.5,1,1.5][b.rotation]*Math.PI);
                const s = TILE_SIZE*0.8;
                this.ctx.fillStyle='#fff'; this.ctx.fillRect(-s/2,-s/2,s,s);
                this.ctx.fillStyle=b.color; // ì§€ë¶• ìƒ‰ìƒ
                this.ctx.beginPath();
                this.ctx.moveTo(-s/2-2,-s/2); this.ctx.lineTo(0,-s/2-10); this.ctx.lineTo(s/2+2,-s/2); this.ctx.fill();
                this.ctx.fillStyle='#795548'; this.ctx.fillRect(-4,s/2-6,8,6);
                this.ctx.restore();
            } else {
                // íšŒì‚¬: ìƒ‰ìƒ ì°½ë¬¸/ë 
                const bw=b.w*TILE_SIZE, bh=b.h*TILE_SIZE;
                this.ctx.fillStyle='#cfd8dc'; this.ctx.fillRect(bx,by,bw,bh); // ë°”ë‹¥
                // ê±´ë¬¼ ë³¸ì²´
                this.ctx.fillStyle='#eceff1'; this.ctx.fillRect(bx,by,bw*0.5-2, bh-2);
                this.ctx.fillStyle=b.color; this.ctx.fillRect(bx,by,bw*0.5-2, 10); // ìƒë‹¨ ì»¬ëŸ¬ë 
                
                // ì£¼ì°¨ì¥
                const px=bx+bw*0.5, py=by;
                this.ctx.fillStyle='#90a4ae'; this.ctx.fillRect(px,py,bw*0.5-2, bh-2);
                this.ctx.strokeStyle='white'; this.ctx.lineWidth=1;
                b.parkingSlots.forEach(s => {
                    this.ctx.strokeRect((b.x+s.rx)*TILE_SIZE-12, (b.y+s.ry)*TILE_SIZE-8, 24, 16);
                });
            }
        }

        drawAgent(a) {
            const sx=a.x*TILE_SIZE, sy=a.y*TILE_SIZE;
            if(a.walking) {
                this.ctx.fillStyle='#333'; this.ctx.beginPath(); this.ctx.arc(sx,sy,4,0,Math.PI*2); this.ctx.fill();
                this.ctx.fillStyle=a.color; this.ctx.beginPath(); this.ctx.arc(sx,sy-3,3,0,Math.PI*2); this.ctx.fill();
            } else {
                this.ctx.save(); this.ctx.translate(sx,sy); this.ctx.rotate(a.angle);
                this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
                this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8); // ìœ ë¦¬ì°½
                this.ctx.restore();
            }
        }

        drawParkedCar(a) {
            if(!a.targetSlot) return;
            const sx = (a.work.x + a.targetSlot.rx) * TILE_SIZE;
            const sy = (a.work.y + a.targetSlot.ry) * TILE_SIZE;
            this.ctx.save(); this.ctx.translate(sx,sy);
            this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
            this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8);
            this.ctx.restore();
        }

        // ìœ í‹¸
        isValid(x, y) { return x>=0 && y>=0 && x<GRID_WIDTH && y<GRID_HEIGHT; }
        rotateBuilding(b) { b.rotation=(b.rotation+1)%4; this.setupEntrance(b); }
        showFloatText(txt, x, y, col) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            el.style.left = x+'px'; el.style.top = y+'px'; el.style.color = col;
            document.body.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
        }
        updateUI() {
            document.getElementById('moneyDisplay').innerText = this.money;
            document.getElementById('scoreDisplay').innerText = this.trips;
        }
        gridToScreen(gx, gy) {
            return {
                x: gx*TILE_SIZE*this.camera.zoom + this.camera.x,
                y: gy*TILE_SIZE*this.camera.zoom + this.camera.y
            };
        }
        zoomIn(){ this.setZoom(this.camera.zoom+0.2); }
        zoomOut(){ this.setZoom(this.camera.zoom-0.2); }
        setZoom(z) {
            const nz = Math.max(0.3, Math.min(z, 3.0));
            const cx = this.canvas.width/2, cy = this.canvas.height/2;
            const wx = (cx - this.camera.x)/this.camera.zoom;
            const wy = (cy - this.camera.y)/this.camera.zoom;
            this.camera.x = cx - wx*nz;
            this.camera.y = cy - wy*nz;
            this.camera.zoom = nz;
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    window.onload = () => { gameInstance = new Game('gameCanvas'); };

</script>
</body>
</html>
