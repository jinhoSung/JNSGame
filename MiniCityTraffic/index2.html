<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini City Tycoon: Smart Traffic</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #263238;
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #263238;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .pointer-auto {
            pointer-events: auto;
        }

        /* ìƒë‹¨ íŒ¨ë„ */
        .top-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ìš°ì¸¡ ë„ë¡œ ë©”ë‰´ */
        .road-menu {
            position: absolute;
            right: 10px;
            top: 60px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            max-height: 70vh;
            overflow-y: auto;
        }

        .road-btn {
            width: 60px;
            height: 55px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            background: #fff;
            transition: all 0.1s;
            color: #455A64;
        }
        
        .road-btn span { font-size: 18px; margin-bottom: 2px; }
        .road-btn:hover { background: #f0f0f0; }
        .road-btn.active { border-color: #2196F3; background: #E3F2FD; color: #1565C0; }

        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ */
        .control-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(33, 33, 33, 0.9);
            padding: 10px;
            border-radius: 24px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 20;
        }

        .main-btn {
            background: #eee;
            border: none;
            padding: 10px 20px;
            border-radius: 16px;
            font-size: 14px;
            font-weight: bold;
            color: #444;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 80px;
            justify-content: center;
        }

        .main-btn.active { background: #FFC107; color: #000; }
        .main-btn.move-mode.active { background: #4CAF50; color: white; }
        .main-btn.erase-mode.active { background: #F44336; color: white; }

        /* íŒì—… */
        #confirm-popup {
            position: absolute; bottom: 90px; left: 50%; transform: translateX(-50%);
            background: white; padding: 15px 20px; border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4); display: none;
            flex-direction: column; gap: 10px; text-align: center; z-index: 30;
            animation: popUp 0.2s ease-out;
        }
        @keyframes popUp { from{transform:translate(-50%, 20px); opacity:0;} to{transform:translate(-50%, 0); opacity:1;} }

        .popup-buttons { display: flex; gap: 10px; justify-content: center; }
        .pop-btn { padding: 8px 16px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
        .btn-yes { background: #4CAF50; color: white; }
        .btn-no { background: #F44336; color: white; }

        .zoom-controls { position: absolute; right: 10px; bottom: 20px; display: flex; flex-direction: column; gap: 10px; z-index:20; }
        .zoom-btn { width: 40px; height: 40px; border-radius: 50%; background: white; border: none; font-size: 20px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

        .float-text {
            position: absolute; font-weight: bold; font-size: 20px; pointer-events: none;
            animation: floatUp 1s forwards; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
        }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-40px); opacity: 0; } }
        
        #instruction {
            position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            background: white; padding: 20px; border-radius: 10px; max-width: 320px;
            text-align: center; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="top-panel pointer-auto">
            <div class="info-box"><span>ğŸ’°</span><span id="moneyDisplay">1000</span></div>
            <div class="info-box"><span>ğŸ‘·</span><span id="populationDisplay">0</span></div>
        </div>

        <div class="road-menu pointer-auto" id="roadMenu">
            <button class="road-btn active" onclick="setRoadType(1)"><span>ğŸ›£ï¸</span>ì¼ë°˜1<br>$10</button>
            <button class="road-btn" onclick="setRoadType(2)"><span>ğŸ›£ï¸</span>ì¼ë°˜2<br>$20</button>
            <button class="road-btn" onclick="setRoadType(3)"><span>ğŸš€</span>ê³ ì†1<br>$30</button>
            <button class="road-btn" onclick="setRoadType(4)"><span>ğŸš€</span>ê³ ì†2<br>$50</button>
            <button class="road-btn" onclick="setRoadType(5)"><span>ğŸš¦</span>êµì°¨ë¡œ<br>$50</button>
            <button class="road-btn" onclick="setRoadType(6)"><span>ğŸ”„</span>íšŒì „<br>$100</button>
        </div>

        <div class="zoom-controls pointer-auto">
            <button class="zoom-btn" onclick="gameInstance.zoomIn()">+</button>
            <button class="zoom-btn" onclick="gameInstance.zoomOut()">-</button>
        </div>

        <div class="control-bar pointer-auto">
            <button class="main-btn active" id="btn-build" onclick="setMode('build')">ğŸš§ ê±´ì„¤</button>
            <button class="main-btn move-mode" id="btn-move" onclick="setMode('move')">âœ‹ ì´ë™</button>
            <button class="main-btn erase-mode" id="btn-erase" onclick="setMode('erase')">ğŸ§¹ ì² ê±°</button>
        </div>

        <div id="confirm-popup" class="pointer-auto">
            <div id="popup-msg">ê±´ì„¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
            <div style="font-weight:bold; color:#E91E63; margin-bottom:5px;" id="popup-cost">ë¹„ìš©: $0</div>
            <div class="popup-buttons">
                <button class="pop-btn btn-yes" onclick="gameInstance.confirmBuild()">í™•ì¸</button>
                <button class="pop-btn btn-no" onclick="gameInstance.cancelBuild()">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <div id="instruction" class="pointer-auto">
        <h3>ğŸš¦ ìŠ¤ë§ˆíŠ¸ êµí†µ ì‹œìŠ¤í…œ</h3>
        <p style="text-align:left; font-size:13px; color:#555; line-height:1.6;">
            1. <strong>ë˜‘ë˜‘í•œ ì£¼í–‰</strong>: ì°¨ë“¤ì´ í”ë“¤ë¦¬ì§€ ì•Šê³  ì°¨ì„ ì„ ì •í™•íˆ ì§€í‚µë‹ˆë‹¤.<br>
            2. <strong>ê¼¬ë¦¬ë¬¼ê¸° ë°©ì§€</strong>: êµì°¨ë¡œê°€ ê½‰ ì°¨ ìˆìœ¼ë©´ ì§„ì…í•˜ì§€ ì•Šê³  ëŒ€ê¸°í•©ë‹ˆë‹¤.<br>
            3. <strong>ì•ˆì „ ê±°ë¦¬</strong>: ì•ì°¨ì™€ ì¶©ëŒí•˜ì§€ ì•Šë„ë¡ ë¯¸ë¦¬ ì†ë„ë¥¼ ì¤„ì…ë‹ˆë‹¤.<br>
            4. <strong>íŒ</strong>: êµí†µëŸ‰ì´ ë§ìœ¼ë©´ 2ì°¨ì„  ë„ë¡œë‚˜ íšŒì „êµì°¨ë¡œë¥¼ í™œìš©í•˜ì„¸ìš”!
        </p>
        <button onclick="document.getElementById('instruction').style.display='none'" style="padding:10px 20px; background:#2196F3; color:white; border:none; border-radius:5px; cursor:pointer;">ê²Œì„ ì‹œì‘</button>
    </div>
</div>

<script>
    const TILE_SIZE = 40;
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;
    const SALARY = 20; 
    const INIT_MONEY = 1000;
    const WORK_DURATION = 300;

    const ROAD_TYPES = {
        1: { name: 'ì¼ë°˜ 1ì°¨ì„ ', cost: 10, speed: 1.0, lanes: 1, type: 'road', color: '#546e7a' },
        2: { name: 'ì¼ë°˜ 2ì°¨ì„ ', cost: 20, speed: 1.0, lanes: 2, type: 'road', color: '#546e7a' },
        3: { name: 'ê³ ì† 1ì°¨ì„ ', cost: 30, speed: 2.5, lanes: 1, type: 'road', color: '#37474F' },
        4: { name: 'ê³ ì† 2ì°¨ì„ ', cost: 50, speed: 2.5, lanes: 2, type: 'road', color: '#37474F' },
        5: { name: 'êµì°¨ë¡œ', cost: 50, type: 'cross', w:1, h:1, color: '#455A64' },
        6: { name: 'íšŒì „êµì°¨ë¡œ', cost: 100, type: 'round', w:2, h:2, color: '#607D8B' }
    };

    const TYPE = { EMPTY: 0, ROAD: 1, HOUSE: 2, COMPANY: 3, COMPANY_PART: 4 };
    const TEAM_COLORS = ['#ef5350', '#42a5f5', '#fdd835'];

    const STATE = {
        IDLE: 0, TO_WORK: 1, PARKING: 2, TO_ENTRANCE: 3, 
        WORKING: 4, TO_CAR: 5, TO_HOME: 6, RESTING: 7
    };

    const DIRS = [
        {dx:0,dy:-1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1},
        {dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1}
    ];

    let gameInstance = null;
    let currentMode = 'build';
    let selectedRoadType = 1;

    function setMode(mode) {
        currentMode = mode;
        document.querySelectorAll('.main-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${mode}`).classList.add('active');
        document.getElementById('roadMenu').style.display = (mode === 'build') ? 'flex' : 'none';
        if (gameInstance) gameInstance.resetInteraction();
    }

    function setRoadType(type) {
        selectedRoadType = type;
        document.querySelectorAll('.road-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.road-btn')[type-1].classList.add('active');
    }

    class Game {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.money = INIT_MONEY;
            this.camera = { x: 0, y: 0, zoom: 1.0 };
            
            this.grid = [];
            this.agents = [];
            this.buildings = [];
            
            this.isDragging = false;
            this.dragStart = null;
            this.dragEnd = null;
            this.previewPath = [];
            this.waitingConfirm = false;
            this.stampPos = null;
            
            this.lastMouse = {x:0, y:0};
            this.isPanDragging = false;
            this.isDragMoved = false;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            this.initGrid();
            this.spawnInitialBuildings();
            this.addInputListeners();
            this.loop();
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.camera.x === 0) {
                this.camera.x = (this.canvas.width - GRID_WIDTH*TILE_SIZE)/2;
                this.camera.y = (this.canvas.height - GRID_HEIGHT*TILE_SIZE)/2;
            }
        }

        initGrid() {
            for(let x=0; x<GRID_WIDTH; x++) {
                this.grid[x] = [];
                for(let y=0; y<GRID_HEIGHT; y++) {
                    this.grid[x][y] = { 
                        type: TYPE.EMPTY, roadType: 0, isFixedRoad: false,
                        connections: new Array(8).fill(false),
                        agents: [],
                        lock: null // êµì°¨ë¡œ ì ìœ ì
                    };
                }
            }
        }

        spawnInitialBuildings() {
            this.spawnBuilding(TYPE.HOUSE, 0);   
            this.spawnBuilding(TYPE.COMPANY, 0); 
            this.spawnBuilding(TYPE.HOUSE, 1);   
            this.spawnBuilding(TYPE.COMPANY, 1); 
        }

        addInputListeners() {
            const getPos = (e) => e.touches ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY};
            const start = (e) => {
                if (this.waitingConfirm) return;
                const p = getPos(e);
                this.handleStart(p.x, p.y, e.button === 2);
            };
            const move = (e) => {
                if (this.waitingConfirm) return;
                const p = getPos(e);
                this.handleMove(p.x, p.y);
            };
            const end = () => { if (this.waitingConfirm) return; this.handleEnd(); };

            this.canvas.addEventListener('mousedown', start);
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', end);
            this.canvas.addEventListener('touchstart', (e)=>{e.preventDefault(); start(e);}, {passive:false});
            window.addEventListener('touchmove', (e)=>{e.preventDefault(); move(e);}, {passive:false});
            window.addEventListener('touchend', end);
            this.canvas.addEventListener('contextmenu', e=>e.preventDefault());
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const newZoom = this.camera.zoom - Math.sign(e.deltaY) * 0.1;
                this.setZoom(newZoom, e.clientX, e.clientY);
            }, {passive: false});
        }

        screenToGrid(sx, sy) {
            const wx = (sx - this.camera.x) / this.camera.zoom;
            const wy = (sy - this.camera.y) / this.camera.zoom;
            return { x: Math.floor(wx/TILE_SIZE), y: Math.floor(wy/TILE_SIZE) };
        }

        handleStart(x, y, isRight) {
            this.lastMouse = {x, y};
            this.isDragMoved = false;
            if (currentMode === 'move' || isRight) {
                this.isPanDragging = true;
                return;
            }
            const g = this.screenToGrid(x, y);
            if (!this.isValid(g.x, g.y)) return;

            const rInfo = ROAD_TYPES[selectedRoadType];
            if (currentMode === 'build' && rInfo.type === 'stamp') {
                // ìŠ¤íƒ¬í”„
            } else {
                this.isDragging = true;
                this.dragStart = g;
                this.dragEnd = g;
            }
        }

        handleMove(x, y) {
            if (!this.isDragMoved && Math.hypot(x-this.lastMouse.x, y-this.lastMouse.y) > 5) this.isDragMoved = true;
            if (this.isPanDragging) {
                if (this.isDragMoved) {
                    this.camera.x += x - this.lastMouse.x;
                    this.camera.y += y - this.lastMouse.y;
                }
                this.lastMouse = {x, y};
                return;
            }
            const g = this.screenToGrid(x, y);
            if (currentMode === 'build' && ROAD_TYPES[selectedRoadType].type === 'stamp') {
                this.stampPos = g;
                return;
            }
            if (this.isDragging && this.isDragMoved) {
                if (this.isValid(g.x, g.y) && (g.x !== this.dragEnd.x || g.y !== this.dragEnd.y)) {
                    this.dragEnd = g;
                    this.updateDragPath();
                }
            }
        }

        handleEnd() {
            const g = this.screenToGrid(this.lastMouse.x, this.lastMouse.y);
            if (!this.isDragMoved) {
                if (this.isValid(g.x, g.y)) {
                    const cell = this.grid[g.x][g.y];
                    if (cell.type === TYPE.HOUSE && cell.ref) {
                        this.rotateBuilding(cell.ref);
                    } else if (currentMode === 'build') {
                        const rInfo = ROAD_TYPES[selectedRoadType];
                        if (rInfo.type === 'stamp') {
                            this.stampPos = g;
                            this.previewPath = [];
                            this.showConfirmPopup();
                        }
                    }
                }
            } else if (this.isDragging && this.previewPath.length > 0) {
                this.showConfirmPopup();
            }
            this.isPanDragging = false;
            this.isDragging = false;
            this.isDragMoved = false;
        }

        updateDragPath() {
            this.previewPath = [];
            if (!this.dragStart || !this.dragEnd) return;
            const x0 = this.dragStart.x, y0 = this.dragStart.y;
            const x1 = this.dragEnd.x, y1 = this.dragEnd.y;
            const dx = x1-x0, dy = y1-y0;
            const dist = Math.max(Math.abs(dx), Math.abs(dy));
            for(let i=0; i<=dist; i++) {
                const t = (dist===0) ? 0 : i/dist;
                this.previewPath.push({ x: Math.round(x0 + dx*t), y: Math.round(y0 + dy*t) });
            }
        }

        showConfirmPopup() {
            let cost = 0;
            let msg = "";
            let valid = false;

            if (currentMode === 'build') {
                const rInfo = ROAD_TYPES[selectedRoadType];
                if (rInfo.type === 'stamp') {
                    let w=rInfo.w, h=rInfo.h;
                    let canBuild = true;
                    if(this.stampPos) {
                        for(let i=0; i<w; i++) for(let j=0; j<h; j++) {
                            const nx=this.stampPos.x+i, ny=this.stampPos.y+j;
                            if(!this.isValid(nx,ny)) { canBuild=false; break; }
                            const c=this.grid[nx][ny];
                            if(c.type!==TYPE.EMPTY && c.type!==TYPE.ROAD) { canBuild=false; break; }
                        }
                    }
                    if(canBuild && this.stampPos) {
                        cost = rInfo.cost;
                        msg = `${rInfo.name} ê±´ì„¤`;
                        valid = true;
                    }
                } else {
                    this.previewPath.forEach(p => {
                        const cell = this.grid[p.x][p.y];
                        if (cell.type === TYPE.EMPTY) {
                            cost += rInfo.cost;
                            valid = true;
                        } else if (cell.type === TYPE.ROAD && !cell.isFixedRoad) {
                             if (cell.roadType !== selectedRoadType) {
                                 cost += rInfo.cost - 5;
                                 valid = true;
                             }
                        }
                    });
                    msg = `${rInfo.name} ê±´ì„¤`;
                }
            } else if (currentMode === 'erase') {
                this.previewPath.forEach(p => {
                    const c = this.grid[p.x][p.y];
                    if (c.type === TYPE.ROAD && !c.isFixedRoad) {
                        cost -= 5; 
                        valid = true;
                    }
                });
                msg = "ë„ë¡œ ì² ê±°";
            }

            if (!valid) { this.cancelBuild(); return; }

            this.waitingConfirm = true;
            document.getElementById('popup-msg').innerText = msg;
            document.getElementById('popup-cost').innerText = cost > 0 ? `ë¹„ìš©: $${cost}` : `í™˜ë¶ˆ: +$${Math.abs(cost)}`;
            document.getElementById('popup-cost').style.color = cost > 0 ? '#E91E63' : '#4CAF50';
            document.getElementById('confirm-popup').style.display = 'flex';
        }

        confirmBuild() {
            let totalCost = 0;
            let changed = false;
            const rInfo = ROAD_TYPES[selectedRoadType];

            // 1. ìŠ¤íƒ¬í”„
            if (currentMode === 'build' && rInfo.type === 'stamp' && this.stampPos) {
                if (this.money >= rInfo.cost) {
                    this.money -= rInfo.cost;
                    totalCost += rInfo.cost;
                    for(let i=0; i<rInfo.w; i++) for(let j=0; j<rInfo.h; j++) {
                        const nx=this.stampPos.x+i, ny=this.stampPos.y+j;
                        const cell = this.grid[nx][ny];
                        if(cell.type===TYPE.ROAD && !cell.isFixedRoad) this.money += 5;
                        cell.type = TYPE.ROAD;
                        cell.roadType = selectedRoadType;
                        cell.connections.fill(true);
                        this.refreshConnections(nx, ny);
                    }
                    changed = true;
                }
            }
            // 2. ë“œë˜ê·¸
            else if (this.previewPath.length > 0) {
                this.previewPath.forEach(p => {
                    const cell = this.grid[p.x][p.y];
                    if (currentMode === 'build') {
                        if (cell.type === TYPE.EMPTY || (cell.type === TYPE.ROAD && !cell.isFixedRoad && cell.roadType !== selectedRoadType)) {
                             let cost = rInfo.cost;
                             let refund = 0;
                             if(cell.type === TYPE.ROAD) refund = 5;
                             if (this.money + refund >= cost) {
                                 this.money = this.money + refund - cost;
                                 totalCost += (cost - refund);
                                 cell.type = TYPE.ROAD;
                                 cell.roadType = selectedRoadType;
                                 changed = true;
                                 this.refreshConnections(p.x, p.y);
                             }
                        }
                    } else if (currentMode === 'erase') {
                        if (cell.type === TYPE.ROAD && !cell.isFixedRoad) {
                            cell.type = TYPE.EMPTY;
                            cell.connections.fill(false);
                            this.money += 5;
                            totalCost -= 5;
                            changed = true;
                            this.disconnectNeighbors(p.x, p.y);
                        }
                    }
                });
            }

            if (changed) {
                const center = (currentMode==='build' && rInfo.type==='stamp') ? this.gridToScreen(this.stampPos.x, this.stampPos.y) : this.gridToScreen(this.previewPath[0].x, this.previewPath[0].y);
                if (totalCost > 0) this.showFloatText(`-$${totalCost}`, center.x, center.y, '#E91E63');
                else if (totalCost < 0) this.showFloatText(`+$${Math.abs(totalCost)}`, center.x, center.y, '#4CAF50');
                this.triggerCommute();
            }
            this.resetInteraction();
            this.updateUI();
        }

        cancelBuild() { this.resetInteraction(); }
        resetInteraction() {
            this.previewPath = [];
            this.stampPos = null;
            this.waitingConfirm = false;
            document.getElementById('confirm-popup').style.display = 'none';
        }

        refreshConnections(x, y) {
            const cell = this.grid[x][y];
            if(cell.type !== TYPE.ROAD) return;
            for(let i=0; i<8; i++) {
                const nx=x+DIRS[i].dx, ny=y+DIRS[i].dy;
                if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                    cell.connections[i] = true;
                    this.grid[nx][ny].connections[(i+4)%8] = true;
                }
            }
        }
        disconnectNeighbors(x, y) {
            for(let i=0; i<8; i++) {
                const nx=x+DIRS[i].dx, ny=y+DIRS[i].dy;
                if(this.isValid(nx, ny) && this.grid[nx][ny].type === TYPE.ROAD) {
                    this.grid[nx][ny].connections[(i+4)%8] = false;
                }
            }
        }

        spawnBuilding(type, colorIdx = -1) {
            let placed = false, attempts=0;
            const w = (type===TYPE.COMPANY)?4:1;
            const h = (type===TYPE.COMPANY)?3:1;
            while(!placed && attempts<100) {
                attempts++;
                const x = Math.floor(Math.random()*(GRID_WIDTH-2-w))+1;
                const y = Math.floor(Math.random()*(GRID_HEIGHT-2-h))+1;
                let ok = true;
                for(let i=-1; i<=w; i++) for(let j=-1; j<=h; j++) {
                    const cx=x+i, cy=y+j;
                    if(cx>=0 && cy>=0 && cx<GRID_WIDTH && cy<GRID_HEIGHT) {
                        if(this.grid[cx][cy].type !== TYPE.EMPTY) ok=false;
                    }
                }
                if(ok) {
                    const cIdx = (colorIdx === -1) ? Math.floor(Math.random()*3) : colorIdx;
                    const b = { x,y,type,w,h, color: TEAM_COLORS[cIdx], colorIdx: cIdx, rotation:0, parkingSlots:[], entranceRoadPos:null };
                    for(let i=0;i<w;i++) for(let j=0;j<h;j++) this.grid[x+i][y+j] = { type:(i===0&&j===0)?type:TYPE.COMPANY_PART, ref:b, connections:[], roadType:0, agents:[] };
                    this.setupEntrance(b);
                    if(type===TYPE.COMPANY) this.setupParking(b);
                    else {
                        b.entrance={x:0.5, y:0.5};
                        this.agents.push(this.createAgent(b));
                    }
                    this.buildings.push(b);
                    placed=true;
                }
            }
        }

        setupEntrance(b) {
            if (b.entranceRoadPos) {
                const ox = b.entranceRoadPos.x, oy = b.entranceRoadPos.y;
                if (this.isValid(ox, oy)) {
                    const old = this.grid[ox][oy];
                    if (old.isFixedRoad) {
                        old.type = TYPE.EMPTY; old.connections.fill(false);
                        this.disconnectNeighbors(ox, oy); 
                    }
                }
            }
            let rx, ry;
            if (b.type === TYPE.COMPANY) { rx=b.x+1; ry=b.y+3; }
            else {
                if(b.rotation===0){rx=b.x;ry=b.y+1;}
                else if(b.rotation===1){rx=b.x-1;ry=b.y;}
                else if(b.rotation===2){rx=b.x;ry=b.y-1;}
                else {rx=b.x+1;ry=b.y;}
            }
            if (this.isValid(rx,ry)) {
                const cell = this.grid[rx][ry];
                if(cell.type===TYPE.EMPTY) { cell.type=TYPE.ROAD; cell.roadType=1; cell.connections.fill(false); }
                cell.isFixedRoad=true;
                b.entranceRoadPos={x:rx, y:ry};
                this.refreshConnections(rx, ry); 
            }
        }

        setupParking(b) {
            b.entranceLocal = {x:1, y:2.8};
            b.parkingSlots = [];
            [{x:2.5,y:0.5},{x:3.5,y:0.5},{x:2.5,y:1.5},{x:3.5,y:1.5},{x:2.5,y:2.5},{x:3.5,y:2.5}].forEach(p=>{
                b.parkingSlots.push({rx:p.x, ry:p.y, occupiedBy:null});
            });
        }

        rotateBuilding(b) {
            b.rotation = (b.rotation + 1) % 4;
            this.setupEntrance(b);
            this.triggerCommute();
        }

        createAgent(home) {
            const preferredLane = Math.random() > 0.5 ? 0 : 1; 
            return {
                x: home.x+0.5, y: home.y+0.5,
                home: home, work: null, color: home.color, colorIdx: home.colorIdx,
                state: STATE.IDLE, path: [], pathIndex: 0,
                speed: 0, maxSpeed: 0.1, walking: false, targetSlot: null, angle: 0, workTimer: 0,
                lane: preferredLane
            };
        }

        triggerCommute() {
            this.agents.forEach(a => {
                if (a.state === STATE.IDLE || (a.state === STATE.TO_WORK && a.path.length === 0)) {
                    const best = this.findBestCompany(a);
                    if(best) { a.work = best; this.planRoute(a, a.work, STATE.TO_WORK); }
                }
            });
        }

        findBestCompany(a) {
            const candidates = this.buildings.filter(b => 
                b.type === TYPE.COMPANY && b.colorIdx === a.colorIdx && b.parkingSlots.some(s => !s.occupiedBy)
            );
            if (candidates.length === 0) return null;
            candidates.sort((b1, b2) => Math.hypot(b1.x - a.x, b1.y - a.y) - Math.hypot(b2.x - a.x, b2.y - a.y));
            return candidates[0];
        }

        planRoute(a, dest, mode) {
            let start = (mode===STATE.TO_WORK) ? a.home.entranceRoadPos : a.work.entranceRoadPos;
            let target = (mode===STATE.TO_WORK) ? dest.entranceRoadPos : dest.entranceRoadPos; 
            if(!start || !target) return;

            let slot = null;
            if (mode === STATE.TO_WORK) {
                slot = dest.parkingSlots.find(s => !s.occupiedBy);
                if (!slot) return;
                slot.occupiedBy = a;
                a.targetSlot = slot;
            }

            const path = this.findPath(start.x, start.y, target.x, target.y);
            if(path) {
                a.path = path;
                a.pathIndex = 0;
                a.state = mode;
                if(mode===STATE.TO_WORK) { a.x=start.x+0.5; a.y=start.y+0.5; a.walking=false; }
            } else {
                if(slot) { slot.occupiedBy = null; a.targetSlot = null; }
            }
        }

        findPath(sx, sy, tx, ty) {
            const open = [{x:sx, y:sy, g:0, h:0, f:0, p:null}];
            const closed = new Set();
            while(open.length > 0) {
                open.sort((a,b)=>a.f-b.f);
                const curr = open.shift();
                if(curr.x===tx && curr.y===ty) {
                    const path=[]; let t=curr;
                    while(t){path.unshift({x:t.x,y:t.y}); t=t.p;}
                    return path;
                }
                const k = `${curr.x},${curr.y}`;
                if(closed.has(k)) continue;
                closed.add(k);
                for(let i=0; i<8; i++) {
                    if(!this.grid[curr.x][curr.y].connections[i]) continue;
                    const nx=curr.x+DIRS[i].dx, ny=curr.y+DIRS[i].dy;
                    if(this.isValid(nx,ny) && !closed.has(`${nx},${ny}`)) {
                        const cell = this.grid[nx][ny];
                        const rType = ROAD_TYPES[cell.roadType] || ROAD_TYPES[1];
                        const weight = ((i%2===0)?1:1.414) / rType.speed; 
                        open.push({x:nx, y:ny, g:curr.g+weight, h:Math.hypot(nx-tx, ny-ty), f:curr.g+weight+Math.hypot(nx-tx, ny-ty), p:curr});
                    }
                }
            }
            return null;
        }

        update() {
            // ë„ì‹œ ì„±ì¥ (ì§‘ ë¹„ìœ¨ 80%)
            if(Math.random()<0.005 && this.buildings.length<150) {
                this.spawnBuilding(Math.random()>0.8?TYPE.COMPANY:TYPE.HOUSE);
            }

            // ê·¸ë¦¬ë“œ ìœ„ ì—ì´ì „íŠ¸ ì •ë³´ ì´ˆê¸°í™” (ì¶©ëŒ ê°ì§€ìš©)
            for(let x=0; x<GRID_WIDTH; x++) for(let y=0; y<GRID_HEIGHT; y++) {
                this.grid[x][y].agents = [];
            }
            
            // Lock í•´ì œ ì²´í¬ (ì ìœ ìê°€ ë– ë‚¬ëŠ”ì§€ í™•ì¸)
            for(let x=0; x<GRID_WIDTH; x++) for(let y=0; y<GRID_HEIGHT; y++) {
                const cell = this.grid[x][y];
                if(cell.lock) {
                    const owner = cell.lock;
                    // ì£¼ì¸ì´ IDLEìƒíƒœê±°ë‚˜, ì´ íƒ€ì¼ì—ì„œ ë©€ì–´ì¡Œìœ¼ë©´(ê±°ë¦¬ 1.5ì´ìƒ) Lock í•´ì œ
                    if(owner.state === STATE.IDLE || Math.hypot(owner.x - (x+0.5), owner.y - (y+0.5)) > 1.2) {
                        cell.lock = null;
                    }
                }
            }

            this.agents.forEach(a => {
                if(a.state === STATE.TO_WORK || a.state === STATE.TO_HOME) {
                    const gx = Math.floor(a.x), gy = Math.floor(a.y);
                    if(this.isValid(gx, gy)) this.grid[gx][gy].agents.push(a);
                }
            });

            this.agents.forEach(a => {
                if (a.state === STATE.IDLE) {
                    const best = this.findBestCompany(a);
                    if(best) { a.work = best; this.planRoute(a, a.work, STATE.TO_WORK); }
                } else if (a.state === STATE.TO_WORK) {
                    this.moveCar(a);
                    if(a.pathIndex >= a.path.length) a.state = STATE.PARKING;
                } else if (a.state === STATE.PARKING) {
                    const s = a.targetSlot;
                    const tx = a.work.x+s.rx, ty = a.work.y+s.ry;
                    if(Math.hypot(tx-a.x, ty-a.y)<0.1) { a.x=tx; a.y=ty; a.state=STATE.TO_ENTRANCE; a.walking=true; }
                    else { a.x+=(tx-a.x)*0.08; a.y+=(ty-a.y)*0.08; a.angle=Math.atan2(ty-a.y, tx-a.x); }
                } else if (a.state === STATE.TO_ENTRANCE) {
                    const ex=a.work.x+a.work.entranceLocal.x, ey=a.work.y+a.work.entranceLocal.y;
                    this.moveWalk(a, ex, ey, STATE.WORKING);
                } else if (a.state === STATE.WORKING) {
                    a.workTimer++;
                    if(a.workTimer > WORK_DURATION) { a.workTimer=0; a.state=STATE.TO_CAR; a.walking=true; }
                } else if (a.state === STATE.TO_CAR) {
                    const cx=a.work.x+a.targetSlot.rx, cy=a.work.y+a.targetSlot.ry;
                    this.moveWalk(a, cx, cy, STATE.TO_HOME);
                } else if (a.state === STATE.TO_HOME) {
                    if(a.path.length===0) { a.walking=false; this.planRoute(a, a.home, STATE.TO_HOME); }
                    this.moveCar(a);
                    if(a.path.length>0 && a.pathIndex>=a.path.length) {
                        if(a.targetSlot) { a.targetSlot.occupiedBy=null; a.targetSlot=null; }
                        a.state = STATE.RESTING;
                        this.money += SALARY; this.trips++; this.updateUI();
                        const sc = this.gridToScreen(a.x, a.y);
                        this.showFloatText(`+$${SALARY}`, sc.x, sc.y, '#4CAF50');
                    }
                } else if (a.state === STATE.RESTING) {
                    a.workTimer++;
                    if(a.workTimer > 100) { a.workTimer=0; a.state=STATE.IDLE; }
                }
            });
        }

        // --- í•µì‹¬ ì£¼í–‰ ë¡œì§ (ê°œì„ ë¨) ---
        moveCar(a) {
            if(!a.path || a.pathIndex >= a.path.length) return;
            
            if(a.pathIndex === 0) a.pathIndex = 1;
            if(a.pathIndex >= a.path.length) return;

            const nextT = a.path[a.pathIndex]; 
            const prevT = a.path[a.pathIndex - 1]; 
            
            const gx = Math.floor(a.x);
            const gy = Math.floor(a.y);
            const currentCell = this.grid[gx][gy];
            const nextCell = this.grid[nextT.x][nextT.y];
            
            const dirX = nextT.x - prevT.x;
            const dirY = nextT.y - prevT.y;
            const dist = Math.hypot(dirX, dirY);
            if(dist < 0.001) return; // ê°™ì€ ìœ„ì¹˜ë©´ íŒ¨ìŠ¤

            const rTypeInfo = ROAD_TYPES[this.grid[prevT.x][prevT.y].roadType] || ROAD_TYPES[1];

            // ìš°ì¸¡ í†µí–‰ ì˜¤í”„ì…‹
            const ndx = dirX / dist;
            const ndy = dirY / dist;
            let perpX = -ndy;
            let perpY = ndx;
            
            let laneOffset = 0.18; 
            if (rTypeInfo.lanes === 2) {
                laneOffset = (a.lane === 0) ? 0.28 : 0.10; 
            }
            
            const targetX = nextT.x + 0.5 + perpX * laneOffset;
            const targetY = nextT.y + 0.5 + perpY * laneOffset;
            
            const distToTarget = Math.hypot(targetX - a.x, targetY - a.y);
            let speed = a.maxSpeed * rTypeInfo.speed;

            // 1. êµì°¨ë¡œ ë½ (Lock)
            if (nextCell.roadType >= 5) {
                if (distToTarget < 0.8) { 
                    if (nextCell.lock && nextCell.lock !== a) {
                        // ë½ ì£¼ì¸ì´ ìœ íš¨í•˜ì§€ ì•Šê±°ë‚˜ ë©€ë©´ ëºê¸°
                        const owner = nextCell.lock;
                        const distOwner = Math.hypot(owner.x - nextT.x - 0.5, owner.y - nextT.y - 0.5);
                        if (distOwner > 1.5 || owner.state === STATE.IDLE) {
                            nextCell.lock = a; 
                        } else {
                            speed = 0; 
                        }
                    } else {
                        nextCell.lock = a; 
                    }
                }
            }

            // 2. ì°¨ê°„ ê±°ë¦¬ ìœ ì§€ (Lane Aware)
            const nearbyAgents = [...currentCell.agents, ...nextCell.agents]; 
            for (let other of nearbyAgents) {
                if (other === a) continue;

                // 2ì°¨ì„  ë„ë¡œì¼ ë•Œ, ë‹¤ë¥¸ ì°¨ì„  ì°¨ëŸ‰ ë¬´ì‹œ
                const curRoadType = ROAD_TYPES[currentCell.roadType];
                if (curRoadType && curRoadType.lanes === 2) {
                    if (a.lane !== other.lane) continue;
                }

                const d = Math.hypot(other.x - a.x, other.y - a.y);
                if (d < 0.7) { 
                    const toOtherX = other.x - a.x;
                    const toOtherY = other.y - a.y;
                    const dot = toOtherX * ndx + toOtherY * ndy;
                    
                    if (dot > 0.5) { // ì „ë°©
                        speed = 0;
                        break;
                    }
                }
            }
            
            // ì´ë™ ì‹¤í–‰
            if (distToTarget < speed) {
                a.x = targetX;
                a.y = targetY;
                a.pathIndex++;
            } else {
                a.x += (targetX - a.x) / distToTarget * speed;
                a.y += (targetY - a.y) / distToTarget * speed;
                a.angle = Math.atan2(dirY, dirX);
            }
        }

        moveWalk(a, tx, ty, next) {
            const dx=tx-a.x, dy=ty-a.y;
            const d=Math.hypot(dx,dy);
            if(d<0.05) { a.x=tx; a.y=ty; a.state=next; if(next===STATE.TO_HOME) a.path=[]; }
            else { a.x += (dx/d)*0.03; a.y += (dy/d)*0.03; }
        }

        draw() {
            this.ctx.fillStyle = '#a5d6a7';
            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
            this.ctx.save();
            this.ctx.translate(this.camera.x, this.camera.y);
            this.ctx.scale(this.camera.zoom, this.camera.zoom);
            this.ctx.fillStyle = '#81c784';
            this.ctx.fillRect(0,0,GRID_WIDTH*TILE_SIZE, GRID_HEIGHT*TILE_SIZE);

            for(let x=0; x<GRID_WIDTH; x++) for(let y=0; y<GRID_HEIGHT; y++) {
                if(this.grid[x][y].type === TYPE.ROAD) this.drawRoad(x, y);
            }
            this.buildings.forEach(b => this.drawBuilding(b));
            this.agents.forEach(a => {
                if(a.state !== STATE.IDLE && a.state !== STATE.RESTING) {
                    this.drawAgent(a);
                    if ([STATE.TO_ENTRANCE, STATE.WORKING, STATE.TO_CAR].includes(a.state)) this.drawParkedCar(a);
                }
            });
            if (currentMode === 'build' || currentMode === 'erase') this.drawPreview();
            this.ctx.restore();
        }

        drawPreview() {
            if (this.previewPath.length > 0) {
                this.ctx.fillStyle = (currentMode==='erase') ? 'rgba(244,67,54,0.5)' : 'rgba(33,150,243,0.5)';
                this.previewPath.forEach(p => this.ctx.fillRect(p.x*TILE_SIZE, p.y*TILE_SIZE, TILE_SIZE, TILE_SIZE));
            } else if (this.stampPos && ROAD_TYPES[selectedRoadType].type==='stamp') {
                const r=ROAD_TYPES[selectedRoadType];
                this.ctx.strokeStyle='rgba(0,255,0,0.8)'; this.ctx.lineWidth=2;
                this.ctx.strokeRect(this.stampPos.x*TILE_SIZE, this.stampPos.y*TILE_SIZE, r.w*TILE_SIZE, r.h*TILE_SIZE);
            }
        }

        drawRoad(x, y) {
            const c = this.grid[x][y];
            const info = ROAD_TYPES[c.roadType] || ROAD_TYPES[1];
            const cx=x*TILE_SIZE+TILE_SIZE/2, cy=y*TILE_SIZE+TILE_SIZE/2;
            
            this.ctx.fillStyle = info.color;
            let radius = TILE_SIZE*0.42;
            if (c.roadType === 6) radius = TILE_SIZE * 0.5;

            this.ctx.beginPath(); this.ctx.arc(cx,cy,radius,0,Math.PI*2); this.ctx.fill();
            this.ctx.strokeStyle = info.color;
            this.ctx.lineWidth = TILE_SIZE * (c.roadType===6 ? 0.9 : 0.85);
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            for(let i=0; i<8; i++) {
                if(c.connections[i]) {
                    this.ctx.moveTo(cx,cy);
                    this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.6, cy+DIRS[i].dy*TILE_SIZE*0.6);
                }
            }
            this.ctx.stroke();

            if(c.roadType <= 4) { 
                const isHighway = (c.roadType >= 3);
                const is2Lane = (c.roadType % 2 === 0);
                this.ctx.strokeStyle = isHighway ? '#FFEB3B' : 'rgba(255,255,255,0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                for(let i=0; i<8; i++) {
                    if(c.connections[i]) {
                        this.ctx.moveTo(cx,cy);
                        this.ctx.lineTo(cx+DIRS[i].dx*TILE_SIZE*0.5, cy+DIRS[i].dy*TILE_SIZE*0.5);
                    }
                }
                this.ctx.stroke();
                if (is2Lane) {
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([3, 3]);
                    // ì¤‘ì•™ì„  ì˜† ì ì„  í‘œí˜„ (ìƒëµ: ë³µì¡ë„)
                    this.ctx.setLineDash([]);
                }
            } else if (c.roadType === 5) { 
                this.ctx.fillStyle='#fff'; this.ctx.fillRect(cx-4,cy-4,8,8);
            } else if (c.roadType === 6) { 
                this.ctx.fillStyle='#4CAF50'; this.ctx.beginPath(); this.ctx.arc(cx,cy,TILE_SIZE*0.2,0,Math.PI*2); this.ctx.fill();
            }
        }

        drawBuilding(b) {
            const bx=b.x*TILE_SIZE, by=b.y*TILE_SIZE;
            if(b.type===TYPE.HOUSE) {
                const cx=bx+TILE_SIZE/2, cy=by+TILE_SIZE/2;
                this.ctx.save(); this.ctx.translate(cx,cy); this.ctx.rotate([0,0.5,1,1.5][b.rotation]*Math.PI);
                const s=TILE_SIZE*0.8; this.ctx.fillStyle='#fff'; this.ctx.fillRect(-s/2,-s/2,s,s);
                this.ctx.fillStyle=b.color; this.ctx.beginPath(); this.ctx.moveTo(-s/2-2,-s/2); this.ctx.lineTo(0,-s/2-10); this.ctx.lineTo(s/2+2,-s/2); this.ctx.fill();
                this.ctx.fillStyle='#795548'; this.ctx.fillRect(-4,s/2-6,8,6);
                this.ctx.restore();
            } else {
                const bw=b.w*TILE_SIZE, bh=b.h*TILE_SIZE;
                this.ctx.fillStyle='#cfd8dc'; this.ctx.fillRect(bx,by,bw,bh);
                this.ctx.fillStyle='#eceff1'; this.ctx.fillRect(bx,by,bw*0.5-2, bh-2);
                this.ctx.fillStyle=b.color; this.ctx.fillRect(bx,by,bw*0.5-2, 10);
                const px=bx+bw*0.5, py=by;
                this.ctx.fillStyle='#90a4ae'; this.ctx.fillRect(px,py,bw*0.5-2, bh-2);
                this.ctx.strokeStyle='white'; this.ctx.lineWidth=1;
                b.parkingSlots.forEach(s => this.ctx.strokeRect((b.x+s.rx)*TILE_SIZE-12, (b.y+s.ry)*TILE_SIZE-8, 24, 16));
            }
        }

        drawAgent(a) {
            const sx=a.x*TILE_SIZE, sy=a.y*TILE_SIZE;
            if(a.walking) {
                this.ctx.fillStyle='#333'; this.ctx.beginPath(); this.ctx.arc(sx,sy,4,0,Math.PI*2); this.ctx.fill();
                this.ctx.fillStyle=a.color; this.ctx.beginPath(); this.ctx.arc(sx,sy-3,3,0,Math.PI*2); this.ctx.fill();
            } else {
                this.ctx.save(); this.ctx.translate(sx,sy); this.ctx.rotate(a.angle);
                this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
                this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8);
                this.ctx.restore();
            }
        }

        drawParkedCar(a) {
            if(!a.targetSlot) return;
            const sx=(a.work.x+a.targetSlot.rx)*TILE_SIZE, sy=(a.work.y+a.targetSlot.ry)*TILE_SIZE;
            this.ctx.save(); this.ctx.translate(sx,sy);
            this.ctx.fillStyle=a.color; this.ctx.fillRect(-9,-5,18,10);
            this.ctx.fillStyle='#222'; this.ctx.fillRect(2,-4,4,8);
            this.ctx.restore();
        }

        isValid(x, y) { return x>=0 && y>=0 && x<GRID_WIDTH && y<GRID_HEIGHT; }
        updateUI() {
            document.getElementById('moneyDisplay').innerText = this.money;
            document.getElementById('populationDisplay').innerText = this.agents.length;
        }
        gridToScreen(gx, gy) { return { x: gx*TILE_SIZE*this.camera.zoom + this.camera.x, y: gy*TILE_SIZE*this.camera.zoom + this.camera.y }; }
        zoomIn(){ this.setZoom(this.camera.zoom+0.2); }
        zoomOut(){ this.setZoom(this.camera.zoom-0.2); }
        setZoom(z) {
            const nz = Math.max(0.3, Math.min(z, 3.0));
            const cx = this.canvas.width/2, cy = this.canvas.height/2;
            const wx = (cx - this.camera.x)/this.camera.zoom, wy = (cy - this.camera.y)/this.camera.zoom;
            this.camera.x = cx - wx*nz; this.camera.y = cy - wy*nz;
            this.camera.zoom = nz;
        }
        loop() { this.update(); this.draw(); requestAnimationFrame(() => this.loop()); }
        showFloatText(txt, x, y, col) {
            const el = document.createElement('div'); el.className = 'float-text';
            el.innerText = txt; el.style.left = x+'px'; el.style.top = y+'px'; el.style.color = col;
            document.body.appendChild(el); setTimeout(()=>el.remove(), 1000);
        }
    }

    window.onload = () => { gameInstance = new Game('gameCanvas'); };
</script>
</body>
</html>
