<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Lander: 50 Levels Challenge</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Consolas', monospace;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            background-color: #000;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            width: 90%;
            display: flex;
            justify-content: space-between;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 5px; }
        .hud-right { text-align: right; }
        
        .info { font-size: 16px; font-weight: bold; letter-spacing: 1px; }
        .danger { color: #ff4444; }
        .safe { color: #44ff44; }
        .warn { color: #ffaa00; }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border: 1px solid white;
            border-radius: 10px;
        }
        #message h1 { font-size: 36px; margin: 0 0 10px 0; color: #fff; }
        #message p { font-size: 16px; margin: 0; color: #ccc; }

        .controls {
            margin-top: 10px;
            color: #666;
            font-size: 12px;
        }
        /* 레벨 진행바 */
        #progressBar {
            position: absolute;
            bottom: 40px;
            width: 800px;
            height: 4px;
            background: #333;
        }
        #progressFill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-left">
            <div class="info">LEVEL <span id="levelVal" style="color:#0f0">1</span>/50</div>
            <div class="info" id="planetName" style="color:#aaa; font-size:14px">THE MOON</div>
            <div class="info">FUEL: <span id="fuelVal">100</span></div>
        </div>
        <div class="hud-right">
            <div class="info">ALT: <span id="altVal">0</span></div>
            <div class="info">H-SPEED: <span id="hSpeedVal">0</span></div>
            <div class="info">V-SPEED: <span id="vSpeedVal">0</span></div>
            <div class="info">WIND: <span id="windVal">0</span></div>
        </div>
    </div>

    <div id="message">
        <h1 id="msgTitle">LEVEL CLEARED</h1>
        <p id="msgSub">Press Space</p>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="progressBar"><div id="progressFill"></div></div>

    <div class="controls">
        [↑] MAIN ENGINE | [← / →] THRUSTERS | [Space] NEXT / RESTART
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI 요소 연결
        const uiLevel = document.getElementById('levelVal');
        const uiPlanet = document.getElementById('planetName');
        const uiFuel = document.getElementById('fuelVal');
        const uiAlt = document.getElementById('altVal');
        const uiHSpeed = document.getElementById('hSpeedVal');
        const uiVSpeed = document.getElementById('vSpeedVal');
        const uiWind = document.getElementById('windVal');
        const msgBox = document.getElementById('message');
        const msgTitle = document.getElementById('msgTitle');
        const msgSub = document.getElementById('msgSub');
        const progressFill = document.getElementById('progressFill');

        // 게임 상수
        const MAX_LEVEL = 50;
        const SAFE_V_SPEED = 2.5; // 수직 착륙 안전 속도
        const SAFE_H_SPEED = 1.5; // 수평 이동 안전 속도
        const SAFE_ANGLE = 0.25;  // 안전 각도 (라디안)
        const LANDER_SIZE = 20;

        // 전역 변수
        let currentLevel = 1;
        let gameState = 'ready'; 
        let keys = {};
        
        let terrainPoints = [];
        let landingPad = { x: 0, width: 0, y: 0 };
        let particles = [];
        let obstacles = [];
        let levelConfig = {};

        const lander = {
            x: 0, y: 0, vx: 0, vy: 0, angle: 0, fuel: 0, visible: true
        };

        // --- 레벨 난이도 생성기 (핵심 로직) ---
        function getLevelConfig(level) {
            // 0.0 ~ 1.0 진행도
            const progress = (level - 1) / (MAX_LEVEL - 1); 

            // 1. 테마 결정 (10레벨마다 변경)
            let theme = 'MOON';
            let bgColor = '#000000';
            let groundColor = '#aaaaaa';
            let weather = 'none';

            if (level <= 10) { theme = 'THE MOON (달)'; bgColor='#050505'; groundColor='#bbb'; weather='none'; }
            else if (level <= 20) { theme = 'MARS (화성)'; bgColor='#2b0e0e'; groundColor='#c1440e'; weather='dust'; }
            else if (level <= 30) { theme = 'EARTH (지구/폭풍)'; bgColor='#0a1a2a'; groundColor='#2a5a1a'; weather='rain'; }
            else if (level <= 40) { theme = 'ICE PLANET (얼음행성)'; bgColor='#0b1021'; groundColor='#aaccff'; weather='snow'; }
            else { theme = 'VOLCANIC (용암행성)'; bgColor='#1a0500'; groundColor='#4a1100'; weather='ember'; }

            // 2. 물리 변수 계산 (선형 보간)
            // 중력: 0.05(쉬움) -> 0.12(매우 무거움)
            const gravity = 0.03 + (0.07 * progress);
            
            // 연료: 120(넉넉함) -> 70(부족함)
            const fuel = Math.max(70, 120 - (progress * 50));

            // 착륙장 크기: 3.5배(넓음) -> 1.2배(기체랑 거의 같음)
            const padSizeMult = Math.max(1.2, 3.5 - (2.3 * progress));

            // 3. 바람 (레벨 5부터 시작, 점점 강해짐)
            let wind = 0;
            if (level >= 5) {
                // 방향은 랜덤 (-1 or 1), 세기는 레벨 비례
                const direction = Math.random() < 0.5 ? 1 : -1;
                const strength = Math.min(0.04, (level - 4) * 0.0015);
                wind = direction * strength;
            }

            // 4. 장애물 (레벨 11부터 10레벨마다 1개씩 추가, 최대 5개)
            let obstacleCount = 0;
            if (level >= 11) {
                obstacleCount = Math.floor((level - 1) / 10);
            }

            return {
                theme, bgColor, groundColor, weather,
                gravity, fuel, padSizeMult, wind, obstacleCount
            };
        }

        // --- 초기화 함수 ---

        function initLevel(level) {
            if (level > MAX_LEVEL) {
                gameState = 'gameover';
                showMessage("GALAXY CONQUERED!", "All 50 Levels Cleared! You are a Legend.", "#ffd700");
                return;
            }

            currentLevel = level;
            levelConfig = getLevelConfig(level);
            
            // 우주선 리셋
            lander.x = canvas.width / 2;
            lander.y = 50;
            lander.vx = 0;
            lander.vy = 0;
            lander.angle = 0;
            lander.fuel = levelConfig.fuel;
            lander.visible = true;

            generateTerrain(levelConfig.padSizeMult);
            initEnvironment(levelConfig);
            initObstacles(levelConfig.obstacleCount);

            // UI 업데이트
            uiLevel.innerText = currentLevel;
            uiPlanet.innerText = levelConfig.theme;
            uiFuel.innerText = Math.floor(lander.fuel);
            updateWindUI(levelConfig.wind);
            
            progressFill.style.width = `${(currentLevel / MAX_LEVEL) * 100}%`;

            gameState = 'playing';
            msgBox.style.display = 'none';
        }

        function updateWindUI(wind) {
            if (Math.abs(wind) < 0.001) {
                uiWind.innerText = "0.00";
                uiWind.style.color = "white";
            } else {
                const direction = wind > 0 ? ">>>" : "<<<";
                const speed = Math.abs(wind * 1000).toFixed(0);
                uiWind.innerText = `${direction} ${speed}`;
                uiWind.style.color = "cyan";
            }
        }

        function generateTerrain(padMult) {
            terrainPoints = [];
            const segments = 30; // 지형을 더 촘촘하게
            const segmentWidth = canvas.width / segments;
            
            // 착륙장 위치 랜덤 (가장자리 제외)
            const padIndex = Math.floor(Math.random() * (segments - 6)) + 3;
            
            landingPad.width = LANDER_SIZE * padMult;
            landingPad.x = padIndex * segmentWidth;
            landingPad.y = 500 + (Math.random() * 50 - 25); // 착륙장 높이도 약간 랜덤

            // 지형 생성 노이즈
            let currentHeight = 400;
            for (let i = 0; i <= segments; i++) {
                let x = i * segmentWidth;
                let y;

                // 착륙장 구간
                if (x >= landingPad.x - segmentWidth/2 && x <= landingPad.x + landingPad.width + segmentWidth/2) {
                    // 착륙장 주변을 부드럽게 평탄화
                    if (x >= landingPad.x && x <= landingPad.x + landingPad.width) {
                        y = landingPad.y; // 완전 평지
                    } else {
                         // 착륙장 연결 부위
                         y = landingPad.y + 10;
                    }
                } else {
                    // 일반 지형: 랜덤하게 높낮이 변화 (레벨이 높을수록 더 험하게 할 수도 있음)
                    currentHeight += (Math.random() - 0.5) * 80;
                    // 화면 범위 제한
                    currentHeight = Math.max(200, Math.min(580, currentHeight));
                    y = currentHeight;
                }
                terrainPoints.push({ x: x, y: y });
            }
        }

        function initEnvironment(config) {
            particles = [];
            let count = 50;
            let type = 'star';
            
            if (config.weather === 'dust') { count = 80; type = 'dust'; }
            if (config.weather === 'rain') { count = 150; type = 'rain'; }
            if (config.weather === 'snow') { count = 120; type = 'snow'; }
            if (config.weather === 'ember') { count = 100; type = 'ember'; }

            for(let i=0; i<count; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: Math.random() * 2 + 0.5,
                    size: Math.random() * 2,
                    type: type
                });
            }
        }

        function initObstacles(count) {
            obstacles = [];
            for(let i=0; i<count; i++) {
                obstacles.push({
                    x: Math.random() * canvas.width,
                    y: 100 + Math.random() * 300,
                    // 속도도 레벨에 따라 빨라짐
                    speed: (1.5 + (currentLevel * 0.05)) * (Math.random() < 0.5 ? 1 : -1),
                    radius: 8 + Math.random() * 5,
                    phase: Math.random() * Math.PI * 2 // 움직임 패턴용
                });
            }
        }

        // --- 게임 루프 ---

        function update() {
            if (gameState !== 'playing') return;

            // 1. 조작
            if (keys['ArrowLeft']) lander.angle -= 0.03;
            if (keys['ArrowRight']) lander.angle += 0.03;
            if (keys['ArrowUp'] && lander.fuel > 0) {
                lander.vx += Math.sin(lander.angle) * 0.15; // 추력
                lander.vy -= Math.cos(lander.angle) * 0.15;
                lander.fuel -= 0.35;
            }

            // 2. 물리 (중력 + 바람)
            lander.vy += levelConfig.gravity;
            lander.vx += levelConfig.wind;

            lander.x += lander.vx;
            lander.y += lander.vy;

            // 화면 루프/막힘
            if (lander.x < 0) lander.x = canvas.width;
            if (lander.x > canvas.width) lander.x = 0;
            if (lander.y < 0) { lander.y = 0; lander.vy = 0; }

            // 3. 장애물 이동 및 충돌
            obstacles.forEach(obs => {
                obs.x += obs.speed;
                // 약간의 상하 움직임 (사인파)
                obs.y += Math.sin(Date.now() / 500 + obs.phase) * 0.5;

                if (obs.x < 0 || obs.x > canvas.width) obs.speed *= -1;

                const dist = Math.hypot(lander.x - obs.x, lander.y - obs.y);
                if (dist < obs.radius + LANDER_SIZE/2) {
                    endGame(false, `COLLISION! (Obj: ${levelConfig.theme})`);
                }
            });

            // 4. 지형 충돌 체크
            checkTerrainCollision();

            // 5. UI 업데이트
            uiFuel.innerText = Math.floor(lander.fuel);
            if (lander.fuel < 20) uiFuel.className = "info danger";
            else uiFuel.className = "info";

            uiAlt.innerText = Math.max(0, Math.floor(landingPad.y - lander.y));
            
            uiHSpeed.innerText = Math.abs(lander.vx).toFixed(2);
            uiHSpeed.className = Math.abs(lander.vx) > SAFE_H_SPEED ? "info danger" : "info safe";
            
            uiVSpeed.innerText = Math.abs(lander.vy).toFixed(2);
            uiVSpeed.className = lander.vy > SAFE_V_SPEED ? "info danger" : "info safe";
        }

        function checkTerrainCollision() {
            const bottomX = lander.x;
            const bottomY = lander.y + LANDER_SIZE/2;
            
            // 착륙장 위인가?
            const onPadX = bottomX >= landingPad.x && bottomX <= landingPad.x + landingPad.width;
            
            // 현재 위치의 지형 높이 찾기 (간단화된 선형 탐색)
            let terrainH = canvas.height;
            const segmentWidth = canvas.width / (terrainPoints.length - 1);
            const idx = Math.floor(bottomX / segmentWidth);
            
            if (idx >= 0 && idx < terrainPoints.length - 1) {
                const p1 = terrainPoints[idx];
                const p2 = terrainPoints[idx + 1];
                // 선형 보간
                terrainH = p1.y + (bottomX - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);
            }

            // 착륙장 위라면 높이 판정을 착륙장 높이로 고정 (판정 관대하게)
            if (onPadX && Math.abs(bottomY - landingPad.y) < 10) {
                 terrainH = landingPad.y;
            }

            if (bottomY >= terrainH) {
                lander.y = terrainH - LANDER_SIZE/2;
                
                if (onPadX) {
                    const safeV = lander.vy < SAFE_V_SPEED;
                    const safeH = Math.abs(lander.vx) < SAFE_H_SPEED;
                    const safeA = Math.abs(lander.angle) < SAFE_ANGLE;

                    if (safeV && safeH && safeA) {
                        endGame(true, "PERFECT LANDING");
                    } else {
                        let reason = "CRASHED: ";
                        if (!safeV) reason += "Too Fast (Vertical)";
                        else if (!safeH) reason += "Too Fast (Horizontal)";
                        else if (!safeA) reason += "Bad Angle";
                        endGame(false, reason);
                    }
                } else {
                    endGame(false, "HIT TERRAIN");
                }
            }
        }

        function endGame(success, reason) {
            gameState = success ? 'landed' : 'crashed';
            lander.visible = !success; 
            
            const color = success ? '#44ff44' : '#ff4444';
            showMessage(success ? "LEVEL CLEARED" : "MISSION FAILED", reason, color);
        }

        function showMessage(title, sub, color) {
            msgTitle.innerText = title;
            msgSub.innerText = sub;
            msgTitle.style.color = color;
            msgBox.style.display = 'block';
        }

        function draw() {
            // 배경
            ctx.fillStyle = levelConfig.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 날씨 입자 그리기
            ctx.fillStyle = (levelConfig.weather === 'ember') ? '#ff5500' : 'white';
            if (levelConfig.weather === 'rain') ctx.fillStyle = '#6688cc';
            
            particles.forEach(p => {
                p.x += p.vx + levelConfig.wind * 20; // 바람 영향 받음
                p.y += p.vy;
                if(p.x > canvas.width) p.x = 0;
                if(p.x < 0) p.x = canvas.width;
                if(p.y > canvas.height) p.y = 0;

                if (levelConfig.weather === 'rain') {
                    ctx.fillRect(p.x, p.y, 1, p.size * 3);
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // 지형
            ctx.beginPath();
            ctx.moveTo(terrainPoints[0].x, terrainPoints[0].y);
            for(let i=1; i<terrainPoints.length; i++) {
                ctx.lineTo(terrainPoints[i].x, terrainPoints[i].y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.fillStyle = levelConfig.groundColor;
            ctx.fill();

            // 착륙장 (반짝이는 효과)
            const glow = Math.sin(Date.now()/200) * 50 + 100;
            ctx.fillStyle = `rgb(${glow}, ${glow}, 0)`;
            ctx.fillRect(landingPad.x, landingPad.y, landingPad.width, 5);
            
            // 착륙장 유도등
            ctx.fillStyle = 'lime';
            ctx.fillRect(landingPad.x, landingPad.y, 3, -10);
            ctx.fillRect(landingPad.x + landingPad.width - 3, landingPad.y, 3, -10);

            // 장애물
            obstacles.forEach(obs => {
                ctx.fillStyle = (levelConfig.weather === 'ember') ? '#550000' : 'red';
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.stroke();
            });

            // 플레이어
            if (lander.visible) {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // 그림자 (기체 회전 무시하고 아래로)
                // ctx.shadowBlur = 10; ctx.shadowColor = "white";

                // 몸체
                ctx.fillStyle = '#eee';
                ctx.fillRect(-10, -10, 20, 20);
                
                // 창문
                ctx.fillStyle = '#33ccff';
                ctx.fillRect(-5, -5, 10, 10);

                // 다리
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-10, 10); ctx.lineTo(-15, 18); ctx.lineTo(-18, 18);
                ctx.moveTo(10, 10); ctx.lineTo(15, 18); ctx.lineTo(18, 18);
                ctx.stroke();

                // 불꽃
                if (keys['ArrowUp'] && lander.fuel > 0) {
                    ctx.fillStyle = `rgb(255, ${Math.random()*200}, 0)`;
                    ctx.beginPath();
                    ctx.moveTo(-6, 10);
                    ctx.lineTo(6, 10);
                    ctx.lineTo(0, 25 + Math.random()*15);
                    ctx.fill();
                }

                // 좌우 추력 불꽃
                if (keys['ArrowLeft']) {
                    ctx.fillStyle = '#aaf';
                    ctx.fillRect(8, -8, 8, 4);
                }
                if (keys['ArrowRight']) {
                    ctx.fillStyle = '#aaf';
                    ctx.fillRect(-16, -8, 8, 4);
                }

                ctx.restore();
            } else if (gameState === 'crashed') {
                // 폭발 이펙트
                for(let k=0; k<10; k++) {
                    ctx.fillStyle = `rgba(255, ${Math.random()*100}, 0, 0.7)`;
                    ctx.beginPath();
                    ctx.arc(lander.x + (Math.random()-0.5)*30, lander.y + (Math.random()-0.5)*30, Math.random()*15, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') {
                if (gameState === 'landed') initLevel(currentLevel + 1);
                else if (gameState === 'crashed') initLevel(currentLevel); // 같은 레벨 재도전
                else if (gameState === 'gameover') initLevel(1);
            }
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // 시작
        initLevel(1);
        loop();

    </script>
</body>
</html>
