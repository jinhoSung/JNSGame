<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Racer - Code Art Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 80px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 
                5px 5px 0 #000,
                0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 20;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <div id="ui">
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span>
    </div>
    <div id="drift-msg">KANSEI DRIFT!!</div>
    <div id="instructions">
        [â–²] ACCEL | [â–¼] BRAKE + TURN (DRIFT) | [â—€ â–¶] STEER
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const driftMsg = document.getElementById('drift-msg');

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- ê²Œì„ ì„¤ì • ìƒìˆ˜ ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 2000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);

    // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     // í•¸ë“¤ë§ ìƒíƒœ (-1 ~ 1)
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;

    let skids = [];
    let segments = [];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // --- ìœ í‹¸ë¦¬í‹° ---
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
        p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
        p.screen.w = Math.round((p.screen.scale * roadWidth * width / 2));
    }

    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    // --- ë„ë¡œ ìƒì„± ---
    function createRoad() {
        segments = [];
        const totalSegments = 2000; 
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;
            // ë§µ ë””ìì¸ (ì½”ë„ˆ ë°°ì¹˜)
            if (i > 300 && i < 700) curve = 2;
            if (i > 800 && i < 1200) curve = -3; // ê¸´ ì™¼ìª½ ì½”ë„ˆ
            if (i > 1300 && i < 1700) curve = 3; // ê¸´ ì˜¤ë¥¸ìª½ ì½”ë„ˆ

            // ì–¸ë• (Slight Hills)
            y = Math.sin(i / 30) * 1000;

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor }
            });
        }
    }

    // --- ë Œë”ë§ ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // 1. ë°°ê²½ (ë°¤ í•˜ëŠ˜)
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#000022');
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        // ë‹¬
        ctx.fillStyle = '#fffc';
        ctx.beginPath(); ctx.arc(width*0.8, 100, 40, 0, Math.PI*2); ctx.fill();

        // 2. ë„ë¡œ ê·¸ë¦¬ê¸°
        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 

        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n) % segments.length;
            let segment = segments[currentIdx];
            let loopOffset = (segment.index < baseSegment.index) ? segments.length * SEGMENT_LENGTH : 0;
            
            // ì¹´ë©”ë¼ Yê°’ì— ë„ë¡œ ë†’ì´ ë°˜ì˜ (ì–¸ë•)
            let camY = CAMERA_HEIGHT + segments[Math.floor((position+100)/SEGMENT_LENGTH)%segments.length].p1.world.y;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH || segment.p2.screen.y >= maxy || segment.p2.screen.y >= segment.p1.screen.y) continue;

            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            // ë•… (ì–´ë‘ìš´ ë…¹ìƒ‰)
            ctx.fillStyle = '#001100';
            ctx.fillRect(0, y2, width, y1 - y2);

            // ëŸ¼ë¸” & ë„ë¡œ
            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, y2, l2 - r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, y2, l2 + r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, y2, l2 - r2, y2, segment.color.road);

            maxy = y2;
        }

        drawSkidMarks();
        drawCarSprite(); // ìƒˆë¡œìš´ ìë™ì°¨ ê·¸ë¦¬ê¸° í•¨ìˆ˜
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }

            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; // ì—°ê¸° ìƒ‰
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    // ==========================================
    //  ğŸ ìë™ì°¨ ê·¸ë¦¬ê¸° (Sprite Replacement) ğŸ
    // ==========================================
    // ì—¬ê¸°ì„œëŠ” ìˆ˜í•™ì  3D ë°•ìŠ¤ ëŒ€ì‹ ,
    // "ìƒí™©ì— ë”°ë¼ ë¯¸ë¦¬ ë””ìì¸ëœ 2D ê·¸ë¦¼"ì„ ê·¸ë¦½ë‹ˆë‹¤.
    // 1. Rear (ì§ì§„)
    // 2. Angled (íšŒì „)
    // 3. Side (ë“œë¦¬í”„íŠ¸)
    
    function drawCarSprite() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 1200; // í¬ê¸° ì¡°ì ˆ
        
        // ë°”ìš´ìŠ¤ íš¨ê³¼
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        
        const cx = width / 2;
        const cy = height - 120 * scale + bounce;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);

        // ìƒíƒœ ê²°ì •
        let mode = 'STRAIGHT';
        const absTurn = Math.abs(playerTurn);
        
        if (driftMode && absTurn > 0.5) mode = 'DRIFT';
        else if (absTurn > 0.2) mode = 'TURN';

        // ë°©í–¥ (ì¢Œ/ìš°)
        const dir = playerTurn < 0 ? -1 : 1;
        
        // ì°¨ ê·¸ë¦¬ê¸°
        if (mode === 'STRAIGHT') drawAE86_Rear(ctx);
        else if (mode === 'TURN') drawAE86_Angle(ctx, dir);
        else if (mode === 'DRIFT') drawAE86_Side(ctx, dir);

        // ë“œë¦¬í”„íŠ¸ ì—°ê¸° ì´í™íŠ¸ (ì°¨ì²´ ì£¼ë³€)
        if (driftMode && speed > 5000) {
             // ... ì—°ê¸° íŒŒí‹°í´ì€ skids ë°°ì—´ì—ì„œ ì²˜ë¦¬
        }

        ctx.restore();
    }

    // [1] ì§ì§„ ëª¨ìŠµ (AE86 ìŠ¤íƒ€ì¼ - í‘ë°± íŒ¬ë”)
    function drawAE86_Rear(ctx) {
        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.ellipse(0, 90, 130, 15, 0, 0, Math.PI*2); ctx.fill();

        // ë°”ë”” (í•˜ë‹¨ - í°ìƒ‰)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(-90, 50); ctx.lineTo(90, 50); // í•˜ë‹¨ í­
        ctx.lineTo(95, 90); ctx.lineTo(-95, 90); // ë°”í€´ ìª½ìœ¼ë¡œ ë„“ì–´ì§
        ctx.fill();

        // ë²”í¼ (ê²€ì •)
        ctx.fillStyle = '#222';
        ctx.fillRect(-95, 80, 190, 15);
        
        // ìºë¹ˆ (ìƒë‹¨ - ìœ ë¦¬ì°½)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(-60, 0); ctx.lineTo(60, 0); // ì§€ë¶•
        ctx.lineTo(80, 50); ctx.lineTo(-80, 50); // í—ˆë¦¬
        ctx.fill();

        // ë’·ìœ ë¦¬
        ctx.fillStyle = '#223';
        ctx.beginPath();
        ctx.moveTo(-55, 5); ctx.lineTo(55, 5);
        ctx.lineTo(75, 45); ctx.lineTo(-75, 45);
        ctx.fill();

        // í…Œì¼ë¨í”„ (AE86 íŠ¹ìœ ì˜ ë°” ëª¨ì–‘)
        ctx.fillStyle = '#111';
        ctx.fillRect(-85, 50, 170, 20); // ë¨í”„ ë² ì´ìŠ¤
        
        // ë¸Œë ˆì´í¬ë“± (ë¹¨ê°•)
        const lightColor = keys.ArrowDown ? '#ff2222' : '#cc0000';
        ctx.fillStyle = lightColor;
        if(keys.ArrowDown) { ctx.shadowColor='red'; ctx.shadowBlur=20; }
        
        ctx.fillRect(-80, 52, 50, 16); // ì¢Œ
        ctx.fillRect(30, 52, 50, 16);  // ìš°
        ctx.shadowBlur = 0;

        // ë²ˆí˜¸íŒ (ë…¸ë‘)
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(-15, 55, 30, 12);

        // ë¨¸í”ŒëŸ¬
        ctx.fillStyle = '#555';
        ctx.beginPath(); ctx.arc(70, 90, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(70, 90, 3, 0, Math.PI*2); ctx.fill();

        // íƒ€ì´ì–´
        ctx.fillStyle = '#111';
        ctx.fillRect(-95, 85, 20, 15);
        ctx.fillRect(75, 85, 20, 15);
    }

    // [2] ì•½ê°„ íšŒì „í•œ ëª¨ìŠµ (íˆ¬ì‹œ ì›ê·¼ ì ìš©)
    // dir: -1(ì¢Œ), 1(ìš°)
    function drawAE86_Angle(ctx, dir) {
        ctx.save();
        ctx.scale(dir, 1); // ì¢Œìš° ë°˜ì „ìœ¼ë¡œ í•œìª½ë§Œ ê·¸ë¦¼

        // íšŒì „ ì‹œ ì°¨ì²´ê°€ ì•½ê°„ ê¸°ì›€
        ctx.rotate(0.05);

        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.ellipse(10, 90, 130, 15, 0, 0, Math.PI*2); ctx.fill();

        // ì˜†ë©´ (ê²€ì • ë¼ì¸ - íŒ¬ë” ë„ìƒ‰)
        ctx.fillStyle = '#eee'; // í°ìƒ‰ ë² ì´ìŠ¤
        ctx.beginPath();
        ctx.moveTo(-90, 50); ctx.lineTo(60, 50); // ë’·ë©´ í­ ì¤„ì–´ë“¦
        ctx.lineTo(110, 60); // ì˜†ë©´ ê¸¸ì–´ì§ (ì›ê·¼)
        ctx.lineTo(110, 90); 
        ctx.lineTo(-95, 90);
        ctx.fill();

        // ê²€ì • ë  (Panda Scheme)
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(60, 50); ctx.lineTo(110, 60);
        ctx.lineTo(110, 75); ctx.lineTo(60, 65);
        ctx.fill();

        // ë’·ë©´ (Turn View)
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(-90, 50); ctx.lineTo(60, 50);
        ctx.lineTo(60, 90); ctx.lineTo(-95, 90);
        ctx.fill();

        // ìºë¹ˆ (ì˜†ëª¨ìŠµ ë³´ì„)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(-60, 0); ctx.lineTo(30, 0);
        ctx.lineTo(90, 50); ctx.lineTo(-80, 50);
        ctx.fill();
        
        // ì˜†ìœ ë¦¬
        ctx.fillStyle = '#223';
        ctx.beginPath();
        ctx.moveTo(30, 5); ctx.lineTo(85, 45);
        ctx.lineTo(35, 45); ctx.lineTo(0, 5);
        ctx.fill();
        
        // ë’·ìœ ë¦¬
        ctx.beginPath();
        ctx.moveTo(-55, 5); ctx.lineTo(0, 5);
        ctx.lineTo(35, 45); ctx.lineTo(-75, 45);
        ctx.fill();

        // í…Œì¼ë¨í”„ (ì•½ê°„ ì°Œê·¸ëŸ¬ì§)
        ctx.fillStyle = '#111';
        ctx.fillRect(-85, 50, 145, 20);
        
        const lightColor = keys.ArrowDown ? '#ff2222' : '#cc0000';
        ctx.fillStyle = lightColor;
        if(keys.ArrowDown) { ctx.shadowColor='red'; ctx.shadowBlur=20; }
        ctx.fillRect(-80, 52, 45, 16); 
        ctx.fillRect(10, 52, 45, 16);
        ctx.shadowBlur=0;

        // íƒ€ì´ì–´
        ctx.fillStyle = '#111';
        ctx.fillRect(-95, 85, 20, 15); // ì¢Œ
        ctx.fillRect(40, 85, 20, 15); // ìš° (ê°€ê¹Œìš´ ìª½)
        ctx.fillRect(90, 85, 20, 15); // ì•ë°”í€´ (ì•½ê°„ ë³´ì„)

        ctx.restore();
    }

    // [3] ë“œë¦¬í”„íŠ¸ (ì™„ì „ ì˜†ëª¨ìŠµ) - ìŠ¤í•€ íš¨ê³¼
    function drawAE86_Side(ctx, dir) {
        ctx.save();
        ctx.scale(dir, 1);
        
        // ì°¨ì²´ê°€ í™• ê¸°ì›€ (ë¡¤ë§)
        ctx.rotate(0.1); 

        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.ellipse(0, 90, 140, 15, 0, 0, Math.PI*2); ctx.fill();

        // ì°¨ì²´ ì˜†ë©´ (í•´ì¹˜ë°± ìŠ¤íƒ€ì¼)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(-110, 50); // ë’¤
        ctx.lineTo(110, 60);  // ì• (ì›ê·¼)
        ctx.lineTo(110, 90);
        ctx.lineTo(-110, 85);
        ctx.fill();

        // ê²€ì • ë  (ì‚¬ì´ë“œ ëª°ë”©)
        ctx.fillStyle = '#111';
        ctx.fillRect(-110, 70, 220, 10);

        // ìºë¹ˆ (ì˜†ë©´)
        ctx.beginPath();
        ctx.moveTo(-70, 0); // ì§€ë¶• ë’¤
        ctx.lineTo(60, 5);  // ì§€ë¶• ì•
        ctx.lineTo(110, 60); // ë³¸ë„· ë¼ì¸
        ctx.lineTo(-110, 50); // íŠ¸ë í¬ ë¼ì¸
        ctx.fill();

        // ì˜†ìœ ë¦¬ (Side Windows)
        ctx.fillStyle = '#223';
        // ë’·ì¢Œì„ ì°½ë¬¸
        ctx.beginPath();
        ctx.moveTo(-65, 5); ctx.lineTo(-10, 5);
        ctx.lineTo(-10, 45); ctx.lineTo(-100, 45);
        ctx.fill();
        // ì•ì¢Œì„ ì°½ë¬¸
        ctx.beginPath();
        ctx.moveTo(-5, 5); ctx.lineTo(55, 8);
        ctx.lineTo(80, 45); ctx.lineTo(-5, 45);
        ctx.fill();

        // ë°”í€´ (Side View - íœ  ëª¨ì–‘ ë³´ì„)
        function drawWheel(x, y) {
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(x, y, 22, 22, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#555'; // íœ 
            ctx.beginPath(); ctx.ellipse(x, y, 12, 12, 0, 0, Math.PI*2); ctx.fill();
        }
        drawWheel(-70, 90); // ë’·ë°”í€´
        drawWheel(70, 90);  // ì•ë°”í€´

        // ì•ìª½ ë¼ì´íŠ¸ (íŒì—… í—¤ë“œë¨í”„ - ì•½ê°„ íŠ€ì–´ë‚˜ì˜´)
        ctx.fillStyle = '#eee';
        ctx.fillRect(100, 55, 15, 5);

        // í›„ë¯¸ë“± (ì˜†ì—ì„œ ë³¸ ëª¨ìŠµ)
        ctx.fillStyle = keys.ArrowDown ? '#ff2222' : '#cc0000';
        ctx.fillRect(-112, 55, 5, 20);

        ctx.restore();
    }

    // --- ì—…ë°ì´íŠ¸ ---
    function update(dt) {
        position = (position + speed * dt) % (segments.length * SEGMENT_LENGTH);
        const currentIdx = Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length;
        const playerSegment = segments[currentIdx];

        if (keys.ArrowUp) speed += accel;
        else if (keys.ArrowDown) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        // ë“œë¦¬í”„íŠ¸ ë¡œì§
        const isTurning = keys.ArrowLeft || keys.ArrowRight;
        // ë¸Œë ˆì´í¬ + í„´ + ì¼ì • ì†ë„ ì´ìƒ = ë“œë¦¬í”„íŠ¸
        driftMode = keys.ArrowDown && isTurning && speed > 5000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 30; // ê°ì†
            // ìŠ¤í‚¤ë“œ ë§ˆí¬ ìƒì„±
            if (Math.random() > 0.3) {
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        // í„´ ê³„ì‚°
        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.6; // ë“œë¦¬í”„íŠ¸ ì‹œ ê°ë„ ë” í¼

        if (keys.ArrowLeft) targetTurn = -turnLimit;
        else if (keys.ArrowRight) targetTurn = turnLimit;
        
        // ê´€ì„± (ë“œë¦¬í”„íŠ¸ ì¤‘ì—ëŠ” í•¸ë“¤ì´ ëŠ¦ê²Œ ëŒì•„ì˜´)
        const smoothing = driftMode ? 2.0 : 6.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        // Xì¶• ì´ë™
        if (speed > 0) {
            // ë“œë¦¬í”„íŠ¸ ì¤‘ì—ëŠ” íš¡ì´ë™ íš¨ìœ¨ ê°ì†Œ (ë¯¸ë„ëŸ¬ì§)
            let moveEff = driftMode ? 0.6 : 1.0;
            let moveAmount = (speed / maxSpeed) * moveEff * 0.06;
            
            if (keys.ArrowLeft) playerX -= moveAmount;
            if (keys.ArrowRight) playerX += moveAmount;

            // ì›ì‹¬ë ¥
            playerX -= (playerSegment.curve * 0.00015) * (speed / maxSpeed);
        }

        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
    }

    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    createRoad();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
