<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Racer - Code Art Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 80px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 
                5px 5px 0 #000,
                0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 20;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <div id="ui">
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span>
    </div>
    <div id="drift-msg">KANSEI DRIFT!!</div>
    <div id="instructions">
        [â–²] ACCEL | [â–¼] BRAKE + TURN (DRIFT) | [â—€ â–¶] STEER
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const driftMsg = document.getElementById('drift-msg');

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- ê²Œì„ ì„¤ì • ìƒìˆ˜ ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 2000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);

    // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     // í•¸ë“¤ë§ ìƒíƒœ (-1 ~ 1)
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;

    let skids = [];
    let segments = [];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // --- ìœ í‹¸ë¦¬í‹° ---
    // [ìˆ˜ì •] Math.round ì œê±°: ë„ë¡œ ê¹¨ì§ í˜„ìƒ(1px ê°­)ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‹¤ìˆ˜ ì¢Œí‘œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = (width / 2) + (p.screen.scale * p.camera.x * width / 2);
        p.screen.y = (height / 2) - (p.screen.scale * p.camera.y * height / 2);
        p.screen.w = (p.screen.scale * roadWidth * width / 2);
    }

    // ë„ë¡œ í‹ˆìƒˆ ë°©ì§€ë¥¼ ìœ„í•œ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° (ì•½ê°„ ê²¹ì¹˜ê²Œ ì²˜ë¦¬ ê°€ëŠ¥í•˜ì§€ë§Œ round ì œê±°ë¡œ ëŒ€ë¶€ë¶„ í•´ê²°)
    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    // --- ë„ë¡œ ìƒì„± ---
    function createRoad() {
        segments = [];
        const totalSegments = 2000; 
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;
            // ë§µ ë””ìì¸ (ì½”ë„ˆ ë°°ì¹˜)
            if (i > 300 && i < 700) curve = 2;
            if (i > 800 && i < 1200) curve = -3; 
            if (i > 1300 && i < 1700) curve = 3; 

            // ì–¸ë• (Slight Hills)
            y = Math.sin(i / 30) * 1000;

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor }
            });
        }
    }

    // --- ë Œë”ë§ ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // 1. ë°°ê²½
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#000022');
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#fffc';
        ctx.beginPath(); ctx.arc(width*0.8, 100, 40, 0, Math.PI*2); ctx.fill();

        // 2. ë„ë¡œ ê·¸ë¦¬ê¸°
        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 

        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n) % segments.length;
            let segment = segments[currentIdx];
            let loopOffset = (segment.index < baseSegment.index) ? segments.length * SEGMENT_LENGTH : 0;
            
            let camY = CAMERA_HEIGHT + segments[Math.floor((position+100)/SEGMENT_LENGTH)%segments.length].p1.world.y;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            // [ìˆ˜ì •] maxy í´ë¦¬í•‘ ì¡°ê±´ ì™„í™”: ì†Œìˆ˜ì  ì˜¤ì°¨ë¡œ ì¸í•œ ê¹œë¹¡ì„ ë°©ì§€ (>= ëŒ€ì‹  > ì‚¬ìš© ë° 0.1 ì—¬ìœ )
            if (segment.p1.camera.z <= CAMERA_DEPTH || segment.p2.screen.y > maxy - 0.5 || segment.p2.screen.y >= segment.p1.screen.y) continue;

            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            ctx.fillStyle = '#001100';
            ctx.fillRect(0, y2, width, y1 - y2);

            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, y2, l2 - r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, y2, l2 + r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, y2, l2 - r2, y2, segment.color.road);

            maxy = y2;
        }

        drawSkidMarks();
        drawCarSprite(); 
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }

            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    // ==========================================
    //  ğŸ ìë™ì°¨ ê·¸ë¦¬ê¸° (ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜) ğŸ
    // ==========================================
    
    function drawCarSprite() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 1200; 
        
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        
        const cx = width / 2;
        const cy = height - 120 * scale + bounce;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);

        // [ìˆ˜ì •] ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•´ ëª¨ë“œë¥¼ ë‚˜ëˆ„ì§€ ì•Šê³ ,
        // playerTurn ê°’(-1 ~ 1)ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì—¬ ì°¨ì²´ ëª¨ì–‘ì„ ë³€í˜•ì‹œí‚µë‹ˆë‹¤.
        
        // íšŒì „ëŸ‰ ê³„ì‚° (ë“œë¦¬í”„íŠ¸ ì¤‘ì´ë©´ ê°ë„ê°€ ë” ì»¤ì§)
        const turnAngle = playerTurn * (driftMode ? 1.5 : 0.8);

        drawAE86_Dynamic(ctx, turnAngle);

        ctx.restore();
    }

    // [í†µí•©] ë™ì  AE86 ê·¸ë¦¬ê¸° (turn: -1(ì¢Œ) ~ 0(ì§ì§„) ~ 1(ìš°))
    function drawAE86_Dynamic(ctx, turn) {
        // ì¢Œìš° ëŒ€ì¹­ ë¡œì§
        const dir = turn < 0 ? -1 : 1;
        const absTurn = Math.abs(turn); // 0 ~ 1.5 ì •ë„ ë²”ìœ„

        ctx.save();
        ctx.scale(dir, 1); // ë°©í–¥ì— ë”°ë¼ ìº”ë²„ìŠ¤ ë°˜ì „ (í•­ìƒ í•œìª½ë§Œ ê·¸ë¦¬ë©´ ë¨)

        // ì°¨ì²´ ê¸°ìš¸ê¸° (Roll)
        ctx.rotate(absTurn * 0.1);

        // --- ì¹˜ìˆ˜ ê³„ì‚° (ì• ë‹ˆë©”ì´ì…˜ í•µì‹¬) ---
        // ì§ì§„ì¼ ë•Œ: ë’·ë©´ ë„“ìŒ, ì˜†ë©´ ì•ˆ ë³´ì„
        // íšŒì „ì¼ ë•Œ: ë’·ë©´ ì¢ì•„ì§, ì˜†ë©´ ë„“ì–´ì§
        
        // ë’·ë©´ ë„ˆë¹„: íšŒì „í• ìˆ˜ë¡ ì¤„ì–´ë“¦ (90 -> 60)
        const rearWidth = 90 - (absTurn * 30);
        
        // ì˜†ë©´ ë„ˆë¹„: íšŒì „í• ìˆ˜ë¡ ëŠ˜ì–´ë‚¨ (0 -> 100)
        // absTurnì´ ì»¤ì§ˆìˆ˜ë¡ ì˜†êµ¬ë¦¬ê°€ íŠ€ì–´ë‚˜ì˜´
        const sideWidth = absTurn * 120;
        
        // ë’·ë©´ ì›ê·¼ê° (Perspective Skew): ì˜†ë©´ì´ ê¸¸ì–´ì§ˆìˆ˜ë¡ ë’·ë©´ ëì´ ì•ˆìª½ìœ¼ë¡œ ëª¨ì„
        const skew = absTurn * 20;

        // --- ê·¸ë¦¬ê¸° ì‹œì‘ ---

        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); 
        ctx.ellipse(sideWidth/2, 90, 130 + sideWidth/2, 15, 0, 0, Math.PI*2); 
        ctx.fill();

        // 1. ì˜†ë©´ (Side Panel) - ë¨¼ì € ê·¸ë¦¼ (ë’¤ì— ìˆìœ¼ë‹ˆê¹Œ)
        // í°ìƒ‰ ë°”ë””
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        // ë’·ë°”í€´ìª½(ì—°ê²°ë¶€) ~ ì•ë°”í€´ìª½
        ctx.moveTo(rearWidth, 50); // ë’¤ ìƒë‹¨
        ctx.lineTo(rearWidth + sideWidth, 60); // ì• ìƒë‹¨ (ì›ê·¼)
        ctx.lineTo(rearWidth + sideWidth, 90); // ì• í•˜ë‹¨
        ctx.lineTo(rearWidth - 5, 90); // ë’¤ í•˜ë‹¨
        ctx.fill();

        // ì˜†ë©´ ëª°ë”© (ê²€ì • ë )
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(rearWidth, 65);
        ctx.lineTo(rearWidth + sideWidth, 75);
        ctx.lineTo(rearWidth + sideWidth, 85);
        ctx.lineTo(rearWidth, 75);
        ctx.fill();

        // ì˜†ë©´ ìºë¹ˆ (ìœ ë¦¬ì°½ í¬í•¨ ìƒë‹¨)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(rearWidth * 0.8, 0); // ì§€ë¶• ë’¤
        ctx.lineTo(rearWidth * 0.8 + sideWidth * 0.8, 10); // ì§€ë¶• ì•
        ctx.lineTo(rearWidth + sideWidth, 60); // ë³¸ë„· ì—°ê²°
        ctx.lineTo(rearWidth, 50); // í—ˆë¦¬ ì—°ê²°
        ctx.fill();

        // ì˜†ìœ ë¦¬
        ctx.fillStyle = '#223';
        ctx.beginPath();
        ctx.moveTo(rearWidth * 0.8 + 5, 5); 
        ctx.lineTo(rearWidth * 0.8 + sideWidth * 0.7, 12); 
        ctx.lineTo(rearWidth + sideWidth * 0.8, 55); 
        ctx.lineTo(rearWidth + 5, 45); 
        ctx.fill();

        // ì•ë°”í€´ (íšŒì „ ì‹œì—ë§Œ ë³´ì„)
        if (absTurn > 0.1) {
            ctx.fillStyle = '#111';
            const wheelX = rearWidth + sideWidth * 0.8;
            ctx.beginPath(); ctx.ellipse(wheelX, 90, 20, 20, 0, 0, Math.PI*2); ctx.fill();
            // íœ 
            ctx.fillStyle = '#555';
            ctx.beginPath(); ctx.ellipse(wheelX, 90, 10, 10, 0, 0, Math.PI*2); ctx.fill();
        }

        // 2. ë’·ë©´ (Rear Panel) - ë®ì–´ì”Œì›€
        // ë°”ë”” (í°ìƒ‰)
        ctx.fillStyle = '#ddd'; // ì˜†ë©´ë³´ë‹¤ ì•½ê°„ ì–´ë‘¡ê²Œ
        ctx.beginPath();
        ctx.moveTo(-rearWidth, 50); ctx.lineTo(rearWidth, 50);
        ctx.lineTo(rearWidth + 5, 90); ctx.lineTo(-rearWidth - 5, 90);
        ctx.fill();

        // ë²”í¼
        ctx.fillStyle = '#222';
        ctx.fillRect(-rearWidth - 5, 80, rearWidth * 2 + 10, 15);

        // ìºë¹ˆ (ë’·ë©´)
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(-rearWidth * 0.6, 0); ctx.lineTo(rearWidth * 0.6, 0); // ì§€ë¶•
        ctx.lineTo(rearWidth * 0.8, 50); ctx.lineTo(-rearWidth * 0.8, 50);
        ctx.fill();

        // ë’·ìœ ë¦¬
        ctx.fillStyle = '#112';
        ctx.beginPath();
        ctx.moveTo(-rearWidth * 0.55, 5); ctx.lineTo(rearWidth * 0.55, 5);
        ctx.lineTo(rearWidth * 0.75, 45); ctx.lineTo(-rearWidth * 0.75, 45);
        ctx.fill();

        // í…Œì¼ë¨í”„
        ctx.fillStyle = '#111';
        ctx.fillRect(-rearWidth * 0.9, 50, rearWidth * 1.8, 20);

        // ë¸Œë ˆì´í¬ë“±
        const lightColor = keys.ArrowDown ? '#ff2222' : '#cc0000';
        ctx.fillStyle = lightColor;
        if(keys.ArrowDown) { ctx.shadowColor='red'; ctx.shadowBlur=20; }
        
        // ë“± ìœ„ì¹˜ë„ ë„ˆë¹„ì— ë¹„ë¡€
        const lampW = rearWidth * 0.5;
        ctx.fillRect(-rearWidth * 0.85, 52, lampW, 16); // ì¢Œ (ë°˜ì „ë˜ì–´ ìš°ì¸¡ì´ ë¨)
        ctx.fillRect(rearWidth * 0.85 - lampW, 52, lampW, 16);  // ìš° (ë°˜ì „ë˜ì–´ ì¢Œì¸¡ì´ ë¨)
        ctx.shadowBlur = 0;

        // ë²ˆí˜¸íŒ
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(-15, 55, 30, 12);

        // ë¨¸í”ŒëŸ¬ (í•œìª½ì—ë§Œ ìˆìŒ - ìš°ì¸¡)
        // scale(-1, 1)ì¼ ë•ŒëŠ” ì¢Œì¸¡ì— ê·¸ë ¤ì§ -> ì›ë³¸ AE86ì€ ìš°ì¸¡ ë°°ê¸°
        // dirì´ 1ì´ë©´ ì •ìƒ, -1ì´ë©´ ë°˜ì „.
        // ë¨¸í”ŒëŸ¬ëŠ” í•­ìƒ ì°¨ì˜ ì˜¤ë¥¸ìª½ì— ìˆì–´ì•¼ í•˜ë¯€ë¡œ, ë°˜ì „ ì—¬ë¶€ì— ë”°ë¼ ìœ„ì¹˜ ì¡°ì • í•„ìš”í•˜ë‚˜ ë‹¨ìˆœí™”.
        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(rearWidth * 0.7, 90, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(rearWidth * 0.7, 90, 4, 0, Math.PI*2); ctx.fill();

        // ë’·ë°”í€´ (ì–‘ìª½)
        ctx.fillStyle = '#111';
        ctx.fillRect(-rearWidth - 5, 85, 20, 15);
        ctx.fillRect(rearWidth - 15, 85, 20, 15);

        ctx.restore();
    }


    // --- ì—…ë°ì´íŠ¸ ---
    function update(dt) {
        position = (position + speed * dt) % (segments.length * SEGMENT_LENGTH);
        const currentIdx = Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length;
        const playerSegment = segments[currentIdx];

        if (keys.ArrowUp) speed += accel;
        else if (keys.ArrowDown) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        // ë“œë¦¬í”„íŠ¸ ë¡œì§
        const isTurning = keys.ArrowLeft || keys.ArrowRight;
        driftMode = keys.ArrowDown && isTurning && speed > 5000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 30; 
            if (Math.random() > 0.3) {
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        // í„´ ê³„ì‚°
        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.6;

        if (keys.ArrowLeft) targetTurn = -turnLimit;
        else if (keys.ArrowRight) targetTurn = turnLimit;
        
        const smoothing = driftMode ? 2.0 : 6.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        // [ìˆ˜ì •] ì¢Œìš° ì´ë™ ì†ë„ ê°ì†Œ: ê¸°ì¡´ 0.06 -> 0.035
        if (speed > 0) {
            let moveEff = driftMode ? 0.6 : 1.0;
            let moveAmount = (speed / maxSpeed) * moveEff * 0.035; 
            
            if (keys.ArrowLeft) playerX -= moveAmount;
            if (keys.ArrowRight) playerX += moveAmount;

            playerX -= (playerSegment.curve * 0.00015) * (speed / maxSpeed);
        }

        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
    }

    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    createRoad();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
