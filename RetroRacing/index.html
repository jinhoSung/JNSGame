<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Racer - Real 3D Drift</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px #ff00de, 3px 3px 0 #000;
            display: none;
            z-index: 20;
            white-space: nowrap;
            text-align: center;
            line-height: 1.5;
        }
        #center-sub {
            font-size: 30px;
            color: #ffff00;
            display: block;
            margin-top: 10px;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 60px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 5px 5px 0 #000, 0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 15;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.6);
        }
        
        .game-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #fff;
            text-shadow: 0 0 10px #000;
            pointer-events: none;
            z-index: 30;
            animation: pop 0.5s ease-out;
            white-space: nowrap;
        }

        @keyframes pop { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }

        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            z-index: 50;
            display: none;
            pointer-events: none;
        }
        .touch-btn {
            pointer-events: auto;
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            touch-action: none;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.5); }
        
        #joystick-area {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 160px; height: 160px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.3);
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px; height: 60px;
            margin-top: -30px; margin-left: -30px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,255,255,0.5);
            transform: translate(0px, 0px);
        }

        #btn-gas {
            bottom: 40px; right: 30px;
            width: 90px; height: 140px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 20px;
            border: 3px solid #0f0;
        }
        #btn-gas::after { content: 'GAS'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; }
        
        #btn-brake {
            bottom: 40px; right: 140px;
            width: 70px; height: 90px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            border: 3px solid #f00;
        }
        #btn-brake::after { content: 'BRAKE'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; font-size: 12px; }

        @media (hover: none) and (pointer: coarse) {
            .touch-controls { display: block; }
            #instructions { display: none; }
        }
    </style>
</head>
<body>

    <div id="ui">
        LEVEL: <span id="levelDisplay">1</span><br>
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span><br>
        DIST: <span id="distDisplay">0</span>
    </div>
    
    <div id="center-msg">
        Retro Racer 3D<br>
        <span id="center-sub">TAP TO START</span>
    </div>
    
    <div id="drift-msg">KANSEI DRIFT!!</div>

    <div class="touch-controls">
        <div id="joystick-area">
            <div id="joystick-knob"></div>
        </div>
        <div id="btn-brake" class="touch-btn"></div>
        <div id="btn-gas" class="touch-btn"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const distDisplay = document.getElementById('distDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const driftMsg = document.getElementById('drift-msg');
    const centerMsg = document.getElementById('center-msg');
    const centerSub = document.getElementById('center-sub');

    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if(isMobile) {
        document.querySelector('.touch-controls').style.display = 'block';
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 게임 상수 ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 3000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);
    const LANES = [-0.67, 0, 0.67]; // 좌, 중, 우 차선 좌표 (Normalized Offset)

    // --- 상태 변수 ---
    let currentLevel = 1;
    const MAX_LEVEL = 3;
    let gameState = 'start'; 
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;
    let analogSteer = 0;
    let trackLength = 0;
    let skyOffset = 0; 
    let cameraShake = 0; 

    let segments = [];
    let cars = []; // 트래픽 차량 배열
    let skids = [];
    let particles = []; 
    let checkpointLocs = [];

    const keys = { 
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        Space: false, ShiftLeft: false 
    };

    // --- 레벨 및 도로 생성 ---
    function initLevel(level) {
        currentLevel = level;
        levelDisplay.innerText = currentLevel;
        position = 0;
        playerX = 0;
        playerTurn = 0;
        speed = 0;
        skids = [];
        particles = [];
        cars = [];
        driftMode = false;
        cameraShake = 0;
        
        document.querySelectorAll('.game-msg').forEach(el => el.remove());
        
        createRoad(level);
        gameState = 'play';
        
        setCenterMessage("", "", false);
        showMessage(`LEVEL ${level} START!`, '#fff', 2000);
    }

    function createRoad(level) {
        segments = [];
        checkpointLocs = [];
        
        let numSegments = 0;
        let hills = 0;
        let curves = 0;
        let trafficDensity = 0; 
        
        if (level === 1) {
            numSegments = 2000; hills = 0; curves = 2; trafficDensity = 0.02;
        } else if (level === 2) {
            numSegments = 3000; hills = 500; curves = 4; trafficDensity = 0.03;
        } else {
            numSegments = 4000; hills = 1500; curves = 6; trafficDensity = 0.04;
        }

        trackLength = numSegments * SEGMENT_LENGTH;
        checkpointLocs.push({ pos: 10, name: "START", passed: false, color: "#00ff00" });

        for (let i = 0; i < numSegments; i++) {
            let curve = 0;
            let y = 0;

            if (level === 1) {
                if (i > 300 && i < 800) curve = 2;
                if (i > 1200 && i < 1700) curve = -2;
            } else if (level === 2) {
                curve = Math.sin(i / 200) * curves; 
                y = Math.sin(i / 300) * hills;
            } else {
                curve = Math.sin(i / 150) * curves + Math.cos(i / 50) * 2;
                y = Math.sin(i / 100) * hills;
                if (i % 500 < 50) y += 500; 
            }

            if (i > numSegments - 100) { curve = 0; y = 0; }

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            let feature = null;
            if (i === 10) feature = { type: 'arch', name: 'START', color: '#00ff00' };
            if (i === numSegments - 20) feature = { type: 'arch', name: 'GOAL', color: '#ff0055' };

            // 트래픽 생성 (별도 배열 관리)
            if (i > 50 && i < numSegments - 100 && Math.random() < trafficDensity) {
                const laneIdx = Math.floor(Math.random() * 3); // 0, 1, 2
                cars.push({
                    z: i * SEGMENT_LENGTH,
                    lane: laneIdx,
                    offset: LANES[laneIdx],
                    targetOffset: LANES[laneIdx], // 차선 변경 목표
                    speed: 3000 + Math.random() * 2000, 
                    color: Math.random() > 0.5 ? '#a00' : '#00a',
                    index: i,
                    changeTimer: Math.random() * 5 // 차선 변경 타이머
                });
            }

            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor },
                feature: feature
            });
        }
        checkpointLocs.push({ pos: Math.floor(numSegments - 20), name: "GOAL", passed: false, color: "#ff0055" });
    }

    // --- 3D 엔진 유틸리티 ---
    function project3D(x, y, z, cx, cy, scale, yaw) {
        let cos = Math.cos(yaw);
        let sin = Math.sin(yaw);
        let rx = x * cos - z * sin;
        let rz = x * sin + z * cos;
        let ry = y;

        const pitch = 0.2; 
        let cosP = Math.cos(pitch);
        let sinP = Math.sin(pitch);
        let y2 = ry * cosP - rz * sinP;
        let z2 = ry * sinP + rz * cosP;

        const camZ = 500; 
        const pz = z2 + camZ; 

        if (pz <= 0) return { x: 0, y: 0, scale: 0, visible: false, depth: pz };
        
        const fov = 600; 
        const proj = fov / pz;
        
        return {
            x: cx + rx * proj * scale,
            y: cy + y2 * proj * scale, 
            scale: proj * scale,
            visible: true,
            depth: pz
        };
    }

    function drawQuad(ctx, p1, p2, p3, p4, color, strokeColor) {
        if (!p1.visible || !p2.visible || !p3.visible || !p4.visible) return;
        ctx.fillStyle = color;
        ctx.strokeStyle = strokeColor || color;
        ctx.lineWidth = 1;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y);
        ctx.closePath(); ctx.fill(); ctx.stroke();
    }

    // 누락되었던 project 함수 복구
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = (width / 2) + (p.screen.scale * p.camera.x * width / 2);
        p.screen.y = (height / 2) - (p.screen.scale * p.camera.y * height / 2);
        p.screen.w = (p.screen.scale * roadWidth * width / 2);
    }

    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    function showMessage(text, color='#fff', duration=2000) {
        if (gameState !== 'play') return; 
        const msg = document.createElement('div');
        msg.className = 'game-msg';
        msg.innerText = text;
        msg.style.color = color;
        document.body.appendChild(msg);
        setTimeout(() => { if(msg.parentNode) msg.remove(); }, duration);
    }

    function setCenterMessage(title, sub, show=true) {
        centerMsg.style.display = show ? 'block' : 'none';
        if (show) {
            centerMsg.innerHTML = `${title}<br><span id="center-sub">${sub}</span>`;
        }
    }

    // --- 배경 그리기 (Parallax) ---
    function drawBackground(ctx, width, height) {
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#050510');
        bgGrad.addColorStop(1, '#202040');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#fff';
        for(let i=0; i<50; i++) {
            let sx = (Math.sin(i * 132.1) * width + skyOffset * 0.2) % width;
            if(sx < 0) sx += width;
            let sy = (Math.cos(i * 53.7) * height/2);
            if(sy > 0) ctx.fillRect(sx, sy, Math.random()*2, Math.random()*2);
        }

        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(0, height);
        for(let i=0; i<=20; i++) {
            const xVal = (i * width/20) - (skyOffset % (width/20));
            const noise = Math.sin(i * 45.2 + 10) * 50 + Math.cos(i * 12.5) * 30;
            const h = height/2 + 50 - noise;
            ctx.lineTo(xVal, h);
        }
        ctx.lineTo(width, height);
        ctx.fill();
    }

    // --- 3D 트래픽 차량 그리기 (크기 조정됨) ---
    function drawTrafficCar(ctx, car, segment, width, height, playerX, playerY, playerZ) {
        const spriteX = segment.p1.screen.x + (segment.p1.screen.w * car.offset);
        const spriteY = segment.p1.screen.y;
        
        // 크기 축소 (기존 0.4 -> 0.05)
        const carW = segment.p1.screen.w * 0.05; 
        const carH = carW * 0.7; // 비율 조정

        ctx.save();
        ctx.translate(spriteX, spriteY);

        // 그림자
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(-carW/2, -carH*0.1, carW, carH*0.2);

        // 차체 색상
        ctx.fillStyle = car.color;
        
        // Main Body (Back Face)
        ctx.fillRect(-carW/2, -carH, carW, carH * 0.8);
        
        // Bumper
        ctx.fillStyle = '#111';
        ctx.fillRect(-carW/2 - 1, -carH * 0.3, carW + 2, carH * 0.2);

        // Tail Lights
        ctx.fillStyle = '#f00';
        ctx.shadowBlur = 5; ctx.shadowColor = '#f00';
        ctx.fillRect(-carW*0.4, -carH*0.25, carW*0.25, carH*0.1);
        ctx.fillRect(carW*0.15, -carH*0.25, carW*0.25, carH*0.1);
        ctx.shadowBlur = 0;

        // Roof
        ctx.fillStyle = '#222'; 
        ctx.beginPath();
        ctx.moveTo(-carW*0.4, -carH*0.8);
        ctx.lineTo(carW*0.4, -carH*0.8);
        ctx.lineTo(carW*0.3, -carH*1.4);
        ctx.lineTo(-carW*0.3, -carH*1.4);
        ctx.fill();
        
        ctx.fillStyle = car.color;
        ctx.fillRect(-carW*0.32, -carH*1.42, carW*0.64, carH*0.1);

        // Wheels
        ctx.fillStyle = '#000';
        ctx.fillRect(-carW*0.55, -carH*0.3, carW*0.15, carH*0.3);
        ctx.fillRect(carW*0.4, -carH*0.3, carW*0.15, carH*0.3);

        ctx.restore();
    }

    function drawSpeedLines(ctx, width, height) {
        if (speed < 5000) return;
        ctx.strokeStyle = `rgba(255, 255, 255, ${ (speed-5000)/maxSpeed * 0.3 })`;
        ctx.lineWidth = 2;
        const cx = width / 2;
        const cy = height / 2;
        ctx.beginPath();
        for(let i=0; i<10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * width/2 + 100;
            const len = Math.random() * 100 + 50;
            const x = cx + Math.cos(angle) * dist;
            const y = cy + Math.sin(angle) * dist;
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle)*len, y + Math.sin(angle)*len);
        }
        ctx.stroke();
    }

    function drawArch(ctx, cx, cy, w, feature) {
        const archWidth = w * 2.5; 
        const archHeight = w * 2.0; 
        const pillarW = w * 0.2;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.fillStyle = '#444';
        ctx.fillRect(-archWidth/2, -archHeight, pillarW, archHeight); 
        ctx.fillRect(archWidth/2 - pillarW, -archHeight, pillarW, archHeight); 
        ctx.fillStyle = feature.color || '#fff';
        ctx.fillRect(-archWidth/2 - pillarW, -archHeight - pillarW, archWidth + pillarW*2, pillarW*2);
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `bold ${Math.max(10, w * 0.8)}px sans-serif`;
        ctx.fillText(feature.name, 0, -archHeight);
        ctx.restore();
    }

    // --- 복구된 drawSkidMarks ---
    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const carOffset = playerTurn * (width * 0.12);
        const centerX = (width / 2) + carOffset;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }
            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    // --- 복구된 drawParticles ---
    function drawParticles() {
        ctx.save();
        for(let i=0; i<particles.length; i++) {
            const p = particles[i];
            p.life -= 0.03;
            p.x += p.vx;
            p.y += p.vy;
            p.size += 0.5;

            if(p.life <= 0) { particles.splice(i, 1); i--; continue; }

            ctx.globalAlpha = p.life * 0.3; // 반투명
            ctx.fillStyle = '#eee'; // 흰색 연기
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        let shakeX = 0, shakeY = 0;
        if (cameraShake > 0) {
            shakeX = (Math.random() - 0.5) * cameraShake;
            shakeY = (Math.random() - 0.5) * cameraShake;
            cameraShake *= 0.9; 
            if (cameraShake < 1) cameraShake = 0;
        }

        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground(ctx, width, height);

        if (segments.length === 0) { ctx.restore(); return; }

        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 
        
        let visibleCars = [];

        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n);
            if (currentIdx >= segments.length) break;

            let segment = segments[currentIdx];
            
            // Projection
            let playerSegIdx = Math.floor((position+100)/SEGMENT_LENGTH);
            let playerY = 0;
            if (playerSegIdx < segments.length) playerY = segments[playerSegIdx].p1.world.y;
            let camY = CAMERA_HEIGHT + playerY;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH) continue; 

            // 화면 밖 체크 (MaxY clipping)
            if (segment.p2.screen.y >= maxy) {
                 // skip
            } else if (segment.p2.screen.y < segment.p1.screen.y) {
                // 도로 그리기
                let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
                let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
                let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;
                let renderY2 = y2; 

                ctx.fillStyle = '#001100'; 
                ctx.fillRect(0, renderY2, width, y1 - renderY2); 

                polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, renderY2, l2 - r2 * 1.2, renderY2, segment.color.rumble);
                polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, renderY2, l2 + r2 * 1.2, renderY2, segment.color.rumble);
                polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, renderY2, l2 - r2, renderY2, segment.color.road);

                // --- 차선 그리기 (3차선, 흰색 점선) ---
                if ((segment.index / 3) % 2 > 1) { // 점선 효과
                    const laneW = r1 * 0.02; // 차선 두께
                    const laneW2 = r2 * 0.02;
                    
                    // 3차선이므로 경계선은 전체 폭의 1/3, 2/3 지점에 위치
                    // l1은 도로 중앙, r1은 도로 절반 폭
                    // 좌측 차선: 중앙 - 1/3 폭, 우측 차선: 중앙 + 1/3 폭
                    // r1이 절반폭이므로 전체폭은 2*r1. 1/3폭은 2/3 * r1.
                    // 정규화된 좌표계에서 차선 위치는 -0.33, 0.33
                    
                    const laneOffset = 0.333;
                    
                    // Left Line
                    let lx1 = l1 - r1 * laneOffset; let lx2 = l2 - r2 * laneOffset;
                    polygon(ctx, lx1 - laneW, y1, lx1 + laneW, y1, lx2 + laneW2, y2, lx2 - laneW2, y2, 'rgba(255,255,255,0.5)');

                    // Right Line
                    let rx1 = l1 + r1 * laneOffset; let rx2 = l2 + r2 * laneOffset;
                    polygon(ctx, rx1 - laneW, y1, rx1 + laneW, y1, rx2 + laneW2, y2, rx2 - laneW2, y2, 'rgba(255,255,255,0.5)');
                }

                maxy = y2;
            }

            // 차 수집
            for(let c=0; c<cars.length; c++) {
                if(cars[c].index === segment.index) {
                    visibleCars.push({ car: cars[c], segment: segment });
                }
            }
            if (segment.feature && segment.feature.type === 'arch') {
                if (segment.p1.screen.y > maxy)
                    visibleCars.push({ type: 'arch', segment: segment });
            }
        }

        // 3. 스프라이트 그리기 (Back-to-Front)
        for (let i = visibleCars.length - 1; i >= 0; i--) {
            const obj = visibleCars[i];
            if (obj.type === 'arch') {
                drawArch(ctx, obj.segment.p1.screen.x, obj.segment.p1.screen.y, obj.segment.p1.screen.w, obj.segment.feature);
            } else {
                drawTrafficCar(ctx, obj.car, obj.segment, width, height, playerX, 0, position);
            }
        }

        drawSkidMarks();
        draw3DCarModel(); 
        drawParticles(); 
        drawSpeedLines(ctx, width, height);

        ctx.restore();
    }

    // --- 업데이트 ---
    function update(dt) {
        if (gameState !== 'play') return;

        position = (position + speed * dt);
        skyOffset -= playerTurn * dt * 300; 

        // 트래픽 이동 및 차선 변경 업데이트
        for(let i=0; i<cars.length; i++) {
            const car = cars[i];
            car.z += car.speed * dt;
            
            // 차선 변경 로직
            car.changeTimer -= dt;
            if (car.changeTimer <= 0) {
                car.changeTimer = Math.random() * 8 + 2; // 다음 변경까지 대기
                if (Math.random() > 0.5) { // 50% 확률로 변경 시도
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    const nextLane = car.lane + dir;
                    if (nextLane >= 0 && nextLane <= 2) {
                        car.lane = nextLane;
                        car.targetOffset = LANES[nextLane];
                    }
                }
            }
            
            // 부드러운 이동 (Lerp)
            if (car.offset !== car.targetOffset) {
                const moveSpeed = 1.0 * dt;
                if (car.offset < car.targetOffset) {
                    car.offset = Math.min(car.offset + moveSpeed, car.targetOffset);
                } else {
                    car.offset = Math.max(car.offset - moveSpeed, car.targetOffset);
                }
            }

            let newIndex = Math.floor(car.z / SEGMENT_LENGTH);
            if (newIndex >= segments.length) newIndex = 0; 
            car.index = newIndex;
        }

        const currentSegIndex = Math.floor((position + 100) / SEGMENT_LENGTH);
        
        // 충돌 체크 (범위 축소: 0.5 -> 0.15)
        for(let i=0; i<cars.length; i++) {
            const car = cars[i];
            if (car.z > position && car.z < position + 250) {
                if (Math.abs(playerX - car.offset) < 0.15) { // 정밀해진 충돌 판정
                    if (speed > 5000) {
                        speed = speed * 0.4; // 감속
                        cameraShake = 30;
                        showMessage("CRASH!!", "#ff0000", 800);
                        playerX -= (car.offset - playerX) * 0.5; 
                    }
                }
            }
        }

        checkpointLocs.forEach(cp => {
            if (!cp.passed && currentSegIndex >= cp.pos) {
                cp.passed = true;
                showMessage(cp.name, cp.color);
                if (cp.name === "GOAL") levelComplete();
                else score += 5000;
            }
        });

        const accelInput = keys.ArrowUp;
        const brakeInput = keys.ArrowDown || keys.Space || keys.ShiftLeft;
        
        let turnInput = 0;
        if(keys.ArrowLeft) turnInput = -1;
        else if(keys.ArrowRight) turnInput = 1;
        else turnInput = analogSteer; 

        if (accelInput) speed += accel;
        else if (brakeInput) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        const isTurning = Math.abs(turnInput) > 0.1;
        driftMode = brakeInput && isTurning && speed > 4000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 20; 
            if (Math.random() > 0.3) {
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
            if (Math.random() > 0.2 && window.carScreenX) {
                const side = Math.random() > 0.5 ? 1 : -1;
                particles.push({ 
                    x: window.carScreenX + side * 40 * window.carScale, 
                    y: window.carScreenY, 
                    vx: (Math.random() - 0.5) * 2 - playerTurn * 5, 
                    vy: -Math.random() * 2 - 1, 
                    size: Math.random() * 5 + 5, 
                    life: 1.0 
                });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.7; 

        if(Math.abs(turnInput) > 0) targetTurn = turnInput * turnLimit;
        
        const smoothing = driftMode ? 2.0 : 4.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        if (speed > 0) {
            let moveAmount = (speed / maxSpeed) * 0.06 * playerTurn;
            playerX += moveAmount;
            
            if (position < trackLength) {
                const pSeg = segments[Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length];
                playerX -= (pSeg.curve * 0.00015) * (speed / maxSpeed);
            }
        }

        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
        distDisplay.innerText = Math.floor(position / 1000) + "m";
    }

    // --- 프로젝트 및 그리기 유틸리티 ---
    function draw3DCarModel() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 400; 
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        const carScreenOffset = playerTurn * (width * 0.12); 
        const cx = (width / 2) + carScreenOffset;
        const cy = height - 80 * (width/1200) + bounce;

        window.carScreenX = cx; window.carScreenY = cy; window.carScale = scale;

        const maxAngle = Math.PI / 6; 
        const driftFactor = driftMode ? 1.5 : 1.0;
        const yaw = -playerTurn * maxAngle * driftFactor;

        // Player Car Vertices
        const w = 35; const h = 24; const l = 75; 
        const ch = 18; const cw = 28; const cl_f = 20; const cl_b = 40; 
        const verts = [
            {x:-w, y:0, z:l}, {x:w, y:0, z:l}, {x:w, y:0, z:-l}, {x:-w, y:0, z:-l}, 
            {x:-w, y:-h, z:l}, {x:w, y:-h, z:l}, {x:w, y:-h, z:-l}, {x:-w, y:-h, z:-l}, 
            {x:-cw, y:-h-ch, z:cl_f}, {x:cw, y:-h-ch, z:cl_f}, {x:cw, y:-h-ch, z:-cl_b}, {x:-cw, y:-h-ch, z:-cl_b}
        ];
        const pl_h = 6; 
        verts.push({x:-w+5, y:-h-pl_h, z:l-10}, {x:-w+15, y:-h-pl_h, z:l-10}, {x:-w+15, y:-h, z:l-10}, {x:-w+5, y:-h, z:l-10});
        verts.push({x:w-15, y:-h-pl_h, z:l-10}, {x:w-5, y:-h-pl_h, z:l-10}, {x:w-5, y:-h, z:l-10}, {x:w-15, y:-h, z:l-10});

        const pVerts = verts.map(v => project3D(v.x, v.y, v.z, cx, cy, scale, yaw));
        const isFrontFacing = (p1, p2, p3) => (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
        const faces = [];
        const addFace = (indices, col, stroke, type) => {
            const p = indices.map(i => pVerts[i]);
            if (p.some(v => !v.visible)) return;
            if (!isFrontFacing(p[0], p[1], p[2])) return;
            faces.push({ verts: p, col: col, stroke: stroke, type: type });
        };

        addFace([4, 5, 1, 0], '#eee', '#ccc'); 
        const backIdx = [7, 6, 2, 3];
        const backP = backIdx.map(i => pVerts[i]);
        if (backP.every(v => v.visible) && isFrontFacing(backP[0], backP[1], backP[2])) {
            faces.push({ verts: backP, col: '#ccc', stroke: '#bbb' });
            faces.push({ verts: backP, col: null, stroke: null, type: 'back_detail' });
        }
        addFace([3, 0, 4, 7], '#f4f4f4', '#ddd'); 
        addFace([3, 0, 4, 7], '#111', null, 'side_molding'); 
        addFace([1, 2, 6, 5], '#f4f4f4', '#ddd'); 
        addFace([1, 2, 6, 5], '#111', null, 'side_molding'); 
        addFace([4, 5, 6, 7], '#fff', '#eee'); 
        addFace([8, 9, 5, 4], '#222', '#111'); 
        addFace([11, 10, 6, 7], '#222', '#111'); 
        addFace([8, 11, 7, 4], '#222', '#111'); 
        addFace([5, 6, 10, 9], '#222', '#111'); 
        addFace([8, 9, 10, 11], '#ddd', '#ccc'); 
        addFace([12, 13, 14, 15], '#fff', '#ccc'); 
        addFace([16, 17, 18, 19], '#fff', '#ccc'); 

        function create3DWheel(x, y, z, width, radius, isFront) {
            const wheelFaces = [];
            const segments = 8;
            const wheelVerts = [];
            let steerAngle = 0;
            if (isFront) {
                const steerLimit = 0.5;
                if(keys.ArrowLeft) steerAngle = steerLimit;
                else if(keys.ArrowRight) steerAngle = -steerLimit;
                else if(Math.abs(analogSteer) > 0.1) steerAngle = -analogSteer * steerLimit;
            }
            for(let i=0; i<segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                wheelVerts.push({x: width/2, y: Math.cos(theta) * radius, z: Math.sin(theta) * radius}); 
            }
            for(let i=0; i<segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                wheelVerts.push({x: -width/2, y: Math.cos(theta) * radius, z: Math.sin(theta) * radius}); 
            }
            const transformedVerts = wheelVerts.map(v => {
                let vx = v.x, vy = v.y, vz = v.z;
                if(isFront) {
                   const cosS = Math.cos(steerAngle);
                   const sinS = Math.sin(steerAngle);
                   const tx = vx * cosS - vz * sinS;
                   const tz = vx * sinS + vz * cosS;
                   vx = tx; vz = tz;
                }
                vx += x; vy += y; vz += z;
                return project3D(vx, vy, vz, cx, cy, scale, yaw);
            });
            const outerPoly = [];
            if (x > 0) { for(let i=segments-1; i>=0; i--) outerPoly.push(transformedVerts[i]); } 
            else { for(let i=0; i<segments; i++) outerPoly.push(transformedVerts[i]); }
            if (outerPoly[0].visible && isFrontFacing(outerPoly[0], outerPoly[1], outerPoly[2])) {
                wheelFaces.push({ verts: outerPoly, col: '#333', stroke: '#111', type: 'wheel_face' });
            }
            for(let i=0; i<segments; i++) {
                const next = (i+1)%segments;
                let poly;
                if (x > 0) poly = [transformedVerts[next], transformedVerts[i], transformedVerts[i+segments], transformedVerts[next+segments]];
                else poly = [transformedVerts[i], transformedVerts[next], transformedVerts[next+segments], transformedVerts[i+segments]];
                if (poly[0].visible && isFrontFacing(poly[0], poly[1], poly[2])) {
                    wheelFaces.push({ verts: poly, col: '#111', stroke: '#000', type: 'wheel_tread' });
                }
            }
            return wheelFaces;
        }

        const wheelFaces = [
            ...create3DWheel(-w, 0, l-15, 10, 12, true), ...create3DWheel(w, 0, l-15, 10, 12, true),
            ...create3DWheel(-w, 0, -l+15, 10, 12, false), ...create3DWheel(w, 0, -l+15, 10, 12, false)
        ];

        [...faces, ...wheelFaces].forEach(f => {
            let zSum = 0, count = 0; f.verts.forEach(v => { if(v) { zSum += v.depth; count++; } }); f.z = count > 0 ? zSum/count : 0;
        });
        const allFaces = [...faces, ...wheelFaces].sort((a, b) => b.z - a.z);

        allFaces.forEach(f => {
            if(!f.verts[0] || !f.verts[0].visible) return;
            if (f.type === 'side_molding') return; 
            if (f.type === 'wheel_face') {
                const pts = f.verts;
                ctx.fillStyle = '#333'; ctx.strokeStyle = '#111'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                ctx.closePath(); ctx.fill(); ctx.stroke();
                let cx=0, cy=0; pts.forEach(p=>{cx+=p.x; cy+=p.y;}); cx/=pts.length; cy/=pts.length;
                ctx.fillStyle = '#888'; ctx.beginPath();
                for(let i=0; i<pts.length; i++) {
                    const px = cx + (pts[i].x - cx)*0.6; const py = cy + (pts[i].y - cy)*0.6;
                    if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath(); ctx.fill(); return;
            }
            if (f.type === 'back_detail') {
                const p = f.verts; 
                const lerp = (a, b, t) => ({ x: a.x + (b.x-a.x)*t, y: a.y + (b.y-a.y)*t });
                const ml = lerp(p[3], p[0], 0.4); const mr = lerp(p[2], p[1], 0.4); 
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(ml.x, ml.y); ctx.lineTo(mr.x, mr.y); ctx.lineTo(p[2].x, p[2].y); ctx.lineTo(p[3].x, p[3].y); ctx.fill();
                const tl = lerp(p[3], p[0], 0.5); const tr = lerp(p[2], p[1], 0.5);
                const tlh = lerp(p[3], p[0], 0.7); const trh = lerp(p[2], p[1], 0.7);
                ctx.fillStyle = '#aa0000';
                if(keys.ArrowDown || keys.Space || keys.ShiftLeft) { ctx.fillStyle = '#ff0000'; ctx.shadowBlur=10; ctx.shadowColor='red'; }
                ctx.beginPath(); ctx.moveTo(tlh.x, tlh.y); ctx.lineTo(trh.x, trh.y); ctx.lineTo(lerp(tl, tr, 0.4).x, lerp(tl, tr, 0.4).y); ctx.lineTo(lerp(tl, tr, 0.05).x, lerp(tl, tr, 0.05).y); ctx.fill();
                ctx.beginPath(); ctx.moveTo(trh.x, trh.y); ctx.lineTo(trh.x, trh.y); ctx.lineTo(lerp(tl, tr, 0.95).x, lerp(tl, tr, 0.95).y); ctx.lineTo(lerp(tl, tr, 0.6).x, lerp(tl, tr, 0.6).y); ctx.fill(); ctx.shadowBlur=0;
                ctx.fillStyle = '#f1c40f';
                const plateY = (ml.y + p[0].y) * 0.5; const plateW = (mr.x - ml.x) * 0.2; const plateX = (ml.x + mr.x) * 0.5 - plateW/2;
                ctx.fillRect(plateX, plateY - 5, plateW, 10);
                return;
            }
            if(f.verts.length === 4) drawQuad(ctx, f.verts[0], f.verts[1], f.verts[2], f.verts[3], f.col, f.stroke);
            if (f.col === '#222') { ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.moveTo(f.verts[0].x, f.verts[0].y); ctx.lineTo(f.verts[1].x, f.verts[1].y); ctx.lineTo(f.verts[2].x, f.verts[2].y); ctx.fill(); }
        });
    }

    function levelComplete() {
        gameState = 'clear';
        showMessage("LEVEL COMPLETED!", "#0ff", 3000);
        const stopInterval = setInterval(() => {
            speed -= 100;
            if (speed <= 0) {
                speed = 0; clearInterval(stopInterval);
                if (currentLevel < MAX_LEVEL) setCenterMessage(`LEVEL ${currentLevel} CLEARED`, "TAP TO NEXT LEVEL");
                else setCenterMessage("ALL LEVELS CLEARED!", "YOU ARE THE DRIFT KING!");
            }
        }, 50);
    }

    function handleInputStart() {
        if (gameState === 'start') initLevel(1);
        else if (gameState === 'clear') {
            if (currentLevel < MAX_LEVEL) initLevel(currentLevel + 1);
            else { score = 0; initLevel(1); }
        }
    }

    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; if (gameState !== 'play') handleInputStart(); });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });
    canvas.addEventListener('touchstart', e => { if (gameState !== 'play') { e.preventDefault(); handleInputStart(); } });

    const joystickArea = document.getElementById('joystick-area');
    const joystickKnob = document.getElementById('joystick-knob');
    let joyStartX = 0, joyStartY = 0, joystickTouchId = null; 
    joystickArea.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); if (joystickTouchId !== null) return; const touch = e.changedTouches[0]; joystickTouchId = touch.identifier; joyStartX = touch.clientX; joyStartY = touch.clientY; joystickKnob.style.transition = 'none'; }, {passive: false});
    joystickArea.addEventListener('touchmove', e => { e.preventDefault(); e.stopPropagation(); if (joystickTouchId === null) return; for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joystickTouchId) { const deltaX = e.changedTouches[i].clientX - joyStartX; const clampedX = Math.max(-50, Math.min(50, deltaX)); joystickKnob.style.transform = `translate(${clampedX}px, 0px)`; analogSteer = clampedX / 50; break; } } }, {passive: false});
    const resetJoystick = () => { joystickTouchId = null; joystickKnob.style.transition = '0.2s'; joystickKnob.style.transform = `translate(0px, 0px)`; analogSteer = 0; };
    joystickArea.addEventListener('touchend', e => { e.preventDefault(); e.stopPropagation(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joystickTouchId) { resetJoystick(); break; } } });
    joystickArea.addEventListener('touchcancel', e => { e.preventDefault(); e.stopPropagation(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joystickTouchId) { resetJoystick(); break; } } });

    const btnGas = document.getElementById('btn-gas'); const btnBrake = document.getElementById('btn-brake');
    const handleBtn = (elem, key, isPressed) => { if(isPressed) { elem.style.background = 'rgba(255,255,255,0.5)'; keys[key] = true; } else { elem.style.background = ''; keys[key] = false; } };
    btnGas.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); handleBtn(btnGas, 'ArrowUp', true); });
    btnGas.addEventListener('touchend', e => { e.preventDefault(); e.stopPropagation(); handleBtn(btnGas, 'ArrowUp', false); });
    btnBrake.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); handleBtn(btnBrake, 'ArrowDown', true); });
    btnBrake.addEventListener('touchend', e => { e.preventDefault(); e.stopPropagation(); handleBtn(btnBrake, 'ArrowDown', false); });

    let lastTime = 0;
    function gameLoop(time) { const dt = Math.min(1, (time - lastTime) / 1000); lastTime = time; update(dt); render(); requestAnimationFrame(gameLoop); }
    setCenterMessage("Retro Racer 3D", "TAP TO START");
    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
