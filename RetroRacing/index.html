<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Racer - Drift & Mobile Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px #ff00de, 3px 3px 0 #000;
            display: none;
            z-index: 20;
            white-space: nowrap;
            animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }

        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 60px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 5px 5px 0 #000, 0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 15;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.6);
        }

        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            z-index: 50;
            display: none;
            pointer-events: none;
        }
        .touch-btn {
            pointer-events: auto;
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            touch-action: none;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.5); }
        
        #joystick-area {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 160px; height: 160px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.3);
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px; height: 60px;
            margin-top: -30px; margin-left: -30px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,255,255,0.5);
            transform: translate(0px, 0px);
        }

        #btn-gas {
            bottom: 40px; right: 30px;
            width: 90px; height: 140px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 20px;
            border: 3px solid #0f0;
        }
        #btn-gas::after { content: 'GAS'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; }
        
        #btn-brake {
            bottom: 40px; right: 140px;
            width: 70px; height: 90px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            border: 3px solid #f00;
        }
        #btn-brake::after { content: 'BRAKE'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; font-size: 12px; }

        @media (hover: none) and (pointer: coarse) {
            .touch-controls { display: block; }
            #instructions { display: none; }
        }
    </style>
</head>
<body>

    <div id="ui">
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span><br>
        DIST: <span id="distDisplay">0</span>
    </div>
    <div id="center-msg">START!</div>
    <div id="drift-msg">KANSEI DRIFT!!</div>

    <div class="touch-controls">
        <div id="joystick-area">
            <div id="joystick-knob"></div>
        </div>
        <div id="btn-brake" class="touch-btn"></div>
        <div id="btn-gas" class="touch-btn"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const distDisplay = document.getElementById('distDisplay');
    const driftMsg = document.getElementById('drift-msg');
    const centerMsg = document.getElementById('center-msg');

    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if(isMobile) {
        document.querySelector('.touch-controls').style.display = 'block';
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 게임 상수 ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 2000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);

    // --- 상태 변수 ---
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;
    let analogSteer = 0;

    let segments = [];
    let skids = [];

    const checkpointLocs = [
        { pos: 10, name: "START", passed: false, color: "#00ff00" },
        { pos: 1000, name: "CHECKPOINT", passed: false, color: "#00ffff" },
        { pos: 1980, name: "GOAL", passed: false, color: "#ff0055" }
    ];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = (width / 2) + (p.screen.scale * p.camera.x * width / 2);
        p.screen.y = (height / 2) - (p.screen.scale * p.camera.y * height / 2);
        p.screen.w = (p.screen.scale * roadWidth * width / 2);
    }

    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    function createRoad() {
        segments = [];
        const totalSegments = 2000; 
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;
            if (i > 300 && i < 700) curve = 2;
            if (i > 800 && i < 1200) curve = -3; 
            if (i > 1300 && i < 1700) curve = 3; 
            y = Math.sin(i / 30) * 1000;

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            let feature = null;
            checkpointLocs.forEach(cp => {
                if(i >= cp.pos && i < cp.pos + 3) feature = { type: 'arch', name: cp.name, color: cp.color };
            });

            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor },
                feature: feature
            });
        }
    }

    function showMessage(text, color='#fff') {
        centerMsg.innerText = text;
        centerMsg.style.color = color;
        centerMsg.style.display = 'block';
        centerMsg.style.animation = 'none';
        centerMsg.offsetHeight; 
        centerMsg.style.animation = 'pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        setTimeout(() => { centerMsg.style.display = 'none'; }, 2000);
    }

    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#0a0a2a');
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#fffc';
        ctx.beginPath(); ctx.arc(width*0.8, 100, 40, 0, Math.PI*2); ctx.fill();

        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 
        
        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n) % segments.length;
            let segment = segments[currentIdx];
            let loopOffset = (segment.index < baseSegment.index) ? segments.length * SEGMENT_LENGTH : 0;
            
            let playerSegIdx = Math.floor((position+100)/SEGMENT_LENGTH)%segments.length;
            let playerY = segments[playerSegIdx].p1.world.y;
            let camY = CAMERA_HEIGHT + playerY;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH || segment.p2.screen.y > maxy - 1 || segment.p2.screen.y >= segment.p1.screen.y) {
                continue; 
            }

            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            let renderY2 = y2 - 1; 

            ctx.fillStyle = '#001100'; 
            ctx.fillRect(0, renderY2, width, y1 - renderY2); 

            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, renderY2, l2 - r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, renderY2, l2 + r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, renderY2, l2 - r2, renderY2, segment.color.road);

            if (segment.feature && segment.feature.type === 'arch') {
                drawArch(ctx, l2, renderY2, r2, segment.feature);
            }

            maxy = y2; 
        }

        drawSkidMarks();
        drawCarSprite(); 
    }

    function drawArch(ctx, cx, cy, w, feature) {
        const archWidth = w * 2.5; 
        const archHeight = w * 2.0; 
        const pillarW = w * 0.2;

        ctx.save();
        ctx.translate(cx, cy);

        ctx.fillStyle = '#444';
        ctx.fillRect(-archWidth/2, -archHeight, pillarW, archHeight); 
        ctx.fillRect(archWidth/2 - pillarW, -archHeight, pillarW, archHeight); 

        ctx.fillStyle = feature.color || '#fff';
        ctx.fillRect(-archWidth/2 - pillarW, -archHeight - pillarW, archWidth + pillarW*2, pillarW*2);

        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `bold ${Math.max(10, w * 0.8)}px sans-serif`;
        ctx.fillText(feature.name, 0, -archHeight);

        ctx.restore();
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }

            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    // --- 3D 투영을 이용한 자동차 그리기 (디자인 개선됨) ---
    function drawCarSprite() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 1000; 
        
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        const cx = width / 2;
        const cy = height - 100 * scale + bounce;

        const maxAngle = Math.PI / 4; 
        const driftFactor = driftMode ? 1.5 : 1.0;
        const yaw = playerTurn * maxAngle * driftFactor;

        draw3DCar(ctx, cx, cy, scale, yaw);
    }

    function draw3DCar(ctx, cx, cy, scale, yaw) {
        // 자동차 치수 (AE86 비율 참조)
        const carW = 38; 
        const carH = 26; 
        const carL = 82;
        const roofH = 18; 
        const hoodL = 10; // 후드 길이 조정용
        
        // 3D 좌표 정의
        const vertices = [
            // 바닥 (0-3)
            {x: -carW, y: 0, z: carL},    // 0: 뒤 왼쪽
            {x: carW, y: 0, z: carL},     // 1: 뒤 오른쪽
            {x: carW, y: 0, z: -carL},    // 2: 앞 오른쪽
            {x: -carW, y: 0, z: -carL},   // 3: 앞 왼쪽
            
            // 벨트라인 (4-7)
            {x: -carW, y: -carH, z: carL},    // 4: 뒤 왼쪽 상단 (트렁크)
            {x: carW, y: -carH, z: carL},     // 5: 뒤 오른쪽 상단
            {x: carW, y: -carH + 5, z: -carL}, // 6: 앞 오른쪽 상단 (후드 - 약간 낮게)
            {x: -carW, y: -carH + 5, z: -carL},// 7: 앞 왼쪽 상단

            // 지붕 (8-11)
            {x: -carW * 0.82, y: -carH - roofH, z: carL * 0.35},  // 8: 뒤 왼쪽
            {x: carW * 0.82, y: -carH - roofH, z: carL * 0.35},   // 9: 뒤 오른쪽
            {x: carW * 0.82, y: -carH - roofH, z: -carL * 0.15},  // 10: 앞 오른쪽
            {x: -carW * 0.82, y: -carH - roofH, z: -carL * 0.15}, // 11: 앞 왼쪽

            // 팝업 라이트 (12-15: 후드 위 돌출부)
            {x: -carW * 0.8, y: -carH + 5, z: -carL * 0.85}, // 12: 왼쪽 라이트 시작
            {x: -carW * 0.4, y: -carH + 5, z: -carL * 0.85}, // 13: 왼쪽 라이트 끝
            {x: carW * 0.4, y: -carH + 5, z: -carL * 0.85},  // 14: 오른쪽 라이트 시작
            {x: carW * 0.8, y: -carH + 5, z: -carL * 0.85},  // 15: 오른쪽 라이트 끝
        ];

        // 회전 및 투영
        const projected = vertices.map(v => {
            // Y축 회전
            const rx = v.x * Math.cos(yaw) - v.z * Math.sin(yaw);
            // 역원근감 적용 (앞쪽을 넓게)
            // z가 음수(앞쪽)일수록 inversePerspective가 커짐
            const perspectiveStrength = 0.35; // 원근감 강도 조절
            const inversePerspective = 1.0 - (v.z / carL) * perspectiveStrength; 
            
            return {
                x: cx + rx * scale * inversePerspective,
                y: cy + v.y * scale 
            };
        });

        // 팝업 라이트 높이 계산 (회전 후 투영된 y값에서 위로 올림)
        const popUpH = 8 * scale; 

        const showLeft = yaw > 0;
        const sideIdx = showLeft ? [0, 3, 7, 4] : [1, 2, 6, 5];
        const roofSideIdx = showLeft ? [4, 7, 11, 8] : [5, 6, 10, 9];

        ctx.save();
        ctx.lineWidth = 1;
        ctx.lineJoin = 'round';

        // 1. 그림자
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath();
        ctx.moveTo(projected[0].x, projected[0].y + 12*scale);
        ctx.lineTo(projected[1].x, projected[1].y + 12*scale);
        ctx.lineTo(projected[2].x, projected[2].y + 12*scale);
        ctx.lineTo(projected[3].x, projected[3].y + 12*scale);
        ctx.fill();

        // 2. 바퀴 (먼 쪽)
        const farWheelX = showLeft ? projected[2].x : projected[3].x;
        const farWheelY = projected[2].y; // 바닥 높이 비슷함
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(farWheelX, farWheelY, 13 * scale, 0, Math.PI*2); ctx.fill();

        // 3. 차체 옆면 (팬더 도색: 흰색 바디 + 검은색 하단)
        
        // 전체 흰색 베이스
        ctx.fillStyle = '#f4f4f4'; 
        ctx.strokeStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(projected[sideIdx[0]].x, projected[sideIdx[0]].y);
        ctx.lineTo(projected[sideIdx[1]].x, projected[sideIdx[1]].y);
        ctx.lineTo(projected[sideIdx[2]].x, projected[sideIdx[2]].y);
        ctx.lineTo(projected[sideIdx[3]].x, projected[sideIdx[3]].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // 검은색 하단 몰딩 (AE86 특징)
        ctx.fillStyle = '#111';
        ctx.beginPath();
        const moldH = 8 * scale;
        // 바닥선에서 일정 높이만큼
        ctx.moveTo(projected[sideIdx[0]].x, projected[sideIdx[0]].y);
        ctx.lineTo(projected[sideIdx[1]].x, projected[sideIdx[1]].y);
        ctx.lineTo(projected[sideIdx[1]].x, projected[sideIdx[1]].y - moldH);
        ctx.lineTo(projected[sideIdx[0]].x, projected[sideIdx[0]].y - moldH);
        ctx.fill();

        // 검은색 사이드 라인 (중간 띠)
        ctx.fillStyle = '#111';
        ctx.beginPath();
        const stripY = (projected[sideIdx[3]].y + projected[sideIdx[0]].y) * 0.5 - 2*scale;
        const stripH = 3 * scale;
        // 4점 보간으로 띠 그리기 (복잡하니 단순하게 y축 비율로)
        // ... 단순화: 위에서 그린 다각형의 중간 높이에 선 긋기
        // 정확히 하려면 3D 보간이 필요하지만, 여기선 캔버스 2D라 근사치
        ctx.moveTo(projected[sideIdx[0]].x + (projected[sideIdx[3]].x - projected[sideIdx[0]].x)*0.4, 
                   projected[sideIdx[0]].y + (projected[sideIdx[3]].y - projected[sideIdx[0]].y)*0.4);
        // ... 생략하고 그냥 검은색 하단 몰딩만 강조해도 느낌 남

        // 4. 지붕 옆면 (필러 + 창문)
        ctx.fillStyle = '#111'; // 윈도우 프레임
        ctx.beginPath();
        ctx.moveTo(projected[sideIdx[3]].x, projected[sideIdx[3]].y); 
        ctx.lineTo(projected[sideIdx[2]].x, projected[sideIdx[2]].y); 
        ctx.lineTo(projected[roofSideIdx[2]].x, projected[roofSideIdx[2]].y); 
        ctx.lineTo(projected[roofSideIdx[3]].x, projected[roofSideIdx[3]].y); 
        ctx.closePath();
        ctx.fill();

        // 5. 팝업 라이트 (측면에서 튀어나온 모습)
        // 차 앞쪽 후드 위(projected[6/7])에 사각형 그리기
        const hoodFrontIdx = showLeft ? 7 : 6;
        // 팝업 라이트는 앞쪽 끝에 위치
        ctx.fillStyle = '#f4f4f4'; // 차체색
        ctx.fillRect(projected[hoodFrontIdx].x - 5*scale, projected[hoodFrontIdx].y - popUpH, 10*scale, popUpH);
        ctx.strokeRect(projected[hoodFrontIdx].x - 5*scale, projected[hoodFrontIdx].y - popUpH, 10*scale, popUpH);


        // 6. 바퀴 (가까운 쪽) - 와타나베 스타일 (검은색 + 실버 림)
        const nearWheelX = projected[sideIdx[0]].x * 0.78 + projected[sideIdx[1]].x * 0.22;
        const nearWheelY = projected[sideIdx[0]].y;
        const frontWheelX = projected[sideIdx[0]].x * 0.22 + projected[sideIdx[1]].x * 0.78;
        const frontWheelY = projected[sideIdx[0]].y; // 투영된 y값 보간

        function drawWheel(wx, wy) {
            // 타이어
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(wx, wy, 13 * scale, 13 * scale, 0, 0, Math.PI*2); ctx.fill();
            // 휠 림 (실버)
            ctx.fillStyle = '#ccc';
            ctx.beginPath(); ctx.ellipse(wx, wy, 8 * scale, 8 * scale, 0, 0, Math.PI*2); ctx.fill();
            // 휠 스포크 (검정 8스포크 느낌)
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.ellipse(wx, wy, 6 * scale, 6 * scale, 0, 0, Math.PI*2); ctx.fill();
            // 센터
            ctx.fillStyle = '#555';
            ctx.beginPath(); ctx.ellipse(wx, wy, 2 * scale, 2 * scale, 0, 0, Math.PI*2); ctx.fill();
        }
        drawWheel(nearWheelX, nearWheelY);
        drawWheel(frontWheelX, frontWheelY);

        // --- 7. 뒷면 렌더링 (가장 중요) ---
        const rearIdx = [0, 1, 5, 4];
        const rearRoofIdx = [4, 5, 9, 8];

        // 차체 뒷면
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(projected[rearIdx[0]].x, projected[rearIdx[0]].y);
        ctx.lineTo(projected[rearIdx[1]].x, projected[rearIdx[1]].y);
        ctx.lineTo(projected[rearIdx[2]].x, projected[rearIdx[2]].y);
        ctx.lineTo(projected[rearIdx[3]].x, projected[rearIdx[3]].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // 뒷 범퍼 (두껍게)
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(projected[rearIdx[0]].x - 2*scale, projected[rearIdx[0]].y); // 범퍼가 약간 튀어나옴
        ctx.lineTo(projected[rearIdx[1]].x + 2*scale, projected[rearIdx[1]].y);
        ctx.lineTo(projected[rearIdx[1]].x + 2*scale, projected[rearIdx[1]].y - 14*scale);
        ctx.lineTo(projected[rearIdx[0]].x - 2*scale, projected[rearIdx[0]].y - 14*scale);
        ctx.fill();

        // 뒷유리창 (해치백 스타일)
        ctx.fillStyle = '#222'; // 틴팅
        ctx.beginPath();
        ctx.moveTo(projected[rearRoofIdx[0]].x, projected[rearRoofIdx[0]].y);
        ctx.lineTo(projected[rearRoofIdx[1]].x, projected[rearRoofIdx[1]].y);
        ctx.lineTo(projected[rearRoofIdx[2]].x, projected[rearRoofIdx[2]].y);
        ctx.lineTo(projected[rearRoofIdx[3]].x, projected[rearRoofIdx[3]].y);
        ctx.closePath();
        ctx.fill();
        // 창문 와이퍼 (디테일)
        ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.moveTo(projected[rearRoofIdx[0]].x + 5*scale, projected[rearRoofIdx[0]].y - 2*scale);
        ctx.lineTo(projected[rearRoofIdx[0]].x + 15*scale, projected[rearRoofIdx[0]].y - 10*scale);
        ctx.stroke();

        // 지붕 윗면
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(projected[8].x, projected[8].y);
        ctx.lineTo(projected[9].x, projected[9].y);
        ctx.lineTo(projected[10].x, projected[10].y);
        ctx.lineTo(projected[11].x, projected[11].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // 테일램프 (AE86 스타일: 가로바 + 격자)
        const p4 = projected[4]; const p5 = projected[5];
        const tlY = p4.y + (projected[0].y - p4.y) * 0.35; 
        const tlH = 10 * scale;

        // 검은색 베이스
        ctx.fillStyle = '#000';
        ctx.fillRect(p4.x, tlY, p5.x - p4.x, tlH);

        // 램프 그리기 함수
        function drawTailLight(x, w, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, tlY + 1*scale, w, tlH - 2*scale);
        }

        const fullW = p5.x - p4.x;
        const lampW = fullW * 0.35;
        
        // 왼쪽 램프
        drawTailLight(p4.x + fullW*0.05, lampW, '#aa0000');
        // 오른쪽 램프
        drawTailLight(p4.x + fullW*0.6, lampW, '#aa0000');
        
        // 방향지시등 (주황색) - 램프 바깥쪽
        drawTailLight(p4.x + fullW*0.02, lampW*0.3, '#ff8800');
        drawTailLight(p5.x - fullW*0.02 - lampW*0.3, lampW*0.3, '#ff8800');

        // 브레이크 효과
        if (keys.ArrowDown) {
            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 20;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.fillRect(p4.x + fullW*0.05, tlY, lampW, tlH);
            ctx.fillRect(p4.x + fullW*0.6, tlY, lampW, tlH);
            ctx.shadowBlur = 0;
        }

        // 트렁크 로고 (TRUENO)
        ctx.fillStyle = '#111';
        ctx.font = `bold ${8*scale}px Arial`;
        ctx.textAlign = 'right';
        ctx.fillText('TRUENO', p5.x - 5*scale, tlY + 20*scale);

        // 번호판
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(cx - 12*scale, projected[0].y - 22*scale, 24*scale, 8*scale);
        ctx.fillStyle = '#000';
        ctx.font = `${6*scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('86-DRIFT', cx, projected[0].y - 16*scale);

        // 머플러
        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(projected[0].x + 10*scale, projected[0].y - 5*scale, 4*scale, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(projected[0].x + 10*scale, projected[0].y - 5*scale, 2*scale, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }

    // --- 업데이트 ---
    function update(dt) {
        position = (position + speed * dt);
        
        const currentSegIndex = Math.floor((position + 100) / SEGMENT_LENGTH);
        checkpointLocs.forEach(cp => {
            if (!cp.passed && currentSegIndex >= cp.pos) {
                cp.passed = true;
                showMessage(cp.name, cp.color);
                score += 5000;
                if(cp.name === "GOAL") {
                    // 완주
                }
            }
        });

        const accelInput = keys.ArrowUp;
        const brakeInput = keys.ArrowDown;
        
        let turnInput = 0;
        if(keys.ArrowLeft) turnInput = -1;
        else if(keys.ArrowRight) turnInput = 1;
        else turnInput = analogSteer; 

        if (accelInput) speed += accel;
        else if (brakeInput) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        const isTurning = Math.abs(turnInput) > 0.1;
        driftMode = brakeInput && isTurning && speed > 4000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 20; 
            if (Math.random() > 0.3) {
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.7; 

        if(Math.abs(turnInput) > 0) targetTurn = turnInput * turnLimit;
        
        const smoothing = driftMode ? 2.0 : 4.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        if (speed > 0) {
            let moveAmount = (speed / maxSpeed) * 0.04 * playerTurn;
            playerX += moveAmount;
            const playerSegment = segments[Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length];
            playerX -= (playerSegment.curve * 0.00015) * (speed / maxSpeed);
        }

        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
        distDisplay.innerText = Math.floor(position / 1000) + "m";
    }

    const joystickArea = document.getElementById('joystick-area');
    const joystickKnob = document.getElementById('joystick-knob');
    let joyStartX = 0, joyStartY = 0;

    joystickArea.addEventListener('touchstart', e => {
        const touch = e.touches[0];
        joyStartX = touch.clientX;
        joyStartY = touch.clientY;
        joystickKnob.style.transition = 'none';
    }, {passive: false});

    joystickArea.addEventListener('touchmove', e => {
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - joyStartX;
        const maxDist = 50;
        const clampedX = Math.max(-maxDist, Math.min(maxDist, deltaX));
        joystickKnob.style.transform = `translate(${clampedX}px, 0px)`;
        analogSteer = clampedX / maxDist;
    }, {passive: false});

    joystickArea.addEventListener('touchend', e => {
        joystickKnob.style.transition = '0.2s';
        joystickKnob.style.transform = `translate(0px, 0px)`;
        analogSteer = 0;
    });

    const btnGas = document.getElementById('btn-gas');
    const btnBrake = document.getElementById('btn-brake');

    const handleBtn = (elem, key, isPressed) => {
        if(isPressed) { elem.style.background = 'rgba(255,255,255,0.5)'; keys[key] = true; }
        else { elem.style.background = ''; keys[key] = false; }
    };

    btnGas.addEventListener('touchstart', e => { e.preventDefault(); handleBtn(btnGas, 'ArrowUp', true); });
    btnGas.addEventListener('touchend', e => { e.preventDefault(); handleBtn(btnGas, 'ArrowUp', false); });

    btnBrake.addEventListener('touchstart', e => { e.preventDefault(); handleBtn(btnBrake, 'ArrowDown', true); });
    btnBrake.addEventListener('touchend', e => { e.preventDefault(); handleBtn(btnBrake, 'ArrowDown', false); });

    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    createRoad();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
