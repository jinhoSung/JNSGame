<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outrun Evolution: Perfect Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #5D94FB; user-select: none; }
        #ui-layer {
            position: absolute;
            top: 20px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; width: 100%; z-index: 10;
        }
        #message {
            font-family: 'Impact', sans-serif; font-size: 80px;
            color: #FF0055; -webkit-text-stroke: 3px #FFFFFF;
            text-shadow: 5px 5px 0px #000; font-style: italic;
            margin-bottom: 20px; display: none;
            animation: pop 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #hud { display: flex; gap: 20px; justify-content: center; }
        .hud-box {
            font-family: 'Verdana', sans-serif; color: #FFFF00;
            background: rgba(0, 0, 0, 0.7); padding: 10px 25px;
            border-radius: 12px; border: 3px solid #FFFFFF;
            font-size: 24px; font-weight: 900; font-style: italic;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .label { font-size: 12px; color: #00FFFF; display: block; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 2px; }
        .danger { color: #FF3333 !important; border-color: #FF3333 !important; animation: shake 0.5s infinite; }
        
        @keyframes pop { 0% { transform: scale(0) rotate(-10deg); } 100% { transform: scale(1) rotate(0deg); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="message">CRASH!</div>
        <div id="hud">
            <div class="hud-box">
                <span class="label">Speed</span>
                <span id="speed">0</span> km/h
            </div>
            <div class="hud-box">
                <span class="label">Stage</span>
                <span id="stage">1</span>
            </div>
            <div class="hud-box">
                <span class="label">Time</span>
                <span id="time">0.0</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 기본 설정 ---
        const scene = new THREE.Scene();
        const skyColorBeach = new THREE.Color(0x5D94FB);
        const skyColorMountain = new THREE.Color(0xFF8C00);
        scene.background = skyColorBeach;
        scene.fog = new THREE.Fog(skyColorBeach, 20, 450);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(150, 300, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096; dirLight.shadow.mapSize.height = 4096;
        const d = 400;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.far = 1000;
        scene.add(dirLight);

        // --- 2. 텍스처 ---
        function createOutrunTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const stripes = 2; const h = canvas.height / stripes;
            for(let i=0; i<stripes; i++) {
                const isDark = i % 2 === 0;
                ctx.fillStyle = isDark ? '#999999' : '#888888'; ctx.fillRect(0, i * h, 512, h);
                ctx.fillStyle = isDark ? '#FF0000' : '#FFFFFF'; ctx.fillRect(0, i * h, 35, h); ctx.fillRect(477, i * h, 35, h);
                if (!isDark) { ctx.fillStyle = '#FFD700'; ctx.fillRect(248, i * h + 20, 16, h - 40); }
            }
            const t = new THREE.CanvasTexture(canvas);
            t.magFilter = THREE.LinearFilter; t.minFilter = THREE.LinearMipMapLinearFilter;
            t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
            t.repeat.set(1, 8); t.anisotropy = 16;
            return t;
        }
        function createGrassTexture() {
            const c = document.createElement('canvas'); c.width = 512; c.height = 512;
            const x = c.getContext('2d');
            x.fillStyle = '#3da834'; x.fillRect(0,0,512,256);
            x.fillStyle = '#328a2a'; x.fillRect(0,256,512,256);
            const t = new THREE.CanvasTexture(c);
            t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping;
            t.repeat.set(40, 40);
            return t;
        }

        // --- 3. 트랙 생성 ---
        const stageInfo = [];
        function generateTrack() {
            const points = [];
            let cx = 0, cy = 0, cz = 0;
            points.push(new THREE.Vector3(0,0,0)); // Start
            
            // Stage 1 (Beach)
            for(let i=0; i<25; i++) {
                cz -= 100; cx += Math.sin(i * 0.4) * 40; 
                points.push(new THREE.Vector3(cx, cy, cz));
            }
            stageInfo.push({ z: cz, color: 0x5D94FB });

            // Stage 2 (Field - Uphill)
            for(let i=0; i<25; i++) {
                cz -= 100; cx += Math.cos(i * 0.7) * 60; cy += 3;
                points.push(new THREE.Vector3(cx, cy, cz));
            }
            stageInfo.push({ z: cz, color: 0xFF8C00 });

            // Stage 3 (Mountain - Downhill & Curves)
            for(let i=0; i<30; i++) {
                cz -= 100; cx += Math.sin(i * 1.5) * 90;
                cy = i < 15 ? cy - 5 : cy * 0.95;
                points.push(new THREE.Vector3(cx, cy, cz));
            }
            return new THREE.CatmullRomCurve3(points);
        }
        const curve = generateTrack();
        const points = curve.getSpacedPoints(3500); 

        function createRoadMesh(pts) {
            const geo = new THREE.BufferGeometry();
            const verts = [], uvs = [];
            const width = 28;

            for (let i = 0; i < pts.length; i++) {
                const p = pts[i];
                let tan;
                if (i === pts.length - 1) tan = pts[i].clone().sub(pts[i - 1]).normalize();
                else tan = pts[i + 1].clone().sub(pts[i]).normalize();
                const side = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(width);
                const l = p.clone().add(side); const r = p.clone().sub(side);
                verts.push(l.x, l.y, l.z, r.x, r.y, r.z);
                const v = i / 15; uvs.push(0, v, 1, v);
            }
            const idx = [];
            for (let i = 0; i < pts.length - 1; i++) {
                const b = i * 2; idx.push(b, b+2, b+1, b+1, b+2, b+3);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geo.setIndex(idx); geo.computeVertexNormals();
            return geo;
        }
        const roadMesh = new THREE.Mesh(createRoadMesh(points), new THREE.MeshStandardMaterial({ map: createOutrunTexture(), roughness: 0.8 }));
        roadMesh.receiveShadow = true;
        scene.add(roadMesh);
        
        // 지형 바닥 (Player를 따라다니도록 설정 예정)
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), new THREE.MeshBasicMaterial({ map: createGrassTexture() }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -2;
        scene.add(ground);
        
        const sea = new THREE.Mesh(new THREE.PlaneGeometry(3000, 8000), new THREE.MeshBasicMaterial({ color: 0x1E90FF }));
        sea.rotation.x = -Math.PI/2; sea.position.set(1800, -8, -3000);
        scene.add(sea);

        // --- 4. 오브젝트 배치 ---
        const obstacles = [];
        const treeGeo = new THREE.CylinderGeometry(0.5, 0.9, 7, 7);
        const treeMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const leafGeo = new THREE.ConeGeometry(3.5, 6, 6);
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const rockGeo = new THREE.DodecahedronGeometry(3.5);
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666 });

        function spawnProp(type, p, sideVec, dist) {
            const g = new THREE.Group();
            let radius = 2;
            if(type === 'palm') {
                const t = new THREE.Mesh(treeGeo, treeMat); t.position.y = 3.5;
                const l = new THREE.Mesh(leafGeo, leafMat); l.position.y = 8;
                g.add(t, l); g.scale.set(1.5,1.5,1.5);
            } else if (type === 'rock') {
                const r = new THREE.Mesh(rockGeo, rockMat); r.position.y = 1.5;
                g.add(r); g.scale.set(1.2,1.2,1.2); radius = 3;
            }
            const pos = p.clone().add(sideVec.multiplyScalar(dist));
            g.position.copy(pos); g.castShadow = true;
            scene.add(g);
            obstacles.push({ pos: pos, radius: radius, type: 'static' });
        }

        for(let i=20; i<points.length; i+=8) {
            const p = points[i];
            const pNext = points[Math.min(i+1, points.length-1)];
            const tan = pNext.clone().sub(p).normalize();
            const side = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0,1,0)).normalize();
            const isLeft = Math.random() > 0.5;
            const dist = 32 + Math.random() * 25; 
            let type = 'palm';
            if(p.z < stageInfo[1].z) type = Math.random()>0.4 ? 'rock' : 'palm'; 

            if(Math.random() > 0.92) {
                 const closeDist = 20; 
                 spawnProp('rock', p, side, isLeft ? closeDist : -closeDist);
            } else {
                 spawnProp(type, p, side, isLeft ? dist : -dist);
            }
        }

        // --- 5. 플레이어 (자동차) 재구성 ---
        // 핵심 수정: +Z 축이 '앞(Front)'이 되도록 모델링 재조립
        const carGroup = new THREE.Group();
        const startIdx = 5; 
        const startPos = points[startIdx];
        const startTan = points[startIdx+1].clone().sub(startPos).normalize();
        
        carGroup.position.copy(startPos);
        // LookAt은 +Z축을 타겟으로 향하게 함 (Object3D 기준)
        const lookTarget = startPos.clone().add(startTan.multiplyScalar(10));
        carGroup.lookAt(lookTarget); 
        
        scene.add(carGroup);

        const carModel = new THREE.Group();
        
        // [모델링 좌표계: +Z가 앞, -Z가 뒤]
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0xD90000, shininess: 80 });
        
        // 차체
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(4, 1.2, 8), bodyMat); 
        chassis.position.y = 1.2;
        
        // 캐빈 (뒤쪽 -Z)
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1, 4), new THREE.MeshPhongMaterial({color:0x111111})); 
        cabin.position.set(0, 2, -1.5); 
        
        // 스포일러 (맨 뒤 -Z)
        const spoiler = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.2, 1), bodyMat); 
        spoiler.position.set(0, 2.3, -3.8); 

        // 헤드라이트 (맨 앞 +Z)
        const lightGeo = new THREE.BoxGeometry(0.8, 0.2, 0.1);
        const lightMat = new THREE.MeshBasicMaterial({ color: 0xFFFFCC });
        const leftLight = new THREE.Mesh(lightGeo, lightMat); leftLight.position.set(-1.2, 1.4, 4.01);
        const rightLight = new THREE.Mesh(lightGeo, lightMat); rightLight.position.set(1.2, 1.4, 4.01);

        carModel.add(chassis, cabin, spoiler, leftLight, rightLight);
        carGroup.add(carModel);

        const wheelGroups = []; 

        function addWheel(x, z, isFront) {
            const wGroup = new THREE.Group();
            wGroup.position.set(x, 0.8, z);
            
            const wGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.8, 24);
            const wMat = new THREE.MeshStandardMaterial({color:0x222222});
            const wMesh = new THREE.Mesh(wGeo, wMat);
            wMesh.rotation.z = Math.PI / 2; // 눕히기
            wMesh.castShadow = true;

            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.2), new THREE.MeshStandardMaterial({color:0xFFD700}));
            wMesh.add(cap);

            wGroup.add(wMesh);
            carModel.add(wGroup);
            
            wheelGroups.push({ group: wGroup, mesh: wMesh, isFront: isFront });
        }

        // 바퀴 위치: +Z가 앞
        addWheel(-2.2, 2.5, true);  // FL
        addWheel(2.2, 2.5, true);   // FR
        addWheel(-2.2, -2.5, false); // RL
        addWheel(2.2, -2.5, false);  // RR

        // --- 6. 파티클 ---
        const particlesGeo = new THREE.BufferGeometry();
        const pCount = 60;
        const pPos = new Float32Array(pCount * 3);
        const pLife = new Float32Array(pCount); 
        for(let i=0; i<pCount; i++) { pLife[i] = -1; }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({ color: 0x888888, size: 0.6, transparent: true, opacity: 0.5 });
        const particleSys = new THREE.Points(particlesGeo, pMat);
        scene.add(particleSys);

        function updateParticles(emitting) {
            const positions = particleSys.geometry.attributes.position.array;
            for(let i=0; i<pCount; i++) {
                if(pLife[i] > 0) {
                    pLife[i] -= 0.04; 
                    positions[i*3 + 1] += 0.08; 
                } else {
                    positions[i*3] = 99999; 
                }

                if(emitting && pLife[i] <= 0 && Math.random() > 0.7) {
                    const offset = new THREE.Vector3((Math.random()-0.5)*3, 0.5, -3.5); // 차 뒤쪽(-Z)
                    offset.applyMatrix4(carGroup.matrixWorld);
                    positions[i*3] = offset.x;
                    positions[i*3+1] = offset.y;
                    positions[i*3+2] = offset.z;
                    pLife[i] = 1.0;
                }
            }
            particleSys.geometry.attributes.position.needsUpdate = true;
        }

        // --- 7. 게임 로직 ---
        const carState = {
            speed: 0, maxSpeed: 4.8, accel: 0.03, friction: 0.98,
            turn: 0, drift: 0, invincible: 0,
            lastValidY: 0
        };
        const keys = { w:false, s:false, a:false, d:false };
        window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; if(e.key.startsWith("Arrow")) keys[e.key] = true; });
        window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; if(e.key.startsWith("Arrow")) keys[e.key] = false; });

        const elSpeed = document.getElementById('speed');
        const elStage = document.getElementById('stage');
        const elTime = document.getElementById('time');
        const elMsg = document.getElementById('message');

        let currentStage = 1;
        let startTime = Date.now();
        let isFinished = false;
        let shakeIntensity = 0;

        function animate() {
            requestAnimationFrame(animate);

            if(!isFinished) {
                // Physics
                if(keys['w']||keys['ArrowUp']) carState.speed += carState.accel;
                else if(keys['s']||keys['ArrowDown']) carState.speed -= carState.accel * 2;
                else carState.speed *= carState.friction;

                // --- 높이 처리 ---
                const raycaster = new THREE.Raycaster();
                raycaster.set(carGroup.position.clone().add(new THREE.Vector3(0,50,0)), new THREE.Vector3(0,-1,0));
                const hits = raycaster.intersectObject(roadMesh);
                
                let isOnRoad = false;
                if(hits.length > 0) {
                    isOnRoad = true;
                    const hitY = hits[0].point.y;
                    carGroup.position.y = THREE.MathUtils.lerp(carGroup.position.y, hitY + 0.8, 0.4);
                    carState.lastValidY = hitY;
                } else {
                    const targetY = carState.lastValidY - 0.5;
                    carGroup.position.y = THREE.MathUtils.lerp(carGroup.position.y, targetY, 0.1);
                    carState.speed *= 0.96;
                }

                // 조향 및 이동
                if(Math.abs(carState.speed) > 0.1) {
                    const dir = carState.speed > 0 ? 1 : -1;
                    const turnInput = (keys['a']||keys['ArrowLeft'] ? 1 : 0) + (keys['d']||keys['ArrowRight'] ? -1 : 0);
                    
                    carState.drift += (turnInput * 0.08 - carState.drift) * 0.1;
                    carGroup.rotateY(carState.drift * dir);
                    
                    carModel.rotation.z = -carState.drift * 4; 
                    carModel.rotation.x = -carState.speed * 0.04; 
                }

                if(carState.speed > carState.maxSpeed) carState.speed = carState.maxSpeed;
                if(carState.speed < -1) carState.speed = -1;
                
                // 전진 (이제 +Z 방향이 앞이므로 +Z로 이동)
                carGroup.translateZ(carState.speed);

                // 바퀴 애니메이션
                wheelGroups.forEach(w => {
                    // 굴러감: 로컬 X축 회전. 전진(+Z)시 -X회전
                    w.mesh.rotation.x -= carState.speed * 0.5;
                    // 조향
                    if(w.isFront) {
                        const steer = (keys['a']||keys['ArrowLeft'] ? 0.5 : 0) + (keys['d']||keys['ArrowRight'] ? -0.5 : 0);
                        w.group.rotation.y = steer;
                    }
                });
                
                if(carState.invincible > 0) carState.invincible--;
                else {
                    const cPos = carGroup.position;
                    for(let obs of obstacles) {
                        const dist = Math.sqrt(Math.pow(cPos.x-obs.pos.x,2) + Math.pow(cPos.z-obs.pos.z,2));
                        if(dist < (2.5 + obs.radius)) {
                            elMsg.innerText = "CRASH!"; elMsg.style.display='block';
                            setTimeout(()=>elMsg.style.display='none', 1000);
                            carState.speed *= -0.4; 
                            shakeIntensity = 2.0; carState.invincible = 60;
                            document.querySelector('.hud-box').classList.add('danger');
                            setTimeout(()=>document.querySelector('.hud-box').classList.remove('danger'),1000);
                        }
                    }
                }
                updateParticles(Math.abs(carState.speed)>2 || !isOnRoad);
            }

            // --- Camera ---
            const camTarget = carGroup.position.clone();
            const offset = new THREE.Vector3(0, 7, -18); // 차 뒤쪽 (-Z) 위
            offset.applyMatrix4(carGroup.matrixWorld);
            
            if(shakeIntensity > 0) {
                offset.x += (Math.random()-0.5)*shakeIntensity;
                offset.y += (Math.random()-0.5)*shakeIntensity;
                shakeIntensity *= 0.9;
            }
            camera.position.lerp(offset, 0.2);
            // 앞을 보게 함 (+Z 방향 앞쪽을 봄)
            const lookAtPos = carGroup.position.clone().add(new THREE.Vector3(0, 2, 20).applyQuaternion(carGroup.quaternion));
            camera.lookAt(lookAtPos);

            // --- Env (Terrain Follow) ---
            ground.position.x = carGroup.position.x;
            ground.position.z = carGroup.position.z;
            // 지형 높이를 차보다 살짝 낮게 유지하여 절벽처럼 보이지 않게 함
            ground.position.y = carGroup.position.y - 3; 

            const z = carGroup.position.z;
            // +Z 이동이 아니므로 거리 계산 필요. 트랙은 여전히 -Z로 뻗어있나?
            // generateTrack: cz -= 100. 트랙은 World -Z 방향.
            // 플레이어는 World -Z 방향으로 가야 함.
            // StartTangent: (0,0,-1). 
            // Car lookAt Target: (0,0,-10). -> +Z축이 (0,0,-1)을 향함? 
            // Three.js LookAt: +Z axis faces target? NO.
            // **중요 수정**: Three.js의 lookAt은 +Z축이 타겟을 향하도록 돌리는게 맞음 (Mesh기준).
            // 그래서 차의 +Z가 World -Z(트랙진행방향)을 향하게 됨.
            // 따라서 translateZ(speed) 하면 World -Z 방향으로 이동.
            // 트랙 포인트들도 World -Z 방향.
            // 모든 로직 일치함.

            if(z < stageInfo[1].z && currentStage !== 3) {
                currentStage = 3; scene.background=skyColorMountain; scene.fog.color=skyColorMountain;
                elMsg.innerText="STAGE 3"; elMsg.style.display='block'; setTimeout(()=>elMsg.style.display='none',2000);
            } else if(z < stageInfo[0].z && currentStage === 1) {
                currentStage = 2; 
                elMsg.innerText="STAGE 2"; elMsg.style.display='block'; setTimeout(()=>elMsg.style.display='none',2000);
            }

            elSpeed.innerText = Math.floor(Math.abs(carState.speed*60));
            elStage.innerText = currentStage;
            if(!isFinished) elTime.innerText = ((Date.now()-startTime)/1000).toFixed(1);

            if(!isFinished && z < points[points.length-1].z + 50) {
                isFinished = true; 
                elMsg.innerText="FINISH!!"; elMsg.style.display='block';
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
