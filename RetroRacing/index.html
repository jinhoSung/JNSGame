<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Racer: Evolution</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            touch-action: none; /* 게임 중 스크롤 방지 */
            user-select: none;
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        /* --- UI 공통 스타일 --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        /* 메인 메뉴는 중앙 정렬 */
        #main-menu, #result-menu { justify-content: center; }

        /* 상점은 스크롤 가능하게 설정 */
        #shop-menu {
            overflow-y: auto;
            touch-action: pan-y; /* 상점에서는 세로 스크롤 허용 */
            justify-content: flex-start;
            padding-top: 40px;
            padding-bottom: 40px;
        }
        
        .hidden { display: none !important; }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            color: #ff00de;
            text-shadow: 4px 4px 0 #00eaff;
            font-size: 30px;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.5;
        }
        
        .btn {
            background: #fff;
            color: #000;
            border: 4px solid #00eaff;
            padding: 15px 30px;
            font-size: 20px;
            font-family: 'Black Ops One', cursive;
            margin: 10px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px #00eaff;
            transition: 0.2s;
            display: inline-block;
        }
        .btn:active { transform: scale(0.95); background: #00eaff; }
        .btn-red { border-color: #ff0055; color: #ff0055; background: #220000; }
        
        /* --- 상점 스타일 --- */
        .shop-header {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .shop-container {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            max-width: 1000px;
            width: 100%;
            margin-bottom: 40px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .shop-panel {
            background: rgba(255,255,255,0.1);
            border: 2px solid #fff;
            padding: 20px;
            border-radius: 10px;
            flex: 1;
            min-width: 300px;
        }
        .car-card {
            border: 1px solid #555;
            padding: 10px;
            margin-bottom: 10px;
            background: #111;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .car-card.selected { border: 2px solid #00ff00; background: #002200; }
        .car-name { font-size: 16px; color: #fff; margin-bottom: 5px; }
        .car-price { color: #ffff00; font-size: 14px; }
        .stat-row { display: flex; justify-content: space-between; align-items: center; margin: 15px 0; font-size: 16px; }
        .money-display {
            font-size: 24px; color: #ffff00; text-shadow: 2px 2px 0 #000;
        }

        /* --- 인게임 UI --- */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        .hud-top-left { position: absolute; top: 20px; left: 20px; text-align: left; font-size: 20px; text-shadow: 2px 2px 0 #000; }
        .hud-center { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); font-size: 40px; color: #ff0055; display: none; }
        
        #drift-msg {
            position: absolute;
            top: 30%; left: 50%; transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 60px; font-weight: bold; color: #ffcc00; 
            text-shadow: 5px 5px 0 #000, 0 0 20px #ff0000;
            display: none; z-index: 15;
            border: 4px solid #000; padding: 10px 40px; background: rgba(255, 0, 0, 0.6);
        }
        
        /* 동적 메시지 (팝업) */
        .game-msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #fff;
            text-shadow: 0 0 10px #000;
            pointer-events: none;
            z-index: 30;
            animation: pop 0.5s ease-out;
            white-space: nowrap;
        }
        @keyframes pop { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }

        /* 모바일 컨트롤 */
        .touch-controls {
            position: absolute; bottom: 20px; width: 100%; height: 150px;
            z-index: 50; display: none; pointer-events: none;
        }
        .touch-btn {
            pointer-events: auto; position: absolute; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px); touch-action: none;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.5); }
        
        #joystick-area {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 160px;
            background: rgba(0,0,0,0.2); border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.3); pointer-events: auto;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px; margin-top: -30px; margin-left: -30px;
            background: rgba(0, 255, 255, 0.5); border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,255,255,0.5); transform: translate(0px, 0px);
        }
        #btn-gas { bottom: 40px; right: 30px; width: 90px; height: 140px; border: 3px solid #0f0; background: rgba(0,255,0,0.2); }
        #btn-gas::after { content: 'GAS'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; }
        #btn-brake { bottom: 40px; right: 140px; width: 70px; height: 90px; border: 3px solid #f00; background: rgba(255,0,0,0.2); }
        #btn-brake::after { content: 'BRAKE'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 12px; color: #fff; }

        @media (hover: none) and (pointer: coarse) {
            .touch-controls { display: block; }
        }
    </style>
</head>
<body>

    <!-- 메인 메뉴 -->
    <div id="main-menu" class="screen">
        <h1>RETRO RACER<br><span style="font-size:20px; color:#fff">EVOLUTION</span></h1>
        <div class="money-display" id="menu-money" style="margin-bottom: 20px;">CR: 0</div>
        <button class="btn" onclick="startGame()">START RACE</button>
        <button class="btn" onclick="openShop()">GARAGE / SHOP</button>
    </div>

    <!-- 상점 화면 -->
    <div id="shop-menu" class="screen hidden">
        <div class="shop-header">
            <h1>GARAGE</h1>
            <div class="money-display" id="shop-money">CR: 0</div>
        </div>
        
        <!-- 상단 닫기 버튼 추가 -->
        <button class="btn btn-red" style="margin-bottom: 20px;" onclick="closeShop()">EXIT SHOP</button>

        <div class="shop-container">
            <!-- 차량 목록 -->
            <div class="shop-panel">
                <h3>MY CARS & SHOP</h3>
                <div id="car-list"></div>
            </div>
            
            <!-- 업그레이드 -->
            <div class="shop-panel">
                <h3>PERFORMANCE TUNING</h3>
                <div class="stat-row">
                    <span>ENGINE (SPEED)</span>
                    <button class="btn" style="font-size:14px; padding:5px 10px" onclick="buyUpgrade('engine')">UP ($2000)</button>
                </div>
                <div style="color:#aaa; font-size:14px; margin-bottom:20px" id="engine-level">Lv. 1</div>

                <div class="stat-row">
                    <span>TIRES (GRIP)</span>
                    <button class="btn" style="font-size:14px; padding:5px 10px" onclick="buyUpgrade('handling')">UP ($1500)</button>
                </div>
                <div style="color:#aaa; font-size:14px; margin-bottom:20px" id="handling-level">Lv. 1</div>

                <div class="stat-row">
                    <span>BOOST (ACCEL)</span>
                    <button class="btn" style="font-size:14px; padding:5px 10px" onclick="buyUpgrade('accel')">UP ($1000)</button>
                </div>
                <div style="color:#aaa; font-size:14px; margin-bottom:20px" id="accel-level">Lv. 1</div>
            </div>
        </div>
        
        <!-- 하단 닫기 버튼 -->
        <button class="btn btn-red" style="margin-bottom: 40px;" onclick="closeShop()">EXIT SHOP</button>
    </div>

    <!-- 결과 화면 -->
    <div id="result-menu" class="screen hidden">
        <h1 id="result-title">STAGE CLEAR!</h1>
        <div style="font-size:24px; margin-bottom:20px">EARNED: <span id="result-money" style="color:#ffff00">0</span> CR</div>
        <button class="btn" onclick="returnToMenu()">MAIN MENU</button>
        <button class="btn" onclick="nextStage()" id="btn-next-stage">NEXT STAGE</button>
    </div>

    <!-- 인게임 HUD -->
    <div id="hud">
        <div class="hud-top-left">
            STAGE: <span id="hud-stage">1</span><br>
            SPEED: <span id="hud-speed">0</span> km/h<br>
            DIST: <span id="hud-dist">0</span>m<br>
            POS: <span id="hud-pos">0</span>
        </div>
        <div id="drift-msg">KANSEI DRIFT!!</div>
        <div class="hud-center" id="center-msg">GO!</div>
    </div>

    <!-- 모바일 컨트롤 -->
    <div class="touch-controls">
        <div id="joystick-area"><div id="joystick-knob"></div></div>
        <div id="btn-brake" class="touch-btn"></div>
        <div id="btn-gas" class="touch-btn"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- 게임 데이터 및 상수 ---
    const CAR_DB = [
        { id: 'ae86', name: 'PANDA 86', price: 0, color: '#eee', maxSpeed: 13000, accel: 30, handling: 1.0 },
        { id: 'rx7', name: 'ROTARY 7', price: 5000, color: '#ffff00', maxSpeed: 14500, accel: 35, handling: 1.2 },
        { id: 'r32', name: 'GODZILLA', price: 12000, color: '#333333', maxSpeed: 15500, accel: 40, handling: 0.9 },
        { id: 'z30', name: 'DEVIL Z', price: 25000, color: '#000088', maxSpeed: 17000, accel: 45, handling: 0.8 },
        { id: 'f40', name: 'RED STAR', price: 50000, color: '#ff0000', maxSpeed: 19000, accel: 55, handling: 1.3 }
    ];

    const UPGRADE_COST = { engine: 2000, handling: 1500, accel: 1000 };
    const STAGE_CONFIG = [
        { len: 2000, curves: 2, hills: 0, traffic: 0.02 }, // Stage 1
        { len: 3000, curves: 4, hills: 500, traffic: 0.03 }, // Stage 2
        { len: 4000, curves: 6, hills: 1000, traffic: 0.04 }, // Stage 3
        { len: 5000, curves: 8, hills: 1500, traffic: 0.05 }, // Stage 4
        { len: 6000, curves: 10, hills: 2000, traffic: 0.06 } // Stage 5
    ];

    let playerProfile = {
        money: 0,
        ownedCars: ['ae86'],
        currentCarId: 'ae86',
        upgrades: { engine: 0, handling: 0, accel: 0 },
        unlockedStage: 0
    };

    // --- 저장/불러오기 ---
    function saveGame() {
        localStorage.setItem('retroRacerData', JSON.stringify(playerProfile));
        updateUI();
    }
    function loadGame() {
        const data = localStorage.getItem('retroRacerData');
        if (data) {
            playerProfile = JSON.parse(data);
        }
        updateUI();
    }

    // --- 엔진 변수 (전역 선언) ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 3000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);
    const LANES = [-0.67, 0, 0.67];

    let gameState = 'menu'; // menu, shop, play, result
    let currentStage = 0;
    let earnedMoney = 0;
    
    // Physics
    let position = 0;
    let playerX = 0;
    let playerTurn = 0;
    let speed = 0;
    let maxSpeed = 0; 
    let accelRate = 0;
    let handlingRate = 0;
    let score = 0; 
    
    // 물리 및 조작 변수 (전역으로 확실히 선언)
    let driftMode = false;
    let analogSteer = 0;
    const offRoadDecel = 300;
    
    let trackLength = 0;
    let skyOffset = 0;
    let cameraShake = 0;

    let segments = [];
    let cars = [];
    let skids = [];
    let particles = [];
    let checkpointLocs = [];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

    // --- 화면 크기 조정 ---
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    // --- UI 로직 ---
    function updateUI() {
        document.getElementById('menu-money').innerText = `CR: ${playerProfile.money}`;
        document.getElementById('shop-money').innerText = `CR: ${playerProfile.money}`;
        
        // 업그레이드 레벨 표시
        document.getElementById('engine-level').innerText = `Lv. ${playerProfile.upgrades.engine + 1} (+${playerProfile.upgrades.engine * 500} Speed)`;
        document.getElementById('handling-level').innerText = `Lv. ${playerProfile.upgrades.handling + 1} (+${playerProfile.upgrades.handling * 10}% Grip)`;
        document.getElementById('accel-level').innerText = `Lv. ${playerProfile.upgrades.accel + 1} (+${playerProfile.upgrades.accel * 5} Accel)`;

        // 차량 목록 갱신
        const list = document.getElementById('car-list');
        list.innerHTML = '';
        CAR_DB.forEach(car => {
            const isOwned = playerProfile.ownedCars.includes(car.id);
            const isSelected = playerProfile.currentCarId === car.id;
            
            const div = document.createElement('div');
            div.className = `car-card ${isSelected ? 'selected' : ''}`;
            div.innerHTML = `
                <div>
                    <div class="car-name" style="color:${car.color}">${car.name}</div>
                    <div style="font-size:12px; color:#aaa">SPD: ${car.maxSpeed} | ACC: ${car.accel}</div>
                </div>
                <div>
                    ${isSelected ? '<span style="color:#0f0">EQUIPPED</span>' : 
                      isOwned ? '<button class="btn" style="font-size:12px; padding:5px" onclick="equipCar(\''+car.id+'\')">EQUIP</button>' : 
                      '<button class="btn" style="font-size:12px; padding:5px" onclick="buyCar(\''+car.id+'\')">$'+car.price+'</button>'}
                </div>
            `;
            list.appendChild(div);
        });
    }

    function buyCar(id) {
        const car = CAR_DB.find(c => c.id === id);
        if (playerProfile.money >= car.price) {
            playerProfile.money -= car.price;
            playerProfile.ownedCars.push(id);
            playerProfile.currentCarId = id;
            saveGame();
        } else {
            alert("Not enough money!");
        }
    }

    function equipCar(id) {
        playerProfile.currentCarId = id;
        saveGame();
    }

    function buyUpgrade(type) {
        const cost = UPGRADE_COST[type] * (playerProfile.upgrades[type] + 1);
        if (playerProfile.money >= cost) {
            playerProfile.money -= cost;
            playerProfile.upgrades[type]++;
            saveGame();
        } else {
            alert("Not enough money!");
        }
    }

    function openShop() {
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('shop-menu').classList.remove('hidden');
        updateUI();
    }

    function closeShop() {
        document.getElementById('shop-menu').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
    }

    function startGame() {
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('hud').style.display = 'block';
        initStage(currentStage);
    }

    function returnToMenu() {
        document.getElementById('result-menu').classList.add('hidden');
        document.getElementById('hud').style.display = 'none';
        document.getElementById('main-menu').classList.remove('hidden');
        gameState = 'menu';
    }

    function nextStage() {
        document.getElementById('result-menu').classList.add('hidden');
        currentStage++;
        if (currentStage >= STAGE_CONFIG.length) currentStage = 0; // Loop or end
        initStage(currentStage);
    }

    // --- 게임 초기화 ---
    function initStage(stageIdx) {
        const config = STAGE_CONFIG[stageIdx] || STAGE_CONFIG[0];
        const car = CAR_DB.find(c => c.id === playerProfile.currentCarId);

        // 스탯 계산 (기본 + 업그레이드)
        maxSpeed = car.maxSpeed + (playerProfile.upgrades.engine * 500);
        accelRate = car.accel + (playerProfile.upgrades.accel * 5);
        handlingRate = car.handling * (1 + playerProfile.upgrades.handling * 0.1);

        position = 0;
        playerX = 0;
        playerTurn = 0;
        speed = 0;
        skids = [];
        particles = [];
        cars = [];
        earnedMoney = 0;
        cameraShake = 0;
        analogSteer = 0; // 초기화
        score = 0; // 점수 초기화
        
        createRoad(config);
        
        document.getElementById('hud-stage').innerText = stageIdx + 1;
        showMessage(`STAGE ${stageIdx + 1}`, '#00eaff', 2000);
        
        gameState = 'play';
    }

    function createRoad(config) {
        segments = [];
        checkpointLocs = [];
        
        const numSegments = Math.floor(config.len / SEGMENT_LENGTH) * 100; 
        const totalSegments = config.len; 
        
        trackLength = totalSegments * SEGMENT_LENGTH;
        
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;

            // 절차적 생성
            curve = Math.sin(i / 150) * config.curves;
            y = Math.sin(i / 200) * config.hills;

            if (i > totalSegments - 100) { curve = 0; y = 0; } // 피니시 라인 평탄화

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            let feature = null;
            if (i === 20) feature = { type: 'arch', name: 'START', color: '#00ff00' };
            if (i === totalSegments - 20) feature = { type: 'arch', name: 'GOAL', color: '#ff0055' };

            // 트래픽 생성
            if (i > 100 && i < totalSegments - 100 && Math.random() < config.traffic) {
                const laneIdx = Math.floor(Math.random() * 3);
                cars.push({
                    z: i * SEGMENT_LENGTH,
                    lane: laneIdx,
                    offset: LANES[laneIdx],
                    targetOffset: LANES[laneIdx],
                    speed: 3000 + Math.random() * 3000 + (currentStage * 500), // 스테이지별로 트래픽도 빨라짐
                    color: Math.random() > 0.5 ? '#800' : '#008',
                    index: i,
                    changeTimer: Math.random() * 5
                });
            }

            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor },
                feature: feature
            });
        }
        checkpointLocs.push({ pos: totalSegments - 20, name: "GOAL", passed: false });
    }

    // --- 3D Projection & Rendering ---
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) { p.screen.scale = 0; }
        else {
            p.screen.scale = cameraDepth / p.camera.z;
            p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
            p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
            p.screen.w = Math.round(p.screen.scale * roadWidth * width / 2);
        }
    }

    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    // --- 트래픽 차량 그리기 (3D Box Sim) ---
    function drawTrafficCar(ctx, car, segment, width, height) {
        const spriteX = segment.p1.screen.x + (segment.p1.screen.w * car.offset);
        const spriteY = segment.p1.screen.y;
        const carW = segment.p1.screen.w * 0.05; // 작게 축소
        const carH = carW * 0.7;

        ctx.save();
        ctx.translate(spriteX, spriteY);

        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-carW/2, -carH*0.1, carW, carH*0.2); // Shadow
        ctx.fillStyle = car.color; ctx.fillRect(-carW/2, -carH, carW, carH * 0.8); // Body
        ctx.fillStyle = '#111'; ctx.fillRect(-carW/2 - 1, -carH * 0.3, carW + 2, carH * 0.2); // Bumper
        ctx.fillStyle = '#f00'; // Tail Lights
        ctx.fillRect(-carW*0.4, -carH*0.25, carW*0.25, carH*0.1);
        ctx.fillRect(carW*0.15, -carH*0.25, carW*0.25, carH*0.1);
        ctx.fillStyle = '#222'; // Glass
        ctx.beginPath(); ctx.moveTo(-carW*0.4, -carH*0.8); ctx.lineTo(carW*0.4, -carH*0.8);
        ctx.lineTo(carW*0.3, -carH*1.4); ctx.lineTo(-carW*0.3, -carH*1.4); ctx.fill();
        ctx.fillStyle = car.color; ctx.fillRect(-carW*0.32, -carH*1.42, carW*0.64, carH*0.1); // Roof Top
        ctx.fillStyle = '#000'; // Wheels
        ctx.fillRect(-carW*0.55, -carH*0.3, carW*0.15, carH*0.3);
        ctx.fillRect(carW*0.4, -carH*0.3, carW*0.15, carH*0.3);

        ctx.restore();
    }

    function drawArch(ctx, x, y, w, feature) {
        const aw = w * 2.5; const ah = w * 2.0; const pw = w * 0.2;
        ctx.save(); ctx.translate(x, y);
        ctx.fillStyle = '#444'; ctx.fillRect(-aw/2, -ah, pw, ah); ctx.fillRect(aw/2 - pw, -ah, pw, ah);
        ctx.fillStyle = feature.color || '#fff'; ctx.fillRect(-aw/2 - pw, -ah - pw, aw + pw*2, pw*2);
        ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = `bold ${Math.max(10, w * 0.8)}px sans-serif`;
        ctx.fillText(feature.name, 0, -ah);
        ctx.restore();
    }

    function drawBackground(ctx, width, height) {
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#050510'); bgGrad.addColorStop(1, '#202040');
        ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, width, height);
        
        ctx.fillStyle = '#fff';
        for(let i=0; i<30; i++) {
            let sx = (Math.sin(i * 132.1) * width + skyOffset * 0.2) % width; if(sx < 0) sx += width;
            let sy = (Math.cos(i * 53.7) * height/2); if(sy > 0) ctx.fillRect(sx, sy, 2, 2);
        }
        // Mountains
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(0, height);
        for(let i=0; i<=20; i++) {
            const xVal = (i * width/20) - (skyOffset % (width/20));
            const noise = Math.sin(i*45.2)*50 + Math.cos(i*12.5)*30;
            ctx.lineTo(xVal, height/2 + 50 - noise);
        }
        ctx.lineTo(width, height); ctx.fill();
    }

    // --- 메인 렌더링 루프 ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        let shakeX = (cameraShake > 0) ? (Math.random() - 0.5) * cameraShake : 0;
        let shakeY = (cameraShake > 0) ? (Math.random() - 0.5) * cameraShake : 0;
        if(cameraShake > 0) cameraShake *= 0.9; else cameraShake = 0;

        ctx.save();
        ctx.translate(shakeX, shakeY);

        drawBackground(ctx, width, height);

        if (segments.length === 0) { ctx.restore(); return; }

        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height;
        let x = 0;
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);

        // Painter's algorithm을 위한 렌더링 (도로 & 트래픽)
        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n);
            if (currentIdx >= segments.length) break;

            let segment = segments[currentIdx];
            let playerSegIdx = Math.floor((position + 100) / SEGMENT_LENGTH);
            let playerY = 0;
            if(playerSegIdx < segments.length) playerY = segments[playerSegIdx].p1.world.y;
            let camY = CAMERA_HEIGHT + playerY;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH) continue;

            if (segment.p2.screen.y >= maxy) continue;
            
            // 도로 그리기
            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            ctx.fillStyle = '#001100'; ctx.fillRect(0, y2, width, y1 - y2); // Grass

            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, y2, l2 - r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, y2, l2 + r2 * 1.2, y2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, y2, l2 - r2, y2, segment.color.road);

            // 차선
            if ((segment.index / 3) % 2 > 1) {
                const laneW = r1 * 0.02; const laneW2 = r2 * 0.02;
                const laneOffset = 0.333;
                let lx1 = l1 - r1 * laneOffset; let lx2 = l2 - r2 * laneOffset;
                polygon(ctx, lx1 - laneW, y1, lx1 + laneW, y1, lx2 + laneW2, y2, lx2 - laneW2, y2, 'rgba(255,255,255,0.5)');
                let rx1 = l1 + r1 * laneOffset; let rx2 = l2 + r2 * laneOffset;
                polygon(ctx, rx1 - laneW, y1, rx1 + laneW, y1, rx2 + laneW2, y2, rx2 - laneW2, y2, 'rgba(255,255,255,0.5)');
            }

            // 아치 & 트래픽 (이 루프 안에서 그리면 먼것부터 그려짐 - Z버퍼 효과)
            if (segment.feature && segment.feature.type === 'arch') {
                drawArch(ctx, segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.w, segment.feature);
            }
            
            // 트래픽 찾기 (이 세그먼트에 있는 차들)
            for(let c=0; c<cars.length; c++) {
                if(Math.floor(cars[c].z / SEGMENT_LENGTH) === segment.index) {
                    drawTrafficCar(ctx, cars[c], segment, width, height);
                }
            }

            maxy = y2;
        }

        drawSkidMarks();
        draw3DPlayerCar(); // 플레이어 차량은 항상 맨 위
        drawParticles();
        drawSpeedLines(width, height);

        ctx.restore();
    }

    // --- 플레이어 차량 그리기 (3D) ---
    function draw3DPlayerCar() {
        // 현재 선택된 차량 정보 가져오기
        const carInfo = CAR_DB.find(c => c.id === playerProfile.currentCarId);
        const carColor = carInfo ? carInfo.color : '#eee';

        const width = canvas.width;
        const height = canvas.height;
        const bounce = Math.sin(Date.now() / 50) * (speed / 10000) * 3;
        
        // 화면 중앙 고정 + 핸들링에 따른 약간의 오프셋
        const cx = width / 2 + (playerTurn * width * 0.1); 
        const cy = height - 80 * (width/1200) + bounce;
        const scale = width / 400; // 기준 스케일

        window.carScreenX = cx; window.carScreenY = cy; window.carScale = scale;

        const yaw = -playerTurn * 0.5; // 드리프트 각도

        // 차량 모델링 (간소화된 3D 렌더링을 위해 project3D 함수 재사용)
        // 로컬 좌표계
        const w = 35; const h = 24; const l = 75; 
        const ch = 18; const cw = 28; const cl_f = 20; const cl_b = 40; 
        
        // 정점 정의
        const verts = [
            {x:-w, y:0, z:l}, {x:w, y:0, z:l}, {x:w, y:0, z:-l}, {x:-w, y:0, z:-l}, 
            {x:-w, y:-h, z:l}, {x:w, y:-h, z:l}, {x:w, y:-h, z:-l}, {x:-w, y:-h, z:-l}, 
            {x:-cw, y:-h-ch, z:cl_f}, {x:cw, y:-h-ch, z:cl_f}, {x:cw, y:-h-ch, z:-cl_b}, {x:-cw, y:-h-ch, z:-cl_b}
        ];
        
        // 투영 (Project to Screen)
        // 플레이어 차량은 항상 카메라 앞에 고정된 위치에 있으므로 별도 투영 로직
        const pVerts = verts.map(v => {
            // 회전
            let rx = v.x * Math.cos(yaw) - v.z * Math.sin(yaw);
            let rz = v.x * Math.sin(yaw) + v.z * Math.cos(yaw);
            let ry = v.y;
            
            // Pitch (약간 위에서 봄)
            const pitch = 0.2;
            let y2 = ry * Math.cos(pitch) - rz * Math.sin(pitch);
            let z2 = ry * Math.sin(pitch) + rz * Math.cos(pitch);
            
            // Perspective
            const camZ = 500;
            const pz = z2 + camZ;
            const proj = 600 / pz;
            
            return {
                x: cx + rx * proj * scale,
                y: cy + y2 * proj * scale,
                visible: true
            };
        });

        const isFrontFacing = (p1, p2, p3) => (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
        const addFace = (idx, col) => {
            const p = idx.map(i => pVerts[i]);
            if (isFrontFacing(p[0], p[1], p[2])) {
                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.moveTo(p[0].x, p[0].y);
                for (let i = 1; i < p.length; i++) ctx.lineTo(p[i].x, p[i].y);
                ctx.closePath(); ctx.fill(); 
                // Wireframe for style
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.stroke();
            }
        };

        // Draw Faces (Order matters for simple painter's algo)
        addFace([4, 5, 1, 0], '#ccc'); // Front Grill
        addFace([3, 0, 4, 7], '#ddd'); // Left
        addFace([1, 2, 6, 5], '#ddd'); // Right
        addFace([7, 6, 2, 3], '#999'); // Back Base
        
        // Back Detail (Taillights & Plate) - Special Drawing
        const backP = [7, 6, 2, 3].map(i => pVerts[i]);
        if (isFrontFacing(backP[0], backP[1], backP[2])) {
             // Custom drawing on the back face area
             const tl = backP[0]; const tr = backP[1]; const br = backP[2]; const bl = backP[3];
             // Simple interpolate
             const lerp = (a, b, t) => ({x: a.x + (b.x-a.x)*t, y: a.y + (b.y-a.y)*t});
             
             // Lights
             ctx.fillStyle = (keys.ArrowDown || keys.Space) ? '#ff0000' : '#880000';
             ctx.shadowBlur = (keys.ArrowDown || keys.Space) ? 15 : 0; ctx.shadowColor='red';
             
             const l1 = lerp(tl, bl, 0.2); const l2 = lerp(tr, br, 0.2);
             const l3 = lerp(tl, bl, 0.5); const l4 = lerp(tr, br, 0.5);
             
             // Left Light
             ctx.beginPath();
             ctx.moveTo(l1.x, l1.y); ctx.lineTo(lerp(l1,l2,0.3).x, lerp(l1,l2,0.3).y);
             ctx.lineTo(lerp(l3,l4,0.3).x, lerp(l3,l4,0.3).y); ctx.lineTo(l3.x, l3.y);
             ctx.fill();
             
             // Right Light
             ctx.beginPath();
             ctx.moveTo(lerp(l1,l2,0.7).x, lerp(l1,l2,0.7).y); ctx.lineTo(l2.x, l2.y);
             ctx.lineTo(l4.x, l4.y); ctx.lineTo(lerp(l3,l4,0.7).x, lerp(l3,l4,0.7).y);
             ctx.fill();
             ctx.shadowBlur = 0;
        }

        addFace([4, 5, 6, 7], carColor); // Top Body/Trunk
        addFace([8, 9, 5, 4], '#222'); // Front Window
        addFace([11, 10, 6, 7], '#222'); // Rear Window
        addFace([8, 11, 7, 4], '#222'); // Left Window
        addFace([5, 6, 10, 9], '#222'); // Right Window
        addFace([8, 9, 10, 11], carColor); // Roof

        // Wheels (Simple cylinders)
        // ... (생략 - 간소화를 위해 차체만 렌더링하거나 검은 박스로 대체 가능하지만 퀄리티 유지)
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const carOffset = playerTurn * (width * 0.12);
        const centerX = (width / 2) + carOffset;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }
            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    function drawParticles() {
        ctx.save();
        for(let i=0; i<particles.length; i++) {
            const p = particles[i];
            p.life -= 0.03; p.x += p.vx; p.y += p.vy; p.size += 0.5;
            if(p.life <= 0) { particles.splice(i, 1); i--; continue; }
            ctx.globalAlpha = p.life * 0.3; ctx.fillStyle = '#eee';
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }

    function drawSpeedLines(width, height) {
        if (speed < 8000) return;
        ctx.strokeStyle = `rgba(255, 255, 255, ${ (speed-8000)/8000 * 0.5 })`;
        ctx.lineWidth = 2;
        const cx = width / 2; const cy = height / 2;
        ctx.beginPath();
        for(let i=0; i<10; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * width/2 + 100;
            const len = Math.random() * 100 + 50;
            const x = cx + Math.cos(angle) * dist;
            const y = cy + Math.sin(angle) * dist;
            ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(angle)*len, y + Math.sin(angle)*len);
        }
        ctx.stroke();
    }

    function showMessage(text, color='#fff', duration=2000) {
        const msg = document.createElement('div');
        msg.className = 'game-msg';
        msg.innerText = text;
        msg.style.color = color;
        document.body.appendChild(msg);
        setTimeout(() => { if(msg.parentNode) msg.remove(); }, duration);
    }

    // --- 게임 루프 & 업데이트 ---
    function update(dt) {
        if (gameState !== 'play') return;

        position = (position + speed * dt);
        skyOffset -= playerTurn * dt * 300; 

        // 트래픽 업데이트
        for(let i=0; i<cars.length; i++) {
            const car = cars[i];
            car.z += car.speed * dt;
            
            // 차선 변경 AI
            car.changeTimer -= dt;
            if (car.changeTimer <= 0) {
                car.changeTimer = Math.random() * 5 + 3;
                if (Math.random() > 0.5) {
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    const nextLane = car.lane + dir;
                    if (nextLane >= 0 && nextLane <= 2) {
                        car.lane = nextLane;
                        car.targetOffset = LANES[nextLane];
                    }
                }
            }
            if (car.offset < car.targetOffset) car.offset += dt * 0.5;
            if (car.offset > car.targetOffset) car.offset -= dt * 0.5;
        }

        const currentSegIndex = Math.floor((position + 100) / SEGMENT_LENGTH);
        
        // 충돌 체크 (정밀)
        for(let i=0; i<cars.length; i++) {
            const car = cars[i];
            if (car.z > position && car.z < position + 200) { // Z축 근접
                if (Math.abs(playerX - car.offset) < 0.15) { // X축 충돌 (차폭)
                    if (speed > 5000) {
                        speed *= 0.5; cameraShake = 30;
                        showMessage("CRASH!", "#f00", 500);
                        playerX -= (car.offset - playerX) * 0.8; // 튕겨나감
                    }
                }
            }
        }

        // 체크포인트
        checkpointLocs.forEach(cp => {
            if (!cp.passed && currentSegIndex >= cp.pos) {
                cp.passed = true;
                if (cp.name === "GOAL") levelComplete();
                else {
                    showMessage("CHECKPOINT", "#0f0", 1000);
                    score += 1000;
                }
            }
        });

        // 입력 및 물리
        const accelInput = keys.ArrowUp;
        const brakeInput = keys.ArrowDown || keys.Space || keys.ShiftLeft;
        let turnInput = keys.ArrowLeft ? -1 : (keys.ArrowRight ? 1 : analogSteer);

        if (accelInput) speed += accelRate;
        else if (brakeInput) speed -= 80;
        else speed -= 15;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        // 드리프트 & 핸들링
        const isTurning = Math.abs(turnInput) > 0.1;
        driftMode = brakeInput && isTurning && speed > 5000;
        
        if(driftMode) {
            speed -= 10;
            if(Math.random()>0.5) skids.push({x: (Math.random()-0.5)*40 - playerTurn*120, y:0, offsetY:0, life:1, size:5});
            score += 10; // 드리프트 점수
            document.getElementById('drift-msg').style.display = 'block';
        } else {
            document.getElementById('drift-msg').style.display = 'none';
        }

        let targetTurn = turnInput * (driftMode ? 1.5 : handlingRate);
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * 4.0;

        if(speed > 0) {
            playerX += (speed/maxSpeed) * 0.07 * playerTurn;
            // 원심력
            const pSeg = segments[Math.floor((position+100)/SEGMENT_LENGTH)%segments.length];
            if(pSeg) playerX -= (pSeg.curve * 0.0002) * (speed/maxSpeed);
        }

        // Offroad penalty
        if((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        // HUD update
        document.getElementById('hud-speed').innerText = Math.floor(speed/100);
        document.getElementById('hud-dist').innerText = Math.floor(position/1000);
        document.getElementById('hud-pos').innerText = Math.floor(score);
    }

    function levelComplete() {
        gameState = 'result';
        earnedMoney = Math.floor(score / 10);
        playerProfile.money += earnedMoney;
        if (currentStage >= playerProfile.unlockedStage) playerProfile.unlockedStage = currentStage + 1;
        saveGame();

        document.getElementById('result-money').innerText = earnedMoney;
        document.getElementById('result-title').innerText = (currentStage === STAGE_CONFIG.length - 1) ? "ALL CLEARED!" : "STAGE CLEAR!";
        document.getElementById('btn-next-stage').style.display = (currentStage === STAGE_CONFIG.length - 1) ? 'none' : 'inline-block';
        
        document.getElementById('hud').style.display = 'none';
        document.getElementById('result-menu').classList.remove('hidden');
    }

    // Input Events
    window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });
    
    // Joystick Logic
    const joyArea = document.getElementById('joystick-area');
    const joyKnob = document.getElementById('joystick-knob');
    let joyTouchId = null; let joyStartX = 0;
    
    joyArea.addEventListener('touchstart', e => { e.preventDefault(); if(joyTouchId!=null) return; let t=e.changedTouches[0]; joyTouchId=t.identifier; joyStartX=t.clientX; joyKnob.style.transition='none'; }, {passive:false});
    joyArea.addEventListener('touchmove', e => { e.preventDefault(); if(joyTouchId==null) return; for(let i=0;i<e.changedTouches.length;i++){ if(e.changedTouches[i].identifier===joyTouchId){ let dx=e.changedTouches[i].clientX-joyStartX; let cx=Math.max(-50,Math.min(50,dx)); joyKnob.style.transform=`translate(${cx}px,0)`; analogSteer=cx/50; break; } } }, {passive:false});
    const joyEnd = () => { joyTouchId=null; joyKnob.style.transition='0.2s'; joyKnob.style.transform='translate(0,0)'; analogSteer=0; };
    joyArea.addEventListener('touchend', joyEnd); joyArea.addEventListener('touchcancel', joyEnd);

    const btnGas = document.getElementById('btn-gas');
    btnGas.addEventListener('touchstart', e=>{e.preventDefault(); keys.ArrowUp=true; btnGas.style.background='rgba(0,255,0,0.5)'});
    btnGas.addEventListener('touchend', e=>{e.preventDefault(); keys.ArrowUp=false; btnGas.style.background='rgba(0,255,0,0.2)'});
    const btnBrake = document.getElementById('btn-brake');
    btnBrake.addEventListener('touchstart', e=>{e.preventDefault(); keys.ArrowDown=true; btnBrake.style.background='rgba(255,0,0,0.5)'});
    btnBrake.addEventListener('touchend', e=>{e.preventDefault(); keys.ArrowDown=false; btnBrake.style.background='rgba(255,0,0,0.2)'});

    // Game Loop
    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        if(gameState === 'play') {
            update(dt);
            render();
        }
        requestAnimationFrame(gameLoop);
    }

    loadGame();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
