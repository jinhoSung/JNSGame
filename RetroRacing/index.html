<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Racer - Code Art Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 80px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 
                5px 5px 0 #000,
                0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 20;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <div id="ui">
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span>
    </div>
    <div id="drift-msg">KANSEI DRIFT!!</div>
    <div id="instructions">
        [â–²] ACCEL | [â–¼] BRAKE + TURN (DRIFT) | [â—€ â–¶] STEER
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const driftMsg = document.getElementById('drift-msg');

    // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- ê²Œì„ ì„¤ì • ìƒìˆ˜ ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 2000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);

    // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     // í•¸ë“¤ë§ ìƒíƒœ (-1 ~ 1)
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;

    let skids = [];
    let segments = [];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // --- ìœ í‹¸ë¦¬í‹° ---
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = (width / 2) + (p.screen.scale * p.camera.x * width / 2);
        p.screen.y = (height / 2) - (p.screen.scale * p.camera.y * height / 2);
        p.screen.w = (p.screen.scale * roadWidth * width / 2);
    }

    // í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    // --- ë„ë¡œ ìƒì„± ---
    function createRoad() {
        segments = [];
        const totalSegments = 2000; 
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;
            // ë§µ ë””ìì¸ (ì½”ë„ˆ ë°°ì¹˜)
            if (i > 300 && i < 700) curve = 2;
            if (i > 800 && i < 1200) curve = -3; 
            if (i > 1300 && i < 1700) curve = 3; 

            // ì–¸ë• (Slight Hills)
            y = Math.sin(i / 30) * 1000;

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor }
            });
        }
    }

    // --- ë Œë”ë§ ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // 1. ë°°ê²½
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#000022');
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#fffc';
        ctx.beginPath(); ctx.arc(width*0.8, 100, 40, 0, Math.PI*2); ctx.fill();

        // 2. ë„ë¡œ ê·¸ë¦¬ê¸°
        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 

        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n) % segments.length;
            let segment = segments[currentIdx];
            let loopOffset = (segment.index < baseSegment.index) ? segments.length * SEGMENT_LENGTH : 0;
            
            let camY = CAMERA_HEIGHT + segments[Math.floor((position+100)/SEGMENT_LENGTH)%segments.length].p1.world.y;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH || segment.p2.screen.y > maxy - 0.5 || segment.p2.screen.y >= segment.p1.screen.y) continue;

            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            // [ìˆ˜ì •] ë„ë¡œ ê¹¨ì§ ë°©ì§€: ìœ—ë³€(y2)ì„ 1í”½ì…€ ì˜¬ë ¤ì„œ(ë¹¼ì„œ) ê²¹ì¹˜ê²Œ ë§Œë“¦
            let renderY2 = y2 - 1;

            ctx.fillStyle = '#001100';
            ctx.fillRect(0, renderY2, width, y1 - renderY2); // ë•…ë„ ê²¹ì¹˜ê²Œ

            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, renderY2, l2 - r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, renderY2, l2 + r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, renderY2, l2 - r2, renderY2, segment.color.road);

            maxy = y2; // í´ë¦¬í•‘ì€ ì›ë˜ ì¢Œí‘œ ê¸°ì¤€
        }

        drawSkidMarks();
        drawCarSprite(); 
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }

            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    // ==========================================
    //  ğŸ ìë™ì°¨ ê·¸ë¦¬ê¸° (ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜) ğŸ
    // ==========================================
    
    function drawCarSprite() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 1200; 
        
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        
        const cx = width / 2;
        const cy = height - 120 * scale + bounce;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        
        // íšŒì „ëŸ‰ ê³„ì‚°
        const turnAngle = playerTurn * (driftMode ? 1.5 : 0.8);

        drawAE86_Dynamic(ctx, turnAngle);

        ctx.restore();
    }

    function drawAE86_Dynamic(ctx, turn) {
        const dir = turn < 0 ? -1 : 1;
        const absTurn = Math.abs(turn);

        ctx.save();
        ctx.scale(dir, 1);

        // ì°¨ì²´ ê¸°ìš¸ê¸°
        ctx.rotate(absTurn * 0.1);

        const rearWidth = 90 - (absTurn * 30);
        const sideWidth = absTurn * 120;
        
        // ê·¸ë¦¼ì
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); 
        ctx.ellipse(sideWidth/2, 90, 130 + sideWidth/2, 15, 0, 0, Math.PI*2); 
        ctx.fill();

        // 1. ì˜†ë©´ (Side Panel)
        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(rearWidth, 50); 
        ctx.lineTo(rearWidth + sideWidth, 60); 
        ctx.lineTo(rearWidth + sideWidth, 90); 
        ctx.lineTo(rearWidth - 5, 90); 
        ctx.fill();

        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(rearWidth, 65);
        ctx.lineTo(rearWidth + sideWidth, 75);
        ctx.lineTo(rearWidth + sideWidth, 85);
        ctx.lineTo(rearWidth, 75);
        ctx.fill();

        ctx.fillStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(rearWidth * 0.8, 0); 
        ctx.lineTo(rearWidth * 0.8 + sideWidth * 0.8, 10); 
        ctx.lineTo(rearWidth + sideWidth, 60); 
        ctx.lineTo(rearWidth, 50); 
        ctx.fill();

        ctx.fillStyle = '#223';
        ctx.beginPath();
        ctx.moveTo(rearWidth * 0.8 + 5, 5); 
        ctx.lineTo(rearWidth * 0.8 + sideWidth * 0.7, 12); 
        ctx.lineTo(rearWidth + sideWidth * 0.8, 55); 
        ctx.lineTo(rearWidth + 5, 45); 
        ctx.fill();

        if (absTurn > 0.1) {
            ctx.fillStyle = '#111';
            const wheelX = rearWidth + sideWidth * 0.8;
            ctx.beginPath(); ctx.ellipse(wheelX, 90, 20, 20, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#555';
            ctx.beginPath(); ctx.ellipse(wheelX, 90, 10, 10, 0, 0, Math.PI*2); ctx.fill();
        }

        // 2. ë’·ë©´ (Rear Panel)
        ctx.fillStyle = '#ddd'; 
        ctx.beginPath();
        ctx.moveTo(-rearWidth, 50); ctx.lineTo(rearWidth, 50);
        ctx.lineTo(rearWidth + 5, 90); ctx.lineTo(-rearWidth - 5, 90);
        ctx.fill();

        ctx.fillStyle = '#222';
        ctx.fillRect(-rearWidth - 5, 80, rearWidth * 2 + 10, 15);

        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(-rearWidth * 0.6, 0); ctx.lineTo(rearWidth * 0.6, 0); 
        ctx.lineTo(rearWidth * 0.8, 50); ctx.lineTo(-rearWidth * 0.8, 50);
        ctx.fill();

        ctx.fillStyle = '#112';
        ctx.beginPath();
        ctx.moveTo(-rearWidth * 0.55, 5); ctx.lineTo(rearWidth * 0.55, 5);
        ctx.lineTo(rearWidth * 0.75, 45); ctx.lineTo(-rearWidth * 0.75, 45);
        ctx.fill();

        ctx.fillStyle = '#111';
        ctx.fillRect(-rearWidth * 0.9, 50, rearWidth * 1.8, 20);

        const lightColor = keys.ArrowDown ? '#ff2222' : '#cc0000';
        ctx.fillStyle = lightColor;
        if(keys.ArrowDown) { ctx.shadowColor='red'; ctx.shadowBlur=20; }
        
        const lampW = rearWidth * 0.5;
        ctx.fillRect(-rearWidth * 0.85, 52, lampW, 16); 
        ctx.fillRect(rearWidth * 0.85 - lampW, 52, lampW, 16);  
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(-15, 55, 30, 12);

        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(rearWidth * 0.7, 90, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(rearWidth * 0.7, 90, 4, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = '#111';
        ctx.fillRect(-rearWidth - 5, 85, 20, 15);
        ctx.fillRect(rearWidth - 15, 85, 20, 15);

        ctx.restore();
    }


    // --- ì—…ë°ì´íŠ¸ ---
    function update(dt) {
        position = (position + speed * dt) % (segments.length * SEGMENT_LENGTH);
        const currentIdx = Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length;
        const playerSegment = segments[currentIdx];

        if (keys.ArrowUp) speed += accel;
        else if (keys.ArrowDown) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        const isTurning = keys.ArrowLeft || keys.ArrowRight;
        driftMode = keys.ArrowDown && isTurning && speed > 5000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 30; 
            if (Math.random() > 0.3) {
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.6;

        if (keys.ArrowLeft) targetTurn = -turnLimit;
        else if (keys.ArrowRight) targetTurn = turnLimit;
        
        // [ìˆ˜ì •] í•¸ë“¤ë§ ë°˜ì‘ ì†ë„ ì¡°ì ˆ (ë” ë¶€ë“œëŸ½ê²Œ)
        // ê¸°ì¡´: driftMode ? 2.0 : 6.0
        const smoothing = driftMode ? 1.5 : 3.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        if (speed > 0) {
            // [ìˆ˜ì •] ì¢Œìš° ì´ë™ ì†ë„ ê°ì†Œ (ë” ë¬µì§í•˜ê²Œ)
            // ê¸°ì¡´: 0.035
            let moveEff = driftMode ? 0.6 : 1.0;
            let moveAmount = (speed / maxSpeed) * moveEff * 0.025; 
            
            if (keys.ArrowLeft) playerX -= moveAmount;
            if (keys.ArrowRight) playerX += moveAmount;

            playerX -= (playerSegment.curve * 0.00015) * (speed / maxSpeed);
        }

        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
    }

    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    createRoad();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
