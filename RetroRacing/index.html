<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Racer - Drift & Mobile Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            color: white;
            font-family: 'Black Ops One', cursive;
            touch-action: none; /* 모바일 터치 확대 방지 */
        }
        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px #ff00de, 3px 3px 0 #000;
            display: none;
            z-index: 20;
            white-space: nowrap;
            animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop { from { transform: translate(-50%, -50%) scale(0); } to { transform: translate(-50%, -50%) scale(1); } }

        #drift-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 60px;
            font-weight: bold;
            color: #ffcc00; 
            text-shadow: 5px 5px 0 #000, 0 0 20px #ff0000;
            display: none;
            pointer-events: none;
            z-index: 15;
            font-style: italic;
            border: 4px solid #000;
            padding: 10px 40px;
            background: rgba(255, 0, 0, 0.6);
        }

        /* 모바일 컨트롤러 */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            z-index: 50;
            display: none; /* JS로 모바일 감지 시 표시 */
            pointer-events: none; /* 버튼만 터치 가능하게 */
        }
        .touch-btn {
            pointer-events: auto;
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(4px);
            touch-action: none;
        }
        .touch-btn:active { background: rgba(255, 255, 255, 0.5); }
        
        /* 조이스틱 영역 */
        #joystick-area {
            position: absolute;
            bottom: 20px; left: 20px;
            width: 160px; height: 160px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            border: 2px dashed rgba(255,255,255,0.3);
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 60px; height: 60px;
            margin-top: -30px; margin-left: -30px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,255,255,0.5);
            transform: translate(0px, 0px);
        }

        /* 페달 */
        #btn-gas {
            bottom: 40px; right: 30px;
            width: 90px; height: 140px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 20px;
            border: 3px solid #0f0;
        }
        #btn-gas::after { content: 'GAS'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; }
        
        #btn-brake {
            bottom: 40px; right: 140px;
            width: 70px; height: 90px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            border: 3px solid #f00;
        }
        #btn-brake::after { content: 'BRAKE'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #fff; font-size: 12px; }

        @media (hover: none) and (pointer: coarse) {
            .touch-controls { display: block; }
            #instructions { display: none; }
        }
    </style>
</head>
<body>

    <div id="ui">
        SPEED: <span id="speedDisplay">0</span> km/h<br>
        SCORE: <span id="scoreDisplay">0</span><br>
        DIST: <span id="distDisplay">0</span>
    </div>
    <div id="center-msg">START!</div>
    <div id="drift-msg">KANSEI DRIFT!!</div>

    <!-- 모바일 컨트롤 -->
    <div class="touch-controls">
        <div id="joystick-area">
            <div id="joystick-knob"></div>
        </div>
        <div id="btn-brake" class="touch-btn"></div>
        <div id="btn-gas" class="touch-btn"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const speedDisplay = document.getElementById('speedDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const distDisplay = document.getElementById('distDisplay');
    const driftMsg = document.getElementById('drift-msg');
    const centerMsg = document.getElementById('center-msg');

    // 모바일 감지
    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if(isMobile) {
        document.querySelector('.touch-controls').style.display = 'block';
    }

    // 캔버스 크기
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- 게임 상수 ---
    const SEGMENT_LENGTH = 200;
    const DRAW_DISTANCE = 300;
    const ROAD_WIDTH = 2000;
    const CAMERA_HEIGHT = 1000;
    const FIELD_OF_VIEW = 100;
    const CAMERA_DEPTH = 1 / Math.tan((FIELD_OF_VIEW / 2) * Math.PI / 180);

    // --- 상태 변수 ---
    let position = 0;       
    let playerX = 0;        
    let playerTurn = 0;     // 현재 핸들링 값
    let speed = 0;
    let maxSpeed = 13000;
    let accel = 30;
    let breaking = 80;
    let decel = 15;
    let offRoadDecel = 300;
    let score = 0;
    let driftMode = false;
    let analogSteer = 0; // 조이스틱 입력값 (-1 ~ 1)

    let segments = [];
    let skids = [];

    // 체크포인트 로직
    const checkpointLocs = [
        { pos: 10, name: "START", passed: false, color: "#00ff00" },
        { pos: 1000, name: "CHECKPOINT", passed: false, color: "#00ffff" },
        { pos: 1980, name: "GOAL", passed: false, color: "#ff0055" }
    ];

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

    // --- 유틸 ---
    function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z <= 0) p.screen.scale = 0;
        else p.screen.scale = cameraDepth / p.camera.z;
        p.screen.x = (width / 2) + (p.screen.scale * p.camera.x * width / 2);
        p.screen.y = (height / 2) - (p.screen.scale * p.camera.y * height / 2);
        p.screen.w = (p.screen.scale * roadWidth * width / 2);
    }

    function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.closePath(); ctx.fill();
    }

    // --- 도로 생성 ---
    function createRoad() {
        segments = [];
        const totalSegments = 2000; 
        for (let i = 0; i < totalSegments; i++) {
            let curve = 0;
            let y = 0;
            // 코너
            if (i > 300 && i < 700) curve = 2;
            if (i > 800 && i < 1200) curve = -3; 
            if (i > 1300 && i < 1700) curve = 3; 

            // 언덕
            y = Math.sin(i / 30) * 1000;

            const floorColor = (Math.floor(i / 3) % 2) ? '#222' : '#252525';
            const rumbleColor = (Math.floor(i / 3) % 2) ? '#fff' : '#c00';
            
            // 구조물(아치) 설정
            let feature = null;
            // 좌표 기반 체크포인트 할당
            checkpointLocs.forEach(cp => {
                if(i >= cp.pos && i < cp.pos + 3) feature = { type: 'arch', name: cp.name, color: cp.color };
            });

            segments.push({
                index: i,
                p1: { world: { x: 0, y: y, z: i * SEGMENT_LENGTH }, camera: {}, screen: {} },
                p2: { world: { x: 0, y: y, z: (i + 1) * SEGMENT_LENGTH }, camera: {}, screen: {} },
                curve: curve,
                color: { road: floorColor, rumble: rumbleColor },
                feature: feature
            });
        }
    }

    function showMessage(text, color='#fff') {
        centerMsg.innerText = text;
        centerMsg.style.color = color;
        centerMsg.style.display = 'block';
        centerMsg.style.animation = 'none';
        centerMsg.offsetHeight; 
        centerMsg.style.animation = 'pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        setTimeout(() => { centerMsg.style.display = 'none'; }, 2000);
    }

    // --- 렌더링 ---
    function render() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // 1. 배경 (그라데이션 & 달)
        const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
        bgGrad.addColorStop(0, '#0a0a2a');
        bgGrad.addColorStop(1, '#000');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = '#fffc';
        ctx.beginPath(); ctx.arc(width*0.8, 100, 40, 0, Math.PI*2); ctx.fill();

        // 2. 도로 투영
        let baseSegment = segments[Math.floor(position / SEGMENT_LENGTH) % segments.length];
        let maxy = height; 
        let dx = -(baseSegment.curve * (position % SEGMENT_LENGTH) / SEGMENT_LENGTH);
        let x = 0; 
        
        for (let n = 0; n < DRAW_DISTANCE; n++) {
            const currentIdx = (baseSegment.index + n) % segments.length;
            let segment = segments[currentIdx];
            let loopOffset = (segment.index < baseSegment.index) ? segments.length * SEGMENT_LENGTH : 0;
            
            // 카메라 Y값 (플레이어가 언덕을 탈 때)
            let playerSegIdx = Math.floor((position+100)/SEGMENT_LENGTH)%segments.length;
            let playerY = segments[playerSegIdx].p1.world.y;
            let camY = CAMERA_HEIGHT + playerY;

            project(segment.p1, (playerX * ROAD_WIDTH) - x, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);
            project(segment.p2, (playerX * ROAD_WIDTH) - x - dx, camY, position - loopOffset, CAMERA_DEPTH, width, height, ROAD_WIDTH);

            x += dx; dx += segment.curve;

            if (segment.p1.camera.z <= CAMERA_DEPTH || segment.p2.screen.y > maxy - 1 || segment.p2.screen.y >= segment.p1.screen.y) {
                continue; 
            }

            let r1 = segment.p1.screen.w; let r2 = segment.p2.screen.w;
            let l1 = segment.p1.screen.x; let l2 = segment.p2.screen.x;
            let y1 = segment.p1.screen.y; let y2 = segment.p2.screen.y;

            let renderY2 = y2 - 1; // 틈새 방지

            ctx.fillStyle = '#001100'; // 잔디색
            ctx.fillRect(0, renderY2, width, y1 - renderY2); 

            // 도로 그리기
            polygon(ctx, l1 - r1 * 1.2, y1, l1 - r1, y1, l2 - r2, renderY2, l2 - r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 + r1 * 1.2, y1, l1 + r1, y1, l2 + r2, renderY2, l2 + r2 * 1.2, renderY2, segment.color.rumble);
            polygon(ctx, l1 - r1, y1, l1 + r1, y1, l2 + r2, renderY2, l2 - r2, renderY2, segment.color.road);

            // 구조물(아치) 그리기
            if (segment.feature && segment.feature.type === 'arch') {
                drawArch(ctx, l2, renderY2, r2, segment.feature);
            }

            maxy = y2; 
        }

        drawSkidMarks();
        drawCarSprite(); 
    }

    function drawArch(ctx, cx, cy, w, feature) {
        // cx: 화면 중앙 X, cy: 화면 바닥 Y, w: 도로 폭의 절반
        const archWidth = w * 2.5; 
        const archHeight = w * 2.0; 
        const pillarW = w * 0.2;

        ctx.save();
        ctx.translate(cx, cy);

        // 기둥
        ctx.fillStyle = '#444';
        ctx.fillRect(-archWidth/2, -archHeight, pillarW, archHeight); // 왼쪽
        ctx.fillRect(archWidth/2 - pillarW, -archHeight, pillarW, archHeight); // 오른쪽

        // 상판
        ctx.fillStyle = feature.color || '#fff';
        ctx.fillRect(-archWidth/2 - pillarW, -archHeight - pillarW, archWidth + pillarW*2, pillarW*2);

        // 텍스트
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `bold ${Math.max(10, w * 0.8)}px sans-serif`;
        ctx.fillText(feature.name, 0, -archHeight);

        ctx.restore();
    }

    function drawSkidMarks() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height - 20;
        
        ctx.save();
        for(let i=0; i<skids.length; i++) {
            const s = skids[i];
            s.life -= 0.05;
            s.y += (speed / maxSpeed) * 15; 
            s.x -= (playerTurn * 5); 
            
            if(s.life <= 0 || s.y > height) { skids.splice(i, 1); i--; continue; }

            ctx.globalAlpha = s.life * 0.4;
            ctx.fillStyle = '#fff'; 
            ctx.beginPath();
            ctx.arc(centerX + s.x, centerY + s.offsetY, s.size * (1 + (s.y/100)), 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    // 자동차 드로잉 업데이트: 86 스타일 상세 구현
    function drawCarSprite() {
        const width = canvas.width;
        const height = canvas.height;
        const scale = width / 1200; 
        
        const bounce = Math.sin(Date.now() / 50) * (speed / maxSpeed) * 3;
        const cx = width / 2;
        const cy = height - 120 * scale + bounce;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        
        // 드리프트 모드일 때 회전 강조
        const turnAngle = playerTurn * (driftMode ? 1.5 : 0.8);
        drawAE86_Enhanced(ctx, turnAngle);
        ctx.restore();
    }

    function drawAE86_Enhanced(ctx, turn) {
        const dir = turn < 0 ? -1 : 1;
        const absTurn = Math.abs(turn);

        // 회전 변환
        ctx.save();
        ctx.scale(dir, 1); // 좌우 반전
        
        // 드리프트 틸트 효과 (차가 기우뚱)
        ctx.rotate(absTurn * 0.1);

        // --- 치수 계산 ---
        // 회전에 따라 뒷면 너비는 줄어들고, 옆면 너비는 늘어남
        const rearW = 90 - (absTurn * 20); 
        const sideW = absTurn * 180; // 옆면이 길게 늘어나도록
        const height = 50;
        const roofH = 35;
        
        // --- 그림자 ---
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        // 그림자는 전체 차폭에 비례
        ctx.ellipse(sideW/2, height + 15, rearW + sideW/2 + 20, 15, 0, 0, Math.PI*2);
        ctx.fill();

        // === 1. 옆면 (Side Panel) - 86 특유의 투톤 & 해치백 라인 ===
        if (absTurn > 0.05) {
            const sideLeft = rearW; // 뒷면의 오른쪽 끝에서 시작
            
            // 차체 (Body) - 팬더(흑백) 도색
            // 흰색 상단
            ctx.fillStyle = '#f4f4f4'; 
            ctx.beginPath();
            ctx.moveTo(sideLeft, 0); 
            ctx.lineTo(sideLeft + sideW, 10); // 앞쪽이 살짝 내려감 (쐐기형)
            ctx.lineTo(sideLeft + sideW, height);
            ctx.lineTo(sideLeft, height);
            ctx.closePath();
            ctx.fill();

            // 검은색 하단 스트립 (몰딩/범퍼 라인)
            ctx.fillStyle = '#111'; 
            ctx.beginPath();
            ctx.moveTo(sideLeft, height - 15);
            ctx.lineTo(sideLeft + sideW, height - 15);
            ctx.lineTo(sideLeft + sideW, height);
            ctx.lineTo(sideLeft, height);
            ctx.fill();

            // 옆 창문 (Cabin) - 패스트백 스타일
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.moveTo(sideLeft, 0); 
            ctx.lineTo(sideLeft + sideW * 0.6, 5); // A필러 쪽으로 기울기
            ctx.lineTo(sideLeft + sideW * 0.5, -roofH); // 지붕 앞쪽
            ctx.lineTo(sideLeft, -roofH); // 지붕 뒤쪽
            ctx.closePath();
            ctx.fill();

            // B필러 디테일 (창문 나눔)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(sideLeft + sideW * 0.25, 0);
            ctx.lineTo(sideLeft + sideW * 0.25, -roofH * 0.9);
            ctx.stroke();

            // 앞바퀴 (사이드 뷰에서 보임)
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(sideLeft + sideW * 0.75, height, 18, 0, Math.PI*2);
            ctx.fill();
            // 휠
            ctx.fillStyle = '#ccc';
            ctx.beginPath();
            ctx.arc(sideLeft + sideW * 0.75, height, 9, 0, Math.PI*2);
            ctx.fill();
        }

        // === 2. 뒷면 (Rear Panel) ===
        // 차체 뒷면
        ctx.fillStyle = '#eee'; // 흰색
        ctx.beginPath();
        ctx.moveTo(-rearW, 0);
        ctx.lineTo(rearW, 0);
        ctx.lineTo(rearW, height);
        ctx.lineTo(-rearW, height);
        ctx.fill();

        // 뒷 범퍼 (검은색)
        ctx.fillStyle = '#111';
        ctx.fillRect(-rearW, height - 20, rearW * 2, 20);

        // 뒷유리 (Cabin Rear)
        ctx.fillStyle = '#333'; // 틴팅된 유리
        ctx.beginPath();
        ctx.moveTo(-rearW * 0.9, 0); // 차체 위
        ctx.lineTo(rearW * 0.9, 0);
        ctx.lineTo(rearW * 0.7, -roofH); // 지붕 (좁아짐)
        ctx.lineTo(-rearW * 0.7, -roofH);
        ctx.fill();
        
        // 지붕 (Roof Top) - 뒷면과 옆면을 연결
        if (absTurn > 0.05) {
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.moveTo(-rearW * 0.7, -roofH); // 뒷유리 왼쪽 위
            ctx.lineTo(rearW * 0.7, -roofH);  // 뒷유리 오른쪽 위
            // 옆면의 지붕 라인과 연결
            ctx.lineTo(rearW + sideW * 0.5, -roofH); 
            ctx.lineTo(rearW, -roofH); // 대각선으로 닫힘 (투시 왜곡)
            ctx.fill();
        }

        // 테일램프 (Rear Lights) - AE86 특유의 가로바
        // 왼쪽
        ctx.fillStyle = '#aa0000'; // 붉은색
        ctx.fillRect(-rearW * 0.9, 5, rearW * 0.8, 15);
        // 오른쪽
        ctx.fillRect(rearW * 0.1, 5, rearW * 0.8, 15);
        
        // 테일램프 디테일 (주황색 방향지시등 / 흰색 후진등)
        ctx.fillStyle = '#ffaa00'; // 주황
        ctx.fillRect(-rearW * 0.9, 15, rearW * 0.25, 5);
        ctx.fillRect(rearW * 0.65, 15, rearW * 0.25, 5);

        // 브레이크 점등 (빛남 효과)
        if (keys.ArrowDown) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20;
            ctx.fillRect(-rearW * 0.9, 5, rearW * 1.8, 15);
            ctx.shadowBlur = 0; // 리셋
        }

        // 번호판
        ctx.fillStyle = '#f1c40f'; // 노란색 번호판
        ctx.fillRect(-15, 25, 30, 12);
        ctx.fillStyle = '#000';
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('86-TRUENO', 0, 34);

        // 머플러 (Muffler)
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.arc(rearW * 0.6, height - 5, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(rearW * 0.6, height - 5, 3, 0, Math.PI*2);
        ctx.fill();
        
        // 뒷바퀴 (Rear Wheels) - 약간 광폭 타이어 느낌
        const wheelY = height;
        // 왼쪽 타이어
        ctx.fillStyle = '#111';
        ctx.fillRect(-rearW - 8, wheelY - 10, 10, 20);
        // 오른쪽 타이어
        ctx.fillRect(rearW - 2, wheelY - 10, 10, 20);

        ctx.restore();
    }

    // --- 업데이트 ---
    function update(dt) {
        position = (position + speed * dt);
        
        // 체크포인트 감지
        const currentSegIndex = Math.floor((position + 100) / SEGMENT_LENGTH);
        checkpointLocs.forEach(cp => {
            if (!cp.passed && currentSegIndex >= cp.pos) {
                cp.passed = true;
                showMessage(cp.name, cp.color);
                score += 5000;
                if(cp.name === "GOAL") {
                    // 완주 로직 (속도 줄이기 등)
                }
            }
        });

        // 입력 처리 (키보드 + 모바일)
        const accelInput = keys.ArrowUp;
        const brakeInput = keys.ArrowDown;
        
        // 조향 입력 (키보드 + 아날로그 조이스틱)
        let turnInput = 0;
        if(keys.ArrowLeft) turnInput = -1;
        else if(keys.ArrowRight) turnInput = 1;
        else turnInput = analogSteer; // 조이스틱 값 사용

        if (accelInput) speed += accel;
        else if (brakeInput) speed -= breaking;
        else speed -= decel;

        speed = Math.max(0, Math.min(speed, maxSpeed));

        // 드리프트 로직 수정: 속도가 일정 이상이고, 회전 중이며, 브레이크를 밟았을 때
        const isTurning = Math.abs(turnInput) > 0.1;
        driftMode = brakeInput && isTurning && speed > 4000;

        if (driftMode) {
            driftMsg.style.display = 'block';
            speed -= 20; // 드리프트 시 감속 감소
            if (Math.random() > 0.3) {
                // 스키드마크 생성
                skids.push({ x: (Math.random()-0.5)*40 - playerTurn*120, y: 0, offsetY: 0, life: 1.0, size: Math.random()*5+5 });
            }
        } else {
            driftMsg.style.display = 'none';
        }

        // 핸들링 물리
        let targetTurn = 0;
        let turnLimit = driftMode ? 1.5 : 0.7; // 드리프트 시 더 많이 꺾임

        // 조이스틱 입력 반영
        if(Math.abs(turnInput) > 0) targetTurn = turnInput * turnLimit;
        
        // 부드러운 핸들링
        const smoothing = driftMode ? 2.0 : 4.0;
        playerTurn = playerTurn + (targetTurn - playerTurn) * dt * smoothing;

        if (speed > 0) {
            let moveAmount = (speed / maxSpeed) * 0.04 * playerTurn;
            playerX += moveAmount;

            // 도로 곡률에 따른 밀림 (원심력)
            const playerSegment = segments[Math.floor((position + 100) / SEGMENT_LENGTH) % segments.length];
            playerX -= (playerSegment.curve * 0.00015) * (speed / maxSpeed);
        }

        // 오프로드 감속
        if ((playerX < -1 || playerX > 1) && speed > offRoadDecel) speed -= offRoadDecel;
        playerX = Math.max(-2, Math.min(2, playerX));

        speedDisplay.innerText = Math.floor(speed / 100);
        score += Math.floor(speed / 1000);
        scoreDisplay.innerText = score;
        distDisplay.innerText = Math.floor(position / 1000) + "m";
    }

    // --- 모바일 컨트롤러 이벤트 ---
    const joystickArea = document.getElementById('joystick-area');
    const joystickKnob = document.getElementById('joystick-knob');
    let joyStartX = 0, joyStartY = 0;

    joystickArea.addEventListener('touchstart', e => {
        const touch = e.touches[0];
        joyStartX = touch.clientX;
        joyStartY = touch.clientY;
        joystickKnob.style.transition = 'none';
    }, {passive: false});

    joystickArea.addEventListener('touchmove', e => {
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - joyStartX;
        const maxDist = 50;
        
        // 클램핑
        const clampedX = Math.max(-maxDist, Math.min(maxDist, deltaX));
        
        joystickKnob.style.transform = `translate(${clampedX}px, 0px)`;
        
        // 조향값 정규화 (-1 ~ 1)
        analogSteer = clampedX / maxDist;
    }, {passive: false});

    joystickArea.addEventListener('touchend', e => {
        joystickKnob.style.transition = '0.2s';
        joystickKnob.style.transform = `translate(0px, 0px)`;
        analogSteer = 0;
    });

    const btnGas = document.getElementById('btn-gas');
    const btnBrake = document.getElementById('btn-brake');

    const handleBtn = (elem, key, isPressed) => {
        if(isPressed) { elem.style.background = 'rgba(255,255,255,0.5)'; keys[key] = true; }
        else { elem.style.background = ''; keys[key] = false; }
    };

    btnGas.addEventListener('touchstart', e => { e.preventDefault(); handleBtn(btnGas, 'ArrowUp', true); });
    btnGas.addEventListener('touchend', e => { e.preventDefault(); handleBtn(btnGas, 'ArrowUp', false); });

    btnBrake.addEventListener('touchstart', e => { e.preventDefault(); handleBtn(btnBrake, 'ArrowDown', true); });
    btnBrake.addEventListener('touchend', e => { e.preventDefault(); handleBtn(btnBrake, 'ArrowDown', false); });


    // --- 메인 루프 ---
    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    // 키보드 리스너
    window.addEventListener('keydown', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = true; });
    window.addEventListener('keyup', e => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });

    createRoad();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
