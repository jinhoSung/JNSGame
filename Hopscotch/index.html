<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì´ë¯¸ì§€ ë•…ë”°ë¨¹ê¸° DX (Canvas)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated; 
        }

        /* ìƒë‹¨ UI ë°” */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            box-sizing: border-box;
            pointer-events: none;
            text-shadow: 2px 2px 4px black;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-weight: bold;
            font-size: 1.1rem;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 10;
            transition: opacity 0.5s;
        }

        .stat-group { display: flex; flex-direction: column; gap: 4px; }
        .stat-item span { color: #ffcc00; }
        
        #right-ui {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .btn-group { display: flex; gap: 8px; }

        .game-btn {
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.6);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .game-btn:hover { background: rgba(255, 255, 255, 0.5); transform: scale(1.05); }
        .icon-btn { font-size: 1.1rem; padding: 6px 10px; }

        /* ë©”ì‹œì§€ ì˜¤ë²„ë ˆì´ (ì•„ì´í…œ íšë“ ë“±) */
        #msg-overlay {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #fff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 60;
        }

        /* ìŠ¹ë¦¬ ì‹œ ìƒë‹¨ ì•ˆë‚´ ë©”ì‹œì§€ */
        #victory-msg {
            display: none;
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 30px;
            color: #00ff00;
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 50;
            border: 2px solid #fff;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* ê²°ê³¼ ëª¨ë‹¬ */
        #result-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #fff;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 0 50px rgba(255,255,255,0.2);
            min-width: 280px;
        }
        #result-title { font-size: 2.5rem; margin-bottom: 10px; color: #ff3333; }
        #result-sub { font-size: 1.2rem; margin-bottom: 25px; color: #ccc; }
        
        #restart-btn {
            padding: 12px 25px;
            font-size: 1.2rem;
            background: #333;
            color: white;
            border: 2px solid white;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 5px;
        }
        #restart-btn:hover { background: #555; transform: scale(1.05); }

        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬ */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            height: 150px;
            display: none; 
            pointer-events: none;
            justify-content: space-between;
            padding: 0 50px;
            box-sizing: border-box;
            z-index: 20;
        }

        #joystick-area {
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            border: 2px solid rgba(255,255,255,0.3);
        }

        #joystick-knob {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        #action-btn {
            width: 110px;
            height: 110px;
            background: rgba(255, 60, 60, 0.6);
            border-radius: 50%;
            border: 5px solid rgba(255, 255, 255, 0.8);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            user-select: none;
            transition: transform 0.1s, background 0.1s;
        }
        #action-btn:active, #action-btn.active {
            transform: scale(0.95);
            background: rgba(255, 60, 60, 0.9);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-group">
            <div class="stat-item">LEVEL <span id="level-val">1</span></div>
            <div class="stat-item" id="area-stat">AREA: <span id="score-val">0.0</span>% / <span id="target-val">80</span>%</div>
            <div class="stat-item">LIFE: <span id="life-val">â¤ï¸â¤ï¸â¤ï¸</span></div>
        </div>

        <div id="right-ui">
            <div class="btn-group">
                <input type="file" id="img-input" accept="image/*" style="display: none;">
                <button class="game-btn" onclick="document.getElementById('img-input').click()">ğŸ“· ì‚¬ì§„</button>
                <button class="game-btn icon-btn" onclick="toggleFullscreen()">â›¶</button>
            </div>
        </div>
    </div>

    <!-- ì•„ì´í…œ/íš¨ê³¼ ë©”ì‹œì§€ -->
    <div id="msg-overlay"></div>

    <!-- ìŠ¹ë¦¬ ë©”ì‹œì§€ -->
    <div id="victory-msg">ì„±ê³µ! í„°ì¹˜í•˜ì—¬ ë‹¤ìŒ ë ˆë²¨ë¡œ â–¶</div>

    <!-- ê²Œì„ì˜¤ë²„ ëª¨ë‹¬ -->
    <div id="result-modal">
        <div id="result-title">GAME OVER</div>
        <div id="result-sub">ë‹¤ì‹œ ë„ì „í•˜ì„¸ìš”!</div>
        <button id="restart-btn" onclick="resetGame(true)">ë‹¤ì‹œí•˜ê¸°</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls">
        <div id="joystick-area"><div id="joystick-knob"></div></div>
        <div id="action-btn">GO!</div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const levelEl = document.getElementById('level-val');
    const scoreEl = document.getElementById('score-val');
    const targetEl = document.getElementById('target-val');
    const lifeEl = document.getElementById('life-val');
    const modal = document.getElementById('result-modal');
    const resultTitle = document.getElementById('result-title');
    const resultSub = document.getElementById('result-sub');
    const victoryMsg = document.getElementById('victory-msg');
    const uiLayer = document.getElementById('ui-layer');
    const imgInput = document.getElementById('img-input');
    const msgOverlay = document.getElementById('msg-overlay');

    // ê²Œì„ ìƒìˆ˜
    const PLAYER_SIZE = 5;
    const BASE_PLAYER_SPEED = 6; 
    const BASE_RETRACT_SPEED = 12;
    const BOSS_BASE_SPEED = 3; 
    const FALLBACK_IMG = "https://images.unsplash.com/photo-1579546929518-9e396f3cc809?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80";
    
    // ì•„ì´í…œ íƒ€ì… ì •ì˜
    const ITEM_TYPES = {
        SPEED: { color: '#FFFF00', icon: 'âš¡', duration: 300, label: "SPEED UP!" }, // 5ì´ˆ (60fps ê¸°ì¤€)
        FREEZE: { color: '#00FFFF', icon: 'â„ï¸', duration: 300, label: "FREEZE!" },
        LIFE: { color: '#FF0000', icon: 'â¤ï¸', duration: 0, label: "LIFE UP!" }
    };

    let gameSpeedMultiplier = 1.0; 
    let currentPlayerSpeed = BASE_PLAYER_SPEED;
    let currentRetractSpeed = BASE_RETRACT_SPEED;

    // ìƒíƒœ ë³€ìˆ˜
    let width, height;
    let level = 1;
    let lives = 3;
    let totalPixels = 0;
    let capturedPixels = 0;
    let gameState = 'playing'; 
    let isInitialized = false;
    let currentTargetPercent = 80;
    let frameCount = 0; 
    
    // ë²„í”„ ìƒíƒœ
    let buffs = {
        speed: 0,
        freeze: 0
    };

    // ë¡œì»¬ ì´ë¯¸ì§€ ê´€ë ¨ ë³€ìˆ˜
    let availableImages = [];
    
    // Grid System
    let grid = null; 
    let landCanvas = document.createElement('canvas'); 
    let landCtx = landCanvas.getContext('2d');
    let bgCanvas = document.createElement('canvas'); 
    let bgCtx = bgCanvas.getContext('2d');
    let bgImage = new Image();

    bgImage.crossOrigin = "Anonymous";
    
    // ì´ˆê¸° ì‹¤í–‰ ì‹œ ì´ë¯¸ì§€ ìŠ¤ìº” ì‹œì‘
    scanLocalImages(1);

    let player = { x: 0, y: 0, color: '#00ff00', state: 'safe' };
    let path = []; 
    let enemies = []; 
    let projectiles = []; 
    let items = []; 
    let input = { left: false, right: false, up: false, down: false, action: false, joyX: 0, joyY: 0 };

    // --- ë™ì  ì´ë¯¸ì§€ ë¡œë”© ë¡œì§ ---
    function scanLocalImages(index) {
        let testImg = new Image();
        testImg.onload = function() {
            availableImages.push(index);
            scanLocalImages(index + 1);
        };
        testImg.onerror = function() {
            console.log(`ì´ë¯¸ì§€ ìŠ¤ìº” ì™„ë£Œ: ì´ ${availableImages.length}ê°œ ë°œê²¬`);
            setRandomBackground();
        };
        testImg.src = `img/${index}.png`;
    }

    function setRandomBackground() {
        if (availableImages.length > 0) {
            let randIdx = Math.floor(Math.random() * availableImages.length);
            let imgNum = availableImages[randIdx];
            bgImage.src = `img/${imgNum}.png`;
        } else {
            if (!bgImage.src || bgImage.src === "") {
                bgImage.src = FALLBACK_IMG;
            } else if (!isInitialized) {
                bgImage.src = FALLBACK_IMG;
            }
        }
    }

    // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
    
    document.addEventListener('click', handleGlobalClick);
    document.addEventListener('touchstart', handleGlobalClick);

    function handleGlobalClick() {
        if (gameState === 'victory_view') {
            nextLevel();
        }
    }

    imgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => { 
                bgImage.src = event.target.result; 
            };
            reader.readAsDataURL(file);
        }
    });

    bgImage.onload = () => {
        if (!isInitialized) { init(); isInitialized = true; }
        else { resize(); }
    };
    bgImage.onerror = () => { 
        console.log("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©");
        if(bgImage.src !== FALLBACK_IMG) {
            bgImage.src = FALLBACK_IMG; 
        }
        if (!isInitialized) { init(); isInitialized = true; }
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    function init() {
        window.addEventListener('resize', resize);
        
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('mobile-controls').style.display = 'flex';
            setupMobileControls();
            
            // [ì†ë„ ì¡°ì ˆ] ëª¨ë°”ì¼ì€ ì „ì²´ ì†ë„ 50%
            gameSpeedMultiplier = 0.5;
        } else {
            gameSpeedMultiplier = 1.0;
        }

        // í”Œë ˆì´ì–´ ì†ë„ ì„¤ì •
        currentPlayerSpeed = BASE_PLAYER_SPEED * gameSpeedMultiplier;
        currentRetractSpeed = BASE_RETRACT_SPEED * gameSpeedMultiplier;

        setupPCControls();
        
        resize();
        requestAnimationFrame(gameLoop);
    }

    function resize() {
        width = window.innerWidth || 320;
        height = window.innerHeight || 240;
        
        canvas.width = width; canvas.height = height;
        landCanvas.width = width; landCanvas.height = height;
        bgCanvas.width = width; bgCanvas.height = height;
        
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            let sRatio = bgImage.width / bgImage.height;
            let dRatio = width / height;
            let rw, rh, rx, ry;
            if (dRatio > sRatio) { rw = width; rh = width/sRatio; rx = 0; ry = (height-rh)/2; }
            else { rh = height; rw = height*sRatio; rx = (width-rw)/2; ry = 0; }
            bgCtx.drawImage(bgImage, rx, ry, rw, rh);
        } else {
            bgCtx.fillStyle = '#3333aa'; bgCtx.fillRect(0,0,width,height);
        }

        if(width > 0 && height > 0) resetGame(false); 
    }

    function resetGame(fullReset = true) {
        if (width === 0 || height === 0) return;

        if (fullReset) {
            level = 1;
            lives = 3;
            if(availableImages.length > 0) setRandomBackground();
        }

        currentTargetPercent = Math.min(80 + (level - 1) * 2, 95);

        gameState = 'playing';
        updateUI();
        
        modal.style.display = 'none';
        victoryMsg.style.display = 'none';
        uiLayer.style.opacity = '1'; 
        
        grid = new Uint8Array(width * height);
        totalPixels = width * height; 
        capturedPixels = 0;
        
        landCtx.fillStyle = '#111111'; 
        landCtx.fillRect(0, 0, width, height);
        
        const border = 40;
        revealArea(0, 0, width, border); 
        revealArea(0, height - border, width, border); 
        revealArea(0, border, border, height - 2*border); 
        revealArea(width - border, border, border, height - 2*border); 

        // 0% ì‹œì‘ ë¡œì§
        let borderPixels = capturedPixels;
        totalPixels = (width * height) - borderPixels; 
        capturedPixels = 0; 
        
        // ë²„í”„ ë° ì¹´ìš´í„° ì´ˆê¸°í™”
        buffs = { speed: 0, freeze: 0 };
        frameCount = 0;
        items = [];
        
        updateUI();

        respawnPlayer();
        initEnemies();
    }

    function nextLevel() {
        level++;
        setRandomBackground();
    }

    function respawnPlayer() {
        player.x = 20; 
        player.y = height / 2; 
        player.state = 'safe'; player.color = '#00ff00';
        path = [];
    }

    function initEnemies() {
        enemies = [];
        projectiles = [];
        
        // [ì†ë„ ì¡°ì ˆ] ë³´ìŠ¤ ì†ë„ì—ë„ ë°°ìœ¨ ì ìš©
        let bossSpeed = (BOSS_BASE_SPEED + (level * 0.5)) * gameSpeedMultiplier;
        
        enemies.push({ 
            type: 'boss', 
            x: width/2, y: height/2, 
            dx: bossSpeed, dy: bossSpeed, 
            radius: 12 + (level), 
            cooldown: 0,
            baseSpeed: bossSpeed,
            laserState: 0, // 0:None, 1:Warning, 2:Firing
            laserTimer: 0,
            laserAngle: 0
        });

        let minionCount = Math.floor((level - 1) * 1.5); 
        for(let i=0; i<minionCount; i++) {
            // [ì†ë„ ì¡°ì ˆ] ë¯¸ë‹ˆì–¸ ìƒì„± ì‹œ ì†ë„
            spawnMinion(width/2, height/2, bossSpeed * 0.8, 'bouncer'); 
        }
    }
    
    function spawnMinion(x, y, speed, subType) {
         let angle = Math.random() * Math.PI * 2;
         enemies.push({
            type: 'minion',
            subType: subType || 'bouncer', // 'bouncer' or 'chaser'
            x: x, y: y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius: 6,
            baseSpeed: speed
        });
    }

    function spawnItem() {
        // ì•ˆì „í•˜ì§€ ì•Šì€ êµ¬ì—­(0)ì— ëœë¤ ìŠ¤í°
        let attempts = 0;
        while(attempts < 50) {
            let rx = Math.random() * width;
            let ry = Math.random() * height;
            // ìº”ë²„ìŠ¤ ë²”ìœ„ ì•ˆì´ê³ , Gridê°€ 0ì¸ ê³³
            if(rx > 20 && rx < width-20 && ry > 20 && ry < height-20) {
                if(!isSafe(rx, ry)) {
                    // ì•„ì´í…œ ì¢…ë¥˜ ëœë¤
                    const keys = Object.keys(ITEM_TYPES);
                    const typeKey = keys[Math.floor(Math.random() * keys.length)];
                    items.push({
                        type: typeKey,
                        x: rx, y: ry,
                        radius: 10,
                        life: 600 // 10ì´ˆ í›„ ì‚¬ë¼ì§
                    });
                    break;
                }
            }
            attempts++;
        }
    }

    function showMsg(text, color) {
        msgOverlay.innerText = text;
        msgOverlay.style.color = color;
        msgOverlay.style.textShadow = `0 0 10px ${color}`;
        msgOverlay.style.opacity = 1;
        setTimeout(() => msgOverlay.style.opacity = 0, 1500);
    }

    function gameLoop() {
        if (gameState === 'playing') {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        frameCount++;
        
        // ì•„ì´í…œ ìŠ¤í° (ì•½ 10ì´ˆë§ˆë‹¤)
        if (frameCount % 600 === 0 && items.length < 3) {
            spawnItem();
        }

        // ë²„í”„ ê°ì†Œ
        if (buffs.speed > 0) buffs.speed--;
        if (buffs.freeze > 0) buffs.freeze--;

        // ì†ë„ ê³„ì‚° (ë²„í”„ ì ìš©)
        let speedMult = buffs.speed > 0 ? 1.5 : 1.0;
        let activePlayerSpeed = currentPlayerSpeed * speedMult;
        let activeRetractSpeed = currentRetractSpeed * speedMult;

        updateEnemies();
        updateProjectiles();
        updateItems();

        if (player.state === 'retracting') {
            let moveDist = activeRetractSpeed; 
            while (moveDist > 0 && path.length > 0) {
                let target = path[path.length - 1];
                let dx = target.x - player.x;
                let dy = target.y - player.y;
                let dist = Math.hypot(dx, dy);

                if (dist <= moveDist) {
                    player.x = target.x; player.y = target.y;
                    moveDist -= dist; path.pop(); 
                } else {
                    player.x += (dx / dist) * moveDist;
                    player.y += (dy / dist) * moveDist;
                    moveDist = 0;
                }
            }
            if (path.length === 0) {
                player.state = 'safe'; player.color = '#00ff00';
            }
            if (checkCollision()) return; 
            return; 
        }

        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1;
        if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joyX !== 0 || input.joyY !== 0) { dx = input.joyX; dy = input.joyY; }
        
        if (dx !== 0 || dy !== 0 && input.joyX === 0) {
            const len = Math.hypot(dx, dy);
            if(len > 1) { dx /= len; dy /= len; }
        }

        let nextX = player.x + dx * activePlayerSpeed;
        let nextY = player.y + dy * activePlayerSpeed;
        
        nextX = Math.max(0, Math.min(width-1, nextX));
        nextY = Math.max(0, Math.min(height-1, nextY));

        const currentlySafe = isSafe(player.x, player.y);
        const nextIsSafe = isSafe(nextX, nextY);

        if (checkCollision()) return;
        checkItemCollection(); // ì•„ì´í…œ íšë“ ì²´í¬

        if (input.action) {
            if (player.state === 'safe' && !nextIsSafe) {
                player.state = 'drawing';
                path = [{x: player.x, y: player.y}]; 
            }
            player.x = nextX; player.y = nextY;

            if (player.state === 'drawing') {
                player.color = '#ff3333';
                const lastPt = path[path.length-1];
                const dist = Math.hypot(player.x - lastPt.x, player.y - lastPt.y);
                if (dist > 4) path.push({x: player.x, y: player.y});

                if (nextIsSafe) {
                    path.push({x: player.x, y: player.y});
                    fillLand(); 
                    player.state = 'safe'; path = [];
                }
            }
        } else {
            if (player.state === 'drawing') {
                player.state = 'retracting'; player.color = '#ffff00'; 
            } else {
                player.state = 'safe'; player.color = '#00ff00';
                if (nextIsSafe) { player.x = nextX; player.y = nextY; }
                else {
                    if (isSafe(nextX, player.y)) player.x = nextX;
                    else if (isSafe(player.x, nextY)) player.y = nextY;
                }
            }
        }
    }

    function updateItems() {
        for (let i = items.length - 1; i >= 0; i--) {
            items[i].life--;
            // ì˜ì—­ ì•ˆì— ê°‡íˆê±°ë‚˜(ì•ˆì „ì§€ëŒ€ë¨) ìˆ˜ëª… ë‹¤í•˜ë©´ ì‚­ì œ
            if (items[i].life <= 0 || isSafe(items[i].x, items[i].y)) {
                items.splice(i, 1);
            }
        }
    }

    function checkItemCollection() {
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            let dist = Math.hypot(player.x - item.x, player.y - item.y);
            // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ (ë°˜ê²½ í•©)
            if (dist < PLAYER_SIZE + item.radius) {
                applyItemEffect(item.type);
                items.splice(i, 1);
            }
        }
    }

    function applyItemEffect(type) {
        const itemData = ITEM_TYPES[type];
        showMsg(itemData.label, itemData.color);
        
        if (type === 'SPEED') {
            buffs.speed = itemData.duration;
        } else if (type === 'FREEZE') {
            buffs.freeze = itemData.duration;
        } else if (type === 'LIFE') {
            lives++;
            updateUI();
        }
    }

    function updateEnemies() {
        enemies.forEach(en => {
            if (buffs.freeze > 0) return;

            // ë³´ìŠ¤ ë ˆì´ì € íŒ¨í„´ ì²˜ë¦¬
            if (en.type === 'boss') {
                if (en.laserState === 1) { // Warning
                    en.laserTimer--;
                    if (en.laserTimer <= 0) {
                        en.laserState = 2; // Fire
                        en.laserTimer = 30; 
                        checkLaserHit(en); 
                    }
                    return; 
                } else if (en.laserState === 2) { // Firing
                    en.laserTimer--;
                    if (en.laserTimer <= 0) {
                        en.laserState = 0; // End
                        en.cooldown = 120; 
                    }
                    checkLaserHit(en); 
                    return; 
                }
            }

            // ì¶”ì ì(chaser) AI
            if (en.subType === 'chaser') {
                let angle = Math.atan2(player.y - en.y, player.x - en.x);
                let chaserSpeed = en.baseSpeed * 0.6;
                en.dx = Math.cos(angle) * chaserSpeed;
                en.dy = Math.sin(angle) * chaserSpeed;
            }

            // ì†ë„ ì œí•œ ë° ìµœì†Œ ì†ë„ ë³´ì¥
            let maxSpeed = en.baseSpeed * 2.5; 
            let currentSpeedSq = en.dx*en.dx + en.dy*en.dy;
            if (currentSpeedSq > maxSpeed*maxSpeed) {
                let scale = maxSpeed / Math.sqrt(currentSpeedSq);
                en.dx *= scale; en.dy *= scale;
            }
            let currentSpeed = Math.sqrt(currentSpeedSq);
            let minSpeed = en.baseSpeed * 0.5;
            if (currentSpeed < minSpeed && currentSpeed > 0.1) {
                let angle = Math.atan2(en.dy, en.dx);
                en.dx = Math.cos(angle) * minSpeed; en.dy = Math.sin(angle) * minSpeed;
            }

            // [ìˆ˜ì •ëœ ì¶©ëŒ ë¡œì§: ë¨¼ì € ì²´í¬í•˜ê³  ì•ˆì „í•  ë•Œë§Œ ì´ë™]
            // Xì¶• ì´ë™ ì‹œë„
            let nextX = en.x + en.dx;
            let checkX = nextX + (en.dx > 0 ? en.radius : -en.radius);
            
            // Xì¶• ë°©í–¥ ë²½ ì¶©ëŒ í™•ì¸ (ì¤‘ì‹¬, ìœ„, ì•„ë˜ 3í¬ì¸íŠ¸ ì²´í¬ë¡œ ë¼ì„ ë°©ì§€)
            if (isSafe(checkX, en.y) || isSafe(checkX, en.y - en.radius*0.7) || isSafe(checkX, en.y + en.radius*0.7)) {
                if (en.subType !== 'chaser') {
                    en.dx *= -1; // ì¼ë°˜ ì ì€ íŠ•ê¸°ê¸°
                } else {
                    en.dx = 0; // ì¶”ì ìëŠ” ë©ˆì¶¤ (ë²½ì— ë¶™ìŒ)
                }
            } else {
                en.x = nextX; // ì•ˆì „í•˜ë©´ ì´ë™
            }

            // Yì¶• ì´ë™ ì‹œë„
            let nextY = en.y + en.dy;
            let checkY = nextY + (en.dy > 0 ? en.radius : -en.radius);
            
            // Yì¶• ë°©í–¥ ë²½ ì¶©ëŒ í™•ì¸
            if (isSafe(en.x, checkY) || isSafe(en.x - en.radius*0.7, checkY) || isSafe(en.x + en.radius*0.7, checkY)) {
                if (en.subType !== 'chaser') {
                    en.dy *= -1;
                } else {
                    en.dy = 0;
                }
            } else {
                en.y = nextY;
            }

            // í™”ë©´ ë°– ì´íƒˆ ë°©ì§€
            if (en.x < en.radius) { en.x = en.radius; if(en.subType !== 'chaser') en.dx = Math.abs(en.dx); }
            else if (en.x > width - en.radius) { en.x = width - en.radius; if(en.subType !== 'chaser') en.dx = -Math.abs(en.dx); }
            
            if (en.y < en.radius) { en.y = en.radius; if(en.subType !== 'chaser') en.dy = Math.abs(en.dy); }
            else if (en.y > height - en.radius) { en.y = height - en.radius; if(en.subType !== 'chaser') en.dy = -Math.abs(en.dy); }

            if (en.type === 'boss' && en.laserState === 0) {
                if (en.cooldown > 0) en.cooldown--;
                else {
                    if (Math.random() < 0.03 + (level * 0.005)) { 
                        bossAttack(en);
                        if(en.laserState === 0) en.cooldown = Math.max(40, 80 - (level * 5)); 
                    }
                }
                if (Math.random() < 0.03) {
                    let angle = Math.random() * Math.PI * 2;
                    let speed = Math.max(Math.hypot(en.dx, en.dy), en.baseSpeed);
                    en.dx = Math.cos(angle) * speed; en.dy = Math.sin(angle) * speed;
                }
                else if (Math.random() < 0.01) { en.dx *= 1.5; en.dy *= 1.5; }
            }
        });
    }

    function bossAttack(boss) {
        let rand = Math.random();
        if (rand < 0.2) {
            shootMinion(boss, 'chaser'); // ì¶”ì ì ì†Œí™˜
        } else if (rand < 0.4) {
            shootSpreadMissile(boss);
        } else if (rand < 0.6) {
            // ë ˆì´ì € ê³µê²© ì‹œì‘
            boss.laserState = 1; // Warning
            boss.laserTimer = 60; // 1ì´ˆ ê²½ê³ 
            // í”Œë ˆì´ì–´ ë°©í–¥ ì¡°ì¤€
            boss.laserAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
        } else {
            shootMissile(boss);
        }
    }

    function checkLaserHit(boss) {
        let maxDist = Math.max(width, height) * 1.5;
        let ex = boss.x + Math.cos(boss.laserAngle) * maxDist;
        let ey = boss.y + Math.sin(boss.laserAngle) * maxDist;
        
        if (!isSafe(player.x, player.y)) {
            let dist = pointToLineDist(player.x, player.y, boss.x, boss.y, ex, ey);
            if (dist < PLAYER_SIZE + 10) { 
                handleDeath("ë ˆì´ì €ì— ë§ì•˜ìŠµë‹ˆë‹¤!"); return;
            }
        }

        if (path.length > 0) {
            for(let p of path) {
                let dist = pointToLineDist(p.x, p.y, boss.x, boss.y, ex, ey);
                if (dist < 10) { 
                    handleDeath("ë ˆì´ì €ì— ì„ ì´ ëŠê²¼ìŠµë‹ˆë‹¤!"); return;
                }
            }
        }
    }

    function pointToLineDist(px, py, x1, y1, x2, y2) {
        let A = px - x1;
        let B = py - y1;
        let C = x2 - x1;
        let D = y2 - y1;

        let dot = A * C + B * D;
        let len_sq = C * C + D * D;
        let param = -1;
        if (len_sq != 0) param = dot / len_sq;

        let xx, yy;

        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }

        let dx = px - xx;
        let dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function shootMinion(boss, type) {
        let angle = Math.atan2(player.y - boss.y, player.x - boss.x);
        // [ì†ë„ ì¡°ì ˆ] ë¯¸ë‹ˆì–¸ ë°œì‚¬ ì†ë„
        let speed = (4 + (level * 0.5)) * gameSpeedMultiplier;
        enemies.push({
            type: 'minion',
            subType: type || 'bouncer',
            x: boss.x, y: boss.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius: 6,
            baseSpeed: speed
        });
    }

    function shootMissile(boss) {
        let angle = Math.atan2(player.y - boss.y, player.x - boss.x);
        // [ì†ë„ ì¡°ì ˆ] ë¯¸ì‚¬ì¼ ë°œì‚¬ ì†ë„
        let speed = (7 + (level * 0.8)) * gameSpeedMultiplier; 
        projectiles.push({
            x: boss.x, y: boss.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius: 4
        });
    }
    
    function shootSpreadMissile(boss) {
        let baseAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
        // [ì†ë„ ì¡°ì ˆ] ì‚°íƒ„ ë¯¸ì‚¬ì¼ ì†ë„
        let speed = (6 + (level * 0.8)) * gameSpeedMultiplier;
        for(let i = -1; i <= 1; i++) {
            let angle = baseAngle + (i * 0.3); 
            projectiles.push({
                x: boss.x, y: boss.y,
                dx: Math.cos(angle) * speed,
                dy: Math.sin(angle) * speed,
                radius: 4
            });
        }
    }

    function updateProjectiles() {
        if (buffs.freeze > 0) return; // í”„ë¦¬ì¦ˆ ì‹œ íˆ¬ì‚¬ì²´ë„ ì •ì§€

        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.dx;
            p.y += p.dy;

            if (isSafe(p.x, p.y)) {
                projectiles.splice(i, 1);
            }
            else if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
                projectiles.splice(i, 1);
            }
        }
    }

    function checkCollision() {
        const isOnSafeGround = isSafe(player.x, player.y);
        let dead = false;

        // ì  ì¶©ëŒ
        enemies.forEach(en => {
            if ((player.state === 'drawing' || player.state === 'retracting') && path.length > 0) {
                for (let p of path) {
                    if (Math.hypot(p.x - en.x, p.y - en.y) < en.radius + 4) {
                        handleDeath("ì„ ì„ ê±´ë“œë ¸ìŠµë‹ˆë‹¤!"); dead = true; return;
                    }
                }
            }
            if (!isOnSafeGround) {
                if (Math.hypot(player.x - en.x, player.y - en.y) < en.radius + PLAYER_SIZE + 2) {
                    handleDeath("ì ì—ê²Œ ì¡í˜”ìŠµë‹ˆë‹¤!"); dead = true; return;
                }
            }
        });
        if(dead) return true;

        // ë¯¸ì‚¬ì¼ ì¶©ëŒ
        projectiles.forEach(p => {
             if ((player.state === 'drawing' || player.state === 'retracting') && path.length > 0) {
                for (let pt of path) {
                    if (Math.hypot(pt.x - p.x, pt.y - p.y) < p.radius + 4) {
                        handleDeath("ë¯¸ì‚¬ì¼ì— ì„ ì´ ëŠê²¼ìŠµë‹ˆë‹¤!"); dead = true; return;
                    }
                }
            }
            if (!isOnSafeGround) {
                if (Math.hypot(player.x - p.x, player.y - p.y) < p.radius + PLAYER_SIZE + 2) {
                    handleDeath("ë¯¸ì‚¬ì¼ì— ë§ì•˜ìŠµë‹ˆë‹¤!"); dead = true; return;
                }
            }
        });
        if(dead) return true;
        
        return false;
    }

    function handleDeath(reason) {
        lives--;
        updateUI();
        canvas.style.opacity = 0.5;
        setTimeout(() => canvas.style.opacity = 1, 100);

        if (lives <= 0) {
            endGame(false, reason);
        } else {
            respawnPlayer();
            projectiles = [];
            // ë³´ìŠ¤ ë ˆì´ì € ìƒíƒœ ì´ˆê¸°í™”
            enemies.forEach(e => { if(e.type === 'boss') e.laserState = 0; });
        }
    }

    function endGame(win, msg) {
        if (win) {
            gameState = 'victory_view';
            revealArea(0, 0, width, height); 
            victoryMsg.style.display = 'block'; 
            uiLayer.style.opacity = '0.5'; 
        } else {
            gameState = 'gameover';
            resultTitle.innerText = "GAME OVER";
            resultSub.innerText = msg;
            modal.style.display = 'block';
        }
    }

    function fillLand() {
        if(path.length > 0) {
             for (let i = 0; i < path.length - 1; i++) {
                drawLineOnGrid(path[i].x, path[i].y, path[i+1].x, path[i+1].y);
            }
        }
        
        let boss = enemies.find(e => e.type === 'boss') || enemies[0];
        let bx = boss ? Math.floor(boss.x) : Math.floor(width/2);
        let by = boss ? Math.floor(boss.y) : Math.floor(height/2);
        
        if (bx < 0) bx = 0; if (bx >= width) bx = width-1;
        if (by < 0) by = 0; if (by >= height) by = height-1;

        let stack = [bx + by * width];
        let visited = new Uint8Array(width * height);
        visited[bx + by * width] = 1;

        while(stack.length > 0) {
            let idx = stack.pop();
            const neighbors = [idx-1, idx+1, idx-width, idx+width];
            for(let nIdx of neighbors) {
                if(nIdx >= 0 && nIdx < grid.length && visited[nIdx] === 0) {
                    if (grid[nIdx] === 0) { 
                        visited[nIdx] = 1;
                        stack.push(nIdx);
                    }
                }
            }
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let en = enemies[i];
            if (en.type === 'boss') continue; 

            let cx = Math.floor(en.x);
            let cy = Math.floor(en.y);
            if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                let idx = cy * width + cx;
                if (visited[idx] === 0) {
                    enemies.splice(i, 1);
                }
            }
        }

        let landImgData = landCtx.getImageData(0, 0, width, height);
        let landData = landImgData.data;
        let bgImgData = bgCtx.getImageData(0, 0, width, height);
        let bgData = bgImgData.data;
        let newPixels = 0;

        for (let i = 0; i < grid.length; i++) {
            if (grid[i] === 0 && visited[i] === 0) {
                grid[i] = 1; 
                newPixels++;
                let idx = i * 4;
                landData[idx] = bgData[idx];     
                landData[idx+1] = bgData[idx+1]; 
                landData[idx+2] = bgData[idx+2]; 
                landData[idx+3] = bgData[idx+3]; 
            }
        }

        if (path.length > 1) {
            for (let i = 0; i < path.length - 1; i++) {
                let p1 = path[i];
                let p2 = path[i+1];
                let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                let steps = Math.ceil(dist); 
                
                for (let s = 0; s <= steps; s++) {
                    let t = s / steps;
                    let lx = p1.x + (p2.x - p1.x) * t;
                    let ly = p1.y + (p2.y - p1.y) * t;
                    
                    let radius = 4; 
                    for(let py = Math.floor(ly)-radius; py <= Math.floor(ly)+radius; py++) {
                        for(let px = Math.floor(lx)-radius; px <= Math.floor(lx)+radius; px++) {
                            if(px >= 0 && px < width && py >= 0 && py < height) {
                                let idx = (py * width + px) * 4;
                                landData[idx] = bgData[idx];
                                landData[idx+1] = bgData[idx+1];
                                landData[idx+2] = bgData[idx+2];
                                landData[idx+3] = bgData[idx+3];
                                
                                let gIdx = py * width + px;
                                if (grid[gIdx] === 0) {
                                    grid[gIdx] = 1;
                                }
                            }
                        }
                    }
                }
            }
        }

        capturedPixels += newPixels;
        landCtx.putImageData(landImgData, 0, 0);
        updateUI();
    }

    function drawLineOnGrid(x0, y0, x1, y1) {
        x0 = Math.floor(x0); y0 = Math.floor(y0);
        x1 = Math.floor(x1); y1 = Math.floor(y1);
        let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while(true) {
            if (x0 >= 0 && x0 < width && y0 >= 0 && y0 < height) grid[y0 * width + x0] = 1; 
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
    }

    function revealArea(x, y, w, h) {
        if (bgCanvas.width === 0) return;
        if (x < 0) x = 0; if (y < 0) y = 0;
        if (x + w > width) w = width - x; if (y + h > height) h = height - y;

        for(let j=y; j<y+h; j++) {
            for(let i=x; i<x+w; i++) {
                let idx = j*width + i;
                if (grid[idx] === 0) { grid[idx] = 1; capturedPixels++; }
            }
        }
        landCtx.drawImage(bgCanvas, x, y, w, h, x, y, w, h);
        updateUI();
    }

    function isSafe(x, y) {
        if (x < 0 || x >= width || y < 0 || y >= height) return true;
        return grid[Math.floor(y) * width + Math.floor(x)] === 1;
    }

    function draw() {
        ctx.drawImage(landCanvas, 0, 0);

        if (gameState === 'victory_view') return;

        // ì•„ì´í…œ ê·¸ë¦¬ê¸°
        items.forEach(item => {
            let info = ITEM_TYPES[item.type];
            ctx.shadowBlur = 10;
            ctx.shadowColor = info.color;
            ctx.fillStyle = info.color;
            ctx.beginPath();
            ctx.arc(item.x, item.y, item.radius, 0, Math.PI*2);
            ctx.fill();
            
            // í…ìŠ¤íŠ¸ ì•„ì´ì½˜
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(info.icon, item.x, item.y);
        });

        if (path.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = player.state === 'retracting' ? '#ffff00' : '#ff3333';
            ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.lineTo(player.x, player.y);
            ctx.stroke();
        }

        enemies.forEach(en => {
            // [Design] Boss Design
            if (en.type === 'boss') {
                // ë ˆì´ì € ë°œì‚¬ ì´í™íŠ¸
                if (en.laserState === 1) { // Warning
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(en.x, en.y);
                    let ex = en.x + Math.cos(en.laserAngle) * 2000;
                    let ey = en.y + Math.sin(en.laserAngle) * 2000;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (en.laserState === 2) { // Fire
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 20; // êµµì€ ë ˆì´ì €
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'red';
                    ctx.beginPath();
                    ctx.moveTo(en.x, en.y);
                    let ex = en.x + Math.cos(en.laserAngle) * 2000;
                    let ey = en.y + Math.sin(en.laserAngle) * 2000;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 8;
                    ctx.strokeStyle = 'white';
                    ctx.stroke();
                }

                // Body Gradient
                let grd = ctx.createRadialGradient(en.x, en.y, en.radius * 0.2, en.x, en.y, en.radius);
                grd.addColorStop(0, "#ff4444");
                grd.addColorStop(1, "#880000");
                ctx.fillStyle = grd;
                
                // Rotating Spikes
                const spikes = 8;
                ctx.beginPath();
                for (let i = 0; i < spikes; i++) {
                    const angle = (Math.PI * 2 / spikes) * i + (Date.now() / 500); 
                    const outerR = en.radius * 1.4;
                    const innerR = en.radius;
                    
                    const sx = en.x + Math.cos(angle) * outerR;
                    const sy = en.y + Math.sin(angle) * outerR;
                    const ix = en.x + Math.cos(angle + Math.PI/spikes) * innerR;
                    const iy = en.y + Math.sin(angle + Math.PI/spikes) * innerR;
                    
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                    ctx.lineTo(ix, iy);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#440000";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Main Body
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius, 0, Math.PI * 2);
                ctx.fill();

                // Big White Eye
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Tracking Pupil
                let angle = Math.atan2(player.y - en.y, player.x - en.x);
                let dist = en.radius * 0.25;
                let px = en.x + Math.cos(angle) * dist;
                let py = en.y + Math.sin(angle) * dist;
                
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(px, py, en.radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye Shine
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(px - en.radius*0.1, py - en.radius*0.1, en.radius * 0.08, 0, Math.PI * 2);
                ctx.fill();

            } else {
                // [Design] Minion Design
                // ì¶”ì ìëŠ” ìƒ‰ìƒì„ ë‹¤ë¥´ê²Œ
                ctx.fillStyle = en.subType === 'chaser' ? "#ff00ff" : "#ff8800";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#884400";
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Eye
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                let angle = Math.atan2(player.y - en.y, player.x - en.x);
                let px = en.x + Math.cos(angle) * (en.radius * 0.15);
                let py = en.y + Math.sin(angle) * (en.radius * 0.15);
                
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(px, py, en.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        ctx.fillStyle = '#ff00ff';
        projectiles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            ctx.fill();
        });

        ctx.fillStyle = player.color;
        // ìŠ¤í”¼ë“œì—… ìƒíƒœë©´ ì”ìƒ íš¨ê³¼
        if (buffs.speed > 0) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'yellow';
        } else {
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'black';
        }
        ctx.beginPath();
        ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function updateUI() {
        // [ë²„ê·¸ìˆ˜ì •] ë¶„ëª¨ê°€ 0ì´ ë˜ëŠ” ê²½ìš° ë°©ì§€
        const percent = totalPixels > 0 ? (capturedPixels / totalPixels * 100).toFixed(2) : "0.00";
        scoreEl.innerText = percent;
        levelEl.innerText = level;
        targetEl.innerText = currentTargetPercent;
        
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "â¤ï¸";
        lifeEl.innerText = hearts.length > 0 ? hearts : "ğŸ’€";

        if (gameState === 'playing' && parseFloat(percent) >= currentTargetPercent) {
            endGame(true, `ë ˆë²¨ ${level} í´ë¦¬ì–´!`);
        }
    }

    function setupPCControls() {
        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft': input.left = true; break;
                case 'ArrowRight': input.right = true; break;
                case 'ArrowUp': input.up = true; break;
                case 'ArrowDown': input.down = true; break;
                case 'Space': input.action = true; break;
            }
        });
        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft': input.left = false; break;
                case 'ArrowRight': input.right = false; break;
                case 'ArrowUp': input.up = false; break;
                case 'ArrowDown': input.down = false; break;
                case 'Space': input.action = false; break;
            }
        });
    }

    function setupMobileControls() {
        const joyArea = document.getElementById('joystick-area');
        const joyKnob = document.getElementById('joystick-knob');
        const actionBtn = document.getElementById('action-btn');
        let startX, startY;

        joyArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joyArea.getBoundingClientRect();
            startX = rect.left + rect.width/2;
            startY = rect.top + rect.height/2;
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive:false});

        joyArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            updateJoystick(touch.clientX, touch.clientY);
        }, {passive:false});

        joyArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            input.joyX = 0; input.joyY = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
        });

        function updateJoystick(cx, cy) {
            const max = 40;
            let dx = cx - startX, dy = cy - startY;
            const dist = Math.min(Math.hypot(dx, dy), max);
            const ang = Math.atan2(dy, dx);
            const mx = Math.cos(ang)*dist, my = Math.sin(ang)*dist;
            joyKnob.style.transform = `translate(calc(-50% + ${mx}px), calc(-50% + ${my}px))`;
            input.joyX = mx/max; input.joyY = my/max;
        }

        actionBtn.addEventListener('touchstart', (e) => { e.preventDefault(); input.action = true; actionBtn.classList.add('active'); }, {passive:false});
        actionBtn.addEventListener('touchend', (e) => { e.preventDefault(); input.action = false; actionBtn.classList.remove('active'); }, {passive:false});
    }
</script>
</body>
</html>
