<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ïù¥ÎØ∏ÏßÄ ÎïÖÎî∞Î®πÍ∏∞ DX (Canvas)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated; 
        }

        /* ÏÉÅÎã® UI Î∞î */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            box-sizing: border-box;
            pointer-events: none;
            text-shadow: 2px 2px 4px black;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-weight: bold;
            font-size: 1.1rem;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 30;
            transition: opacity 0.5s;
        }

        .stat-group { display: flex; flex-direction: column; gap: 4px; }
        .stat-item span { color: #ffcc00; }
        
        #right-ui {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        .btn-group { display: flex; gap: 8px; }

        .game-btn {
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.6);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .game-btn:hover { background: rgba(255, 255, 255, 0.5); transform: scale(1.05); }
        .icon-btn { font-size: 1.1rem; padding: 6px 10px; }

        #msg-overlay {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #fff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 60;
        }

        #victory-msg {
            display: none;
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 30px;
            color: #00ff00;
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 50;
            border: 2px solid #fff;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        #result-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #fff;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 0 50px rgba(255,255,255,0.2);
            min-width: 280px;
        }
        #result-title { font-size: 2.5rem; margin-bottom: 10px; color: #ff3333; }
        #result-sub { font-size: 1.2rem; margin-bottom: 25px; color: #ccc; }
        
        #restart-btn {
            padding: 12px 25px;
            font-size: 1.2rem;
            background: #333;
            color: white;
            border: 2px solid white;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 5px;
        }
        #restart-btn:hover { background: #555; transform: scale(1.05); }

        #mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 20;
            pointer-events: none;
        }

        #zone-left {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        #zone-right {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        #dynamic-joystick {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: none;
            transform: translate(-50%, -50%);
            pointer-events: none;
            backdrop-filter: blur(2px);
        }

        #dynamic-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #action-btn {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 90px;
            height: 90px;
            background: rgba(255, 60, 60, 0.5);
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.4rem;
            color: white;
            pointer-events: none;
            transition: transform 0.1s, background 0.1s;
        }
        #action-btn.active {
            transform: scale(0.9);
            background: rgba(255, 60, 60, 0.9);
            box-shadow: 0 0 20px rgba(255, 60, 60, 0.6);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-group">
            <div class="stat-item">LEVEL <span id="level-val">1</span></div>
            <div class="stat-item" id="area-stat">AREA: <span id="score-val">0.0</span>% / <span id="target-val">80</span>%</div>
            <div class="stat-item">LIFE: <span id="life-val">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        </div>

        <div id="right-ui">
            <div class="btn-group">
                <input type="file" id="img-input" accept="image/*" style="display: none;">
                <button class="game-btn" onclick="document.getElementById('img-input').click()">üì∑ ÏÇ¨ÏßÑ</button>
                <button class="game-btn icon-btn" onclick="toggleFullscreen()">‚õ∂</button>
            </div>
        </div>
    </div>

    <div id="msg-overlay"></div>
    <div id="victory-msg">ÏÑ±Í≥µ! ÌÑ∞ÏπòÌïòÏó¨ Îã§Ïùå Î†àÎ≤®Î°ú ‚ñ∂</div>

    <div id="result-modal">
        <div id="result-title">GAME OVER</div>
        <div id="result-sub">Îã§Ïãú ÎèÑÏ†ÑÌïòÏÑ∏Ïöî!</div>
        <button id="restart-btn" onclick="resetGame(true)">Îã§ÏãúÌïòÍ∏∞</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls">
        <div id="zone-left"></div>
        <div id="zone-right"></div>
        <div id="dynamic-joystick">
            <div id="dynamic-knob"></div>
        </div>
        <div id="action-btn">GO!</div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const levelEl = document.getElementById('level-val');
    const scoreEl = document.getElementById('score-val');
    const targetEl = document.getElementById('target-val');
    const lifeEl = document.getElementById('life-val');
    const modal = document.getElementById('result-modal');
    const resultTitle = document.getElementById('result-title');
    const resultSub = document.getElementById('result-sub');
    const victoryMsg = document.getElementById('victory-msg');
    const uiLayer = document.getElementById('ui-layer');
    const imgInput = document.getElementById('img-input');
    const msgOverlay = document.getElementById('msg-overlay');

    // [Ï§ëÏöî] Í≤åÏûÑ ÏÉÅÏàò (Í∏∞Î≥∏ Ìï¥ÏÉÅÎèÑ 720p Í∏∞Ï§Ä Í∞í)
    // Ïù¥ Í∞íÎì§ÏùÄ resize()ÏóêÏÑú gameScaleÏóê Îî∞Îùº Í≥±Ìï¥Ï†∏ÏÑú Ïã§Ï†ú Í∞íÏúºÎ°ú Î≥ÄÌôòÎê©ÎãàÎã§.
    const BASE_PLAYER_SIZE = 5;
    const BASE_PLAYER_SPEED = 6; 
    const BASE_RETRACT_SPEED = 12;
    const BOSS_BASE_SPEED = 2; // ÎÇúÏù¥ÎèÑ ÏôÑÌôî
    
    const MAX_MINIONS = 6;
    const MINION_LIFETIME = 700;
    const FALLBACK_IMG = "https://images.unsplash.com/photo-1579546929518-9e396f3cc809?ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80";
    
    const ITEM_TYPES = {
        SPEED: { color: '#FFFF00', icon: '‚ö°', duration: 300, label: "SPEED UP!" }, 
        FREEZE: { color: '#00FFFF', icon: '‚ùÑÔ∏è', duration: 300, label: "FREEZE!" },
        LIFE: { color: '#FF0000', icon: '‚ù§Ô∏è', duration: 0, label: "LIFE UP!" }
    };

    // Ïä§ÏºÄÏùºÎßÅ Î≥ÄÏàò
    let gameScale = 1.0;
    
    // Ïã§Ï†ú Ï†ÅÏö©Îê† Î≥ÄÏàòÎì§ (resizeÏóêÏÑú Í≥ÑÏÇ∞Îê®)
    let s_playerSize, s_playerSpeed, s_retractSpeed, s_bossSpeed;

    // ÏÉÅÌÉú Î≥ÄÏàò
    let width, height;
    let level = 1;
    let lives = 3;
    let totalPixels = 0;
    let capturedPixels = 0;
    let gameState = 'playing'; 
    let isInitialized = false;
    let currentTargetPercent = 80;
    let frameCount = 0; 
    
    let buffs = { speed: 0, freeze: 0 };
    let availableImages = [];
    
    let grid = null; 
    let landCanvas = document.createElement('canvas'); 
    let landCtx = landCanvas.getContext('2d');
    let bgCanvas = document.createElement('canvas'); 
    let bgCtx = bgCanvas.getContext('2d');
    let bgImage = new Image();

    bgImage.crossOrigin = "Anonymous";
    scanLocalImages(1);

    let player = { x: 0, y: 0, color: '#00ff00', state: 'safe' };
    let path = []; 
    let enemies = []; 
    let projectiles = []; 
    let items = []; 
    let input = { left: false, right: false, up: false, down: false, action: false, joyX: 0, joyY: 0 };

    function scanLocalImages(index) {
        let testImg = new Image();
        testImg.onload = function() {
            availableImages.push(index);
            scanLocalImages(index + 1);
        };
        testImg.onerror = function() {
            setRandomBackground();
        };
        testImg.src = `img/${index}.png`;
    }

    function setRandomBackground() {
        if (availableImages.length > 0) {
            let randIdx = Math.floor(Math.random() * availableImages.length);
            let imgNum = availableImages[randIdx];
            bgImage.src = `img/${imgNum}.png`;
        } else {
            if (!bgImage.src || bgImage.src === "") {
                bgImage.src = FALLBACK_IMG;
            } else if (!isInitialized) {
                bgImage.src = FALLBACK_IMG;
            }
        }
    }

    document.addEventListener('click', handleGlobalClick);
    document.addEventListener('touchstart', handleGlobalClick);

    function handleGlobalClick() {
        if (gameState === 'victory_view') {
            nextLevel();
        }
    }

    imgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => { bgImage.src = event.target.result; };
            reader.readAsDataURL(file);
        }
    });

    bgImage.onload = () => {
        if (!isInitialized) { init(); isInitialized = true; }
        else { resize(); }
    };
    bgImage.onerror = () => { 
        if(bgImage.src !== FALLBACK_IMG) bgImage.src = FALLBACK_IMG; 
        if (!isInitialized) { init(); isInitialized = true; }
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    }

    function init() {
        window.addEventListener('resize', resize);
        
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('mobile-controls').style.display = 'block';
            setupMobileControls();
        }

        setupPCControls();
        resize();
        requestAnimationFrame(gameLoop);
    }

    function resize() {
        width = window.innerWidth || 320;
        height = window.innerHeight || 240;
        
        // [ÌïµÏã¨] Ìï¥ÏÉÅÎèÑ ÎπÑÎ°Ä Ïä§ÏºÄÏùº Í≥ÑÏÇ∞ (Í∏∞Ï§Ä: ÏßßÏùÄ Î≥Ä 720px)
        // 720pÎ≥¥Îã§ ÌôîÎ©¥Ïù¥ ÏûëÏúºÎ©¥ gameScale < 1, ÌÅ¨Î©¥ gameScale > 1
        gameScale = Math.min(width, height) / 720;
        
        // Ïä§ÏºÄÏùº Ï†ÅÏö© Í∞í Í≥ÑÏÇ∞
        s_playerSize = BASE_PLAYER_SIZE * gameScale;
        s_playerSpeed = BASE_PLAYER_SPEED * gameScale;
        s_retractSpeed = BASE_RETRACT_SPEED * gameScale;
        s_bossSpeed = BOSS_BASE_SPEED * gameScale;

        canvas.width = width; canvas.height = height;
        landCanvas.width = width; landCanvas.height = height;
        bgCanvas.width = width; bgCanvas.height = height;
        
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            let sRatio = bgImage.width / bgImage.height;
            let dRatio = width / height;
            let rw, rh, rx, ry;
            if (dRatio > sRatio) { rw = width; rh = width/sRatio; rx = 0; ry = (height-rh)/2; }
            else { rh = height; rw = height*sRatio; rx = (width-rw)/2; ry = 0; }
            bgCtx.drawImage(bgImage, rx, ry, rw, rh);
        } else {
            bgCtx.fillStyle = '#3333aa'; bgCtx.fillRect(0,0,width,height);
        }

        if(width > 0 && height > 0) resetGame(false); 
    }

    function resetGame(fullReset = true) {
        if (width === 0 || height === 0) return;

        if (fullReset) {
            level = 1;
            lives = 3;
            if(availableImages.length > 0) setRandomBackground();
        }

        currentTargetPercent = Math.min(80 + (level - 1) * 2, 95);

        gameState = 'playing';
        updateUI();
        
        modal.style.display = 'none';
        victoryMsg.style.display = 'none';
        uiLayer.style.opacity = '1'; 
        
        grid = new Uint8Array(width * height);
        totalPixels = width * height; 
        capturedPixels = 0;
        
        landCtx.fillStyle = '#111111'; 
        landCtx.fillRect(0, 0, width, height);
        
        // ÌÖåÎëêÎ¶¨ÎèÑ Ïä§ÏºÄÏùº Ï†ÅÏö©
        const border = 40 * gameScale;
        revealArea(0, 0, width, border); 
        revealArea(0, height - border, width, border); 
        revealArea(0, border, border, height - 2*border); 
        revealArea(width - border, border, border, height - 2*border); 

        let borderPixels = capturedPixels;
        totalPixels = (width * height) - borderPixels; 
        capturedPixels = 0; 
        
        buffs = { speed: 0, freeze: 0 };
        frameCount = 0;
        items = [];
        
        updateUI();
        respawnPlayer();
        initEnemies();
    }

    function nextLevel() {
        level++;
        setRandomBackground();
    }

    function respawnPlayer() {
        // ÏãúÏûë ÏúÑÏπòÎèÑ Ïä§ÏºÄÏùº Ï†ÅÏö©
        player.x = 20 * gameScale; 
        player.y = height / 2; 
        player.state = 'safe'; player.color = '#00ff00';
        path = [];
    }

    function initEnemies() {
        enemies = [];
        projectiles = [];
        
        // Î≥¥Ïä§ ÏÜçÎèÑ Í≥ÑÏÇ∞ (Î†àÎ≤® ÎπÑÎ°Ä + Ïä§ÏºÄÏùº)
        let bossSpeed = s_bossSpeed + (level * 0.4 * gameScale); 
        
        enemies.push({ 
            type: 'boss', 
            x: width/2, y: height/2, 
            dx: bossSpeed, dy: bossSpeed, 
            radius: (12 + (level)) * gameScale, 
            cooldown: 0,
            baseSpeed: bossSpeed,
            laserState: 0,
            laserTimer: 0,
            laserAngle: 0
        });

        let minionCount = Math.floor((level - 1) * 1.5); 
        for(let i=0; i<minionCount; i++) {
            let type = level < 3 ? 'bouncer' : 'bouncer'; 
            spawnMinion(width/2, height/2, bossSpeed * 0.8, type); 
        }
    }
    
    function spawnMinion(x, y, speed, subType) {
         let angle = Math.random() * Math.PI * 2;
         enemies.push({
            type: 'minion',
            subType: subType || 'bouncer',
            x: x, y: y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius: 6 * gameScale,
            baseSpeed: speed,
            isChasing: false,
            stateTimer: Math.random() * 60 + 60,
            life: MINION_LIFETIME + Math.random() * 200 
        });
    }

    function spawnItem() {
        let attempts = 0;
        let margin = 20 * gameScale;
        while(attempts < 50) {
            let rx = Math.random() * width;
            let ry = Math.random() * height;
            if(rx > margin && rx < width-margin && ry > margin && ry < height-margin) {
                if(!isSafe(rx, ry)) {
                    const keys = Object.keys(ITEM_TYPES);
                    const typeKey = keys[Math.floor(Math.random() * keys.length)];
                    items.push({
                        type: typeKey,
                        x: rx, y: ry,
                        radius: 10 * gameScale,
                        life: 600
                    });
                    break;
                }
            }
            attempts++;
        }
    }

    function showMsg(text, color) {
        msgOverlay.innerText = text;
        msgOverlay.style.color = color;
        msgOverlay.style.textShadow = `0 0 10px ${color}`;
        msgOverlay.style.opacity = 1;
        setTimeout(() => msgOverlay.style.opacity = 0, 1500);
    }

    function gameLoop() {
        if (gameState === 'playing') {
            update();
        }
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        frameCount++;
        if (frameCount % 500 === 0 && items.length < 3) spawnItem();

        if (buffs.speed > 0) buffs.speed--;
        if (buffs.freeze > 0) buffs.freeze--;

        let speedMult = buffs.speed > 0 ? 1.5 : 1.0;
        let activePlayerSpeed = s_playerSpeed * speedMult;
        let activeRetractSpeed = s_retractSpeed * speedMult;

        updateEnemies();
        updateProjectiles();
        updateItems();

        if (player.state === 'retracting') {
            let moveDist = activeRetractSpeed; 
            while (moveDist > 0 && path.length > 0) {
                let target = path[path.length - 1];
                let dx = target.x - player.x;
                let dy = target.y - player.y;
                let dist = Math.hypot(dx, dy);

                if (dist <= moveDist) {
                    player.x = target.x; player.y = target.y;
                    moveDist -= dist; path.pop(); 
                } else {
                    player.x += (dx / dist) * moveDist;
                    player.y += (dy / dist) * moveDist;
                    moveDist = 0;
                }
            }
            if (path.length === 0) {
                player.state = 'safe'; player.color = '#00ff00';
            }
            if (checkCollision()) return; 
            return; 
        }

        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1;
        if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joyX !== 0 || input.joyY !== 0) { dx = input.joyX; dy = input.joyY; }
        
        if (dx !== 0 || dy !== 0 && input.joyX === 0) {
            const len = Math.hypot(dx, dy);
            if(len > 1) { dx /= len; dy /= len; }
        }

        let nextX = player.x + dx * activePlayerSpeed;
        let nextY = player.y + dy * activePlayerSpeed;
        
        nextX = Math.max(0, Math.min(width-1, nextX));
        nextY = Math.max(0, Math.min(height-1, nextY));

        const currentlySafe = isSafe(player.x, player.y);
        const nextIsSafe = isSafe(nextX, nextY);

        if (checkCollision()) return;
        checkItemCollection();

        if (input.action) {
            if (player.state === 'safe' && !nextIsSafe) {
                player.state = 'drawing';
                path = [{x: player.x, y: player.y}]; 
            }
            player.x = nextX; player.y = nextY;

            if (player.state === 'drawing') {
                player.color = '#ff3333';
                // ÏÑ† Í∏ãÍ∏∞ Í∞ÑÍ≤©ÎèÑ Ïä§ÏºÄÏùº Í≥†Î†§
                const lastPt = path[path.length-1];
                const dist = Math.hypot(player.x - lastPt.x, player.y - lastPt.y);
                if (dist > 4 * gameScale) path.push({x: player.x, y: player.y});

                if (nextIsSafe) {
                    path.push({x: player.x, y: player.y});
                    fillLand(); 
                    player.state = 'safe'; path = [];
                }
            }
        } else {
            if (player.state === 'drawing') {
                player.state = 'retracting'; player.color = '#ffff00'; 
            } else {
                player.state = 'safe'; player.color = '#00ff00';
                if (nextIsSafe) { player.x = nextX; player.y = nextY; }
                else {
                    if (isSafe(nextX, player.y)) player.x = nextX;
                    else if (isSafe(player.x, nextY)) player.y = nextY;
                }
            }
        }
    }

    function updateItems() {
        for (let i = items.length - 1; i >= 0; i--) {
            items[i].life--;
            if (items[i].life <= 0 || isSafe(items[i].x, items[i].y)) {
                items.splice(i, 1);
            }
        }
    }

    function checkItemCollection() {
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            let dist = Math.hypot(player.x - item.x, player.y - item.y);
            // ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¨Í∏∞ + ÏïÑÏù¥ÌÖú Î∞òÍ≤Ω Ïä§ÏºÄÏùº Í≥†Î†§
            if (dist < s_playerSize + item.radius) {
                applyItemEffect(item.type);
                items.splice(i, 1);
            }
        }
    }

    function applyItemEffect(type) {
        const itemData = ITEM_TYPES[type];
        showMsg(itemData.label, itemData.color);
        if (type === 'SPEED') buffs.speed = itemData.duration;
        else if (type === 'FREEZE') buffs.freeze = itemData.duration;
        else if (type === 'LIFE') { lives++; updateUI(); }
    }

    function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
            let en = enemies[i];
            if (en.type === 'minion') {
                en.life--;
                if (en.life <= 0) {
                    enemies.splice(i, 1);
                    continue;
                }
            }
        }

        enemies.forEach(en => {
            if (buffs.freeze > 0) return;

            if (en.type === 'boss') {
                if (en.laserState === 1) { 
                    en.laserTimer--;
                    if (en.laserTimer <= 0) {
                        en.laserState = 2; 
                        en.laserTimer = 30; 
                        checkLaserHit(en); 
                    }
                    return; 
                } else if (en.laserState === 2) { 
                    en.laserTimer--;
                    if (en.laserTimer <= 0) {
                        en.laserState = 0; 
                        en.cooldown = 120; 
                    }
                    checkLaserHit(en); 
                    return; 
                }
            }

            if (en.subType === 'chaser') {
                if (en.stateTimer > 0) en.stateTimer--;
                
                if (en.stateTimer <= 0) {
                    en.isChasing = !en.isChasing;
                    if (en.isChasing) {
                        en.stateTimer = 60 + (level * 20); 
                    } else {
                        en.stateTimer = Math.max(60, 180 - (level * 10));
                        let randAngle = Math.random() * Math.PI * 2;
                        en.dx = Math.cos(randAngle) * en.baseSpeed;
                        en.dy = Math.sin(randAngle) * en.baseSpeed;
                    }
                }

                if (en.isChasing) {
                    let angle = Math.atan2(player.y - en.y, player.x - en.x);
                    let chaserSpeed = en.baseSpeed * 0.7; 
                    en.dx = Math.cos(angle) * chaserSpeed;
                    en.dy = Math.sin(angle) * chaserSpeed;
                }
            }

            let maxSpeed = en.baseSpeed * 2.5; 
            let currentSpeedSq = en.dx*en.dx + en.dy*en.dy;
            if (currentSpeedSq > maxSpeed*maxSpeed) {
                let scale = maxSpeed / Math.sqrt(currentSpeedSq);
                en.dx *= scale; en.dy *= scale;
            }
            let currentSpeed = Math.sqrt(currentSpeedSq);
            let minSpeed = en.baseSpeed * 0.5;
            if (currentSpeed < minSpeed && currentSpeed > 0.1) {
                let angle = Math.atan2(en.dy, en.dx);
                en.dx = Math.cos(angle) * minSpeed; en.dy = Math.sin(angle) * minSpeed;
            }

            let nextX = en.x + en.dx;
            let checkX = nextX + (en.dx > 0 ? en.radius : -en.radius);
            
            if (isSafe(checkX, en.y) || isSafe(checkX, en.y - en.radius*0.7) || isSafe(checkX, en.y + en.radius*0.7)) {
                if (en.subType !== 'chaser') en.dx *= -1; 
                else en.dx = 0; 
            } else {
                en.x = nextX;
            }

            let nextY = en.y + en.dy;
            let checkY = nextY + (en.dy > 0 ? en.radius : -en.radius);
            
            if (isSafe(en.x, checkY) || isSafe(en.x - en.radius*0.7, checkY) || isSafe(en.x + en.radius*0.7, checkY)) {
                if (en.subType !== 'chaser') en.dy *= -1;
                else en.dy = 0;
            } else {
                en.y = nextY;
            }

            if (en.x < en.radius) { en.x = en.radius; if(en.subType !== 'chaser') en.dx = Math.abs(en.dx); }
            else if (en.x > width - en.radius) { en.x = width - en.radius; if(en.subType !== 'chaser') en.dx = -Math.abs(en.dx); }
            if (en.y < en.radius) { en.y = en.radius; if(en.subType !== 'chaser') en.dy = Math.abs(en.dy); }
            else if (en.y > height - en.radius) { en.y = height - en.radius; if(en.subType !== 'chaser') en.dy = -Math.abs(en.dy); }

            if (en.type === 'boss' && en.laserState === 0) {
                if (en.cooldown > 0) en.cooldown--;
                else {
                    if (Math.random() < 0.03 + (level * 0.005)) { 
                        bossAttack(en);
                        if(en.laserState === 0) en.cooldown = Math.max(40, 80 - (level * 5)); 
                    }
                }
                if (Math.random() < 0.03) {
                    let angle = Math.random() * Math.PI * 2;
                    let speed = Math.max(Math.hypot(en.dx, en.dy), en.baseSpeed);
                    en.dx = Math.cos(angle) * speed; en.dy = Math.sin(angle) * speed;
                }
                else if (Math.random() < 0.01) { en.dx *= 1.5; en.dy *= 1.5; }
            }
        });
    }

    function bossAttack(boss) {
        let rand = Math.random();
        if (rand < 0.3) {
            let type = level >= 3 ? 'chaser' : 'bouncer';
            shootMinion(boss, type);
        } else if (rand < 0.5) shootSpreadMissile(boss);
        else if (rand < 0.6) {
            boss.laserState = 1; 
            boss.laserTimer = 60; 
            boss.laserAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
        } else {
            shootMissile(boss);
        }
    }

    function checkLaserHit(boss) {
        let maxDist = Math.max(width, height) * 1.5;
        let ex = boss.x + Math.cos(boss.laserAngle) * maxDist;
        let ey = boss.y + Math.sin(boss.laserAngle) * maxDist;
        
        if (!isSafe(player.x, player.y)) {
            let dist = pointToLineDist(player.x, player.y, boss.x, boss.y, ex, ey);
            if (dist < s_playerSize + 10 * gameScale) { 
                handleDeath("Î†àÏù¥Ï†ÄÏóê ÎßûÏïòÏäµÎãàÎã§!"); return;
            }
        }

        if (path.length > 0) {
            for(let p of path) {
                let dist = pointToLineDist(p.x, p.y, boss.x, boss.y, ex, ey);
                if (dist < 10 * gameScale) { 
                    handleDeath("Î†àÏù¥Ï†ÄÏóê ÏÑ†Ïù¥ ÎÅäÍ≤ºÏäµÎãàÎã§!"); return;
                }
            }
        }
    }

    function pointToLineDist(px, py, x1, y1, x2, y2) {
        let A = px - x1; let B = py - y1; let C = x2 - x1; let D = y2 - y1;
        let dot = A * C + B * D;
        let len_sq = C * C + D * D;
        let param = -1;
        if (len_sq != 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        let dx = px - xx; let dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function shootMinion(boss, type) {
        let currentMinions = enemies.filter(e => e.type === 'minion').length;
        if (currentMinions >= MAX_MINIONS) return;

        let angle = Math.atan2(player.y - boss.y, player.x - boss.x);
        let speed = (4 + (level * 0.5)) * gameScale; // ÏÜçÎèÑ Ïä§ÏºÄÏùºÎßÅ
        enemies.push({
            type: 'minion', subType: type || 'bouncer',
            x: boss.x, y: boss.y,
            dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
            radius: 6 * gameScale, baseSpeed: speed,
            isChasing: false, stateTimer: 60,
            life: MINION_LIFETIME + Math.random() * 200
        });
    }

    function shootMissile(boss) {
        let angle = Math.atan2(player.y - boss.y, player.x - boss.x);
        let speed = (7 + (level * 0.8)) * gameScale; 
        projectiles.push({
            x: boss.x, y: boss.y,
            dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, radius: 4 * gameScale
        });
    }
    
    function shootSpreadMissile(boss) {
        let baseAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
        let speed = (6 + (level * 0.8)) * gameScale;
        for(let i = -1; i <= 1; i++) {
            let angle = baseAngle + (i * 0.3); 
            projectiles.push({
                x: boss.x, y: boss.y,
                dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, radius: 4 * gameScale
            });
        }
    }

    function updateProjectiles() {
        if (buffs.freeze > 0) return; 
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.dx; p.y += p.dy;
            if (isSafe(p.x, p.y)) projectiles.splice(i, 1);
            else if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) projectiles.splice(i, 1);
        }
    }

    function checkCollision() {
        const isOnSafeGround = isSafe(player.x, player.y);
        let dead = false;
        enemies.forEach(en => {
            if ((player.state === 'drawing' || player.state === 'retracting') && path.length > 0) {
                for (let p of path) {
                    if (Math.hypot(p.x - en.x, p.y - en.y) < en.radius + 4 * gameScale) {
                        handleDeath("ÏÑ†ÏùÑ Í±¥ÎìúÎ†∏ÏäµÎãàÎã§!"); dead = true; return;
                    }
                }
            }
            if (!isOnSafeGround) {
                if (Math.hypot(player.x - en.x, player.y - en.y) < en.radius + s_playerSize + 2 * gameScale) {
                    handleDeath("Ï†ÅÏóêÍ≤å Ïû°ÌòîÏäµÎãàÎã§!"); dead = true; return;
                }
            }
        });
        if(dead) return true;
        projectiles.forEach(p => {
             if ((player.state === 'drawing' || player.state === 'retracting') && path.length > 0) {
                for (let pt of path) {
                    if (Math.hypot(pt.x - p.x, pt.y - p.y) < p.radius + 4 * gameScale) {
                        handleDeath("ÎØ∏ÏÇ¨ÏùºÏóê ÏÑ†Ïù¥ ÎÅäÍ≤ºÏäµÎãàÎã§!"); dead = true; return;
                    }
                }
            }
            if (!isOnSafeGround) {
                if (Math.hypot(player.x - p.x, player.y - p.y) < p.radius + s_playerSize + 2 * gameScale) {
                    handleDeath("ÎØ∏ÏÇ¨ÏùºÏóê ÎßûÏïòÏäµÎãàÎã§!"); dead = true; return;
                }
            }
        });
        if(dead) return true;
        return false;
    }

    function handleDeath(reason) {
        lives--;
        updateUI();
        canvas.style.opacity = 0.5;
        setTimeout(() => canvas.style.opacity = 1, 100);
        if (lives <= 0) {
            endGame(false, reason);
        } else {
            respawnPlayer();
            projectiles = [];
            enemies.forEach(e => { if(e.type === 'boss') e.laserState = 0; });
        }
    }

    function endGame(win, msg) {
        if (win) {
            gameState = 'victory_view';
            revealArea(0, 0, width, height); 
            victoryMsg.style.display = 'block'; 
            uiLayer.style.opacity = '0.5'; 
        } else {
            gameState = 'gameover';
            resultTitle.innerText = "GAME OVER";
            resultSub.innerText = msg;
            modal.style.display = 'block';
        }
    }

    function fillLand() {
        if(path.length > 0) {
             for (let i = 0; i < path.length - 1; i++) {
                drawLineOnGrid(path[i].x, path[i].y, path[i+1].x, path[i+1].y);
            }
        }
        
        let boss = enemies.find(e => e.type === 'boss') || enemies[0];
        let bx = boss ? Math.floor(boss.x) : Math.floor(width/2);
        let by = boss ? Math.floor(boss.y) : Math.floor(height/2);
        if (bx < 0) bx = 0; if (bx >= width) bx = width-1;
        if (by < 0) by = 0; if (by >= height) by = height-1;

        let stack = [bx + by * width];
        let visited = new Uint8Array(width * height);
        visited[bx + by * width] = 1;

        while(stack.length > 0) {
            let idx = stack.pop();
            const neighbors = [idx-1, idx+1, idx-width, idx+width];
            for(let nIdx of neighbors) {
                if(nIdx >= 0 && nIdx < grid.length && visited[nIdx] === 0) {
                    if (grid[nIdx] === 0) { 
                        visited[nIdx] = 1;
                        stack.push(nIdx);
                    }
                }
            }
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let en = enemies[i];
            if (en.type === 'boss') continue; 
            let cx = Math.floor(en.x);
            let cy = Math.floor(en.y);
            if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                let idx = cy * width + cx;
                if (visited[idx] === 0) {
                    enemies.splice(i, 1);
                }
            }
        }

        let landImgData = landCtx.getImageData(0, 0, width, height);
        let landData = landImgData.data;
        let bgImgData = bgCtx.getImageData(0, 0, width, height);
        let bgData = bgImgData.data;
        let newPixels = 0;

        for (let i = 0; i < grid.length; i++) {
            if (grid[i] === 0 && visited[i] === 0) {
                grid[i] = 1; 
                newPixels++;
                let idx = i * 4;
                landData[idx] = bgData[idx];     
                landData[idx+1] = bgData[idx+1]; 
                landData[idx+2] = bgData[idx+2]; 
                landData[idx+3] = bgData[idx+3]; 
            }
        }

        if (path.length > 1) {
            for (let i = 0; i < path.length - 1; i++) {
                let p1 = path[i];
                let p2 = path[i+1];
                let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                let steps = Math.ceil(dist); 
                for (let s = 0; s <= steps; s++) {
                    let t = s / steps;
                    let lx = p1.x + (p2.x - p1.x) * t;
                    let ly = p1.y + (p2.y - p1.y) * t;
                    let radius = 4 * gameScale; // [Ïä§ÏºÄÏùº] ÏÑ† ÎëêÍªò Ï†ÅÏö©
                    for(let py = Math.floor(ly)-radius; py <= Math.floor(ly)+radius; py++) {
                        for(let px = Math.floor(lx)-radius; px <= Math.floor(lx)+radius; px++) {
                            if(px >= 0 && px < width && py >= 0 && py < height) {
                                let idx = (py * width + px) * 4;
                                landData[idx] = bgData[idx];
                                landData[idx+1] = bgData[idx+1];
                                landData[idx+2] = bgData[idx+2];
                                landData[idx+3] = bgData[idx+3];
                                let gIdx = py * width + px;
                                if (grid[gIdx] === 0) grid[gIdx] = 1;
                            }
                        }
                    }
                }
            }
        }

        capturedPixels += newPixels;
        landCtx.putImageData(landImgData, 0, 0);

        for (let i = items.length - 1; i >= 0; i--) {
            if (isSafe(items[i].x, items[i].y)) {
                applyItemEffect(items[i].type);
                items.splice(i, 1);
            }
        }

        updateUI();
    }

    function drawLineOnGrid(x0, y0, x1, y1) {
        x0 = Math.floor(x0); y0 = Math.floor(y0);
        x1 = Math.floor(x1); y1 = Math.floor(y1);
        let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while(true) {
            if (x0 >= 0 && x0 < width && y0 >= 0 && y0 < height) grid[y0 * width + x0] = 1; 
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
    }

    function revealArea(x, y, w, h) {
        if (bgCanvas.width === 0) return;
        if (x < 0) x = 0; if (y < 0) y = 0;
        if (x + w > width) w = width - x; if (y + h > height) h = height - y;
        for(let j=y; j<y+h; j++) {
            for(let i=x; i<x+w; i++) {
                let idx = j*width + i;
                if (grid[idx] === 0) { grid[idx] = 1; capturedPixels++; }
            }
        }
        landCtx.drawImage(bgCanvas, x, y, w, h, x, y, w, h);
        updateUI();
    }

    function isSafe(x, y) {
        if (x < 0 || x >= width || y < 0 || y >= height) return true;
        return grid[Math.floor(y) * width + Math.floor(x)] === 1;
    }

    function draw() {
        ctx.drawImage(landCanvas, 0, 0);
        if (gameState === 'victory_view') return;

        items.forEach(item => {
            let info = ITEM_TYPES[item.type];
            ctx.shadowBlur = 10 * gameScale;
            ctx.shadowColor = info.color;
            ctx.fillStyle = info.color;
            ctx.beginPath();
            ctx.arc(item.x, item.y, item.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'black';
            ctx.font = (12 * gameScale) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(info.icon, item.x, item.y);
        });

        if (path.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = player.state === 'retracting' ? '#ffff00' : '#ff3333';
            ctx.lineWidth = 3 * gameScale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.lineTo(player.x, player.y);
            ctx.stroke();
        }

        enemies.forEach(en => {
            if (en.type === 'boss') {
                if (en.laserState === 1) { 
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.lineWidth = 2 * gameScale;
                    ctx.setLineDash([5 * gameScale, 5 * gameScale]);
                    ctx.beginPath();
                    ctx.moveTo(en.x, en.y);
                    let ex = en.x + Math.cos(en.laserAngle) * 2000;
                    let ey = en.y + Math.sin(en.laserAngle) * 2000;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (en.laserState === 2) { 
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 20 * gameScale; 
                    ctx.shadowBlur = 20 * gameScale;
                    ctx.shadowColor = 'red';
                    ctx.beginPath();
                    ctx.moveTo(en.x, en.y);
                    let ex = en.x + Math.cos(en.laserAngle) * 2000;
                    let ey = en.y + Math.sin(en.laserAngle) * 2000;
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 8 * gameScale;
                    ctx.strokeStyle = 'white';
                    ctx.stroke();
                }

                let grd = ctx.createRadialGradient(en.x, en.y, en.radius * 0.2, en.x, en.y, en.radius);
                grd.addColorStop(0, "#ff4444");
                grd.addColorStop(1, "#880000");
                ctx.fillStyle = grd;
                
                const spikes = 8;
                ctx.beginPath();
                for (let i = 0; i < spikes; i++) {
                    const angle = (Math.PI * 2 / spikes) * i + (Date.now() / 500); 
                    const outerR = en.radius * 1.4;
                    const innerR = en.radius;
                    const sx = en.x + Math.cos(angle) * outerR;
                    const sy = en.y + Math.sin(angle) * outerR;
                    const ix = en.x + Math.cos(angle + Math.PI/spikes) * innerR;
                    const iy = en.y + Math.sin(angle + Math.PI/spikes) * innerR;
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                    ctx.lineTo(ix, iy);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = "#440000";
                ctx.lineWidth = 2 * gameScale;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                let angle = Math.atan2(player.y - en.y, player.x - en.x);
                let dist = en.radius * 0.25;
                let px = en.x + Math.cos(angle) * dist;
                let py = en.y + Math.sin(angle) * dist;
                
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(px, py, en.radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(px - en.radius*0.1, py - en.radius*0.1, en.radius * 0.08, 0, Math.PI * 2);
                ctx.fill();

            } else {
                ctx.globalAlpha = Math.min(1, en.life / 100 + 0.3); 
                ctx.fillStyle = en.subType === 'chaser' ? "#ff00ff" : "#ff8800";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#884400";
                ctx.lineWidth = 1 * gameScale;
                ctx.stroke();
                
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(en.x, en.y, en.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                let angle = Math.atan2(player.y - en.y, player.x - en.x);
                let px = en.x + Math.cos(angle) * (en.radius * 0.15);
                let py = en.y + Math.sin(angle) * (en.radius * 0.15);
                
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(px, py, en.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1.0; 
            }
        });

        ctx.fillStyle = '#ff00ff';
        projectiles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            ctx.fill();
        });

        ctx.fillStyle = player.color;
        if (buffs.speed > 0) {
            ctx.shadowBlur = 15 * gameScale;
            ctx.shadowColor = 'yellow';
        } else {
            ctx.shadowBlur = 10 * gameScale;
            ctx.shadowColor = 'black';
        }
        ctx.beginPath();
        ctx.arc(player.x, player.y, s_playerSize, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function updateUI() {
        const percent = totalPixels > 0 ? (capturedPixels / totalPixels * 100).toFixed(2) : "0.00";
        scoreEl.innerText = percent;
        levelEl.innerText = level;
        targetEl.innerText = currentTargetPercent;
        
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "‚ù§Ô∏è";
        lifeEl.innerText = hearts.length > 0 ? hearts : "üíÄ";

        if (gameState === 'playing' && parseFloat(percent) >= currentTargetPercent) {
            endGame(true, `Î†àÎ≤® ${level} ÌÅ¥Î¶¨Ïñ¥!`);
        }
    }

    function setupPCControls() {
        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'ArrowLeft': input.left = true; break;
                case 'ArrowRight': input.right = true; break;
                case 'ArrowUp': input.up = true; break;
                case 'ArrowDown': input.down = true; break;
                case 'Space': input.action = true; break;
            }
        });
        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft': input.left = false; break;
                case 'ArrowRight': input.right = false; break;
                case 'ArrowUp': input.up = false; break;
                case 'ArrowDown': input.down = false; break;
                case 'Space': input.action = false; break;
            }
        });
    }

    function setupMobileControls() {
        const zoneLeft = document.getElementById('zone-left');
        const zoneRight = document.getElementById('zone-right');
        const dJoystick = document.getElementById('dynamic-joystick');
        const dKnob = document.getElementById('dynamic-knob');
        const actionBtn = document.getElementById('action-btn');
        
        let joyStartX, joyStartY;
        let joyActiveId = null;

        // --- ÏôºÏ™Ω ÏòÅÏó≠: ÎèôÏ†Å Ï°∞Ïù¥Ïä§Ìã± ---
        zoneLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (joyActiveId !== null) return;

            const touch = e.changedTouches[0];
            joyActiveId = touch.identifier;
            joyStartX = touch.clientX;
            joyStartY = touch.clientY;

            // Ï°∞Ïù¥Ïä§Ìã± ÎπÑÏ£ºÏñº ÌëúÏãú
            dJoystick.style.display = 'block';
            dJoystick.style.left = joyStartX + 'px';
            dJoystick.style.top = joyStartY + 'px';
            dKnob.style.transform = `translate(-50%, -50%)`;

            input.joyX = 0;
            input.joyY = 0;
        });

        zoneLeft.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joyActiveId === null) return;

            // ÌôúÏÑ± ÌÑ∞Ïπò Ï∞æÍ∏∞
            let touch = null;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joyActiveId) {
                    touch = e.changedTouches[i];
                    break;
                }
            }
            if (!touch) return;

            let dx = touch.clientX - joyStartX;
            let dy = touch.clientY - joyStartY;
            const maxDist = 40 * gameScale; // [Ïä§ÏºÄÏùº] Ï°∞Ïù¥Ïä§Ìã± Î∞òÍ≤Ω
            const dist = Math.min(Math.hypot(dx, dy), maxDist);
            const angle = Math.atan2(dy, dx);

            const moveX = Math.cos(angle) * dist;
            const moveY = Math.sin(angle) * dist;

            // ÎÜâ Ïù¥Îèô
            dKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;

            // ÏûÖÎ†• ÏóÖÎç∞Ïù¥Ìä∏
            input.joyX = moveX / maxDist;
            input.joyY = moveY / maxDist;
        });

        const endJoystick = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joyActiveId) {
                    joyActiveId = null;
                    dJoystick.style.display = 'none';
                    input.joyX = 0;
                    input.joyY = 0;
                    break;
                }
            }
        };
        zoneLeft.addEventListener('touchend', endJoystick);
        zoneLeft.addEventListener('touchcancel', endJoystick);

        // --- Ïò§Î•∏Ï™Ω ÏòÅÏó≠: Ïï°ÏÖò Î≤ÑÌäº ---
        zoneRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            input.action = true;
            actionBtn.classList.add('active');
        });

        const endAction = (e) => {
            e.preventDefault();
            // Î™®Îì† ÌÑ∞ÏπòÍ∞Ä ÎÅùÎÇ¨ÎäîÏßÄ Ï≤¥ÌÅ¨ÌïòÍ±∞ÎÇò Îã®ÏàúÌûà Ïï°ÏÖò Ìï¥Ï†ú
            if (e.touches.length === 0 || Array.from(e.touches).every(t => t.clientX < window.innerWidth / 2)) {
                 input.action = false;
                 actionBtn.classList.remove('active');
            }
        };
        
        zoneRight.addEventListener('touchend', (e) => {
             e.preventDefault();
             // Ïù¥ ÏòÅÏó≠Ïóê ÎÇ®ÏùÄ ÌÑ∞ÏπòÍ∞Ä ÏóÜÏúºÎ©¥ Ïï°ÏÖò Ìï¥Ï†ú
             let hasRightTouch = false;
             for (let i=0; i<e.touches.length; i++) {
                 if (e.touches[i].clientX > window.innerWidth / 2) {
                     hasRightTouch = true;
                     break;
                 }
             }
             if (!hasRightTouch) {
                 input.action = false;
                 actionBtn.classList.remove('active');
             }
        });
    }
</script>
</body>
</html>
