<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>땅따먹기 게임 (Qix Style) - Fixed</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        canvas {
            display: block;
            background-color: #000;
        }
        #uiLayer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        .hud-text {
            font-size: 18px;
            margin-bottom: 5px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid white;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="uiLayer">
        <div class="hud-text">땅따먹기: <span id="percentDisplay">0</span>% (목표: 80%)</div>
        <div class="hud-text">생명: <span id="livesDisplay">3</span></div>
        <div class="hud-text">레벨: <span id="levelDisplay">1</span></div>
    </div>
    <div id="message"></div>
</div>

<script>
/**
 * 게임 설정 및 상수
 */
const CONFIG = {
    gridSize: 8,         // 그리드 크기 (작을수록 정교함)
    playerSpeed: 4,      // 플레이어 속도 (gridSize의 약수 권장)
    bossSpeed: 3,        // 보스 속도
    targetPercent: 80,   // 클리어 목표 퍼센트
    lives: 3,            // 목숨
    bgImageCount: 5,     // 준비된 배경 이미지 수 (bg_1 ~ bg_5)
    extensions: ['webp', 'png'] // 지원할 확장자 우선순위
};

/**
 * 전역 변수
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiPercent = document.getElementById('percentDisplay');
const uiLives = document.getElementById('livesDisplay');
const uiLevel = document.getElementById('levelDisplay');
const msgBox = document.getElementById('message');

let width, height;
let cols, rows;
let grid = []; // 0: 빈공간, 1: 플레이어 경로(임시), 2: 확정된 땅
let player;
let bosses = [];
let items = []; // 프리즈 아이템 등
let gameState = 'playing'; // playing, gameover, win, levelup
let currentLevel = 1;
let totalArea = 0;
let claimedArea = 0;
let bgImage = null; // 현재 배경 이미지 객체

// 효과음 (간단한 오실레이터)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    if (type === 'move') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
    } else if (type === 'claim') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    } else if (type === 'die') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
    } else if (type === 'freeze') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
    }
}

/**
 * 이미지 로더 (WebP -> PNG 순차 시도)
 */
function loadRandomBackground() {
    // 1부터 CONFIG.bgImageCount 사이의 랜덤 숫자
    const idx = Math.floor(Math.random() * CONFIG.bgImageCount) + 1;
    const filenameBase = `bg_${idx}`; // 파일명 예: bg_1, bg_2...
    
    // 재귀적으로 확장자를 시도하는 함수
    function tryLoad(extIndex) {
        if (extIndex >= CONFIG.extensions.length) {
            console.log("이미지 로드 실패: 기본 검은 배경 사용");
            bgImage = null;
            return;
        }
        
        const ext = CONFIG.extensions[extIndex];
        const img = new Image();
        // 실제 파일 경로 예시: assets/bg_1.webp (폴더 구조에 맞게 수정 필요)
        // 여기서는 같은 폴더에 있다고 가정하거나 플레이스홀더 사용
        // 테스트를 위해 picsum 사용 (실제 코드 적용시 아래 주석 해제 및 경로 수정)
        
        /* [실제 파일 사용 시 이 부분 주석 해제]
        img.src = `${filenameBase}.${ext}`; 
        */

        // [데모용 랜덤 이미지]
        img.src = `https://picsum.photos/800/600?random=${Date.now()}`; 

        img.onload = () => {
            console.log(`배경 로드 성공: ${img.src}`);
            bgImage = img;
        };
        
        img.onerror = () => {
            console.log(`${ext} 로드 실패, 다음 확장자 시도...`);
            // picsum을 쓰고 있어서 에러가 잘 안나지만, 로컬 파일 사용시 중요
            // tryLoad(extIndex + 1); // 실제 파일 사용시 주석 해제
        };
    }

    tryLoad(0);
}

/**
 * 초기화
 */
function init() {
    width = 800;
    height = 600;
    canvas.width = width;
    canvas.height = height;
    
    cols = Math.ceil(width / CONFIG.gridSize);
    rows = Math.ceil(height / CONFIG.gridSize);
    
    resetGame();
    loadRandomBackground();
    requestAnimationFrame(gameLoop);
}

function resetGame() {
    // 그리드 초기화 (가장자리는 이미 먹은 땅으로 처리)
    grid = [];
    for(let c=0; c<cols; c++) {
        grid[c] = [];
        for(let r=0; r<rows; r++) {
            if (c===0 || c===cols-1 || r===0 || r===rows-1) {
                grid[c][r] = 2; // 벽
            } else {
                grid[c][r] = 0; // 빈 땅
            }
        }
    }
    
    // 플레이어 초기 위치
    player = {
        x: 0, 
        y: 0, 
        dirX: 0, 
        dirY: 0,
        drawing: false,
        path: [] // 현재 그리고 있는 선의 좌표들
    };

    // 보스 초기화
    bosses = [];
    // 레벨에 따라 보스 수 증가 등 난이도 조절 가능
    for(let i=0; i < 1 + Math.floor(currentLevel/2); i++) {
        spawnBoss();
    }

    // 아이템 초기화
    items = [];
    spawnItemTimer();

    calculateArea();
    gameState = 'playing';
    msgBox.style.display = 'none';
    uiLevel.innerText = currentLevel;
    uiLives.innerText = CONFIG.lives;
}

function spawnBoss() {
    bosses.push({
        x: width / 2,
        y: height / 2,
        vx: (Math.random() > 0.5 ? 1 : -1) * CONFIG.bossSpeed,
        vy: (Math.random() > 0.5 ? 1 : -1) * CONFIG.bossSpeed,
        radius: 10,
        frozen: false,
        freezeTimer: 0
    });
}

function spawnItemTimer() {
    setTimeout(() => {
        if(gameState !== 'playing') return;
        // 빈 공간 중 랜덤 위치
        let valid = false;
        let rx, ry;
        let attempts = 0;
        while(!valid && attempts < 100) {
            rx = Math.floor(Math.random() * (cols-2)) + 1;
            ry = Math.floor(Math.random() * (rows-2)) + 1;
            if (grid[rx][ry] === 0) valid = true;
            attempts++;
        }
        if(valid) {
            items.push({
                x: rx * CONFIG.gridSize + CONFIG.gridSize/2,
                y: ry * CONFIG.gridSize + CONFIG.gridSize/2,
                type: 'freeze',
                radius: 10
            });
        }
        spawnItemTimer(); // 재귀 호출로 계속 생성 시도
    }, 5000 + Math.random() * 5000);
}

/**
 * 게임 루프
 */
function gameLoop() {
    if (gameState === 'playing') {
        update();
    }
    render();
    requestAnimationFrame(gameLoop);
}

function update() {
    // 1. 플레이어 이동
    // 그리드 좌표계로 변환하여 처리
    let nextX = player.x + player.dirX * CONFIG.playerSpeed;
    let nextY = player.y + player.dirY * CONFIG.playerSpeed;

    // 캔버스 경계 체크
    if (nextX < 0) nextX = 0;
    if (nextX > width) nextX = width;
    if (nextY < 0) nextY = 0;
    if (nextY > height) nextY = height;

    // 현재 위치의 그리드 상태 확인
    let pc = Math.floor((player.x + player.dirX * (CONFIG.playerSpeed/2)) / CONFIG.gridSize); // 약간 앞선 위치 체크
    let pr = Math.floor((player.y + player.dirY * (CONFIG.playerSpeed/2)) / CONFIG.gridSize);
    
    // 범위 안전장치
    if (pc < 0) pc = 0; if (pc >= cols) pc = cols-1;
    if (pr < 0) pr = 0; if (pr >= rows) pr = rows-1;

    let cellState = grid[pc][pr];

    // 그리기 시작/종료 로직
    if (cellState === 0) {
        // 빈 땅에 들어오면 그리기 모드
        if (!player.drawing) {
            player.drawing = true;
            player.path = [{x: player.x, y: player.y}]; // 시작점
        }
    } else if (cellState === 2) {
        // 안전한 땅에 들어옴
        if (player.drawing) {
            // 경로 완성!
            finishPath();
            player.drawing = false;
            player.path = [];
            player.dirX = 0; player.dirY = 0; // 멈춤
            playSound('claim');
        }
    } else if (cellState === 1) {
        // 자기 경로(꼬리)를 밟음 -> 사망
        if (player.drawing && player.path.length > 5) { // 바로 뒤돌아서 죽는거 방지용 버퍼
             die();
             return;
        }
    }

    player.x = nextX;
    player.y = nextY;

    // 경로 기록 (드로잉 중일 때만)
    if (player.drawing) {
        // 너무 촘촘하게 저장하지 않도록 거리 체크 또는 그리드 단위 체크
        // 여기서는 픽셀 단위로 선을 긋되, 충돌 판정은 그리드에 마킹
        
        // 현재 플레이어가 지나가는 그리드를 임시 경로(1)로 표시
        // 픽셀 -> 그리드 변환 시 약간의 여유를 두어 정확도 향상
        let gc = Math.floor(player.x / CONFIG.gridSize);
        let gr = Math.floor(player.y / CONFIG.gridSize);
        if (gc>=0 && gc<cols && gr>=0 && gr<rows) {
            if (grid[gc][gr] === 0) {
                grid[gc][gr] = 1; // 임시 경로
            }
        }
        player.path.push({x: player.x, y: player.y});
    }

    // 2. 보스 이동
    bosses.forEach(boss => {
        // 프리즈 상태 확인 (버그 수정됨)
        if (boss.frozen) {
            boss.freezeTimer--;
            if (boss.freezeTimer <= 0) {
                boss.frozen = false;
            }
            return; // 이동 로직 스킵
        }

        let bx = boss.x + boss.vx;
        let by = boss.y + boss.vy;

        // 벽/경로 충돌 체크 (그리드 기반 반사)
        // 보스의 네 귀퉁이+중심을 체크하여 정밀도 향상
        let hit = false;
        
        // 캔버스 외곽 체크
        if (bx - boss.radius < 0 || bx + boss.radius > width) {
            boss.vx *= -1; hit = true;
        }
        if (by - boss.radius < 0 || by + boss.radius > height) {
            boss.vy *= -1; hit = true;
        }

        // 내부 그리드(완성된 땅 또는 플레이어 경로) 충돌 체크
        if (!hit) {
            // 보스의 바운딩 박스 체크
            let checkPoints = [
                {x: bx + boss.radius, y: by},
                {x: bx - boss.radius, y: by},
                {x: bx, y: by + boss.radius},
                {x: bx, y: by - boss.radius}
            ];

            for (let p of checkPoints) {
                let c = Math.floor(p.x / CONFIG.gridSize);
                let r = Math.floor(p.y / CONFIG.gridSize);
                if (c>=0 && c<cols && r>=0 && r<rows) {
                    if (grid[c][r] === 2) { // 완성된 땅에 부딪힘 -> 튕김
                        // 간단하게 X, Y 반전 (정교한 물리엔진 대신)
                        if (Math.abs(p.x - bx) > Math.abs(p.y - by)) boss.vx *= -1;
                        else boss.vy *= -1;
                        hit = true;
                        break;
                    } else if (grid[c][r] === 1) { // 플레이어 경로(선)에 부딪힘 -> 플레이어 사망
                        die();
                        return;
                    }
                }
            }
        }

        if(!hit) {
            boss.x = bx;
            boss.y = by;
        }
    });
    
    // 3. 아이템 충돌 체크
    for(let i = items.length - 1; i >= 0; i--) {
        let it = items[i];
        let dx = player.x - it.x;
        let dy = player.y - it.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < it.radius + 10) { // 플레이어 크기 고려
            // 획득
            if (it.type === 'freeze') {
                playSound('freeze');
                bosses.forEach(b => {
                    b.frozen = true;
                    b.freezeTimer = 300; // 약 5초 (60fps 기준)
                });
                showMessage("FREEZE!", 1000);
            }
            items.splice(i, 1);
        }
    }
}

/**
 * 영역 채우기 알고리즘
 */
function finishPath() {
    // 1. 임시 경로(1)를 모두 확정(2) 상태로 변경할지, 아니면 플러드필을 할지 결정
    // 일단 경로 자체를 2로 바꿈
    for(let c=0; c<cols; c++) {
        for(let r=0; r<rows; r++) {
            if (grid[c][r] === 1) grid[c][r] = 2;
        }
    }

    // 2. 보스가 없는 영역을 찾아 채우기 (Flood Fill)
    // 두 개의 영역(A, B)으로 나뉘었을 때, 보스가 *없는* 쪽을 채워야 함.
    // 간단한 방법: 전체 빈 공간에 대해 플러드필 그룹링을 하고, 보스가 포함된 그룹만 남기고 나머지는 다 채운다.

    // 방문 배열 초기화
    let visited = new Array(cols).fill(0).map(() => new Array(rows).fill(false));
    
    // 보스가 위치한 좌표들의 그룹 ID를 찾기
    let bossGroups = new Set();

    bosses.forEach(boss => {
        let bc = Math.floor(boss.x / CONFIG.gridSize);
        let br = Math.floor(boss.y / CONFIG.gridSize);
        // 보스가 벽 안에 있을 확률은 낮지만 체크
        if (bc >=0 && bc < cols && br >= 0 && br < rows) {
             // 이 보스 위치에서 플러드필하여 연결된 모든 빈칸을 '보스 영역'으로 간주
             // 하지만 매 프레임 전체 검사는 무거우므로,
             // 여기서는 역발상:
             // "보스가 있는 위치"에서 시작하는 플러드필은 '살아남는 땅'이다.
             // 이 플러드필에 닿지 않는 모든 '0'(빈땅)은 '죽는 땅(채워질 땅)'이다.
        }
    });

    // 효율적인 로직:
    // 1. visited 배열을 사용하여 보스 위치에서부터 BFS/DFS로 갈 수 있는 모든 0을 방문 표시한다.
    // 2. 방문되지 않은 나머지 0들은 갇힌 영역이므로 2로 바꾼다.

    let queue = [];
    bosses.forEach(boss => {
        let bc = Math.floor(boss.x / CONFIG.gridSize);
        let br = Math.floor(boss.y / CONFIG.gridSize);
        if (bc>=0 && bc<cols && br>=0 && br<rows && grid[bc][br] === 0) {
            queue.push({c: bc, r: br});
            visited[bc][br] = true;
        }
    });

    // BFS
    let head = 0;
    while(head < queue.length) {
        let curr = queue[head++];
        let cx = curr.c;
        let cy = curr.r;

        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        for(let d of dirs) {
            let nc = cx + d[0];
            let nr = cy + d[1];
            
            if (nc >= 0 && nc < cols && nr >= 0 && nr < rows) {
                if (!visited[nc][nr] && grid[nc][nr] === 0) {
                    visited[nc][nr] = true;
                    queue.push({c: nc, r: nr});
                }
            }
        }
    }

    // 채우기 수행
    let filledCount = 0;
    for(let c=0; c<cols; c++) {
        for(let r=0; r<rows; r++) {
            if (grid[c][r] === 0 && !visited[c][r]) {
                grid[c][r] = 2; // 갇힌 영역 채우기
                filledCount++;
            }
        }
    }

    calculateArea();
}

function calculateArea() {
    let totalCells = (cols-2) * (rows-2); // 테두리 제외
    let claimed = 0;
    for(let c=1; c<cols-1; c++) {
        for(let r=1; r<rows-1; r++) {
            if (grid[c][r] === 2) claimed++;
        }
    }
    let percent = Math.floor((claimed / totalCells) * 100);
    uiPercent.innerText = percent;
    
    if (percent >= CONFIG.targetPercent) {
        levelUp();
    }
}

function die() {
    playSound('die');
    CONFIG.lives--;
    uiLives.innerText = CONFIG.lives;
    
    // 경로 초기화 (죽으면 그리던 선 사라짐)
    player.drawing = false;
    player.path = [];
    for(let c=0; c<cols; c++) {
        for(let r=0; r<rows; r++) {
            if (grid[c][r] === 1) grid[c][r] = 0;
        }
    }

    if (CONFIG.lives <= 0) {
        showMessage("GAME OVER<br><small>Click to Restart</small>");
        gameState = 'gameover';
        canvas.onclick = () => {
            canvas.onclick = null;
            currentLevel = 1;
            CONFIG.lives = 3;
            init();
        };
    } else {
        // 위치 리셋 (안전한 곳으로 - 보통 (0,0)은 항상 안전)
        player.x = 0; player.y = 0;
        player.dirX = 0; player.dirY = 0;
        showMessage("OUCH!", 1000);
    }
}

function levelUp() {
    gameState = 'levelup';
    playSound('claim'); // 승리음
    showMessage(`LEVEL ${currentLevel} CLEARED!`);
    setTimeout(() => {
        currentLevel++;
        resetGame();
    }, 2000);
}

function showMessage(html, duration) {
    msgBox.innerHTML = html;
    msgBox.style.display = 'block';
    if (duration) {
        setTimeout(() => {
            msgBox.style.display = 'none';
        }, duration);
    }
}

/**
 * 렌더링 (검은줄 버그 수정됨)
 */
function render() {
    // 1. 전체 지우기
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);

    // 2. 배경 이미지 그리기 (마스킹을 위해 먼저 전체를 그림)
    // 하지만 땅따먹기는 '벗겨내는' 게임이므로,
    // 정복한 땅(2)에만 이미지를 보여주고,
    // 정복하지 못한 땅(0)은 검은색(또는 그림자)으로 덮는 방식이 예쁩니다.
    
    // (A) 배경 이미지 전체 그리기
    if (bgImage) {
        // 비율 유지하며 꽉 채우기
        ctx.drawImage(bgImage, 0, 0, width, height);
    } else {
        // 이미지 없으면 예쁜 그라데이션
        let grad = ctx.createLinearGradient(0, 0, width, height);
        grad.addColorStop(0, '#222');
        grad.addColorStop(1, '#444');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);
    }

    // (B) 정복되지 않은 땅(0)과 임시경로(1) 위에 '어둠' 덮어씌우기
    // 성능 최적화 + 검은줄 제거를 위해:
    // 개별 rect를 그리는 대신 path를 모아서 한번에 그립니다.
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)'; // 미정복 지역 색상 (약간 투명하게 해서 뒤가 살짝 비치게 할 수도 있음)
    ctx.beginPath();
    
    // 팁: 검은 줄이 생기는 이유인 "인접 타일간의 틈"을 막기 위해
    // fillRect로 하나씩 그릴때 Math.ceil을 쓰거나
    // 아래처럼 path로 묶어서 그리면 해결됩니다.
    // 여기서는 가장 확실한 방법인 "타일 크기 + 여유분"을 사용하여 틈새를 메꿉니다.
    
    const overlap = 0.5; // 틈새 방지용 겹침
    
    for(let c=0; c<cols; c++) {
        for(let r=0; r<rows; r++) {
            if (grid[c][r] === 0 || grid[c][r] === 1) {
                // grid[c][r] == 1 (경로) 도 일단 어둠으로 덮고, 나중에 선을 위에 그린다
                ctx.rect(
                    c * CONFIG.gridSize, 
                    r * CONFIG.gridSize, 
                    CONFIG.gridSize + overlap, 
                    CONFIG.gridSize + overlap
                );
            }
        }
    }
    ctx.fill();

    // 3. 현재 그리고 있는 선(Path) 강조
    if (player.drawing && player.path.length > 0) {
        ctx.strokeStyle = '#00ff00'; // 네온 그린
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(player.path[0].x, player.path[0].y);
        for(let i=1; i<player.path.length; i++) {
            ctx.lineTo(player.path[i].x, player.path[i].y);
        }
        ctx.lineTo(player.x, player.y);
        ctx.stroke();
        
        ctx.shadowBlur = 0; // 리셋
    }

    // 4. 플레이어 그리기
    ctx.fillStyle = '#fff';
    ctx.fillRect(player.x - 3, player.y - 3, 6, 6);

    // 5. 보스 그리기
    bosses.forEach(boss => {
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
        if (boss.frozen) {
            ctx.fillStyle = '#00ffff'; // 얼어있을 때 색상
            ctx.strokeStyle = '#fff';
            // 얼음 효과 텍스트
            ctx.font = "10px Arial";
            ctx.fillStyle = "white";
            ctx.fillText("❄️", boss.x - 5, boss.y + 4);
        } else {
            ctx.fillStyle = '#ff0000';
        }
        ctx.fill();
        ctx.closePath();
    });

    // 6. 아이템 그리기
    items.forEach(item => {
        ctx.beginPath();
        ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
        if (item.type === 'freeze') {
            ctx.fillStyle = 'blue';
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fill();
            // 아이콘
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText("F", item.x-4, item.y+4);
        }
    });
}

/**
 * 키보드 입력
 */
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    updateDirection();
});
window.addEventListener('keyup', e => {
    keys[e.code] = false;
    updateDirection();
});

function updateDirection() {
    // 대각선 이동 방지 & 부드러운 전환
    if (keys['ArrowUp']) { player.dirX = 0; player.dirY = -1; }
    else if (keys['ArrowDown']) { player.dirX = 0; player.dirY = 1; }
    else if (keys['ArrowLeft']) { player.dirX = -1; player.dirY = 0; }
    else if (keys['ArrowRight']) { player.dirX = 1; player.dirY = 0; }
    else { player.dirX = 0; player.dirY = 0; }
}

// 게임 시작
init();

</script>
</body>
</html>
