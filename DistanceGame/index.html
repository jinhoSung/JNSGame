<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Launcher - Item Boost</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Orbitron', 'Noto Sans KR', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: #fff;
        }

        canvas {
            display: block;
        }

        /* UI Î†àÏù¥Ïñ¥ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-box {
            text-align: left;
        }

        .right-controls {
            display: flex;
            gap: 10px;
            pointer-events: auto; /* Î≤ÑÌäº ÌÅ¥Î¶≠ Í∞ÄÎä• */
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 10px #000;
        }

        #score-display {
            font-size: 40px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #000;
        }

        /* ÏÜçÎèÑ Î∞è Í≥†ÎèÑ UI Ïä§ÌÉÄÏùº */
        .status-info {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            margin-top: 5px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-label {
            color: #aaa;
            font-size: 12px;
            width: 50px;
        }
        .status-value {
            font-weight: bold;
        }
        #speed-val { color: #0ff; }
        #height-val { color: #f0f; }

        #combo-display {
            font-size: 24px;
            color: #ff0;
            text-shadow: 0 0 10px #000;
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Í≥µÌÜµ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        .ui-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 8px 15px;
            border-radius: 20px;
            font-family: 'Noto Sans KR', sans-serif;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .ui-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
        }

        .ui-btn:active {
            transform: scale(0.95);
        }

        /* Ï†ÑÏ≤¥ÌôîÎ©¥ Î≤ÑÌäº Ïä§ÌÉÄÏùº (ÏïÑÏù¥ÏΩòÎßå) */
        #btn-fullscreen {
            padding: 8px 12px;
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        #btn-fullscreen:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        #center-ui {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            width: 100%;
            pointer-events: none;
        }

        #status-msg {
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            transition: opacity 0.2s;
            line-height: 1.5;
        }

        #hit-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            opacity: 0;
            pointer-events: none;
            z-index: 30;
        }

        /* Îû≠ÌÇπ Î™®Îã¨ Ïä§ÌÉÄÏùº */
        #ranking-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            background: rgba(0, 0, 20, 0.95);
            border: 2px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 50;
            display: none; /* Í∏∞Î≥∏ Ïà®ÍπÄ */
            font-family: 'Noto Sans KR', sans-serif;
        }

        #ranking-modal h2 {
            color: #0ff;
            margin: 0 0 20px 0;
            text-shadow: 0 0 10px #0ff;
        }

        /* Îã´Í∏∞ Î≤ÑÌäº (X) */
        #btn-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            margin: 0;
            line-height: 1;
        }
        #btn-modal-close:hover { color: #f00; }

        .rank-list {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
            text-align: left;
            max-height: 250px;
            overflow-y: auto;
            border-bottom: 1px solid #333;
        }

        .rank-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .rank-item.my-score {
            color: #ff0;
            font-weight: bold;
            background: rgba(255, 255, 0, 0.1);
        }

        .rank-rank { width: 30px; text-align: center; }
        .rank-name { flex-grow: 1; padding-left: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .rank-score { width: 80px; text-align: right; }

        input[type="text"] {
            background: #111;
            border: 1px solid #0ff;
            color: #fff;
            padding: 10px;
            width: 70%;
            border-radius: 5px;
            margin-bottom: 10px;
            font-family: inherit;
            outline: none;
        }

        button.action-btn {
            background: linear-gradient(45deg, #0088ff, #00ffff);
            border: none;
            color: #000;
            padding: 10px 20px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: transform 0.1s;
            margin: 5px;
        }

        button.action-btn:active { transform: scale(0.95); }
        button.action-btn:disabled { background: #555; color: #888; cursor: not-allowed; }

        #final-score {
            font-size: 32px;
            color: #f0f;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #f0f;
            font-family: 'Orbitron', sans-serif;
        }

        #my-rank-info {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 15px;
        }

        @keyframes pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.0); opacity: 0; }
        }

        .pop-anim {
            animation: pop 1s forwards;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="score-box">
            <h1>NEON LAUNCHER</h1>
            <div>Distance: <span id="score-display">0</span> m</div>
            
            <!-- ÏÜçÎèÑ Î∞è ÎÜíÏù¥ ÌëúÏãú UI Ï∂îÍ∞Ä -->
            <div class="status-info">
                <div class="status-item">
                    <span class="status-label">SPEED</span>
                    <span id="speed-val" class="status-value">0</span> km/h
                </div>
                <div class="status-item">
                    <span class="status-label">HEIGHT</span>
                    <span id="height-val" class="status-value">0</span> m
                </div>
            </div>

            <div id="combo-display">COMBO x0</div>
            <div style="font-size: 14px; color: #fff; margin-top: 5px;">Best: <span id="best-score">0</span> m</div>
        </div>
        
        <div class="right-controls">
            <!-- Ï†ÑÏ≤¥ÌôîÎ©¥ Î≤ÑÌäº Ï∂îÍ∞Ä -->
            <button id="btn-fullscreen" class="ui-btn" title="Ï†ÑÏ≤¥ÌôîÎ©¥">‚õ∂</button>
            <button id="btn-show-ranking" class="ui-btn">üèÜ Îû≠ÌÇπ</button>
        </div>
    </div>

    <div id="hit-feedback">PERFECT!</div>

    <div id="center-ui">
        <div id="status-msg">ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥<br>Í≥µÏù¥ Îñ®Ïñ¥ÏßëÎãàÎã§!</div>
    </div>

    <div id="ranking-modal">
        <button id="btn-modal-close">&times;</button>
        <h2 id="modal-title">GAME OVER</h2>
        <div id="final-score" class="hidden">0 m</div>
        
        <div id="register-form" class="hidden">
            <input type="text" id="player-name" placeholder="Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî (ÏµúÎåÄ 8Ïûê)" maxlength="8">
            <div style="display: flex; gap: 5px; justify-content: center;">
                <button id="btn-submit" class="action-btn" style="flex: 2;">Îû≠ÌÇπ Îì±Î°ù</button>
                <button id="btn-skip" class="action-btn" style="flex: 1; background: #333; border: 1px solid #555; color: #aaa;">Ïû¨ÏãúÏûë</button>
            </div>
        </div>

        <div id="ranking-container">
            <div id="my-rank-info" class="hidden">ÎÇ¥ ÏàúÏúÑ Í≥ÑÏÇ∞ Ï§ë...</div>
            <ul class="rank-list" id="rank-list">
                <li style="padding:10px; color:#888;">Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</li>
            </ul>
            <button id="btn-retry" class="action-btn hidden">Îã§Ïãú ÌïòÍ∏∞</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Firebase SDK Modules -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, where, getCountFromServer } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.GAME = {
            db: null,
            auth: null,
            user: null,
            initFirebase: async function() {
                const firebaseConfig = {
                    apiKey: "AIzaSyBUGN1Zlpk-Avfu-5s4G6qQrSfMaq_QXhw",
                    authDomain: "distancegame-f4bba.firebaseapp.com",
                    projectId: "distancegame-f4bba",
                    storageBucket: "distancegame-f4bba.firebasestorage.app",
                    messagingSenderId: "180425278674",
                    appId: "1:180425278674:web:af07ce51992cb622fc990b",
                    measurementId: "G-0PGCH52GKN"
                };
                try {
                    const app = initializeApp(firebaseConfig);
                    this.auth = getAuth(app);
                    this.db = getFirestore(app);
                    await signInAnonymously(this.auth);
                    onAuthStateChanged(this.auth, (user) => {
                        this.user = user;
                    });
                } catch (e) {
                    console.error("Firebase Init Failed:", e);
                }
            },
            saveScore: async function(name, score) {
                const currentUser = this.auth?.currentUser || this.user;
                if (!this.db || !currentUser) return false;
                try {
                    const scoresRef = collection(this.db, 'scores');
                    await addDoc(scoresRef, {
                        name: name,
                        score: score,
                        userId: currentUser.uid,
                        timestamp: Date.now()
                    });
                    return true;
                } catch (e) {
                    return false;
                }
            },
            getRanking: async function(myScore) {
                if (!this.db) return { top10: [], myRank: '-' };
                try {
                    const scoresRef = collection(this.db, 'scores');
                    const qTop = query(scoresRef, orderBy('score', 'desc'), limit(10));
                    const snapshot = await getDocs(qTop);
                    const top10 = snapshot.docs.map(doc => doc.data());
                    let myRank = '-';
                    if (myScore !== null && myScore !== undefined) {
                        try {
                            const qBetter = query(scoresRef, where("score", ">", myScore));
                            const snapshotBetter = await getCountFromServer(qBetter);
                            myRank = snapshotBetter.data().count + 1;
                        } catch (e) {
                            const idx = top10.findIndex(d => d.score === myScore);
                            if(idx !== -1) myRank = idx + 1;
                            else myRank = "ÏßëÍ≥ÑÏ§ë";
                        }
                    }
                    return { top10, myRank };
                } catch (e) {
                    return { top10: [], myRank: '-' };
                }
            }
        };
        window.GAME.initFirebase();
    </script>

    <script>
        const Sound = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playHit: function(isPerfect) {
                this.init();
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                if (isPerfect) {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                } else {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.1); 
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                }
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },
            playBoost: function() { this.playTone(600, 'sine', 0.2); setTimeout(() => this.playTone(1200, 'sine', 0.4), 50); },
            playJump: function() { this.playTone(300, 'square', 0.1); setTimeout(() => this.playTone(600, 'square', 0.3), 50); },
            playBlast: function() { this.playTone(100, 'sawtooth', 0.5, 0.2); this.playTone(50, 'square', 0.5, 0.2); },
            playBreath: function() {
                this.playTone(100, 'sawtooth', 0.8, 0.3);
                setTimeout(() => this.playTone(800, 'square', 0.2, 0.5), 600);
            },
            playCrash: function() { 
                this.playTone(150, 'sawtooth', 0.1, 0.5);
                setTimeout(() => this.playTone(80, 'square', 0.2, 0.5), 50);
            },
            playShield: function() { // [Ï∂îÍ∞Ä] Ïâ¥Îìú ÏÇ¨Ïö¥Îìú
                this.playTone(400, 'sine', 0.3, 0.3);
            },
            playFloat: function() { // [Ï∂îÍ∞Ä] ÌîåÎ°úÌä∏ ÏÇ¨Ïö¥Îìú
                this.playTone(800, 'sine', 0.5, 0.1);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiScore = document.getElementById('score-display');
        const uiCombo = document.getElementById('combo-display');
        const uiBest = document.getElementById('best-score');
        const uiMsg = document.getElementById('status-msg');
        const uiFeedback = document.getElementById('hit-feedback');
        // Ïã†Í∑ú UI ÏöîÏÜå
        const uiSpeed = document.getElementById('speed-val');
        const uiHeight = document.getElementById('height-val');
        const btnFullscreen = document.getElementById('btn-fullscreen');
        
        const modal = document.getElementById('ranking-modal');
        const modalTitle = document.getElementById('modal-title');
        const finalScoreEl = document.getElementById('final-score');
        const registerForm = document.getElementById('register-form');
        const rankingContainer = document.getElementById('ranking-container');
        const rankListEl = document.getElementById('rank-list');
        const myRankEl = document.getElementById('my-rank-info');
        const playerNameInput = document.getElementById('player-name');
        const btnSubmit = document.getElementById('btn-submit');
        const btnRetry = document.getElementById('btn-retry');
        const btnShowRanking = document.getElementById('btn-show-ranking');
        const btnModalClose = document.getElementById('btn-modal-close');
        const btnSkip = document.getElementById('btn-skip');

        const STATE = { READY: 0, DROPPING: 1, FLYING: 2, STOPPED: 3, MISS: 4 };
        let gameState = STATE.READY;
        let width, height;
        let frameId;
        let bestDistance = 0;
        let lastBoosterX = 0;
        let scaleFactor = 1;
        let lastTime = 0;
        let combo = 0;
        let currentScore = 0;
        
        let hitFreeze = 0; 
        let specialEffects = [];

        const camera = { x: 0, y: 0, shake: 0 };
        const GRAVITY_BASE = 0.25;
        let GRAVITY = GRAVITY_BASE;
        const FRICTION_AIR = 0.998; 
        const FRICTION_GROUND = 0.85; 
        const BOUNCE = 0.6; 
        const CHAR_SCALE = 1.3;

        let ball, batter, particles = [], shockwaves = [], speedLines = [], stars = [], boosters = [], mountains = [], cityBuildings = [], obstacles = [];
        let skyManager = null;

        // UI Event Listeners
        // Ï†ÑÏ≤¥ÌôîÎ©¥ ÌÜ†Í∏Ä
        btnFullscreen.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        btnSubmit.addEventListener('click', async () => {
            const name = playerNameInput.value.trim();
            if (!name) { alert("Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."); return; }
            if (name.length > 8) { alert("Ïù¥Î¶ÑÏùÄ 8Ïûê Ïù¥ÌïòÎ°ú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."); return; }
            localStorage.setItem('neon_launcher_name', name);
            btnSubmit.disabled = true;
            btnSubmit.innerText = "Îì±Î°ù Ï§ë...";
            if (window.GAME) {
                const success = await window.GAME.saveScore(name, currentScore);
                if (success) {
                    await updateRankingBoard(currentScore, name);
                    registerForm.classList.add('hidden');
                    rankingContainer.classList.remove('hidden');
                    btnRetry.classList.remove('hidden'); 
                } else {
                    alert("Ï†êÏàò Ï†ÄÏû• Ïã§Ìå®.");
                    btnSubmit.disabled = false;
                    btnSubmit.innerText = "Îû≠ÌÇπ Îì±Î°ù";
                }
            } else { alert("Îû≠ÌÇπ ÏãúÏä§ÌÖú Ïò§Î•ò"); }
        });

        btnRetry.addEventListener('click', () => { modal.style.display = 'none'; resetGame(); });
        btnSkip.addEventListener('click', () => { modal.style.display = 'none'; resetGame(); });

        btnShowRanking.addEventListener('click', async () => {
            modalTitle.innerText = "TOP RANKING";
            finalScoreEl.classList.add('hidden');
            registerForm.classList.add('hidden');
            btnRetry.classList.add('hidden'); 
            rankingContainer.classList.remove('hidden');
            myRankEl.classList.add('hidden'); 
            modal.style.display = 'block';
            await updateRankingBoard(null, null); 
        });

        btnModalClose.addEventListener('click', () => {
            modal.style.display = 'none';
            if (gameState === STATE.STOPPED || gameState === STATE.MISS) { resetGame(); }
        });

        async function updateRankingBoard(myScore, myName) {
            rankListEl.innerHTML = '<li style="padding:10px; color:#888;">Î°úÎî© Ï§ë...</li>';
            const { top10, myRank } = await window.GAME.getRanking(myScore);
            if (myScore !== null) {
                myRankEl.innerText = `Ïù¥Î≤à Í∏∞Î°ù ÏàúÏúÑ: ${myRank}ÏúÑ`;
                myRankEl.classList.remove('hidden');
            } else {
                myRankEl.classList.add('hidden');
            }
            rankListEl.innerHTML = '';
            if (top10.length === 0) {
                rankListEl.innerHTML = '<li style="padding:10px; color:#888;">Îì±Î°ùÎêú Îû≠ÌÇπÏù¥ ÏóÜÏäµÎãàÎã§.</li>';
                return;
            }
            top10.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'rank-item';
                if (myName && item.name === myName && item.score === myScore) li.classList.add('my-score');
                let rankIcon = index + 1;
                if (index === 0) rankIcon = 'ü•á'; else if (index === 1) rankIcon = 'ü•à'; else if (index === 2) rankIcon = 'ü•â';
                li.innerHTML = `<span class="rank-rank">${rankIcon}</span><span class="rank-name">${item.name}</span><span class="rank-score">${item.score}m</span>`;
                rankListEl.appendChild(li);
            });
        }

        const savedName = localStorage.getItem('neon_launcher_name');
        if (savedName) playerNameInput.value = savedName;

        // --- Classes ---
        class SkyManager {
            constructor() {
                this.time = 0.25; this.dayDuration = 6000; this.weather = 'clear'; this.weatherTimer = 0;
                this.clouds = []; this.precipitations = []; this.sunX = 0; this.sunY = 0; this.moonX = 0; this.moonY = 0;
                for(let i=0; i<8; i++) { this.clouds.push(new Cloud()); }
            }
            update(dt) {
                this.time = (this.time + (dt / this.dayDuration)) % 1.0;
                const centerX = width / 2; const centerY = height + 200; const radius = Math.max(width, height) * 0.9;
                const sunAngle = Math.PI + (this.time * Math.PI * 2); 
                this.sunX = centerX + Math.cos(sunAngle) * radius; this.sunY = centerY + Math.sin(sunAngle) * radius;
                const moonAngle = sunAngle + Math.PI;
                this.moonX = centerX + Math.cos(moonAngle) * radius; this.moonY = centerY + Math.sin(moonAngle) * radius;
                this.weatherTimer += dt;
                if(this.weatherTimer > 600) {
                    this.weatherTimer = 0; const r = Math.random();
                    if(r < 0.6) this.weather = 'clear'; else if(r < 0.8) this.weather = 'rain'; else this.weather = 'snow';
                }
                this.clouds.forEach(c => c.update(dt));
                if(this.weather !== 'clear') {
                    const count = Math.ceil(width / 200); 
                    for(let i=0; i<count; i++) { if(Math.random() > 0.5) this.precipitations.push(new WeatherParticle(this.weather)); }
                }
                this.precipitations.forEach((p, i) => { p.update(dt); if(!p.active) this.precipitations.splice(i, 1); });
            }
            draw(ctx) {
                const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
                const sunHeight = -Math.cos(this.time * Math.PI * 2); 
                const L = Math.max(10, 10 + (sunHeight + 1) * 20); 
                const H = 220 + sunHeight * 20; 
                bgGrad.addColorStop(0, `hsl(${H}, 60%, ${L * 0.5}%)`); bgGrad.addColorStop(1, `hsl(${H + 20}, 70%, ${L}%)`);
                ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, width, height);
                const starAlpha = Math.max(0, -sunHeight); 
                if(starAlpha > 0) { ctx.save(); ctx.globalAlpha = starAlpha; stars.forEach(s => s.draw(ctx)); ctx.restore(); }
                ctx.save(); ctx.shadowBlur = 50; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(this.sunX, this.sunY, 60 * scaleFactor, 0, Math.PI*2); ctx.fill(); ctx.restore();
                ctx.save(); ctx.shadowBlur = 30; ctx.shadowColor = '#ffffff'; ctx.fillStyle = '#ffffee'; ctx.beginPath(); ctx.arc(this.moonX, this.moonY, 50 * scaleFactor, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(200,200,200,0.3)'; ctx.beginPath(); ctx.arc(this.moonX - 10, this.moonY - 5, 10 * scaleFactor, 0, Math.PI*2); ctx.arc(this.moonX + 15, this.moonY + 10, 8 * scaleFactor, 0, Math.PI*2); ctx.fill(); ctx.restore();
                this.clouds.forEach(c => c.draw(ctx));
                this.precipitations.forEach(p => p.draw(ctx));
            }
        }

        class Cloud {
            constructor(x, y) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height * 0.4;
                this.speed = 0.3 + Math.random() * 0.5; // ÏÜçÎèÑ Ï°∞Ï†à
                this.size = 0.8 + Math.random() * 1.5; // ÌÅ¨Í∏∞ Îã§ÏñëÌôî
                this.circles = [];
                const count = 4 + Math.floor(Math.random() * 5); // Îç©Ïñ¥Î¶¨ Í∞úÏàò
                for(let i=0; i<count; i++) {
                    this.circles.push({
                        x: (Math.random() - 0.5) * 80, // Í∞ÄÎ°úÎ°ú Îçî ÎÑìÍ≤å ÌçºÏßê
                        y: (Math.random() - 0.5) * 20, // ÏÑ∏Î°úÎäî ÎÇ©ÏûëÌïòÍ≤å
                        r: 20 + Math.random() * 25
                    });
                }
            }
            update(dt) {
                this.x -= this.speed * dt * 0.5; 
                if(this.x < -200) { 
                    this.x = width + 200; 
                    this.y = Math.random() * height * 0.4; 
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.size * scaleFactor, this.size * scaleFactor);
                
                // ÏùÄÏùÄÌïú ÎÑ§Ïò® Íµ¨Î¶Ñ Ïä§ÌÉÄÏùº
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; 
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
                
                ctx.beginPath();
                this.circles.forEach(c => {
                    // Ï§ëÏã¨Ï†ê Ïù¥Îèô ÏóÜÏù¥ Ïô∏Í≥ΩÏÑ†Îßå Í∑∏Î¶¨Í∏∞ (ÏÑ† Ï†úÍ±∞)
                    ctx.moveTo(c.x + c.r, c.y); 
                    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
                });
                ctx.fill();
                ctx.restore();
            }
        }

        class WeatherParticle {
            constructor(type) {
                this.type = type; this.x = Math.random() * width; this.y = -10; this.active = true;
                if(type === 'rain') { this.vy = 15 + Math.random() * 10; this.vx = -2 - Math.random() * 2; this.len = 10 + Math.random() * 10; } 
                else { this.vy = 2 + Math.random() * 3; this.vx = (Math.random() - 0.5) * 2; this.size = 2 + Math.random() * 3; this.angle = Math.random() * Math.PI * 2; }
            }
            update(dt) {
                this.x += this.vx * dt; this.y += this.vy * dt;
                if(this.type === 'snow') { this.angle += 0.1; this.x += Math.sin(this.angle) * 0.5; }
                if(this.y > height) this.active = false;
            }
            draw(ctx) {
                ctx.save();
                if(this.type === 'rain') { ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx, this.y + this.len); ctx.stroke(); } 
                else { ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = 40 * scaleFactor; this.active = true;
                this.rotation = Math.random() * Math.PI * 2; this.rotSpeed = (Math.random() - 0.5) * 0.1;
            }
            update(dt) { this.rotation += this.rotSpeed * dt; }
            draw() {
                if (!this.active) return;
                if (this.x - camera.x < -100 || this.x - camera.x > width + 100) return;
                ctx.save(); ctx.translate(this.x - camera.x, this.y - camera.y); ctx.rotate(this.rotation);
                const gx = (Math.random() - 0.5) * 5; const gy = (Math.random() - 0.5) * 5;
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(-this.size/2 + gx, -this.size/2 + gy, this.size, this.size);
                ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.beginPath(); ctx.moveTo(-this.size/3, -this.size/3); ctx.lineTo(this.size/3, this.size/3);
                ctx.moveTo(this.size/3, -this.size/3); ctx.lineTo(-this.size/3, this.size/3); ctx.stroke(); ctx.restore();
            }
            checkCollision(p) {
                if (!this.active) return false;
                const dx = this.x - p.x; const dy = this.y - p.y; const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < this.size/1.5 + p.radius) { this.active = false; return true; }
                return false;
            }
        }

        class Building {
            constructor(x, w, h, z) {
                this.x = x; this.w = w; this.h = h; this.z = z; this.windows = [];
                const rows = Math.floor(h / 30); const cols = Math.floor(w / 20);
                for(let r=0; r<rows; r++) { for(let c=0; c<cols; c++) { if(Math.random() > 0.4) { this.windows.push({x: c*20 + 5, y: r*30 + 10, on: true}); } } }
                const colors = ['#f0f', '#0ff', '#a0f']; this.neonColor = colors[Math.floor(Math.random() * colors.length)];
            }
            draw() {
                const parallax = 1 / this.z; let rx = (this.x - camera.x * parallax);
                const totalWidth = 3000; rx = rx % totalWidth; if(rx < -this.w) rx += totalWidth;
                if (rx > width || rx + this.w < 0) return;
                const gy = height - 50 - camera.y; const by = gy - this.h * scaleFactor;
                ctx.fillStyle = '#050510'; ctx.strokeStyle = this.neonColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(rx, by, this.w * scaleFactor, this.h * scaleFactor); ctx.fill(); ctx.stroke();
                ctx.fillStyle = this.neonColor;
                this.windows.forEach(win => { if(win.on) { ctx.globalAlpha = 0.5; ctx.fillRect(rx + win.x * scaleFactor, by + win.y * scaleFactor, 10 * scaleFactor, 15 * scaleFactor); } });
                ctx.globalAlpha = 1.0;
            }
        }

        class BreathEffect {
            constructor() { this.active = true; this.life = 1.0; this.text = "ÎÑ§Ïò®Ïùò Ìò∏Ìù°... Ï†ú1Ìòï..."; this.subText = "Î≤ΩÎ†•ÏùºÏÑ¨ (ÈúπÈùÇ‰∏ÄÈñÉ) ‚ö°"; }
            update(dt) { this.life -= 0.02 * dt; if (this.life <= 0) this.active = false; }
            draw() {
                if (!this.active) return;
                ctx.save(); ctx.fillStyle = `rgba(0, 0, 0, ${this.life * 0.7})`; ctx.fillRect(0, 0, width, height);
                const slashWidth = width * 1.5;
                ctx.translate(width/2, height/2); ctx.rotate(-Math.PI / 6); 
                ctx.shadowBlur = 50; ctx.shadowColor = '#ffff00'; ctx.fillStyle = '#fff'; ctx.globalAlpha = this.life;
                ctx.beginPath(); ctx.moveTo(-slashWidth/2, 0); ctx.lineTo(slashWidth/2, 0); ctx.lineWidth = 10 * scaleFactor; ctx.strokeStyle = '#fff'; ctx.stroke();
                ctx.rotate(Math.PI / 6); 
                ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
                ctx.font = `bold ${40 * scaleFactor}px 'Noto Sans KR', sans-serif`; ctx.fillText(this.text, 0, -50 * scaleFactor);
                ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ff0000'; ctx.font = `900 ${60 * scaleFactor}px 'Noto Sans KR', sans-serif`; ctx.fillText(this.subText, 0, 50 * scaleFactor);
                ctx.restore();
            }
        }

        class SpeedLine {
            constructor() { this.reset(); }
            reset() { this.x = Math.random() * width; this.y = Math.random() * height; this.length = 50 + Math.random() * 150; this.speed = 20 + Math.random() * 30; this.width = 1 + Math.random() * 2; this.alpha = 0; }
            update(ballSpeed) {
                if (ballSpeed > 15) {
                    this.alpha = Math.min(0.5, (ballSpeed - 15) * 0.05); this.x -= this.speed * (ballSpeed / 20); 
                    if (this.x < 0) { this.x = width + Math.random() * 200; this.y = Math.random() * height; }
                } else { this.alpha = 0; }
            }
            draw() {
                if (this.alpha <= 0) return;
                ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.rect(this.x, this.y, this.length, this.width); ctx.fill(); ctx.globalAlpha = 1.0; ctx.restore();
            }
        }

        class Shockwave {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.radius = 10; this.maxRadius = 100 * scaleFactor; this.alpha = 1.0; this.lineWidth = 5 * scaleFactor; }
            update(dt) { this.radius += 8 * scaleFactor * dt; this.alpha -= 0.08 * dt; this.lineWidth -= 0.2 * dt; if (this.lineWidth < 0) this.lineWidth = 0; }
            draw() {
                if (this.alpha <= 0) return;
                ctx.save(); ctx.globalAlpha = this.alpha; ctx.strokeStyle = this.color; ctx.lineWidth = this.lineWidth; ctx.beginPath(); ctx.arc(this.x - camera.x, this.y - camera.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
            }
        }

        class Star {
            constructor() { this.reset(); }
            reset() { this.x = Math.random() * width; this.y = Math.random() * height; this.size = Math.random() * 2; this.blinkSpeed = 0.01 + Math.random() * 0.05; this.alpha = Math.random(); this.parallax = 0.05 + Math.random() * 0.2; this.isShooting = false; }
            update(dt) {
                if (Math.random() < 0.001 && !this.isShooting) { this.isShooting = true; this.vx = -10 - Math.random() * 10; this.vy = 5 + Math.random() * 5; this.life = 60; }
                if (this.isShooting) { this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; if (this.life <= 0) { this.reset(); this.isShooting = false; } }
            }
            draw(ctx) {
                if(this.isShooting) {
                    ctx.save(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3); ctx.stroke(); ctx.restore();
                } else {
                    let rx = (this.x - camera.x * this.parallax) % width; if (rx < 0) rx += width;
                    let ry = this.y - camera.y * this.parallax;
                    this.alpha += this.blinkSpeed; if (this.alpha > 1 || this.alpha < 0) this.blinkSpeed *= -1;
                    ctx.save(); ctx.globalAlpha = ctx.globalAlpha * Math.abs(this.alpha); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(rx, ry, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }
            }
        }

        class Particle {
            constructor(x, y, color, speed, sizeObj = 2) {
                this.x = x; this.y = y; this.color = color;
                const a = Math.random() * Math.PI * 2; const v = Math.random() * speed * scaleFactor;
                this.vx = Math.cos(a) * v; this.vy = Math.sin(a) * v;
                this.life = 1.0; this.decay = 0.02 + Math.random() * 0.03;
                this.size = (sizeObj + Math.random() * 3) * scaleFactor;
            }
            update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.vy += 0.05 * scaleFactor * dt; this.life -= this.decay * dt; }
            draw() {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x - camera.x, this.y - camera.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1.0;
            }
        }

        class Booster {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type || 'speed';
                this.radius = 35 * scaleFactor; this.active = true; this.pulse = 0;
                if (this.type === 'speed') { this.color = '#ffd700'; this.glow = '#ff8800'; }
                else if (this.type === 'jump') { this.color = '#00ffff'; this.glow = '#0088ff'; }
                else if (this.type === 'blast') { this.color = '#ff0055'; this.glow = '#ff0000'; }
                // [Ï∂îÍ∞Ä] ÏÉàÎ°úÏö¥ Î∂ÄÏä§ÌÑ∞ ÏÜçÏÑ±
                else if (this.type === 'shield') { this.color = '#aa00ff'; this.glow = '#ff00ff'; }
                else if (this.type === 'float') { this.color = '#ffffff'; this.glow = '#aaffff'; }
            }
            draw() {
                if (!this.active) return;
                if (this.x - camera.x < -100 || this.x - camera.x > width + 100) return;
                if (this.y - camera.y < -100 || this.y - camera.y > height + 100) return;
                this.pulse += 0.1;
                const r = this.radius + Math.sin(this.pulse) * 5;
                ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.shadowBlur = 20; ctx.shadowColor = this.glow;
                ctx.beginPath();
                if (this.type === 'blast') {
                    ctx.moveTo(this.x - camera.x, this.y - camera.y - r); ctx.lineTo(this.x - camera.x + r, this.y - camera.y);
                    ctx.lineTo(this.x - camera.x, this.y - camera.y + r); ctx.lineTo(this.x - camera.x - r, this.y - camera.y); ctx.closePath();
                } else if (this.type === 'shield') {
                     // Ïâ¥Îìú Î™®Ïñë (Ïú°Í∞ÅÌòï)
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const bx = this.x - camera.x + Math.cos(angle) * r;
                        const by = this.y - camera.y + Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(bx, by); else ctx.lineTo(bx, by);
                    }
                    ctx.closePath();
                } else { ctx.arc(this.x - camera.x, this.y - camera.y, r, 0, Math.PI * 2); }
                ctx.stroke();
                ctx.fillStyle = this.color; ctx.globalAlpha = 0.2; ctx.fill(); ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff'; ctx.font = `bold ${16 * scaleFactor}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                let icon = '>>'; 
                if (this.type === 'jump') icon = 'UP'; if (this.type === 'blast') icon = '‚òÖ';
                if (this.type === 'shield') icon = 'SHD'; if (this.type === 'float') icon = 'FLT';
                ctx.fillText(icon, this.x - camera.x, this.y - camera.y);
            }
            checkCollision(p) {
                if (!this.active) return false;
                const dx = this.x - p.x; const dy = this.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < this.radius + p.radius) { this.active = false; return true; }
                return false;
            }
        }

        class Batter {
            constructor() { this.x = 200 * scaleFactor; this.y = height - 50; this.armAngle = -Math.PI / 2; this.swinging = false; this.swingSpeed = 0; this.idleTime = 0; }
            reset() { this.x = 200 * scaleFactor; this.y = height - 50; this.armAngle = -Math.PI * 0.65; this.swinging = false; this.swingSpeed = 0; this.idleTime = 0; }
            swing() { if (!this.swinging) { this.swinging = true; this.swingSpeed = 0.15; } }
            update(dt) {
                if (this.swinging) {
                    this.armAngle += this.swingSpeed * dt; this.swingSpeed += 0.05 * dt;
                    if (this.armAngle > Math.PI * 0.2) { this.swinging = false; this.armAngle = Math.PI * 0.2; if (gameState === STATE.DROPPING) endGame("MISS"); }
                } else if (gameState === STATE.READY || gameState === STATE.DROPPING) {
                     this.idleTime += dt * 0.05;
                     const breath = Math.sin(this.idleTime) * 0.05;
                     const targetAngle = -Math.PI * 0.65 + breath;
                     this.armAngle += (targetAngle - this.armAngle) * 0.1 * dt;
                }
            }
            draw() {
                const drawX = this.x - camera.x; const drawY = this.y - camera.y; const s = scaleFactor * CHAR_SCALE;
                if (drawX < -100 || drawX > width + 100) return;
                const breathY = Math.sin(this.idleTime) * 2 * s;
                ctx.save(); ctx.translate(drawX, drawY);
                ctx.strokeStyle = '#0ff'; ctx.fillStyle = '#000'; ctx.lineWidth = 3 * s;
                ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
                // Legs
                ctx.beginPath(); ctx.moveTo(-5*s, -55*s); ctx.lineTo(-20*s, -25*s); ctx.lineTo(-35*s, 0); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(5*s, -55*s); ctx.lineTo(25*s, -25*s); ctx.lineTo(30*s, 0); ctx.stroke();
                // Body
                ctx.save(); ctx.translate(0, breathY);
                ctx.fillStyle = '#051515'; ctx.beginPath(); ctx.moveTo(-12*s, -100*s); ctx.lineTo(12*s, -100*s); ctx.lineTo(6*s, -55*s); ctx.lineTo(-6*s, -55*s); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(0, -80*s, 5*s, 0, Math.PI * 2); ctx.fill();
                // Head
                ctx.save(); ctx.translate(0, -105*s); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 16*s, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.shadowColor = '#f0f'; ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.moveTo(7*s, -5*s); ctx.lineTo(16*s, -3*s); ctx.lineTo(16*s, 5*s); ctx.lineTo(7*s, 7*s); ctx.closePath(); ctx.fill(); ctx.restore();
                // Arm & Bat
                ctx.save(); ctx.translate(0, -95*s); ctx.rotate(this.armAngle);
                ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(30*s, 0); ctx.stroke();
                ctx.translate(30*s, 0); ctx.fillStyle = '#555'; ctx.fillRect(0, -5*s, 12*s, 10*s);
                ctx.shadowColor = '#0f0'; ctx.shadowBlur = 20;
                const batGrad = ctx.createLinearGradient(0, 0, 110*s, 0);
                batGrad.addColorStop(0, '#fff'); batGrad.addColorStop(0.3, '#0f0'); batGrad.addColorStop(1, 'rgba(0, 255, 0, 0.5)');
                ctx.fillStyle = batGrad; ctx.beginPath(); ctx.moveTo(12*s, -6*s); ctx.lineTo(110*s, -9*s); ctx.lineTo(115*s, 0); ctx.lineTo(110*s, 9*s); ctx.lineTo(12*s, 6*s); ctx.closePath(); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * s; ctx.beginPath(); ctx.moveTo(12*s, 0); ctx.lineTo(105*s, 0); ctx.stroke();
                ctx.restore(); 
                ctx.restore(); // Body end
                ctx.restore(); // Player end
            }
        }

        class Ball {
            constructor() { this.radius = 15; this.reset(); }
            reset() { 
                this.x = 200 * scaleFactor; this.y = -50 * scaleFactor; this.vx = 0; this.vy = 0; 
                this.rotation = 0; this.trail = []; this.isStopped = false; this.radius = 15 * scaleFactor; 
                // [Ï∂îÍ∞Ä] ÏÉÅÌÉú Î≥ÄÏàò
                this.hasShield = false;
                this.floatTimer = 0;
            }
            drop() { this.x = 200 * scaleFactor; this.y = -180 * scaleFactor; this.vx = 0; this.vy = 0; }
            hit(speed, angleDeg) {
                const rad = angleDeg * Math.PI / 180;
                this.vx = Math.cos(rad) * speed * scaleFactor;
                this.vy = Math.sin(rad) * speed * scaleFactor;
                camera.shake = 20; 
                shockwaves.push(new Shockwave(this.x, this.y, '#fff')); 
                for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#fff', 8));
            }
            update(dt) { 
                if (gameState === STATE.READY) return;
                if (gameState === STATE.DROPPING) {
                    this.vy += GRAVITY * 0.5 * dt; this.y += this.vy * dt;
                    if (this.y > height - 50) endGame("MISS");
                    return;
                }
                if (gameState === STATE.FLYING) {
                    this.x += this.vx * dt; this.y += this.vy * dt; 
                    
                    // [Ï∂îÍ∞Ä] ÌîåÎ°úÌä∏ ÏÉÅÌÉúÏùº Îïå Ï§ëÎ†• Î¨¥Ïãú
                    if (this.floatTimer > 0) {
                        this.floatTimer -= dt;
                        this.vy *= 0.9; // ÏàòÏßÅ ÏÜçÎèÑ Í∞êÏÜå (ÏïàÏ†ïÌôî)
                    } else {
                        this.vy += GRAVITY * dt; 
                    }

                    this.vx *= Math.pow(FRICTION_AIR, dt); this.vy *= Math.pow(FRICTION_AIR, dt);
                    this.rotation += this.vx * 0.1 * dt;
                    if (frameId % 3 === 0) { 
                        this.trail.push({x: this.x, y: this.y, alpha: 1.0}); 
                        if (this.trail.length > 25) this.trail.shift(); 
                    }
                    if (this.y + this.radius > height - 50) {
                        this.y = height - 50 - this.radius; this.vy *= -BOUNCE; this.vx *= Math.pow(FRICTION_GROUND, dt); 
                        if (combo > 0) { combo = 0; uiCombo.style.opacity = 0; }
                        if (Math.abs(this.vx) < 1.0 && Math.abs(this.vy) < 2.0) { this.vx = 0; this.vy = 0; this.stop(); }
                        else if (Math.abs(this.vx) > 0.5 && Math.random() > 0.7) particles.push(new Particle(this.x, this.y + 10, '#555', 2));
                    }
                    boosters.forEach(b => {
                        if (b.checkCollision(this)) {
                            combo++; uiCombo.innerText = `COMBO x${combo}`; uiCombo.style.opacity = 1;
                            const comboBonus = 1 + (combo * 0.1);
                            const boostPower = 15 * scaleFactor * comboBonus;
                            const jumpPower = 25 * scaleFactor * comboBonus;
                            const blastPower = 25 * scaleFactor * comboBonus;
                            if (b.type === 'speed') { Sound.playBoost(); this.vx += boostPower; this.vy = -12 * scaleFactor; showFeedback("SPEED!", "#ff0"); camera.shake = 5; shockwaves.push(new Shockwave(this.x, this.y, '#ff0')); for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, '#ff0', 8)); } 
                            else if (b.type === 'jump') { Sound.playJump(); this.vx += 5 * scaleFactor; this.vy = -jumpPower; showFeedback("HIGH JUMP!", "#0ff"); camera.shake = 8; shockwaves.push(new Shockwave(this.x, this.y, '#0ff')); for(let i=0; i<20; i++) particles.push(new Particle(this.x, this.y, '#0ff', 10)); }
                            else if (b.type === 'blast') { Sound.playBlast(); this.vx += blastPower; this.vy = -20 * scaleFactor; showFeedback("EXPLOSION!", "#f05"); camera.shake = 15; shockwaves.push(new Shockwave(this.x, this.y, '#f05')); for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, '#f05', 12)); }
                            else if (b.type === 'shield') { // [Ï∂îÍ∞Ä] Ïâ¥Îìú
                                Sound.playShield();
                                this.hasShield = true;
                                showFeedback("SHIELD UP!", "#a0f");
                                shockwaves.push(new Shockwave(this.x, this.y, '#a0f'));
                            }
                            else if (b.type === 'float') { // [Ï∂îÍ∞Ä] ÌîåÎ°úÌä∏
                                Sound.playFloat();
                                this.floatTimer = 120; // ÏïΩ 2Ï¥à
                                this.vx += 5 * scaleFactor; // ÏïΩÍ∞Ñ Í∞ÄÏÜç
                                showFeedback("FLOAT!", "#fff");
                                shockwaves.push(new Shockwave(this.x, this.y, '#fff'));
                            }
                        }
                    });
                    
                    obstacles.forEach(o => {
                        if(o.checkCollision(this)) {
                            // [Ï∂îÍ∞Ä] Ïâ¥Îìú ÏûàÏúºÎ©¥ Î∞©Ïñ¥
                            if (this.hasShield) {
                                this.hasShield = false;
                                showFeedback("BLOCKED!", "#a0f");
                                Sound.playShield(); // Î∞©Ïñ¥Ïùå
                                shockwaves.push(new Shockwave(this.x, this.y, '#a0f'));
                                return; 
                            }
                            
                            this.vx *= 0.5; this.vy *= 0.5; camera.shake = 15; showFeedback("CRASH!", "#f00"); Sound.playCrash(); shockwaves.push(new Shockwave(this.x, this.y, '#f00')); combo = 0; uiCombo.style.opacity = 0;
                        }
                    });
                }
            }
            stop() {
                if (this.isStopped) return;
                this.isStopped = true;
                gameState = STATE.STOPPED;
                currentScore = Math.floor((this.x - 200 * scaleFactor) / scaleFactor);
                checkBestScore();
                
                modalTitle.innerText = "GAME OVER";
                finalScoreEl.innerText = `${currentScore} m`;
                finalScoreEl.classList.remove('hidden');
                registerForm.classList.remove('hidden');
                rankingContainer.classList.add('hidden');
                btnRetry.classList.add('hidden');
                btnSubmit.disabled = false;
                btnSubmit.innerText = "Îû≠ÌÇπ Îì±Î°ù";
                modal.style.display = 'block';
            }
            draw() {
                if (gameState === STATE.DROPPING && this.y < 0) {
                    ctx.save(); ctx.fillStyle = '#f00'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00'; ctx.translate(this.x - camera.x, 30);
                    if (Math.floor(Date.now() / 100) % 2 === 0) { ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, -10); ctx.lineTo(0, 10); ctx.fill(); }
                    ctx.restore();
                }
                if (gameState === STATE.READY && this.y < 0) return;
                const drawX = this.x - camera.x; const drawY = this.y - camera.y;
                if (gameState === STATE.FLYING && this.trail.length > 1) {
                    if (Math.abs(this.vx) > 15) {
                        this.trail.forEach(t => {
                            ctx.fillStyle = `rgba(0, 255, 255, ${t.alpha * 0.2})`;
                            ctx.beginPath(); ctx.arc(t.x - camera.x, t.y - camera.y, this.radius * 0.8, 0, Math.PI*2); ctx.fill();
                            t.alpha -= 0.05;
                        });
                    }
                    ctx.beginPath(); ctx.moveTo(this.trail[0].x - camera.x, this.trail[0].y - camera.y);
                    for (let i = 1; i < this.trail.length; i++) ctx.lineTo(this.trail[i].x - camera.x, this.trail[i].y - camera.y);
                    if (combo >= 5) {
                        const grad = ctx.createLinearGradient(0,0,width,0);
                        grad.addColorStop(0, "red"); grad.addColorStop(0.2, "orange"); grad.addColorStop(0.4, "yellow"); grad.addColorStop(0.6, "green"); grad.addColorStop(0.8, "blue"); grad.addColorStop(1, "violet");
                        ctx.strokeStyle = grad; ctx.lineWidth = 4;
                    } else { ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; }
                    ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.stroke(); ctx.shadowBlur = 0;
                }
                
                // Í≥µ Í∑∏Î¶¨Í∏∞
                ctx.save(); ctx.translate(drawX, drawY); ctx.rotate(this.rotation);
                
                // [Ï∂îÍ∞Ä] Ïâ¥Îìú Ïù¥ÌéôÌä∏
                if (this.hasShield) {
                    ctx.shadowBlur = 20; ctx.shadowColor = '#a0f';
                    ctx.strokeStyle = '#a0f'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.stroke();
                }

                ctx.shadowBlur = 15; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff';
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2); ctx.fill();
                
                // [Ï∂îÍ∞Ä] ÌîåÎ°úÌä∏ ÏÉÅÌÉú ÎÇ†Í∞ú Ïù¥ÌéôÌä∏
                if (this.floatTimer > 0) {
                     ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
                     ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                     ctx.beginPath(); ctx.moveTo(-this.radius, 0); ctx.lineTo(-this.radius - 15, -10); ctx.stroke();
                     ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(this.radius + 15, -10); ctx.stroke();
                }

                ctx.restore();
            }
        }

        // --- Init Functions ---
        function init() {
            resize(); window.addEventListener('resize', resize);
            const inputHandler = (e) => {
                // ÌÅ¥Î¶≠ Î∞©ÏßÄ ÏòàÏô∏ Ï≤òÎ¶¨ Ï∂îÍ∞Ä
                if(e.target.closest('#ranking-modal') || e.target.closest('#btn-show-ranking') || e.target.closest('#btn-fullscreen')) return;
                Sound.init(); handleInput();
            };
            window.addEventListener('mousedown', inputHandler);
            window.addEventListener('touchstart', (e) => {
                 if(!e.target.closest('#ranking-modal') && !e.target.closest('#btn-show-ranking') && !e.target.closest('#btn-fullscreen')) e.preventDefault();
                 Sound.init(); handleInput();
            }, {passive: false});

            skyManager = new SkyManager();
            batter = new Batter(); ball = new Ball();
            for(let i=0; i<80; i++) stars.push(new Star());
            for(let i=0; i<20; i++) {
                let bw = 60 + Math.random() * 80; let bh = 100 + Math.random() * 300; let bx = i * 200 - 500; let bz = 1 + Math.random() * 2; 
                cityBuildings.push(new Building(bx, bw, bh, bz));
            }
            for(let i=0; i<20; i++) speedLines.push(new SpeedLine());
            initBoosters();
            requestAnimationFrame(loop);
        }

        function initBoosters() {
            boosters = [];
            obstacles = [];
            lastBoosterX = 600 * scaleFactor; 
            addBoosters(25); 
        }

        function addBoosters(count) {
             for(let i=0; i<count; i++) {
                let gap = (50 + Math.random() * 150) * scaleFactor;
                lastBoosterX += gap;
                let by = height - 100 - (Math.random() * 2000 * scaleFactor); 
                
                if (Math.random() > 0.95) {
                    obstacles.push(new Obstacle(lastBoosterX, by));
                } else {
                    let rand = Math.random();
                    let type = 'speed'; 
                    if (rand > 0.85) type = 'blast';  
                    else if (rand > 0.70) type = 'shield'; 
                    else if (rand > 0.55) type = 'float';
                    else if (rand > 0.30) type = 'jump'; 
                    
                    boosters.push(new Booster(lastBoosterX, by, type));
                }
            }
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            scaleFactor = Math.min(width, height) / 800; 
            if (scaleFactor < 0.6) scaleFactor = 0.6; if (scaleFactor > 1.2) scaleFactor = 1.2; 
            GRAVITY = GRAVITY_BASE * scaleFactor;
            if (batter) batter.reset(); if (ball) ball.reset();
        }

        function handleInput() {
            if (gameState === STATE.READY) {
                gameState = STATE.DROPPING; ball.drop(); uiMsg.classList.add('hidden');
            } else if (gameState === STATE.DROPPING) { attemptHit(); }
        }

        function attemptHit() {
            batter.swing(); 
            const shoulderY = batter.y - (95 * scaleFactor * CHAR_SCALE); 
            const hitZoneY = shoulderY + 10 * scaleFactor; 
            const distY = ball.y - hitZoneY; 

            if (Math.abs(distY) < 90 * scaleFactor) {
                let isPerfect = false;
                if (Math.abs(distY) < 20 * scaleFactor) {
                    isPerfect = true;
                    hitFreeze = 45; 
                    specialEffects.push(new BreathEffect());
                    Sound.playBreath();
                }

                gameState = STATE.FLYING;
                let power = 25 * scaleFactor; let angle = -45; 
                
                if (isPerfect) {
                    power = 40 * scaleFactor; angle = -45; 
                    showFeedback("PERFECT!", "#0ff"); Sound.playHit(true);
                } else {
                    power = (28 * scaleFactor) - (Math.abs(distY) * 0.15); 
                    if (distY < 0) { angle = -45 + (distY * 0.5); showFeedback("TOO EARLY", "#ff8"); } 
                    else { angle = -45 + (distY * 0.8); showFeedback("TOO LATE", "#f88"); }
                    Sound.playHit(false);
                }
                if (power < 10 * scaleFactor) power = 10 * scaleFactor;
                ball.hit(power / scaleFactor, angle); 
            }
        }

        function endGame(type) {
            gameState = STATE.STOPPED; 
            if (type === "MISS") {
                currentScore = 0;
                modalTitle.innerText = "GAME OVER";
                finalScoreEl.innerText = "MISS";
                finalScoreEl.classList.remove('hidden');
                registerForm.classList.remove('hidden');
                rankingContainer.classList.add('hidden');
                btnRetry.classList.add('hidden');
                btnSubmit.disabled = false;
                btnSubmit.innerText = "Îû≠ÌÇπ Îì±Î°ù";
                modal.style.display = 'block';
            }
        }

        function resetGame() {
            gameState = STATE.READY;
            camera.x = 0;
            camera.y = 0;
            batter.reset();
            ball.reset();
            combo = 0;
            uiCombo.style.opacity = 0;
            uiMsg.classList.remove('hidden');
            uiMsg.innerHTML = "ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥<br>Í≥µÏù¥ Îñ®Ïñ¥ÏßëÎãàÎã§!";
            modal.style.display = 'none';
            initBoosters();
        }

        function checkBestScore() {
            if (currentScore > bestDistance) {
                bestDistance = currentScore;
                uiBest.innerText = bestDistance;
            }
        }

        function showFeedback(text, color) {
            uiFeedback.innerText = text; uiFeedback.style.color = color; uiFeedback.style.textShadow = `0 0 20px ${color}`;
            uiFeedback.classList.remove('pop-anim'); void uiFeedback.offsetWidth; uiFeedback.classList.add('pop-anim');
        }

        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime; lastTime = timestamp;
            const dt = Math.min(deltaTime, 100) / (1000 / 60);

            if (hitFreeze > 0) {
                hitFreeze -= dt;
                specialEffects.forEach(e => e.update(dt));
                draw();
                specialEffects.forEach(e => e.draw());
            } else {
                update(dt);
                draw();
                specialEffects.forEach(e => e.draw());
            }
            
            frameId = requestAnimationFrame(loop);
        }

        function update(dt) {
            skyManager.update(dt);
            batter.update(dt); ball.update(dt);
            stars.forEach(s => s.update(dt)); 
            obstacles.forEach(o => o.update(dt));
            
            specialEffects.forEach((e, i) => {
                if(!e.active) specialEffects.splice(i, 1);
                else e.update(dt);
            });

            if (gameState === STATE.FLYING) {
                let targetCamX = ball.x - width * 0.2; if (targetCamX < 0) targetCamX = 0;
                
                // [ÏàòÏ†ïÎê®] Ïπ¥Î©îÎùº Ï∂îÏ†Å Î°úÏßÅ Í∞úÏÑ† (Í≥µÏù¥ ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÏßÄ ÏïäÎèÑÎ°ù)
                // 1. Ï∂îÏ†Å ÏÜçÎèÑ Ï¶ùÍ∞Ä (0.1 -> 0.15)
                camera.x += (targetCamX - camera.x) * 0.15 * dt;
                
                // 2. Í≥µÏù¥ ÌôîÎ©¥ Ïò§Î•∏Ï™Ω 70% ÏßÄÏ†êÏùÑ ÎÑòÏñ¥Í∞ÄÎ©¥ Ïπ¥Î©îÎùºÎ•º Í∞ïÏ†úÎ°ú Ïù¥Îèô (Hard Clamp)
                if (ball.x - camera.x > width * 0.7) {
                    camera.x = ball.x - width * 0.7;
                }

                let targetCamY = ball.y - height * 0.5; if (targetCamY > 0) targetCamY = 0; 
                camera.y += (targetCamY - camera.y) * 0.1 * dt;
                
                if (ball.x > lastBoosterX - width * 2) addBoosters(10); 
                
                if (boosters.length > 50) { while(boosters.length > 0 && boosters[0].x < ball.x - width * 2) boosters.shift(); }
                if (obstacles.length > 20) { while(obstacles.length > 0 && obstacles[0].x < ball.x - width * 2) obstacles.shift(); }
            } else { camera.y += (0 - camera.y) * 0.1 * dt; }
            if (camera.shake > 0) { camera.shake *= Math.pow(0.9, dt); if(camera.shake < 0.5) camera.shake = 0; }
            for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(dt); if (particles[i].life <= 0) particles.splice(i, 1); }
            for (let i = shockwaves.length - 1; i >= 0; i--) { shockwaves[i].update(dt); if (shockwaves[i].alpha <= 0) shockwaves.splice(i, 1); }
            const ballSpeed = Math.abs(ball.vx); speedLines.forEach(l => l.update(ballSpeed));
            
            // [Ï∂îÍ∞Ä] ÏÜçÎèÑ Î∞è Í≥†ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            if (gameState === STATE.FLYING || gameState === STATE.STOPPED) {
                let dist = Math.floor((ball.x - 200 * scaleFactor) / scaleFactor); if (dist < 0) dist = 0; uiScore.innerText = dist;
                
                // ÏÜçÎèÑ (Îã®Ïàú ÌîΩÏÖÄ Îã®ÏúÑÎ•º Ï†ÅÏ†àÌïú ÏàòÏπòÎ°ú Î≥ÄÌôòÌïòÏó¨ ÌëúÏãú)
                let speedKmh = Math.floor(Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy) * 2);
                uiSpeed.innerText = speedKmh;

                // Í≥†ÎèÑ (Î∞îÎã• Í∏∞Ï§Ä)
                let altitude = Math.floor((height - 50 - ball.y) / scaleFactor);
                if (altitude < 0) altitude = 0;
                uiHeight.innerText = altitude;
            }
        }

        function draw() {
            const shakeX = (Math.random() - 0.5) * camera.shake; const shakeY = (Math.random() - 0.5) * camera.shake;
            ctx.save(); ctx.translate(shakeX, shakeY);
            
            skyManager.draw(ctx);
            cityBuildings.forEach(b => b.draw()); 
            speedLines.forEach(l => l.draw());
            obstacles.forEach(o => o.draw()); 
            boosters.forEach(b => b.draw());

            const groundY = height - 50 - camera.y;
            const hueShift = (ball.x / (1000 * scaleFactor)) % 360;
            ctx.strokeStyle = `hsl(${300 + hueShift}, 100%, 50%)`; 
            ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle; ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(width, groundY); ctx.stroke();
            const gridSize = 100 * scaleFactor; const offsetX = camera.x % gridSize; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
            ctx.beginPath(); for (let i = -gridSize; i < width + gridSize; i += gridSize) { let x = i - offsetX; ctx.moveTo(x, groundY); ctx.lineTo(x - (width/2 - x)*2, height); } ctx.stroke(); ctx.shadowBlur = 0; ctx.globalAlpha = 1.0;
            
            if (gameState === STATE.DROPPING) {
                const hitZoneY = batter.y - (85 * scaleFactor * CHAR_SCALE); 
                ctx.fillStyle = 'rgba(0, 255, 0, 0.15)'; ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)'; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.arc(200 * scaleFactor, hitZoneY, 60 * scaleFactor, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; ctx.font = `12px Orbitron`; ctx.textAlign = 'center'; ctx.fillText("HIT HERE", 200 * scaleFactor, hitZoneY + 75 * scaleFactor);
            }
            batter.draw(); ball.draw();
            ctx.globalCompositeOperation = 'lighter'; particles.forEach(p => p.draw()); shockwaves.forEach(s => s.draw()); 
            ctx.globalCompositeOperation = 'source-over'; ctx.restore(); 
        }

        init();
    </script>
</body>
</html>
