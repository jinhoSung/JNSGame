<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 비행기 학습 - VFX & 저장 기능</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            margin-top: 10px;
        }
        #controls {
            width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 0 0 10px 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .stat-box {
            font-size: 14px;
        }
        button {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover {
            background: #ff6b81;
        }
        button.save-btn {
            background: #2ed573;
        }
        button.save-btn:hover {
            background: #7bed9f;
        }
        input[type="number"] {
            width: 50px;
            padding: 5px;
            border-radius: 5px;
            border: none;
            text-align: center;
        }
        #speedSlider {
            width: 80px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="controls">
        <div class="stat-box">
            세대: <span id="genDisplay">1</span> | 
            생존: <span id="aliveDisplay">0</span> | 
            최고 점수: <span id="scoreDisplay">0</span>
        </div>
        <div class="control-group">
            <span id="saveStatus" style="color: #2ed573; font-size: 12px;"></span>
            <label style="font-size: 12px;">개체수: <input type="number" id="popInput" value="100" min="10" max="500"></label>
            <label style="font-size: 12px;">속도: <input type="range" id="speedSlider" min="1" max="20" value="1"></label>
            <button class="save-btn" onclick="saveBestBrain()">저장</button>
            <button onclick="resetBrain()">초기화</button>
        </div>
    </div>

<script>
// ==========================================
// 1. 신경망 (Neural Network) 클래스
// ==========================================
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;

        this.weightsIH = new Float32Array(this.inputNodes * this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(this.hiddenNodes * this.outputNodes).map(() => Math.random() * 2 - 1);
        
        this.biasH = new Float32Array(this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(this.outputNodes).map(() => Math.random() * 2 - 1);
    }

    predict(inputArray) {
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) {
                sum += inputArray[j] * this.weightsIH[j * this.hiddenNodes + i];
            }
            sum += this.biasH[i];
            hidden[i] = Math.tanh(sum);
        }

        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) {
                sum += hidden[j] * this.weightsHO[j * this.outputNodes + i];
            }
            sum += this.biasO[i];
            output[i] = Math.tanh(sum);
        }
        return output;
    }

    clone() {
        let clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        clone.weightsIH.set(this.weightsIH);
        clone.weightsHO.set(this.weightsHO);
        clone.biasH.set(this.biasH);
        clone.biasO.set(this.biasO);
        return clone;
    }

    mutate(rate) {
        function mutateVal(val) {
            if (Math.random() < rate) {
                return val + (Math.random() * 2 - 1) * 0.5;
            }
            return val;
        }
        this.weightsIH = this.weightsIH.map(mutateVal);
        this.weightsHO = this.weightsHO.map(mutateVal);
        this.biasH = this.biasH.map(mutateVal);
        this.biasO = this.biasO.map(mutateVal);
    }
    
    static fromJSON(data) {
        let nn = new NeuralNetwork(data.inputNodes, data.hiddenNodes, data.outputNodes);
        nn.weightsIH = Float32Array.from(Object.values(data.weightsIH));
        nn.weightsHO = Float32Array.from(Object.values(data.weightsHO));
        nn.biasH = Float32Array.from(Object.values(data.biasH));
        nn.biasO = Float32Array.from(Object.values(data.biasO));
        return nn;
    }
}

// ==========================================
// 2. 게임 엔티티
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 800;
canvas.height = 500;

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.color = color;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.vx *= 0.95;
        this.vy *= 0.95;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Pipe {
    constructor(id) {
        this.id = id;
        this.spacing = 130; // 기본 간격
        this.top = Math.random() * (canvas.height / 2);
        this.x = canvas.width;
        this.w = 50;
        this.speed = 3;
        this.passed = false;
        
        // 장애물 타입 결정 (0: 일반, 1: 좁은통로, 2: 움직임)
        const rand = Math.random();
        this.type = 'normal';
        this.color = '#4cd137'; // Green
        
        if (rand < 0.2) {
            this.type = 'moving';
            this.color = '#00a8ff'; // Blue
            this.moveSpeed = 1.5;
            this.moveDir = Math.random() > 0.5 ? 1 : -1;
        } else if (rand < 0.4) {
            this.type = 'narrow';
            this.spacing = 100; // 더 좁음
            this.color = '#e84118'; // Red
        }

        this.bottom = canvas.height - (this.top + this.spacing);
    }

    update() {
        this.x -= this.speed;

        // 움직이는 장애물 로직
        if (this.type === 'moving') {
            this.top += this.moveSpeed * this.moveDir;
            // 상하 반전 체크
            if (this.top < 20 || this.top > canvas.height / 2 + 50) {
                this.moveDir *= -1;
            }
            // bottom 재계산 (간격 유지)
            this.bottom = canvas.height - (this.top + this.spacing);
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 0;
        
        // 위 파이프
        ctx.fillRect(this.x, 0, this.w, this.top);
        // 아래 파이프
        ctx.fillRect(this.x, canvas.height - this.bottom, this.w, this.bottom);
        
        // 입체감 장식
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(this.x + 40, 0, 10, this.top);
        ctx.fillRect(this.x + 40, canvas.height - this.bottom, 10, this.bottom);

        // 번호 표시
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.id, this.x + this.w/2, this.top - 10);
    }
}

class Plane {
    constructor(brain = null) {
        this.y = canvas.height / 2;
        this.x = 60;
        this.gravity = 0.6;
        this.lift = -10;
        this.velocity = 0;
        this.width = 20;
        this.height = 20;
        
        this.score = 0;
        this.fitness = 0;
        this.dead = false;

        if (brain) {
            this.brain = brain.clone();
        } else {
            this.brain = new NeuralNetwork(5, 8, 1);
        }

        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.trail = []; 
        this.trailLength = 20; // 꼬리 길이 증가
    }

    mutate(rate) {
        this.brain.mutate(rate);
    }

    think(pipes) {
        let closest = null;
        let closestD = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            let d = (pipes[i].x + pipes[i].w) - this.x;
            if (d > 0 && d < closestD) {
                closest = pipes[i];
                closestD = d;
            }
        }

        if (closest != null) {
            let inputs = [];
            inputs[0] = this.y / canvas.height;
            inputs[1] = this.velocity / 10;
            inputs[2] = closest.x / canvas.width;
            inputs[3] = closest.top / canvas.height;
            inputs[4] = (canvas.height - closest.bottom) / canvas.height;

            let output = this.brain.predict(inputs);
            if (output[0] > 0.5) {
                this.up();
            }
        }
    }

    up() {
        this.velocity += this.lift;
        if (this.velocity < -8) this.velocity = -8;
    }

    update() {
        this.velocity += this.gravity;
        this.y += this.velocity;
        this.score++;

        // 꼬리 궤적 로직 수정: 현재 위치 저장
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.trailLength) {
            this.trail.shift();
        }

        // 꼬리 이동: 모든 궤적 점을 왼쪽으로 이동시켜 속도감 연출
        for(let point of this.trail) {
            point.x -= 3; // 꼬리가 뒤로 밀려나는 속도
        }
    }

    draw(ctx, isHighScorer, fewSurvivors) {
        // 1. 꼬리 그리기
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for(let i=1; i<this.trail.length; i++) {
                let p = this.trail[i];
                // 부드러운 곡선
                // ctx.lineTo(p.x, p.y); 
                // 혹은 그냥 직선 연결
                ctx.lineTo(p.x, p.y);
            }
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // 2. 비행기 그리기
        ctx.fillStyle = this.color;
        
        if (isHighScorer || fewSurvivors) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-10, -5);
        ctx.fill();
        ctx.restore();

        ctx.shadowBlur = 0;
    }
}

// ==========================================
// 3. 게임 관리
// ==========================================
let totalPlanes = 100; // 초기값
let planes = [];
let savedPlanes = [];
let pipes = [];
let particles = [];
let generation = 1;
let highScore = 0;
let gameSpeed = 1;
let pipeCounter = 1; // 장애물 번호 카운터

const STORAGE_KEY = 'MyAI_Flyer_Brain';

function init() {
    // UI에서 개체수 읽어오기
    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;
    
    let bestBrainJSON = localStorage.getItem(STORAGE_KEY);
    planes = [];
    
    if (bestBrainJSON) {
        document.getElementById('saveStatus').innerText = "로드됨";
        let bestBrain = NeuralNetwork.fromJSON(JSON.parse(bestBrainJSON));
        
        for (let i = 0; i < totalPlanes; i++) {
            let p = new Plane(bestBrain);
            if (i > 0) p.mutate(0.1); 
            planes.push(p);
        }
    } else {
        document.getElementById('saveStatus').innerText = "새 시작";
        for (let i = 0; i < totalPlanes; i++) {
            planes.push(new Plane());
        }
    }
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetGame() {
    generation++;
    document.getElementById('genDisplay').innerText = generation;
    pipes = [];
    particles = [];
    pipeCounter = 1; // 파이프 번호 리셋 (원하면 계속 증가하게 해도 됨)
    
    savedPlanes.sort((a, b) => b.score - a.score);
    let bestOne = savedPlanes[0];
    
    if (bestOne.score > highScore) {
        highScore = bestOne.score;
        document.getElementById('scoreDisplay').innerText = highScore;
        saveBrainToLocal(bestOne.brain); 
    } else if (savedPlanes.length > 0) {
        saveBrainToLocal(bestOne.brain);
    }

    // 다음 세대 개체수 재확인
    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;

    planes = [];
    for (let i = 0; i < totalPlanes; i++) {
        let p = new Plane(bestOne.brain);
        if (i > 0) { 
             p.mutate(0.1); 
        }
        planes.push(p);
    }
    savedPlanes = [];
}

function saveBrainToLocal(brain) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(brain));
    let status = document.getElementById('saveStatus');
    status.innerText = "저장됨";
    status.style.opacity = 1;
    setTimeout(() => { status.style.opacity = 0.5; }, 1000);
}

function saveBestBrain() {
    let currentBest = planes[0];
    if (savedPlanes.length > 0) {
        let deadBest = savedPlanes.sort((a,b) => b.score - a.score)[0];
        if (!currentBest || deadBest.score > currentBest.score) {
            currentBest = deadBest;
        }
    }
    
    if (currentBest) {
        saveBrainToLocal(currentBest.brain);
    }
}

function resetBrain() {
    if(confirm("모든 학습 데이터를 지우고 처음부터 시작하시겠습니까?")) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
    }
}

function animate() {
    for (let n = 0; n < gameSpeed; n++) {
        // 파이프 생성
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 250) {
            pipes.push(new Pipe(pipeCounter++));
        }

        // 비행기 업데이트
        for (let i = planes.length - 1; i >= 0; i--) {
            let p = planes[i];
            p.think(pipes);
            p.update();

            let crashed = false;
            if (p.y > canvas.height || p.y < 0) crashed = true;

            for (let pipe of pipes) {
                if (p.x + 10 > pipe.x && p.x - 10 < pipe.x + pipe.w) {
                    if (p.y - 5 < pipe.top || p.y + 5 > canvas.height - pipe.bottom) {
                        crashed = true;
                    }
                }
            }

            if (crashed) {
                createExplosion(p.x, p.y, p.color);
                savedPlanes.push(planes.splice(i, 1)[0]);
            }
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
            pipes[i].update();
            if (pipes[i].x + pipes[i].w < 0) {
                pipes.splice(i, 1);
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        if (planes.length === 0) {
            resetGame();
            break;
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let pipe of pipes) pipe.draw(ctx);
    for (let p of particles) p.draw(ctx);

    let currentHighScore = 0;
    planes.forEach(p => { if(p.score > currentHighScore) currentHighScore = p.score; });
    let fewSurvivors = planes.length <= 5;

    for (let p of planes) {
        let isHighScorer = (p.score === currentHighScore) && (p.score > 0);
        p.draw(ctx, isHighScorer, fewSurvivors);
    }

    document.getElementById('aliveDisplay').innerText = planes.length;
    
    requestAnimationFrame(animate);
}

document.getElementById('speedSlider').addEventListener('input', (e) => {
    gameSpeed = parseInt(e.target.value);
});

init();
animate();

</script>
</body>
</html>
