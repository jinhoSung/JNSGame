<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 비행기 학습 - VFX & 저장 기능</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            margin-top: 10px;
        }
        #controls {
            width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 0 0 10px 10px;
        }
        .stat-box {
            font-size: 14px;
        }
        button {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover {
            background: #ff6b81;
        }
        button.save-btn {
            background: #2ed573;
        }
        button.save-btn:hover {
            background: #7bed9f;
        }
        #speedSlider {
            width: 100px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="controls">
        <div class="stat-box">
            세대: <span id="genDisplay">1</span> | 
            생존: <span id="aliveDisplay">0</span> | 
            최고 점수: <span id="scoreDisplay">0</span>
        </div>
        <div class="stat-box">
            <span id="saveStatus" style="color: #2ed573; margin-right: 10px;"></span>
            <label>게임 속도: <input type="range" id="speedSlider" min="1" max="10" value="1"></label>
            <button class="save-btn" onclick="saveBestBrain()">현재 뇌 저장</button>
            <button onclick="resetBrain()">학습 초기화</button>
        </div>
    </div>

<script>
// ==========================================
// 1. 간단한 신경망 (Neural Network) 클래스
// ==========================================
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;

        // 가중치(Weights) 초기화 (-1 ~ 1)
        this.weightsIH = new Float32Array(this.inputNodes * this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(this.hiddenNodes * this.outputNodes).map(() => Math.random() * 2 - 1);
        
        // 편향(Bias) 초기화
        this.biasH = new Float32Array(this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(this.outputNodes).map(() => Math.random() * 2 - 1);
    }

    // 예측 (Feed Forward)
    predict(inputArray) {
        // Input -> Hidden
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) {
                sum += inputArray[j] * this.weightsIH[j * this.hiddenNodes + i];
            }
            sum += this.biasH[i];
            hidden[i] = Math.tanh(sum); // 활성화 함수
        }

        // Hidden -> Output
        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) {
                sum += hidden[j] * this.weightsHO[j * this.outputNodes + i];
            }
            sum += this.biasO[i];
            output[i] = Math.tanh(sum);
        }
        return output;
    }

    // 복제 (Mutation 포함)
    clone() {
        let clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        // 가중치 복사
        clone.weightsIH.set(this.weightsIH);
        clone.weightsHO.set(this.weightsHO);
        clone.biasH.set(this.biasH);
        clone.biasO.set(this.biasO);
        return clone;
    }

    // 돌연변이 (Mutation)
    mutate(rate) {
        function mutateVal(val) {
            if (Math.random() < rate) {
                return val + (Math.random() * 2 - 1) * 0.5; // 약간 조정
            }
            return val;
        }
        this.weightsIH = this.weightsIH.map(mutateVal);
        this.weightsHO = this.weightsHO.map(mutateVal);
        this.biasH = this.biasH.map(mutateVal);
        this.biasO = this.biasO.map(mutateVal);
    }
    
    // 데이터 로드용 (JSON 객체에서 복원)
    static fromJSON(data) {
        let nn = new NeuralNetwork(data.inputNodes, data.hiddenNodes, data.outputNodes);
        nn.weightsIH = Float32Array.from(Object.values(data.weightsIH));
        nn.weightsHO = Float32Array.from(Object.values(data.weightsHO));
        nn.biasH = Float32Array.from(Object.values(data.biasH));
        nn.biasO = Float32Array.from(Object.values(data.biasO));
        return nn;
    }
}

// ==========================================
// 2. 게임 엔티티 (비행기, 파이프, 파티클)
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 800;
canvas.height = 500;

// 파티클 (폭발 효과)
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0; // 수명
        this.color = color;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.vx *= 0.95; // 마찰
        this.vy *= 0.95;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Pipe {
    constructor() {
        this.spacing = 120; // 파이프 사이 간격
        this.top = Math.random() * (canvas.height / 2);
        this.bottom = canvas.height - (this.top + this.spacing);
        this.x = canvas.width;
        this.w = 50;
        this.speed = 3;
        this.passed = false;
    }

    update() {
        this.x -= this.speed;
    }

    draw(ctx) {
        ctx.fillStyle = '#4cd137'; // 파이프 색
        ctx.shadowBlur = 0; // 파이프는 빛나지 않음
        ctx.fillRect(this.x, 0, this.w, this.top);
        ctx.fillRect(this.x, canvas.height - this.bottom, this.w, this.bottom);
        
        // 파이프 장식 (입체감)
        ctx.fillStyle = '#44bd32';
        ctx.fillRect(this.x + 5, 0, this.w - 10, this.top);
        ctx.fillRect(this.x + 5, canvas.height - this.bottom, this.w - 10, this.bottom);
    }
}

class Plane {
    constructor(brain = null) {
        this.y = canvas.height / 2;
        this.x = 60;
        this.gravity = 0.6;
        this.lift = -10;
        this.velocity = 0;
        this.width = 20;
        this.height = 20;
        
        this.score = 0;
        this.fitness = 0;
        this.dead = false;

        // 신경망
        if (brain) {
            this.brain = brain.clone();
        } else {
            // 입력: Y위치, 속도, 파이프거리X, 상단파이프Y, 하단파이프Y
            this.brain = new NeuralNetwork(5, 8, 1);
        }

        // 시각 효과용
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.trail = []; // 꼬리 궤적
        this.trailLength = 10;
    }

    mutate(rate) {
        this.brain.mutate(rate);
    }

    think(pipes) {
        // 가장 가까운 파이프 찾기
        let closest = null;
        let closestD = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            let d = (pipes[i].x + pipes[i].w) - this.x;
            if (d > 0 && d < closestD) {
                closest = pipes[i];
                closestD = d;
            }
        }

        if (closest != null) {
            let inputs = [];
            // 입력 데이터 정규화 (0~1 사이 값으로 변환 시도)
            inputs[0] = this.y / canvas.height;
            inputs[1] = this.velocity / 10;
            inputs[2] = closest.x / canvas.width;
            inputs[3] = closest.top / canvas.height;
            inputs[4] = (canvas.height - closest.bottom) / canvas.height;

            let output = this.brain.predict(inputs);
            // 출력이 0.5보다 크면 점프
            if (output[0] > 0.5) {
                this.up();
            }
        }
    }

    up() {
        this.velocity += this.lift;
        // 속도 제한
        if (this.velocity < -8) this.velocity = -8;
    }

    update() {
        this.velocity += this.gravity;
        this.y += this.velocity;
        this.score++;

        // 꼬리 궤적 저장
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.trailLength) {
            this.trail.shift();
        }
    }

    draw(ctx, isHighScorer, fewSurvivors) {
        // 1. 꼬리 그리기 (Trail Effect)
        ctx.beginPath();
        for(let i=0; i<this.trail.length; i++) {
            let p = this.trail[i];
            let alpha = i / this.trail.length; // 뒤로 갈수록 투명
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = alpha * 0.5;
            ctx.lineWidth = 3;
            if (i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // 2. 비행기 그리기
        ctx.fillStyle = this.color;
        
        // 빛나는 효과 (조건 충족 시)
        if (isHighScorer || fewSurvivors) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        // 비행기 회전
        // let angle = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
        // ctx.rotate(angle);
        
        // 삼각형 비행기
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-10, -5);
        ctx.fill();
        ctx.restore();

        // 그림자 초기화 (다른 객체에 영향 안 주게)
        ctx.shadowBlur = 0;
    }
}

// ==========================================
// 3. 게임 관리 (Game Controller)
// ==========================================
const TOTAL_PLANES = 100;
let planes = [];
let savedPlanes = [];
let pipes = [];
let particles = []; // 폭발 파티클
let generation = 1;
let highScore = 0;
let gameSpeed = 1;

// 로컬 스토리지 키
const STORAGE_KEY = 'MyAI_Flyer_Brain';

// 게임 초기화
function init() {
    // 1. 저장된 뇌가 있는지 확인
    let bestBrainJSON = localStorage.getItem(STORAGE_KEY);
    
    planes = [];
    if (bestBrainJSON) {
        document.getElementById('saveStatus').innerText = "저장된 데이터 로드됨";
        let bestBrain = NeuralNetwork.fromJSON(JSON.parse(bestBrainJSON));
        
        // 불러온 뇌를 기반으로 100마리 생성 (약간씩 변이)
        for (let i = 0; i < TOTAL_PLANES; i++) {
            let p = new Plane(bestBrain);
            if (i > 0) p.mutate(0.1); // 0번은 원본 유지, 나머지는 변이
            planes.push(p);
        }
    } else {
        document.getElementById('saveStatus').innerText = "새로운 학습 시작";
        for (let i = 0; i < TOTAL_PLANES; i++) {
            planes.push(new Plane());
        }
    }
}

// 폭발 생성 함수
function createExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetGame() {
    // 다음 세대 준비
    generation++;
    document.getElementById('genDisplay').innerText = generation;
    pipes = [];
    particles = [];
    
    // 가장 잘한 놈 찾기 (Fitness 기반)
    // 점수가 높은 순으로 정렬
    savedPlanes.sort((a, b) => b.score - a.score);
    let bestOne = savedPlanes[0];
    
    // 최고 점수 갱신 확인 및 저장
    if (bestOne.score > highScore) {
        highScore = bestOne.score;
        document.getElementById('scoreDisplay').innerText = highScore;
        // 최고 기록 경신 시 자동 저장
        saveBrainToLocal(bestOne.brain); 
    } else if (savedPlanes.length > 0) {
        // 최고 기록이 아니더라도, 이번 세대의 챔피언은 저장 (점진적 학습)
        // 단, 너무 못했으면 저장 안하는 로직을 넣을 수도 있음. 
        // 여기서는 그냥 이번 세대 1등을 저장.
        saveBrainToLocal(bestOne.brain);
    }

    planes = [];
    // 다음 세대 생성 전략:
    // 1등의 뇌를 그대로 복사하거나 변이시켜서 채움
    for (let i = 0; i < TOTAL_PLANES; i++) {
        let p = new Plane(bestOne.brain);
        if (i > 0) { // 0번은 엘리트 보존
             p.mutate(0.1); 
        }
        planes.push(p);
    }
    savedPlanes = [];
}

// 로컬 스토리지 저장
function saveBrainToLocal(brain) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(brain));
    let status = document.getElementById('saveStatus');
    status.innerText = "자동 저장 완료!";
    status.style.opacity = 1;
    setTimeout(() => { status.style.opacity = 0.5; }, 1000);
}

// 버튼용 수동 저장
function saveBestBrain() {
    // 현재 살아있는 애들 중 1등 혹은 죽은 애들 중 1등
    let currentBest = planes[0];
    // 죽은 애들이 있다면 비교
    if (savedPlanes.length > 0) {
        let deadBest = savedPlanes.sort((a,b) => b.score - a.score)[0];
        if (!currentBest || deadBest.score > currentBest.score) {
            currentBest = deadBest;
        }
    }
    
    if (currentBest) {
        saveBrainToLocal(currentBest.brain);
        alert("현재 최고 기록의 뇌가 저장되었습니다.");
    }
}

// 초기화 (Reset)
function resetBrain() {
    if(confirm("모든 학습 데이터를 지우고 처음부터 시작하시겠습니까?")) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
    }
}

// 게임 루프
function animate() {
    // 속도 조절 (루프를 여러 번 실행)
    for (let n = 0; n < gameSpeed; n++) {
        // 파이프 생성
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 250) {
            pipes.push(new Pipe());
        }

        // 비행기 업데이트
        for (let i = planes.length - 1; i >= 0; i--) {
            let p = planes[i];
            p.think(pipes);
            p.update();

            // 충돌 체크 (천장, 바닥, 파이프)
            let crashed = false;
            
            // 1. 화면 밖
            if (p.y > canvas.height || p.y < 0) crashed = true;

            // 2. 파이프 충돌
            for (let pipe of pipes) {
                if (p.x + 10 > pipe.x && p.x - 10 < pipe.x + pipe.w) {
                    if (p.y - 5 < pipe.top || p.y + 5 > canvas.height - pipe.bottom) {
                        crashed = true;
                    }
                }
            }

            if (crashed) {
                createExplosion(p.x, p.y, p.color); // 폭발 이펙트!
                savedPlanes.push(planes.splice(i, 1)[0]);
            }
        }

        // 파이프 업데이트
        for (let i = pipes.length - 1; i >= 0; i--) {
            pipes[i].update();
            if (pipes[i].x + pipes[i].w < 0) {
                pipes.splice(i, 1);
            }
        }

        // 파티클 업데이트
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // 전멸 체크
        if (planes.length === 0) {
            resetGame();
            break; // 이번 프레임 루프 중단
        }
    }

    // 그리기 (1번만 수행)
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 파이프 그리기
    for (let pipe of pipes) pipe.draw(ctx);

    // 파티클 그리기
    for (let p of particles) p.draw(ctx);

    // 비행기 그리기
    // 점수 상위권이거나, 남은 수가 적으면 빛나게 하기 위한 조건 계산
    let currentHighScore = 0;
    planes.forEach(p => { if(p.score > currentHighScore) currentHighScore = p.score; });

    let fewSurvivors = planes.length <= 5; // 5마리 이하 남았을 때

    for (let p of planes) {
        let isHighScorer = (p.score === currentHighScore) && (p.score > 0);
        p.draw(ctx, isHighScorer, fewSurvivors);
    }

    // UI 업데이트
    document.getElementById('aliveDisplay').innerText = planes.length;
    
    requestAnimationFrame(animate);
}

// 이벤트 리스너
document.getElementById('speedSlider').addEventListener('input', (e) => {
    gameSpeed = parseInt(e.target.value);
});

// 실행
init();
animate();

</script>
</body>
</html>
