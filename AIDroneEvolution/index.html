<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë¹„í–‰ê¸° í•™ìŠµ - ê³ ê¸‰ ì„¤ì • & ì €ì¥</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: row;
            height: 100vh;
        }
        
        #game-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
        }

        #sidebar {
            width: 340px; /* ë„ˆë¹„ ì•½ê°„ ì¦ê°€ */
            background: rgba(22, 33, 62, 0.95);
            border-left: 1px solid #30475e;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        h2, h3 {
            margin: 0 0 10px 0;
            color: #00ffcc;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
            border-bottom: 1px solid #30475e;
            padding-bottom: 5px;
        }

        h2 { font-size: 1.2rem; color: #fff; border: none; }

        .control-group {
            background: #1f2a40;
            padding: 12px;
            border-radius: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #b0c4de;
        }
        .stat-val { font-weight: bold; color: #fff; }

        label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            margin-top: 8px;
            color: #d1d5db;
        }

        input[type="range"] {
            width: 45%;
            height: 4px;
            background: #30475e;
            border-radius: 2px;
            appearance: none;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="number"] {
            width: 50px;
            background: #0f1526;
            border: 1px solid #30475e;
            color: white;
            padding: 4px;
            border-radius: 4px;
            text-align: center;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            background: #ff4757;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            width: 100%;
        }
        button:hover { opacity: 0.9; }
        button.save-btn { background: #2ed573; }
        button.reset-btn { background: #535c68; }

        .value-display {
            font-size: 0.8rem;
            color: #00ffcc;
            width: 35px;
            text-align: right;
        }
        
        .hint {
            font-size: 0.7rem; color: #666; margin-bottom: 5px; display: block;
        }
    </style>
</head>
<body>

    <div id="game-area">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div id="sidebar">
        <div>
            <h2>AI í•™ìŠµ ì œì–´ ì„¼í„°</h2>
            <div style="font-size: 0.8rem; color: #aaa;">Neural Evolution Dashboard V2</div>
        </div>

        <!-- 1. í•™ìŠµ í˜„í™© -->
        <div class="control-group">
            <h3>ğŸ“Š í•™ìŠµ í˜„í™©</h3>
            <div class="stat-row"><span>í˜„ì¬ ì„¸ëŒ€</span><span class="stat-val" id="genDisplay">1</span></div>
            <div class="stat-row"><span>ìƒì¡´ ê°œì²´</span><span class="stat-val" id="aliveDisplay">0</span></div>
            <div class="stat-row"><span>ìµœê³  ì ìˆ˜</span><span class="stat-val" id="scoreDisplay">0</span></div>
            <div class="stat-row"><span id="saveStatus" style="color: #2ed573;">ëŒ€ê¸°ì¤‘...</span></div>
        </div>

        <!-- 2. ì‹ ê²½ë§ ì„¤ì • -->
        <div class="control-group">
            <h3>ğŸ§  ì‹ ê²½ë§ (Brain)</h3>
            <label>
                ê°œì²´ìˆ˜ (Pop)
                <input type="number" id="popInput" value="100" min="10" max="500">
            </label>
            <label>
                ë³€ì´ í™•ë¥  (Rate)
                <input type="range" id="mutationRate" min="0.01" max="1.0" step="0.01" value="0.1">
                <span class="value-display" id="val_mutationRate">0.1</span>
            </label>
            <label>
                ë³€ì´ ê°•ë„ (Strength)
                <input type="range" id="mutationStrength" min="0.1" max="2.0" step="0.1" value="0.5">
                <span class="value-display" id="val_mutationStrength">0.5</span>
            </label>
        </div>

        <!-- 3. ë¬¼ë¦¬/í™˜ê²½ ì„¤ì • -->
        <div class="control-group">
            <h3>ğŸŒ ë¬¼ë¦¬ ì—”ì§„ (Physics)</h3>
            <label>
                ê²Œì„ ì†ë„ (Speed)
                <input type="range" id="gameSpeed" min="1" max="50" step="1" value="1">
                <span class="value-display" id="val_gameSpeed">x1</span>
            </label>
            <label>
                ì¤‘ë ¥ (Gravity)
                <input type="range" id="gravity" min="0.1" max="1.5" step="0.1" value="0.6">
                <span class="value-display" id="val_gravity">0.6</span>
            </label>
            <label>
                ì í”„ í˜ (Lift)
                <input type="range" id="lift" min="-20" max="-5" step="1" value="-10">
                <span class="value-display" id="val_lift">-10</span>
            </label>
        </div>

        <!-- 4. ì¥ì• ë¬¼ ì„¤ì • (í™•ì¥ë¨) -->
        <div class="control-group">
            <h3>ğŸš§ ì¥ì• ë¬¼ (Obstacles)</h3>
            <label>
                ìˆ˜ì§ í†µë¡œ ê°„ê²© (Gap)
                <input type="range" id="pipeGap" min="80" max="200" step="10" value="130">
                <span class="value-display" id="val_pipeGap">130</span>
            </label>
            <label>
                ì´ë™ ì†ë„ (Speed)
                <input type="range" id="pipeSpeed" min="1" max="10" step="1" value="3">
                <span class="value-display" id="val_pipeSpeed">3</span>
            </label>
            
            <hr style="border: 0; border-top: 1px solid #30475e; margin: 10px 0;">
            
            <label>
                ë“±ì¥ ê°„ê²© (Distance)
                <input type="range" id="pipeDistance" min="150" max="400" step="10" value="250">
                <span class="value-display" id="val_pipeDistance">250</span>
            </label>
            <span class="hint">ë‚®ì„ìˆ˜ë¡ ì¥ì• ë¬¼ì´ ì´˜ì´˜í•˜ê²Œ(ìì£¼) ë‚˜ì˜µë‹ˆë‹¤.</span>

            <label>
                íŠ¹ìˆ˜ ì¥ì• ë¬¼ í™•ë¥  (Complex)
                <input type="range" id="specialChance" min="0" max="1.0" step="0.1" value="0.3">
                <span class="value-display" id="val_specialChance">0.3</span>
            </label>
            <span class="hint">ì›€ì§ì´ê±°ë‚˜ ë³€í˜•ë˜ëŠ” ì¥ì• ë¬¼ì˜ ë“±ì¥ ë¹ˆë„ì…ë‹ˆë‹¤.</span>
        </div>

        <!-- ë²„íŠ¼ -->
        <div class="btn-group">
            <button class="save-btn" onclick="saveBestBrain()">ğŸ’¾ ìµœê³  ê¸°ë¡ ì €ì¥</button>
            <button class="reset-btn" onclick="resetBrain()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
        </div>
    </div>

<script>
// ==========================================
// 0. ì „ì—­ ì„¤ì • (Config)
// ==========================================
const CONFIG = {
    mutationRate: 0.1,
    mutationStrength: 0.5,
    gameSpeed: 1,
    gravity: 0.6,
    lift: -10,
    pipeGap: 130,       // ìˆ˜ì§ ê°„ê²©
    pipeSpeed: 3,
    pipeDistance: 250,  // ìˆ˜í‰ ë“±ì¥ ê°„ê²© (ë°€ë„)
    specialChance: 0.3  // íŠ¹ìˆ˜ ì¥ì• ë¬¼ í™•ë¥ 
};

// UI ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
function bindInput(id, configKey, displayId) {
    const input = document.getElementById(id);
    const display = document.getElementById(displayId);
    
    input.addEventListener('input', (e) => {
        CONFIG[configKey] = parseFloat(e.target.value);
        if(display) display.innerText = CONFIG[configKey];
        if(id === 'gameSpeed') display.innerText = 'x' + CONFIG[configKey];
    });
}

const inputs = [
    ['mutationRate', 'mutationRate', 'val_mutationRate'],
    ['mutationStrength', 'mutationStrength', 'val_mutationStrength'],
    ['gameSpeed', 'gameSpeed', 'val_gameSpeed'],
    ['gravity', 'gravity', 'val_gravity'],
    ['lift', 'lift', 'val_lift'],
    ['pipeGap', 'pipeGap', 'val_pipeGap'],
    ['pipeSpeed', 'pipeSpeed', 'val_pipeSpeed'],
    ['pipeDistance', 'pipeDistance', 'val_pipeDistance'],
    ['specialChance', 'specialChance', 'val_specialChance']
];

inputs.forEach(item => bindInput(item[0], item[1], item[2]));


// ==========================================
// 1. ì‹ ê²½ë§ (Neural Network)
// ==========================================
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;

        this.weightsIH = new Float32Array(this.inputNodes * this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(this.hiddenNodes * this.outputNodes).map(() => Math.random() * 2 - 1);
        
        this.biasH = new Float32Array(this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(this.outputNodes).map(() => Math.random() * 2 - 1);
    }

    predict(inputArray) {
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) {
                sum += inputArray[j] * this.weightsIH[j * this.hiddenNodes + i];
            }
            sum += this.biasH[i];
            hidden[i] = Math.tanh(sum);
        }

        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) {
                sum += hidden[j] * this.weightsHO[j * this.outputNodes + i];
            }
            sum += this.biasO[i];
            output[i] = Math.tanh(sum);
        }
        return output;
    }

    clone() {
        let clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        clone.weightsIH.set(this.weightsIH);
        clone.weightsHO.set(this.weightsHO);
        clone.biasH.set(this.biasH);
        clone.biasO.set(this.biasO);
        return clone;
    }

    mutate() {
        const rate = CONFIG.mutationRate;
        const strength = CONFIG.mutationStrength;

        function mutateVal(val) {
            if (Math.random() < rate) {
                return val + (Math.random() * 2 - 1) * strength;
            }
            return val;
        }
        this.weightsIH = this.weightsIH.map(mutateVal);
        this.weightsHO = this.weightsHO.map(mutateVal);
        this.biasH = this.biasH.map(mutateVal);
        this.biasO = this.biasO.map(mutateVal);
    }
    
    static fromJSON(data) {
        let nn = new NeuralNetwork(data.inputNodes, data.hiddenNodes, data.outputNodes);
        nn.weightsIH = Float32Array.from(Object.values(data.weightsIH));
        nn.weightsHO = Float32Array.from(Object.values(data.weightsHO));
        nn.biasH = Float32Array.from(Object.values(data.biasH));
        nn.biasO = Float32Array.from(Object.values(data.biasO));
        return nn;
    }
}

// ==========================================
// 2. ê²Œì„ ì—”í‹°í‹° (ì—…ë°ì´íŠ¸ë¨)
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 800;
canvas.height = 500;

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.color = color;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Pipe {
    constructor(id) {
        this.id = id;
        this.spacing = CONFIG.pipeGap; 
        this.top = Math.random() * (canvas.height / 2);
        this.x = canvas.width;
        this.w = 50;
        
        // ê¸°ë³¸ê°’
        this.type = 'normal';
        this.color = '#4cd137'; // Green
        this.moveSpeed = 0;
        this.angle = 0;
        this.baseTop = this.top; // ì›€ì§ì„ ê³„ì‚° ê¸°ì¤€ì 
        this.baseSpacing = this.spacing;

        // íŠ¹ìˆ˜ ì¥ì• ë¬¼ í™•ë¥  ì²´í¬
        if (Math.random() < CONFIG.specialChance) {
            const typeRoll = Math.random();
            
            if (typeRoll < 0.33) {
                // Type 1: Moving (ìœ„ì•„ë˜ ì„ í˜• ì´ë™)
                this.type = 'moving';
                this.color = '#00a8ff'; // Blue
                this.moveSpeed = 1.5;
                this.moveDir = Math.random() > 0.5 ? 1 : -1;
            } else if (typeRoll < 0.66) {
                // Type 2: Narrow (ì¢ì€ í†µë¡œ)
                this.type = 'narrow';
                this.spacing = CONFIG.pipeGap * 0.7; // 30% ë” ì¢ìŒ
                this.color = '#e84118'; // Red
                this.baseSpacing = this.spacing;
            } else {
                // Type 3: Sine Wave (ë¬¼ê²° ì´ë™)
                this.type = 'sine';
                this.color = '#9c88ff'; // Purple
                this.angle = 0;
            }
        }

        this.updateBottom();
    }

    updateBottom() {
        this.bottom = canvas.height - (this.top + this.spacing);
    }

    update() {
        this.x -= CONFIG.pipeSpeed;

        // ì¥ì• ë¬¼ ìœ í˜•ë³„ ë™ì‘
        if (this.type === 'moving') {
            this.top += this.moveSpeed * this.moveDir;
            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ë°˜ì „
            if (this.top < 20 || this.top > canvas.height / 2 + 50) {
                this.moveDir *= -1;
            }
            this.updateBottom();
        } 
        else if (this.type === 'sine') {
            this.angle += 0.05;
            // ê¸°ì¤€ì (baseTop)ì„ ì¤‘ì‹¬ìœ¼ë¡œ ìœ„ì•„ë˜ 50px ì§„ë™
            this.top = this.baseTop + Math.sin(this.angle) * 50;
            this.updateBottom();
        }
        // NarrowëŠ” ì›€ì§ì´ì§€ ì•Šì§€ë§Œ ê°„ê²©ì´ ì¢ìŒ (ìƒì„±ì‹œ ì²˜ë¦¬ë¨)
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        
        // ìœ— íŒŒì´í”„
        ctx.fillRect(this.x, 0, this.w, this.top);
        // ì•„ë« íŒŒì´í”„
        ctx.fillRect(this.x, canvas.height - this.bottom, this.w, this.bottom);
        
        // íŒŒì´í”„ ì¥ì‹
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(this.x + 40, 0, 10, this.top);
        ctx.fillRect(this.x + 40, canvas.height - this.bottom, 10, this.bottom);
        
        // íŠ¹ìˆ˜ ì¥ì• ë¬¼ í‘œì‹œ
        if(this.type !== 'normal') {
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            let label = this.type === 'moving' ? 'MOVE' : (this.type === 'sine' ? 'SINE' : 'NARROW');
            ctx.fillText(label, this.x + 5, 15);
        }
    }
}

class Plane {
    constructor(brain = null) {
        this.y = canvas.height / 2;
        this.x = 60;
        this.velocity = 0;
        this.width = 20;
        this.height = 20;
        
        this.score = 0;
        this.dead = false;

        if (brain) {
            this.brain = brain.clone();
        } else {
            this.brain = new NeuralNetwork(5, 8, 1);
        }

        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.trail = []; 
        this.trailLength = 20;
    }

    mutate() {
        this.brain.mutate();
    }

    think(pipes) {
        let closest = null;
        let closestD = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            let d = (pipes[i].x + pipes[i].w) - this.x;
            if (d > 0 && d < closestD) {
                closest = pipes[i];
                closestD = d;
            }
        }

        if (closest != null) {
            let inputs = [];
            // ì…ë ¥ 1: ë‚´ ë†’ì´
            inputs[0] = this.y / canvas.height;
            // ì…ë ¥ 2: ë‚´ ì†ë„
            inputs[1] = this.velocity / 10;
            // ì…ë ¥ 3: íŒŒì´í”„ê¹Œì§€ ê±°ë¦¬
            inputs[2] = closest.x / canvas.width;
            // ì…ë ¥ 4: ìœ„ íŒŒì´í”„ ëì 
            inputs[3] = closest.top / canvas.height;
            // ì…ë ¥ 5: ì•„ë˜ íŒŒì´í”„ ì‹œì‘ì 
            inputs[4] = (canvas.height - closest.bottom) / canvas.height;

            let output = this.brain.predict(inputs);
            if (output[0] > 0.5) {
                this.up();
            }
        }
    }

    up() {
        this.velocity += CONFIG.lift;
    }

    update() {
        this.velocity += CONFIG.gravity;
        this.y += this.velocity;
        this.score++;

        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.trailLength) {
            this.trail.shift();
        }
        for(let point of this.trail) {
            point.x -= CONFIG.pipeSpeed;
        }
    }

    draw(ctx, isHighScorer, fewSurvivors) {
        // ê¼¬ë¦¬
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for(let i=1; i<this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // ë³¸ì²´
        ctx.fillStyle = this.color;
        if (isHighScorer || fewSurvivors) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-10, -5);
        ctx.fill();
        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

// ==========================================
// 3. ê²Œì„ ê´€ë¦¬ (Game Manager)
// ==========================================
let totalPlanes = 100;
let planes = [];
let savedPlanes = [];
let pipes = [];
let particles = [];
let generation = 1;
let highScore = 0;
let pipeCounter = 1;

const STORAGE_KEY = 'MyAI_Flyer_Pro_Brain'; // í‚¤ ë³€ê²½ (ì„¤ì • êµ¬ì¡° ë°”ë€œ)

function init() {
    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;
    
    let bestBrainJSON = localStorage.getItem(STORAGE_KEY);
    planes = [];
    
    if (bestBrainJSON) {
        document.getElementById('saveStatus').innerText = "ë¡œë“œ ì™„ë£Œ";
        let bestBrain = NeuralNetwork.fromJSON(JSON.parse(bestBrainJSON));
        
        for (let i = 0; i < totalPlanes; i++) {
            let p = new Plane(bestBrain);
            if (i > 0) p.mutate();
            planes.push(p);
        }
    } else {
        document.getElementById('saveStatus').innerText = "ìƒˆë¡œìš´ ì‹œì‘";
        for (let i = 0; i < totalPlanes; i++) {
            planes.push(new Plane());
        }
    }
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetGame() {
    generation++;
    document.getElementById('genDisplay').innerText = generation;
    pipes = [];
    particles = [];
    pipeCounter = 1;
    
    savedPlanes.sort((a, b) => b.score - a.score);
    let bestOne = savedPlanes[0];
    
    if (bestOne.score > highScore) {
        highScore = bestOne.score;
        document.getElementById('scoreDisplay').innerText = highScore;
        saveBrainToLocal(bestOne.brain); 
    } else if (savedPlanes.length > 0) {
        saveBrainToLocal(bestOne.brain);
    }

    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;
    planes = [];
    
    for (let i = 0; i < totalPlanes; i++) {
        let p = new Plane(bestOne.brain);
        if (i > 0) { 
             p.mutate();
        }
        planes.push(p);
    }
    savedPlanes = [];
}

function saveBrainToLocal(brain) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(brain));
    let status = document.getElementById('saveStatus');
    status.innerText = "ìë™ ì €ì¥ë¨";
    status.style.opacity = 1;
    status.style.color = '#2ed573';
}

function saveBestBrain() {
    let currentBest = planes[0];
    if (savedPlanes.length > 0) {
        let deadBest = savedPlanes.sort((a,b) => b.score - a.score)[0];
        if (!currentBest || deadBest.score > currentBest.score) {
            currentBest = deadBest;
        }
    }
    if (currentBest) {
        saveBrainToLocal(currentBest.brain);
        alert(`ìµœê³  ì ìˆ˜ ${currentBest.score}ì ì˜ ì‹ ê²½ë§ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    }
}

function resetBrain() {
    if(confirm("ëª¨ë“  í•™ìŠµ ë°ì´í„°ì™€ ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
    }
}

function animate() {
    for (let n = 0; n < CONFIG.gameSpeed; n++) {
        
        // íŒŒì´í”„ ìƒì„± ë¡œì§ (ê±°ë¦¬ ì„¤ì • ë°˜ì˜)
        // ë§ˆì§€ë§‰ íŒŒì´í”„ì˜ Xì¢Œí‘œê°€ 'ì „ì²´ ë„ˆë¹„ - ë“±ì¥ê°„ê²©' ë³´ë‹¤ ì‘ì•„ì§€ë©´ ìƒì„±
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - CONFIG.pipeDistance) {
            pipes.push(new Pipe(pipeCounter++));
        }

        // ë¹„í–‰ê¸° ì—…ë°ì´íŠ¸
        for (let i = planes.length - 1; i >= 0; i--) {
            let p = planes[i];
            p.think(pipes);
            p.update();

            let crashed = false;
            // ë°”ë‹¥/ì²œì¥ ì¶©ëŒ
            if (p.y > canvas.height || p.y < 0) crashed = true;

            // íŒŒì´í”„ ì¶©ëŒ
            for (let pipe of pipes) {
                if (p.x + 10 > pipe.x && p.x - 10 < pipe.x + pipe.w) {
                    if (p.y - 5 < pipe.top || p.y + 5 > canvas.height - pipe.bottom) {
                        crashed = true;
                    }
                }
            }

            if (crashed) {
                createExplosion(p.x, p.y, p.color);
                savedPlanes.push(planes.splice(i, 1)[0]);
            }
        }

        // íŒŒì´í”„ ì—…ë°ì´íŠ¸
        for (let i = pipes.length - 1; i >= 0; i--) {
            pipes[i].update();
            if (pipes[i].x + pipes[i].w < 0) {
                pipes.splice(i, 1);
            }
        }

        // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        if (planes.length === 0) {
            resetGame();
            break;
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let pipe of pipes) pipe.draw(ctx);
    for (let p of particles) p.draw(ctx);

    let currentHighScore = 0;
    planes.forEach(p => { if(p.score > currentHighScore) currentHighScore = p.score; });
    let fewSurvivors = planes.length <= 5;

    for (let p of planes) {
        let isHighScorer = (p.score === currentHighScore) && (p.score > 0);
        p.draw(ctx, isHighScorer, fewSurvivors);
    }

    document.getElementById('aliveDisplay').innerText = planes.length;
    
    requestAnimationFrame(animate);
}

init();
animate();

</script>
</body>
</html>
