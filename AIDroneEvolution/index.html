<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ë¹„í–‰ê¸° í•™ìŠµ - UI í† ê¸€ ê¸°ëŠ¥</title>
    <style>
        /* ê¸°ë³¸ ì„¤ì • */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a2e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* ì „ì²´ í˜ì´ì§€ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }

        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        #main-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
            transition: all 0.3s ease; /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ íš¨ê³¼ */
        }
        
        /* ê²Œì„ ì˜ì—­ */
        #game-area {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
        }

        /* ì‚¬ì´ë“œë°” ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #sidebar {
            width: 340px;
            min-width: 300px;
            background: rgba(22, 33, 62, 0.98);
            border-left: 1px solid #30475e;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
            transition: all 0.3s ease; /* ë¶€ë“œëŸ¬ìš´ ì—´ë¦¼/ë‹«í˜ */
        }

        /* UI ìˆ¨ê¹€ í´ë˜ìŠ¤ */
        .hidden-ui {
            display: none !important;
        }

        /* í† ê¸€ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        #toggle-ui-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(0, 255, 204, 0.2);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }

        #toggle-ui-btn:hover {
            background: rgba(0, 255, 204, 0.4);
            transform: rotate(90deg);
        }

        /* ëª¨ë°”ì¼ìš© ìŠ¤íƒ€ì¼ */
        @media (max-width: 900px) {
            #main-container {
                flex-direction: column;
            }

            #game-area {
                flex: 1;
                min-height: 200px;
            }

            #sidebar {
                width: 100%;
                height: 40%;
                min-height: 250px;
                border-left: none;
                border-top: 1px solid #30475e;
                padding: 15px;
            }
        }

        /* UI ìš”ì†Œ ìŠ¤íƒ€ì¼ë“¤ */
        h2, h3 { margin: 0 0 10px 0; color: #00ffcc; text-transform: uppercase; font-size: 0.9rem; letter-spacing: 1px; border-bottom: 1px solid #30475e; padding-bottom: 5px; }
        h2 { font-size: 1.2rem; color: #fff; border: none; }
        .control-group { background: #1f2a40; padding: 12px; border-radius: 8px; flex-shrink: 0; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; color: #b0c4de; }
        .stat-val { font-weight: bold; color: #fff; }
        label { display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; margin-top: 8px; color: #d1d5db; }
        input[type="range"] { width: 45%; height: 15px; -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #30475e; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #00ffcc; border-radius: 50%; cursor: pointer; margin-top: -8px; box-shadow: 0 0 5px rgba(0,255,204,0.5); }
        input[type="number"] { width: 50px; background: #0f1526; border: 1px solid #30475e; color: white; padding: 4px; border-radius: 4px; text-align: center; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; flex-shrink: 0; padding-bottom: 20px; }
        button { background: #ff4757; color: white; border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-weight: bold; transition: 0.2s; width: 100%; font-size: 0.9rem; }
        button:hover { opacity: 0.9; }
        button.save-btn { background: #2ed573; }
        button.reset-btn { background: #535c68; }
        .value-display { font-size: 0.8rem; color: #00ffcc; width: 35px; text-align: right; }
        .hint { font-size: 0.7rem; color: #666; margin-bottom: 5px; display: block; }
    </style>
</head>
<body>

<!-- í† ê¸€ ë²„íŠ¼ -->
<button id="toggle-ui-btn" title="ì„¤ì • íŒ¨ë„ í† ê¸€">âš™ï¸</button>

<div id="main-container">
    <div id="game-area">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div id="sidebar">
        <div>
            <h2>AI í•™ìŠµ ì œì–´ ì„¼í„°</h2>
            <div style="font-size: 0.8rem; color: #aaa;">Neural Evolution Dashboard V2</div>
        </div>

        <!-- 1. í•™ìŠµ í˜„í™© -->
        <div class="control-group">
            <h3>ğŸ“Š í•™ìŠµ í˜„í™©</h3>
            <div class="stat-row"><span>í˜„ì¬ ì„¸ëŒ€</span><span class="stat-val" id="genDisplay">1</span></div>
            <div class="stat-row"><span>ìƒì¡´ ê°œì²´</span><span class="stat-val" id="aliveDisplay">0</span></div>
            <div class="stat-row"><span>í˜„ì¬ ì ìˆ˜</span><span class="stat-val" id="currentScoreDisplay">0</span></div>
            <div class="stat-row"><span>ìµœê³  ì ìˆ˜</span><span class="stat-val" id="scoreDisplay">0</span></div>
            <div class="stat-row"><span id="saveStatus" style="color: #2ed573;">ëŒ€ê¸°ì¤‘...</span></div>
        </div>

        <!-- 2. ì‹ ê²½ë§ ì„¤ì • -->
        <div class="control-group">
            <h3>ğŸ§  ì‹ ê²½ë§ (Brain)</h3>
            <label>
                ê°œì²´ìˆ˜ (Pop)
                <input type="number" id="popInput" value="100" min="10" max="500">
            </label>
            <label>
                ë³€ì´ í™•ë¥  (Rate)
                <input type="range" id="mutationRate" min="0.01" max="1.0" step="0.01" value="0.1">
                <span class="value-display" id="val_mutationRate">0.1</span>
            </label>
            <label>
                ë³€ì´ ê°•ë„ (Strength)
                <input type="range" id="mutationStrength" min="0.1" max="2.0" step="0.1" value="0.5">
                <span class="value-display" id="val_mutationStrength">0.5</span>
            </label>
        </div>

        <!-- 3. ë¬¼ë¦¬/í™˜ê²½ ì„¤ì • -->
        <div class="control-group">
            <h3>ğŸŒ ë¬¼ë¦¬ ì—”ì§„ (Physics)</h3>
            <label>
                ê²Œì„ ì†ë„ (Speed)
                <input type="range" id="gameSpeed" min="1" max="50" step="1" value="1">
                <span class="value-display" id="val_gameSpeed">x1</span>
            </label>
            <label>
                ì¤‘ë ¥ (Gravity)
                <input type="range" id="gravity" min="0.1" max="1.5" step="0.1" value="0.6">
                <span class="value-display" id="val_gravity">0.6</span>
            </label>
            <label>
                ì í”„ í˜ (Lift)
                <input type="range" id="lift" min="-20" max="-5" step="1" value="-10">
                <span class="value-display" id="val_lift">-10</span>
            </label>
        </div>

        <!-- 4. ì¥ì• ë¬¼ ì„¤ì • -->
        <div class="control-group">
            <h3>ğŸš§ ì¥ì• ë¬¼ (Obstacles)</h3>
            <label>
                ìˆ˜ì§ í†µë¡œ ê°„ê²© (Gap)
                <input type="range" id="pipeGap" min="80" max="200" step="10" value="130">
                <span class="value-display" id="val_pipeGap">130</span>
            </label>
            <label>
                ì´ë™ ì†ë„ (Speed)
                <input type="range" id="pipeSpeed" min="1" max="10" step="1" value="3">
                <span class="value-display" id="val_pipeSpeed">3</span>
            </label>
            <hr style="border: 0; border-top: 1px solid #30475e; margin: 10px 0;">
            <label>
                ë“±ì¥ ê°„ê²© (Distance)
                <input type="range" id="pipeDistance" min="150" max="400" step="10" value="250">
                <span class="value-display" id="val_pipeDistance">250</span>
            </label>
            <label>
                íŠ¹ìˆ˜ ì¥ì• ë¬¼ í™•ë¥  (Complex)
                <input type="range" id="specialChance" min="0" max="1.0" step="0.1" value="0.3">
                <span class="value-display" id="val_specialChance">0.3</span>
            </label>
        </div>

        <!-- ë²„íŠ¼ -->
        <div class="btn-group">
            <button class="save-btn" onclick="saveBestBrain()">ğŸ’¾ ìµœê³  ê¸°ë¡ ì €ì¥</button>
            <button class="reset-btn" onclick="resetBrain()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
        </div>
    </div>
</div>

<script>
// ==========================================
// UI í† ê¸€ ë¡œì§
// ==========================================
const toggleBtn = document.getElementById('toggle-ui-btn');
const sidebar = document.getElementById('sidebar');

toggleBtn.addEventListener('click', () => {
    sidebar.classList.toggle('hidden-ui');
    
    // ì•„ì´ì½˜ ë³€ê²½ (X ë˜ëŠ” í†±ë‹ˆë°”í€´)
    if (sidebar.classList.contains('hidden-ui')) {
        toggleBtn.innerText = 'âš™ï¸'; // ë‹«í˜”ì„ ë•Œ (ì—´ê¸° ì•„ì´ì½˜)
        toggleBtn.style.opacity = '0.5'; // ì•½ê°„ íë¦¬ê²Œ
    } else {
        toggleBtn.innerText = 'âœ–'; // ì—´ë ¸ì„ ë•Œ (ë‹«ê¸° ì•„ì´ì½˜)
        toggleBtn.style.opacity = '1';
    }

    // UIê°€ ì‚¬ë¼ì§€ê±°ë‚˜ ë‚˜íƒ€ë‚  ë•Œ ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì¡°ì •
    // ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„(0.3s) ê³ ë ¤í•˜ì—¬ ì•½ê°„ì˜ ë”œë ˆì´ í›„ ë¦¬ì‚¬ì´ì¦ˆ
    setTimeout(resizeCanvas, 50); 
    setTimeout(resizeCanvas, 310); 
});

// ==========================================
// 0. í™”ë©´ ëŒ€ì‘ (Responsive Logic)
// ==========================================
function resizeCanvas() {
    const container = document.getElementById('game-area');
    const canvas = document.getElementById('gameCanvas');
    
    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 500;
    const TARGET_RATIO = GAME_WIDTH / GAME_HEIGHT;

    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    const containerRatio = containerWidth / containerHeight;

    let finalWidth, finalHeight;

    if (containerRatio > TARGET_RATIO) {
        finalHeight = containerHeight;
        finalWidth = finalHeight * TARGET_RATIO;
    } else {
        finalWidth = containerWidth;
        finalHeight = finalWidth / TARGET_RATIO;
    }

    canvas.style.width = (finalWidth * 0.95) + 'px';
    canvas.style.height = (finalHeight * 0.95) + 'px';
}

window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);


// ==========================================
// 1. ì „ì—­ ì„¤ì • (Config)
// ==========================================
const CONFIG = {
    mutationRate: 0.1,
    mutationStrength: 0.5,
    gameSpeed: 1,
    gravity: 0.6,
    lift: -10,
    pipeGap: 130,
    pipeSpeed: 3,
    pipeDistance: 250,
    specialChance: 0.3
};

function bindInput(id, configKey, displayId) {
    const input = document.getElementById(id);
    const display = document.getElementById(displayId);
    
    input.addEventListener('input', (e) => {
        CONFIG[configKey] = parseFloat(e.target.value);
        if(display) display.innerText = CONFIG[configKey];
        if(id === 'gameSpeed') display.innerText = 'x' + CONFIG[configKey];
    });
}

const inputs = [
    ['mutationRate', 'mutationRate', 'val_mutationRate'],
    ['mutationStrength', 'mutationStrength', 'val_mutationStrength'],
    ['gameSpeed', 'gameSpeed', 'val_gameSpeed'],
    ['gravity', 'gravity', 'val_gravity'],
    ['lift', 'lift', 'val_lift'],
    ['pipeGap', 'pipeGap', 'val_pipeGap'],
    ['pipeSpeed', 'pipeSpeed', 'val_pipeSpeed'],
    ['pipeDistance', 'pipeDistance', 'val_pipeDistance'],
    ['specialChance', 'specialChance', 'val_specialChance']
];

inputs.forEach(item => bindInput(item[0], item[1], item[2]));


// ==========================================
// 2. ì‹ ê²½ë§ (Neural Network)
// ==========================================
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;

        this.weightsIH = new Float32Array(this.inputNodes * this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(this.hiddenNodes * this.outputNodes).map(() => Math.random() * 2 - 1);
        
        this.biasH = new Float32Array(this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(this.outputNodes).map(() => Math.random() * 2 - 1);
    }

    predict(inputArray) {
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) {
                sum += inputArray[j] * this.weightsIH[j * this.hiddenNodes + i];
            }
            sum += this.biasH[i];
            hidden[i] = Math.tanh(sum);
        }

        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) {
                sum += hidden[j] * this.weightsHO[j * this.outputNodes + i];
            }
            sum += this.biasO[i];
            output[i] = Math.tanh(sum);
        }
        return output;
    }

    clone() {
        let clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        clone.weightsIH.set(this.weightsIH);
        clone.weightsHO.set(this.weightsHO);
        clone.biasH.set(this.biasH);
        clone.biasO.set(this.biasO);
        return clone;
    }

    mutate() {
        const rate = CONFIG.mutationRate;
        const strength = CONFIG.mutationStrength;

        function mutateVal(val) {
            if (Math.random() < rate) {
                return val + (Math.random() * 2 - 1) * strength;
            }
            return val;
        }
        this.weightsIH = this.weightsIH.map(mutateVal);
        this.weightsHO = this.weightsHO.map(mutateVal);
        this.biasH = this.biasH.map(mutateVal);
        this.biasO = this.biasO.map(mutateVal);
    }
    
    static fromJSON(data) {
        let nn = new NeuralNetwork(data.inputNodes, data.hiddenNodes, data.outputNodes);
        nn.weightsIH = Float32Array.from(Object.values(data.weightsIH));
        nn.weightsHO = Float32Array.from(Object.values(data.weightsHO));
        nn.biasH = Float32Array.from(Object.values(data.biasH));
        nn.biasO = Float32Array.from(Object.values(data.biasO));
        return nn;
    }
}

// ==========================================
// 3. ê²Œì„ ì—”í‹°í‹°
// ==========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 800;
canvas.height = 500;

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.color = color;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Pipe {
    constructor(id) {
        this.id = id;
        this.spacing = CONFIG.pipeGap; 
        this.top = Math.random() * (canvas.height / 2);
        this.x = canvas.width;
        this.w = 50;
        
        this.type = 'normal';
        this.color = '#4cd137';
        this.moveSpeed = 0;
        this.angle = 0;
        this.baseTop = this.top;
        this.baseSpacing = this.spacing;

        if (Math.random() < CONFIG.specialChance) {
            const typeRoll = Math.random();
            if (typeRoll < 0.33) {
                this.type = 'moving';
                this.color = '#00a8ff';
                this.moveSpeed = 1.5;
                this.moveDir = Math.random() > 0.5 ? 1 : -1;
            } else if (typeRoll < 0.66) {
                this.type = 'narrow';
                this.spacing = CONFIG.pipeGap * 0.7;
                this.color = '#e84118';
                this.baseSpacing = this.spacing;
            } else {
                this.type = 'sine';
                this.color = '#9c88ff';
                this.angle = 0;
            }
        }
        this.updateBottom();
    }

    updateBottom() {
        this.bottom = canvas.height - (this.top + this.spacing);
    }

    update() {
        this.x -= CONFIG.pipeSpeed;

        if (this.type === 'moving') {
            this.top += this.moveSpeed * this.moveDir;
            if (this.top < 20 || this.top > canvas.height / 2 + 50) {
                this.moveDir *= -1;
            }
            this.updateBottom();
        } 
        else if (this.type === 'sine') {
            this.angle += 0.05;
            this.top = this.baseTop + Math.sin(this.angle) * 50;
            this.updateBottom();
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, 0, this.w, this.top);
        ctx.fillRect(this.x, canvas.height - this.bottom, this.w, this.bottom);
        
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(this.x + 40, 0, 10, this.top);
        ctx.fillRect(this.x + 40, canvas.height - this.bottom, 10, this.bottom);
        
        if(this.type !== 'normal') {
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            let label = this.type === 'moving' ? 'MOVE' : (this.type === 'sine' ? 'SINE' : 'NARROW');
            ctx.fillText(label, this.x + 5, 15);
        }
    }
}

class Plane {
    constructor(brain = null) {
        this.y = canvas.height / 2;
        this.x = 60;
        this.velocity = 0;
        this.width = 20;
        this.height = 20;
        
        this.score = 0;
        this.dead = false;

        if (brain) {
            this.brain = brain.clone();
        } else {
            this.brain = new NeuralNetwork(5, 8, 1);
        }

        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.trail = []; 
        this.trailLength = 20;
    }

    mutate() {
        this.brain.mutate();
    }

    think(pipes) {
        let closest = null;
        let closestD = Infinity;
        for (let i = 0; i < pipes.length; i++) {
            let d = (pipes[i].x + pipes[i].w) - this.x;
            if (d > 0 && d < closestD) {
                closest = pipes[i];
                closestD = d;
            }
        }

        if (closest != null) {
            let inputs = [];
            inputs[0] = this.y / canvas.height;
            inputs[1] = this.velocity / 10;
            inputs[2] = closest.x / canvas.width;
            inputs[3] = closest.top / canvas.height;
            inputs[4] = (canvas.height - closest.bottom) / canvas.height;

            let output = this.brain.predict(inputs);
            if (output[0] > 0.5) {
                this.up();
            }
        }
    }

    up() {
        this.velocity += CONFIG.lift;
    }

    update() {
        this.velocity += CONFIG.gravity;
        this.y += this.velocity;
        this.score++;

        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.trailLength) {
            this.trail.shift();
        }
        for(let point of this.trail) {
            point.x -= CONFIG.pipeSpeed;
        }
    }

    draw(ctx, isHighScorer, fewSurvivors) {
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for(let i=1; i<this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = this.color;
        if (isHighScorer || fewSurvivors) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-10, 5);
        ctx.lineTo(-10, -5);
        ctx.fill();
        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

// ==========================================
// 4. ê²Œì„ ê´€ë¦¬ (Game Manager)
// ==========================================
let totalPlanes = 100;
let planes = [];
let savedPlanes = [];
let pipes = [];
let particles = [];
let generation = 1;
let highScore = 0;
let pipeCounter = 1;

const STORAGE_KEY = 'MyAI_Flyer_Pro_Brain'; 

function init() {
    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;
    
    let bestBrainJSON = localStorage.getItem(STORAGE_KEY);
    planes = [];
    
    if (bestBrainJSON) {
        document.getElementById('saveStatus').innerText = "ë¡œë“œ ì™„ë£Œ";
        let bestBrain = NeuralNetwork.fromJSON(JSON.parse(bestBrainJSON));
        
        for (let i = 0; i < totalPlanes; i++) {
            let p = new Plane(bestBrain);
            if (i > 0) p.mutate();
            planes.push(p);
        }
    } else {
        document.getElementById('saveStatus').innerText = "ìƒˆë¡œìš´ ì‹œì‘";
        for (let i = 0; i < totalPlanes; i++) {
            planes.push(new Plane());
        }
    }
    resizeCanvas();
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function resetGame() {
    generation++;
    document.getElementById('genDisplay').innerText = generation;
    pipes = [];
    particles = [];
    pipeCounter = 1;
    
    savedPlanes.sort((a, b) => b.score - a.score);
    let bestOne = savedPlanes[0];
    
    if (bestOne.score > highScore) {
        highScore = bestOne.score;
        document.getElementById('scoreDisplay').innerText = highScore;
        saveBrainToLocal(bestOne.brain); 
    } else if (savedPlanes.length > 0) {
        saveBrainToLocal(bestOne.brain);
    }

    totalPlanes = parseInt(document.getElementById('popInput').value) || 100;
    planes = [];
    
    for (let i = 0; i < totalPlanes; i++) {
        let p = new Plane(bestOne.brain);
        if (i > 0) { 
             p.mutate();
        }
        planes.push(p);
    }
    savedPlanes = [];
}

function saveBrainToLocal(brain) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(brain));
    let status = document.getElementById('saveStatus');
    status.innerText = "ìë™ ì €ì¥ë¨";
    status.style.opacity = 1;
    status.style.color = '#2ed573';
}

function saveBestBrain() {
    let currentBest = planes[0];
    if (savedPlanes.length > 0) {
        let deadBest = savedPlanes.sort((a,b) => b.score - a.score)[0];
        if (!currentBest || deadBest.score > currentBest.score) {
            currentBest = deadBest;
        }
    }
    if (currentBest) {
        saveBrainToLocal(currentBest.brain);
        alert(`ìµœê³  ì ìˆ˜ ${currentBest.score}ì ì˜ ì‹ ê²½ë§ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    }
}

function resetBrain() {
    if(confirm("ëª¨ë“  í•™ìŠµ ë°ì´í„°ì™€ ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
        localStorage.removeItem(STORAGE_KEY);
        location.reload();
    }
}

function animate() {
    for (let n = 0; n < CONFIG.gameSpeed; n++) {
        
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - CONFIG.pipeDistance) {
            pipes.push(new Pipe(pipeCounter++));
        }

        for (let i = planes.length - 1; i >= 0; i--) {
            let p = planes[i];
            p.think(pipes);
            p.update();

            let crashed = false;
            if (p.y > canvas.height || p.y < 0) crashed = true;

            for (let pipe of pipes) {
                if (p.x + 10 > pipe.x && p.x - 10 < pipe.x + pipe.w) {
                    if (p.y - 5 < pipe.top || p.y + 5 > canvas.height - pipe.bottom) {
                        crashed = true;
                    }
                }
            }

            if (crashed) {
                createExplosion(p.x, p.y, p.color);
                savedPlanes.push(planes.splice(i, 1)[0]);
            }
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
            pipes[i].update();
            if (pipes[i].x + pipes[i].w < 0) {
                pipes.splice(i, 1);
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        if (planes.length === 0) {
            resetGame();
            break;
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let pipe of pipes) pipe.draw(ctx);
    for (let p of particles) p.draw(ctx);

    let currentHighScore = 0;
    planes.forEach(p => { if(p.score > currentHighScore) currentHighScore = p.score; });
    let fewSurvivors = planes.length <= 5;

    for (let p of planes) {
        let isHighScorer = (p.score === currentHighScore) && (p.score > 0);
        p.draw(ctx, isHighScorer, fewSurvivors);
    }

    document.getElementById('aliveDisplay').innerText = planes.length;
    document.getElementById('currentScoreDisplay').innerText = currentHighScore;
    
    requestAnimationFrame(animate);
}

init();
animate();

</script>
</body>
</html>
