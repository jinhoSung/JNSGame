<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‘ë”ì§€ ì¡ê¸°: UI ê°œì„ íŒ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #87CEEB;
            font-family: 'Jua', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #65a30d;
            cursor: none;
        }

        canvas { display: block; }

        /* --- HUD (Head-Up Display) ë ˆì´ì•„ì›ƒ --- */
        
        /* ê³µí†µ ìŠ¤íƒ€ì¼ */
        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: 15px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            pointer-events: none; /* í´ë¦­ í†µê³¼ (ë²„íŠ¼ ì œì™¸) */
            z-index: 20;
            backdrop-filter: blur(2px);
        }

        /* 1. ì¢Œì¸¡ ìƒë‹¨: ì ìˆ˜ì™€ ë ˆë²¨ */
        .hud-left {
            top: 20px;
            left: 20px;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
            font-size: clamp(16px, 3vw, 24px);
        }
        .hud-row { display: flex; align-items: center; gap: 10px; }
        .hud-label { color: #ddd; }
        .hud-value { color: #ffd700; font-size: 1.2em; }

        /* 2. ì¤‘ì•™ ìƒë‹¨: ì‹œê°„ */
        .hud-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(24px, 5vw, 40px);
            padding: 5px 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 30px;
        }
        #time-display { color: #fff; margin-left: 10px; }

        /* 3. ìš°ì¸¡ ìƒë‹¨: ë²„íŠ¼ ê·¸ë£¹ */
        .hud-right {
            top: 20px;
            right: 20px;
            background: transparent; /* ë°°ê²½ ì—†ìŒ */
            box-shadow: none;
            padding: 0;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto; /* ë²„íŠ¼ í´ë¦­ ê°€ëŠ¥ */
            align-items: flex-end; /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
        }

        /* ìš°ì¸¡ ìƒë‹¨ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .icon-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 8px 15px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Jua', sans-serif;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100px; /* ë²„íŠ¼ ë„ˆë¹„ í†µì¼ */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .icon-btn:hover { background: rgba(255, 255, 255, 0.4); transform: translateY(-2px); }
        .icon-btn:active { transform: translateY(0); }


        /* --- ìŠ¤í¬ë¦° (ì‹œì‘, ì¢…ë£Œ, ë­í‚¹) --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .screen.active { opacity: 1; pointer-events: auto; cursor: default; }

        h1 { font-size: clamp(3rem, 8vw, 5rem); margin: 0 0 10px 0; text-shadow: 4px 4px 0 #000; color: #ff9800; -webkit-text-stroke: 2px white; }
        h2 { font-size: clamp(2rem, 6vw, 3.5rem); margin-bottom: 20px; }
        p { font-size: clamp(1.2rem, 3vw, 1.8rem); margin: 5px 0; color: #eee; }

        /* ë©”ì¸ ì•¡ì…˜ ë²„íŠ¼ */
        .btn-group { display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center; }
        
        button.action-btn {
            padding: 15px 40px;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            background-color: #ff9800;
            border: none;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Jua', sans-serif;
            box-shadow: 0 6px 0 #b36b00, 0 10px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button.action-btn.secondary { background-color: #4CAF50; box-shadow: 0 6px 0 #2E7D32, 0 10px 10px rgba(0,0,0,0.3); }
        button.action-btn.danger { background-color: #f44336; box-shadow: 0 6px 0 #c62828, 0 10px 10px rgba(0,0,0,0.3); }

        button.action-btn:hover { transform: translateY(-2px); }
        button.action-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #b36b00, 0 0 0 rgba(0,0,0,0); }

        /* ë­í‚¹ ë¦¬ìŠ¤íŠ¸ */
        .rank-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px 40px;
            min-width: 300px;
            margin-bottom: 20px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .rank-item {
            display: flex; justify-content: space-between;
            font-size: 1.5rem; margin: 10px 0; border-bottom: 1px dashed rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        .rank-item:last-child { border-bottom: none; }
        .rank-rank { color: #ff9800; margin-right: 15px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- 1. ì¢Œì¸¡ ìƒë‹¨: ë ˆë²¨ & ì ìˆ˜ -->
        <div class="hud-panel hud-left">
            <div class="hud-row">
                <span class="hud-label">LV.</span>
                <span class="hud-value" id="level-display">1</span>
            </div>
            <div class="hud-row">
                <span class="hud-label">SCORE</span>
                <span class="hud-value" id="score-display">0</span>
            </div>
        </div>

        <!-- 2. ì¤‘ì•™ ìƒë‹¨: ì‹œê°„ -->
        <div class="hud-panel hud-center">
            TIME <span id="time-display">30</span>
        </div>

        <!-- 3. ìš°ì¸¡ ìƒë‹¨: ì»¨íŠ¸ë¡¤ ë²„íŠ¼ë“¤ -->
        <div class="hud-panel hud-right">
            <button class="icon-btn" id="fullscreen-btn" onclick="toggleFullScreen()">ì „ì²´í™”ë©´</button>
            <button class="icon-btn" id="ranking-btn" onclick="openRanking()">ğŸ† ë­í‚¹</button>
        </div>

        <!-- ì‹œì‘ í™”ë©´ -->
        <div id="start-screen" class="screen active">
            <h1>ë‘ë”ì§€ ì¡ê¸°</h1>
            <p>ë‘ë”ì§€ë¥¼ ì¡ìœ¼ë©´ ì ìˆ˜ UP!</p>
            <p style="color: #ff6b6b;">ê²€ì€ í­íƒ„ì„ ê±´ë“œë¦¬ë©´ ê°ì !</p>
            <div class="btn-group">
                <button class="action-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
            </div>
        </div>

        <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
        <div id="game-over-screen" class="screen">
            <h2>ê²Œì„ ì¢…ë£Œ</h2>
            <p>ìµœì¢… ì ìˆ˜: <span id="final-score" style="color:#ff9800; font-size:1.5em;">0</span></p>
            <p id="new-record-msg" style="color: #4CAF50; display:none;">ğŸ‰ ìµœê³  ê¸°ë¡ ê°±ì‹ ! ğŸ‰</p>
            <div class="btn-group">
                <button class="action-btn" onclick="startGame()">ë‹¤ì‹œ í•˜ê¸°</button>
            </div>
        </div>

        <!-- ë­í‚¹ í™”ë©´ -->
        <div id="ranking-screen" class="screen">
            <h2>ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</h2>
            <div class="rank-list" id="rank-list-content">
                <!-- JSë¡œ ì±„ì›Œì§ -->
            </div>
            <div class="btn-group">
                <button class="action-btn danger" onclick="closeRanking()">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        // Screens
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const rankingScreen = document.getElementById('ranking-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const newRecordMsg = document.getElementById('new-record-msg');
        const rankListContent = document.getElementById('rank-list-content');

        // ê²Œì„ ì„¤ì •
        const config = {
            cols: 3, rows: 3,
            holeSize: 100, moleSize: 80, gap: 20,
            missPenalty: 5,
            bombPenalty: 20,
            baseTime: 30,
            offsetX: 0, offsetY: 0
        };

        const gameState = {
            score: 0,
            level: 1,
            timeLeft: 30,
            isPlaying: false,
            isPaused: false, // ë­í‚¹ ë³¼ ë•Œ ì¼ì‹œì •ì§€ìš©
            lastHole: null,
            mouseX: 0, mouseY: 0,
            hammer: { angle: 0, isHitting: false, x:0, y:0 }
        };

        let holes = [];
        let effects = [];
        let gameLoopId;
        let timerId;
        let previousScreen = null; // ë­í‚¹ ë‹«ì„ ë•Œ ëŒì•„ê°ˆ í™”ë©´ ê¸°ì–µ

        // ==========================================
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ & ë­í‚¹ ê´€ë¦¬
        // ==========================================
        function getHighScores() {
            const scores = localStorage.getItem('whac-a-mole-scores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighScore(score) {
            let scores = getHighScores();
            scores.push(score);
            scores.sort((a, b) => b - a);
            scores = scores.slice(0, 5);
            localStorage.setItem('whac-a-mole-scores', JSON.stringify(scores));
            return scores[0] === score;
        }

        function renderRanking() {
            const scores = getHighScores();
            rankListContent.innerHTML = '';
            if (scores.length === 0) {
                rankListContent.innerHTML = '<p style="font-size: 1rem;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            scores.forEach((score, index) => {
                const div = document.createElement('div');
                div.className = 'rank-item';
                let medal = '';
                if(index === 0) medal = 'ğŸ¥‡';
                else if(index === 1) medal = 'ğŸ¥ˆ';
                else if(index === 2) medal = 'ğŸ¥‰';
                
                div.innerHTML = `<span class="rank-rank">${medal} ${index + 1}ìœ„</span> <span>${score}ì </span>`;
                rankListContent.appendChild(div);
            });
        }

        // ==========================================
        // í™”ë©´ ì „í™˜ í•¨ìˆ˜ (ë­í‚¹ ë¡œì§ ê°œì„ )
        // ==========================================
        function switchScreen(screen) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            if (screen) screen.classList.add('active');
        }

        function openRanking() {
            // í˜„ì¬ í™œì„±í™”ëœ ìŠ¤í¬ë¦° ê¸°ì–µ (ì—†ìœ¼ë©´ null = ê²Œì„ ì¤‘)
            const activeScreen = document.querySelector('.screen.active');
            previousScreen = activeScreen;

            // ê²Œì„ ì¤‘ì´ì—ˆë‹¤ë©´ ì¼ì‹œì •ì§€ í”Œë˜ê·¸ ì„¤ì • (íƒ€ì´ë¨¸ ë©ˆì¶¤ ë“±ì„ ìœ„í•´)
            if (!activeScreen && gameState.isPlaying) {
                gameState.isPaused = true; 
            }

            renderRanking();
            rankingScreen.classList.add('active'); // ë­í‚¹ë§Œ ìœ„ì— ë®ì–´ì”Œì›€ (ê¸°ì¡´ ìŠ¤í¬ë¦° ìœ ì§€í•˜ë˜ z-indexë¡œ ë®ìŒ)
        }

        function closeRanking() {
            rankingScreen.classList.remove('active');
            
            // ê²Œì„ ì¤‘ì´ì—ˆë‹¤ë©´ ì¼ì‹œì •ì§€ í•´ì œ
            if (gameState.isPaused) {
                gameState.isPaused = false;
            }
            
            // ë§Œì•½ ê²Œì„ ì¤‘ì´ ì•„ë‹ˆì—ˆê³ , ì´ì „ì— ë‹¤ë¥¸ ìŠ¤í¬ë¦°ì´ ìˆì—ˆë‹¤ë©´ ê·¸ ìŠ¤í¬ë¦° ë³µêµ¬
            if (previousScreen) {
                previousScreen.classList.add('active');
            }
        }

        // ==========================================
        // ê²Œì„ ë¡œì§
        // ==========================================
        function checkLevel() {
            const newLevel = Math.floor(gameState.score / 50) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                levelDisplay.innerText = gameState.level;
                effects.push(new Effect(canvas.width/2, canvas.height/2, 'levelup'));
                gameState.timeLeft = Math.min(gameState.timeLeft + 5, 60);
                timeDisplay.innerText = gameState.timeLeft;
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const minDim = Math.min(canvas.width, canvas.height);
            const contentSize = minDim * 0.85;
            
            config.holeSize = contentSize / 3.5; 
            config.moleSize = config.holeSize * 0.8;
            config.gap = config.holeSize * 0.15;

            const gridWidth = config.cols * config.holeSize + (config.cols - 1) * config.gap;
            const gridHeight = config.rows * config.holeSize + (config.rows - 1) * config.gap;

            config.offsetX = (canvas.width - gridWidth) / 2;
            config.offsetY = (canvas.height - gridHeight) / 2 + (minDim * 0.08);

            if (holes.length === 0) initHoles();
            else {
                let idx = 0;
                for(let r=0; r<config.rows; r++){
                    for(let c=0; c<config.cols; c++){
                        if(holes[idx]){
                            holes[idx].x = config.offsetX + c*(config.holeSize+config.gap);
                            holes[idx].y = config.offsetY + r*(config.holeSize+config.gap);
                        }
                        idx++;
                    }
                }
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // ==========================================
        // í´ë˜ìŠ¤ ì •ì˜ (Effect, Hole)
        // ==========================================
        class Effect {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.life = 1.0;
                if (type === 'hit') this.radius = config.holeSize * 0.1;
                else if (type === 'bomb_hit') this.radius = config.holeSize * 0.1;
                else if (type === 'miss') this.vy = -2;
                else if (type === 'levelup') { this.life = 2.0; this.vy = -1; }
                else if (type === 'star' || type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.size = Math.random() * 10 + 5;
                }
            }
            update() {
                this.life -= 0.05;
                if (this.type === 'hit') this.radius += 5;
                else if (this.type === 'bomb_hit') this.radius += 8;
                else if (this.type === 'miss' || this.type === 'levelup') this.y += this.vy;
                else if (this.type === 'star' || this.type === 'smoke') {
                    this.x += this.vx; this.y += this.vy;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, this.life));
                if (this.type === 'hit') {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 5; ctx.stroke();
                } else if (this.type === 'bomb_hit') {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff4444'; ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = `bold ${config.holeSize*0.4}px Jua`;
                    ctx.fillText("ì¾…!!!", this.x-config.holeSize*0.2, this.y);
                } else if (this.type === 'miss') {
                    ctx.fillStyle = '#FF4500'; ctx.font = `bold ${config.holeSize*0.3}px Jua`;
                    ctx.fillText("MISS!", this.x - 20, this.y);
                } else if (this.type === 'levelup') {
                    ctx.fillStyle = '#ffffff'; ctx.shadowColor="black"; ctx.shadowBlur=10;
                    ctx.font = `bold ${config.holeSize*0.6}px Jua`; ctx.textAlign = "center";
                    ctx.fillText("LEVEL UP!", this.x, this.y);
                } else if (this.type === 'star') {
                    ctx.fillStyle = '#FFFF00'; ctx.translate(this.x, this.y); ctx.rotate(this.life*5);
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                } else if (this.type === 'smoke') {
                    ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Hole {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.state = 'idle'; this.type = 'mole'; this.moleY = 0;
            }
            pop() {
                if (this.state !== 'idle' || gameState.isPaused) return; // ì¼ì‹œì •ì§€ ì‹œ pop ë°©ì§€
                this.state = 'rising';
                this.moleY = config.holeSize;
                
                const bombChance = Math.min(0.3, (gameState.level - 1) * 0.1); 
                this.type = Math.random() < bombChance ? 'bomb' : 'mole';

                const baseTime = 1000;
                const minTime = 400;
                const speedFactor = (gameState.level - 1) * 100; 
                const stayTime = Math.max(minTime, Math.random() * (baseTime - speedFactor) + minTime);

                setTimeout(() => {
                    if (this.state === 'rising') this.state = 'idle';
                }, stayTime);
            }
            hit(hitX, hitY) {
                if (this.state === 'rising') {
                    this.state = 'hit';
                    if (this.type === 'mole') {
                        updateScore(10);
                        effects.push(new Effect(hitX, hitY, 'hit'));
                        for(let i=0; i<5; i++) effects.push(new Effect(hitX, hitY, 'star'));
                    } else {
                        updateScore(-config.bombPenalty);
                        effects.push(new Effect(hitX, hitY, 'bomb_hit'));
                        for(let i=0; i<8; i++) effects.push(new Effect(hitX, hitY, 'smoke'));
                        canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                        setTimeout(()=>canvas.style.transform='none', 200);
                    }
                    setTimeout(() => { this.state = 'idle'; }, 500);
                    return true;
                }
                return false;
            }
            draw() {
                const cx = this.x + config.holeSize/2;
                const cy = this.y + config.holeSize/2;
                ctx.fillStyle = '#3e2723';
                ctx.beginPath(); ctx.ellipse(cx, cy + config.holeSize*0.15, config.holeSize/2, config.holeSize/3, 0, 0, Math.PI * 2); ctx.fill();

                ctx.save();
                ctx.beginPath(); ctx.rect(this.x, this.y - config.holeSize, config.holeSize, config.holeSize * 2); ctx.clip();

                let moveSpeed = (config.holeSize * 0.1) + (gameState.level * 0.5);
                if(gameState.isPaused) moveSpeed = 0; // ì¼ì‹œì •ì§€ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ë©ˆì¶¤

                if (this.state !== 'idle') {
                    this.moleY = Math.max(0, this.moleY - (this.state === 'rising' ? moveSpeed : -moveSpeed/2));
                } else {
                    this.moleY = Math.min(config.holeSize, this.moleY + moveSpeed);
                }

                const drawY = cy + this.moleY;
                if (this.moleY < config.holeSize) {
                    if (this.type === 'mole') this.drawMole(cx, drawY);
                    else this.drawBomb(cx, drawY);
                }
                ctx.restore();

                ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.ellipse(cx, cy + config.holeSize*0.2, config.holeSize/2, config.holeSize/6, 0, 0, Math.PI); ctx.fill();
            }
            drawMole(x, y) {
                ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.ellipse(x, y, config.moleSize/2, config.moleSize/1.8, 0, Math.PI, 0); ctx.fill(); ctx.stroke();
                const eyeOffX = config.moleSize*0.2; const eyeOffY = config.moleSize*0.4;
                ctx.fillStyle = 'black';
                if (this.state === 'hit') {
                    ctx.lineWidth=3;
                    ctx.beginPath(); ctx.moveTo(x-eyeOffX-5, y-eyeOffY-5); ctx.lineTo(x-eyeOffX+5, y-eyeOffY+5); ctx.moveTo(x-eyeOffX+5, y-eyeOffY-5); ctx.lineTo(x-eyeOffX-5, y-eyeOffY+5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(x+eyeOffX-5, y-eyeOffY-5); ctx.lineTo(x+eyeOffX+5, y-eyeOffY+5); ctx.moveTo(x+eyeOffX+5, y-eyeOffY-5); ctx.lineTo(x+eyeOffX-5, y-eyeOffY+5); ctx.stroke();
                    ctx.lineWidth=1;
                    ctx.fillStyle = 'red'; ctx.font = `bold ${config.moleSize*0.3}px Jua`; 
                    ctx.fillText('ì•„ì•¼!', x-config.moleSize*0.4, y-config.moleSize*0.6);
                } else {
                    ctx.beginPath(); ctx.arc(x-eyeOffX, y-eyeOffY, 3, 0, Math.PI*2); ctx.arc(x+eyeOffX, y-eyeOffY, 3, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = '#ffab91'; ctx.beginPath(); ctx.ellipse(x, y-eyeOffY+15, 8, 5, 0, 0, Math.PI*2); ctx.fill();
            }
            drawBomb(x, y) {
                ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(x, y-config.moleSize*0.2, config.moleSize/2.2, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(x-10, y-config.moleSize*0.4, 5, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#d4a017'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(x, y-config.moleSize*0.6); ctx.quadraticCurveTo(x+10, y-config.moleSize*0.8, x+15, y-config.moleSize*0.7); ctx.stroke();
                if (this.state !== 'hit') {
                    ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(x+15, y-config.moleSize*0.7, Math.random()*4+2, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = 'red'; ctx.font = `bold ${config.moleSize*0.4}px sans-serif`; ctx.fillText("!", x-4, y-config.moleSize*0.1);
            }
        }

        function drawHammer(ctx, x, y, angle) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
            const scale = config.holeSize / 120;
            ctx.fillStyle = '#8B4513'; ctx.fillRect(-10*scale, -20*scale, 20*scale, 100*scale);
            ctx.fillStyle = '#FF6347'; ctx.beginPath(); ctx.roundRect(-40*scale, -50*scale, 80*scale, 40*scale, 10*scale); ctx.fill();
            ctx.strokeStyle = '#B22222'; ctx.lineWidth = 3*scale; ctx.stroke();
            ctx.fillStyle = '#ff8a65'; ctx.beginPath(); ctx.arc(-20*scale, -30*scale, 5*scale, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(20*scale, -30*scale, 5*scale, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // ==========================================
        // ë©”ì¸ ê²Œì„ ë£¨í”„
        // ==========================================
        function initHoles() {
            holes = [];
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    holes.push(new Hole(0,0));
                }
            }
        }

        function randomHole() {
            const idx = Math.floor(Math.random() * holes.length);
            const hole = holes[idx];
            if (hole === gameState.lastHole) return randomHole();
            gameState.lastHole = hole;
            return hole;
        }

        function peep() {
            if (!gameState.isPlaying || gameState.isPaused) {
                if(gameState.isPlaying && gameState.isPaused) {
                    // ì¼ì‹œì •ì§€ ì¤‘ì´ë©´ ì ì‹œ í›„ ë‹¤ì‹œ ì²´í¬
                    setTimeout(peep, 500); 
                }
                return;
            }
            
            let freq = Math.max(300, 1000 - (gameState.level * 100));
            let variance = Math.max(100, 500 - (gameState.level * 50));
            
            const time = Math.random() * variance + freq;
            randomHole().pop();
            setTimeout(peep, time);
        }

        function updateScore(points) {
            gameState.score += points;
            scoreDisplay.textContent = gameState.score;
            if (points > 0) checkLevel();
        }

        function startGame() {
            gameState.score = 0;
            gameState.level = 1;
            gameState.timeLeft = config.baseTime;
            gameState.isPlaying = true;
            gameState.isPaused = false;
            effects = [];
            
            scoreDisplay.textContent = "0";
            levelDisplay.textContent = "1";
            timeDisplay.textContent = gameState.timeLeft;
            newRecordMsg.style.display = 'none';
            
            switchScreen(null);
            
            resizeCanvas();
            peep();
            
            if (timerId) clearInterval(timerId);
            timerId = setInterval(() => {
                if(!gameState.isPaused) {
                    gameState.timeLeft--;
                    timeDisplay.textContent = gameState.timeLeft;
                    if (gameState.timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
            
            if (!gameLoopId) animate();
        }

        function endGame() {
            gameState.isPlaying = false;
            clearInterval(timerId);
            finalScoreSpan.textContent = gameState.score;
            const isNewRecord = saveHighScore(gameState.score);
            if(isNewRecord && gameState.score > 0) newRecordMsg.style.display = 'block';
            switchScreen(gameOverScreen);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            holes.forEach(hole => hole.draw());
            
            // ì¼ì‹œì •ì§€ ì¤‘ì—ëŠ” ì´í™íŠ¸ ì—…ë°ì´íŠ¸ ì•ˆí•¨ (ê·¸ë¦¬ê¸°ë§Œ í•¨)
            if(!gameState.isPaused) {
                effects = effects.filter(e => e.life > 0);
                effects.forEach(e => e.update());
            }
            effects.forEach(e => e.draw(ctx));

            if (gameState.isPlaying && !gameState.isPaused) {
                drawHammer(ctx, gameState.mouseX, gameState.mouseY, gameState.hammer.angle);
            }

            gameLoopId = requestAnimationFrame(animate);
        }

        // ==========================================
        // ì…ë ¥ í•¸ë“¤ëŸ¬
        // ==========================================
        function handleInput(x, y) {
            if (!gameState.isPlaying || gameState.isPaused) return;

            gameState.mouseX = x; gameState.mouseY = y;
            gameState.hammer.isHitting = true;
            gameState.hammer.angle = -Math.PI / 4;

            let hitSomething = false;
            holes.forEach(hole => {
                const cx = hole.x + config.holeSize / 2;
                const cy = hole.y + config.holeSize / 2;
                const dist = Math.hypot(x - cx, y - cy);
                if (dist < config.holeSize / 1.5 && hole.state === 'rising') {
                    hole.hit(x, y);
                    hitSomething = true;
                }
            });

            if (!hitSomething) {
                updateScore(-config.missPenalty);
                effects.push(new Effect(x, y, 'miss'));
            }

            setTimeout(() => { 
                gameState.hammer.isHitting = false; 
                gameState.hammer.angle = 0; 
            }, 100);
        }

        canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => { gameState.mouseX = e.clientX; gameState.mouseY = e.clientY; });
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); gameState.mouseX = e.touches[0].clientX; gameState.mouseY = e.touches[0].clientY; }, {passive: false});

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        initHoles();
        resizeCanvas();

    </script>
</body>
</html>
