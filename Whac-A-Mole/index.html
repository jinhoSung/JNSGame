<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‘ë”ì§€ ì¡ê¸°: ë ˆë²¨ì—… & ë­í‚¹</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #87CEEB;
            font-family: 'Jua', sans-serif; /* ê·€ì—¬ìš´ í°íŠ¸ë¡œ ë³€ê²½ */
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #65a30d;
            cursor: none;
        }

        canvas { display: block; }

        /* --- UI ì˜¤ë²„ë ˆì´ (ìƒë‹¨ ì •ë³´ì°½) --- */
        .ui-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50px;
            padding: 10px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: clamp(18px, 4vw, 28px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 10;
        }

        .ui-group { display: flex; gap: 20px; }
        .ui-item span { color: #ffd700; margin-left: 5px; }

        /* --- ì „ì²´í™”ë©´ ë²„íŠ¼ (ìš°ì¸¡ ìƒë‹¨) --- */
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 14px;
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s;
            font-family: 'Jua', sans-serif;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.4); }

        /* --- ê³µí†µ ìŠ¤í¬ë¦° ìŠ¤íƒ€ì¼ (ì‹œì‘, ì¢…ë£Œ, ë­í‚¹) --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .screen.active { opacity: 1; pointer-events: auto; cursor: default; }

        h1 { font-size: clamp(3rem, 8vw, 5rem); margin: 0 0 10px 0; text-shadow: 4px 4px 0 #000; color: #ff9800; -webkit-text-stroke: 2px white; }
        h2 { font-size: clamp(2rem, 6vw, 3.5rem); margin-bottom: 20px; }
        p { font-size: clamp(1.2rem, 3vw, 1.8rem); margin: 5px 0; color: #eee; }

        /* --- ë²„íŠ¼ ìŠ¤íƒ€ì¼ (ì‹¬í”Œí•˜ê³  í†µì¼ê° ìˆê²Œ) --- */
        .btn-group { display: flex; gap: 15px; margin-top: 30px; flex-wrap: wrap; justify-content: center; }
        
        button.action-btn {
            padding: 15px 40px;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            background-color: #ff9800;
            border: none;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Jua', sans-serif;
            box-shadow: 0 6px 0 #b36b00, 0 10px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button.action-btn.secondary { background-color: #4CAF50; box-shadow: 0 6px 0 #2E7D32, 0 10px 10px rgba(0,0,0,0.3); }
        button.action-btn.danger { background-color: #f44336; box-shadow: 0 6px 0 #c62828, 0 10px 10px rgba(0,0,0,0.3); }

        button.action-btn:hover { transform: translateY(-2px); }
        button.action-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #b36b00, 0 0 0 rgba(0,0,0,0); }
        button.action-btn.secondary:active { box-shadow: 0 0 0 #2E7D32; }

        /* --- ë­í‚¹ ë³´ë“œ ìŠ¤íƒ€ì¼ --- */
        .rank-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px 40px;
            min-width: 300px;
            margin-bottom: 20px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .rank-item {
            display: flex; justify-content: space-between;
            font-size: 1.5rem; margin: 10px 0; border-bottom: 1px dashed rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        .rank-item:last-child { border-bottom: none; }
        .rank-rank { color: #ff9800; margin-right: 15px; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- ìƒë‹¨ ì •ë³´ UI -->
        <button id="fullscreen-btn" onclick="toggleFullScreen()">ì „ì²´í™”ë©´</button>
        <div class="ui-bar">
            <div class="ui-group">
                <div class="ui-item">LV.<span id="level-display">1</span></div>
                <div class="ui-item">SCORE <span id="score-display">0</span></div>
            </div>
            <div class="ui-item">TIME <span id="time-display">30</span></div>
        </div>

        <!-- ì‹œì‘ í™”ë©´ -->
        <div id="start-screen" class="screen active">
            <h1>ë‘ë”ì§€ ì¡ê¸°</h1>
            <p>ë‘ë”ì§€ë¥¼ ì¡ìœ¼ë©´ ì ìˆ˜ UP!</p>
            <p style="color: #ff6b6b;">ê²€ì€ í­íƒ„ì„ ê±´ë“œë¦¬ë©´ ê°ì !</p>
            <div class="btn-group">
                <button class="action-btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
                <button class="action-btn secondary" onclick="showRanking()">ë­í‚¹ ë³´ê¸°</button>
            </div>
        </div>

        <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
        <div id="game-over-screen" class="screen">
            <h2>ê²Œì„ ì¢…ë£Œ</h2>
            <p>ìµœì¢… ì ìˆ˜: <span id="final-score" style="color:#ff9800; font-size:1.5em;">0</span></p>
            <p id="new-record-msg" style="color: #4CAF50; display:none;">ğŸ‰ ìµœê³  ê¸°ë¡ ê°±ì‹ ! ğŸ‰</p>
            <div class="btn-group">
                <button class="action-btn" onclick="startGame()">ë‹¤ì‹œ í•˜ê¸°</button>
                <button class="action-btn secondary" onclick="showRanking()">ë­í‚¹ ë³´ê¸°</button>
            </div>
        </div>

        <!-- ë­í‚¹ í™”ë©´ -->
        <div id="ranking-screen" class="screen">
            <h2>ğŸ† ëª…ì˜ˆì˜ ì „ë‹¹</h2>
            <div class="rank-list" id="rank-list-content">
                <!-- JSë¡œ ì±„ì›Œì§ -->
            </div>
            <div class="btn-group">
                <button class="action-btn danger" onclick="showStartScreen()">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const levelDisplay = document.getElementById('level-display');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        // Screens
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const rankingScreen = document.getElementById('ranking-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const newRecordMsg = document.getElementById('new-record-msg');
        const rankListContent = document.getElementById('rank-list-content');

        // ê²Œì„ ì„¤ì • ë° ìƒíƒœ
        const config = {
            cols: 3, rows: 3,
            holeSize: 100, moleSize: 80, gap: 20,
            missPenalty: 5,
            bombPenalty: 20, // í­íƒ„ íŒ¨ë„í‹°
            baseTime: 30,
            offsetX: 0, offsetY: 0
        };

        const gameState = {
            score: 0,
            level: 1,
            timeLeft: 30,
            isPlaying: false,
            lastHole: null,
            mouseX: 0, mouseY: 0,
            hammer: { angle: 0, isHitting: false, x:0, y:0 }
        };

        let holes = [];
        let effects = [];
        let gameLoopId;
        let timerId;

        // ==========================================
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ & ë­í‚¹ ê´€ë¦¬
        // ==========================================
        function getHighScores() {
            const scores = localStorage.getItem('whac-a-mole-scores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighScore(score) {
            let scores = getHighScores();
            scores.push(score);
            scores.sort((a, b) => b - a); // ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
            scores = scores.slice(0, 5); // ìƒìœ„ 5ê°œë§Œ ìœ ì§€
            localStorage.setItem('whac-a-mole-scores', JSON.stringify(scores));
            return scores[0] === score; // ì‹ ê¸°ë¡ ì—¬ë¶€ ë¦¬í„´
        }

        function renderRanking() {
            const scores = getHighScores();
            rankListContent.innerHTML = '';
            if (scores.length === 0) {
                rankListContent.innerHTML = '<p>ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            scores.forEach((score, index) => {
                const div = document.createElement('div');
                div.className = 'rank-item';
                div.innerHTML = `<span class="rank-rank">${index + 1}ìœ„</span> <span>${score}ì </span>`;
                rankListContent.appendChild(div);
            });
        }

        // ==========================================
        // í™”ë©´ ì „í™˜ í•¨ìˆ˜
        // ==========================================
        function switchScreen(screen) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            if (screen) screen.classList.add('active');
        }
        function showStartScreen() { switchScreen(startScreen); }
        function showRanking() { renderRanking(); switchScreen(rankingScreen); }
        
        // ==========================================
        // ê²Œì„ ë¡œì§ (ë ˆë²¨, í­íƒ„)
        // ==========================================
        
        // ë ˆë²¨ ì²´í¬: ì ìˆ˜ì— ë”°ë¼ ë ˆë²¨ì—…
        function checkLevel() {
            const newLevel = Math.floor(gameState.score / 50) + 1; // 50ì ë§ˆë‹¤ ë ˆë²¨ì—…
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                levelDisplay.innerText = gameState.level;
                // ë ˆë²¨ì—… ì´í™íŠ¸ (ì¤‘ì•™ì— í…ìŠ¤íŠ¸)
                effects.push(new Effect(canvas.width/2, canvas.height/2, 'levelup'));
                // ì‹œê°„ ì•½ê°„ ì¶”ê°€ ë³´ë„ˆìŠ¤
                gameState.timeLeft = Math.min(gameState.timeLeft + 5, 60);
                timeDisplay.innerText = gameState.timeLeft;
            }
        }

        // ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const minDim = Math.min(canvas.width, canvas.height);
            const contentSize = minDim * 0.85; // 85% ì‚¬ìš©
            
            config.holeSize = contentSize / 3.5; 
            config.moleSize = config.holeSize * 0.8;
            config.gap = config.holeSize * 0.15;

            const gridWidth = config.cols * config.holeSize + (config.cols - 1) * config.gap;
            const gridHeight = config.rows * config.holeSize + (config.rows - 1) * config.gap;

            config.offsetX = (canvas.width - gridWidth) / 2;
            config.offsetY = (canvas.height - gridHeight) / 2 + (minDim * 0.08);

            if (holes.length === 0) initHoles();
            else {
                // ê¸°ì¡´ êµ¬ë© ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                let idx = 0;
                for(let r=0; r<config.rows; r++){
                    for(let c=0; c<config.cols; c++){
                        if(holes[idx]){
                            holes[idx].x = config.offsetX + c*(config.holeSize+config.gap);
                            holes[idx].y = config.offsetY + r*(config.holeSize+config.gap);
                        }
                        idx++;
                    }
                }
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // ==========================================
        // í´ë˜ìŠ¤: ì´í™íŠ¸ & êµ¬ë©
        // ==========================================
        class Effect {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.life = 1.0;
                
                if (type === 'hit') this.radius = config.holeSize * 0.1;
                else if (type === 'bomb_hit') this.radius = config.holeSize * 0.1;
                else if (type === 'miss') this.vy = -2;
                else if (type === 'levelup') { this.life = 2.0; this.vy = -1; } // ë ˆë²¨ì—… í…ìŠ¤íŠ¸ ê¸¸ê²Œ
                else if (type === 'star' || type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.size = Math.random() * 10 + 5;
                }
            }
            update() {
                this.life -= 0.05;
                if (this.type === 'hit') this.radius += 5;
                else if (this.type === 'bomb_hit') this.radius += 8; // í­ë°œ ë” í¬ê²Œ
                else if (this.type === 'miss' || this.type === 'levelup') this.y += this.vy;
                else if (this.type === 'star' || this.type === 'smoke') {
                    this.x += this.vx; this.y += this.vy;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, this.life));
                
                if (this.type === 'hit') {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 5; ctx.stroke();
                } else if (this.type === 'bomb_hit') { // ì¾…! ì´í™íŠ¸
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff4444'; ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = `bold ${config.holeSize*0.4}px Jua`;
                    ctx.fillText("ì¾…!!!", this.x-config.holeSize*0.2, this.y);
                } else if (this.type === 'miss') {
                    ctx.fillStyle = '#FF4500'; ctx.font = `bold ${config.holeSize*0.3}px Jua`;
                    ctx.fillText("MISS!", this.x - 20, this.y);
                } else if (this.type === 'levelup') {
                    ctx.fillStyle = '#ffffff'; 
                    ctx.shadowColor="black"; ctx.shadowBlur=10;
                    ctx.font = `bold ${config.holeSize*0.6}px Jua`;
                    ctx.textAlign = "center";
                    ctx.fillText("LEVEL UP!", this.x, this.y);
                } else if (this.type === 'star') {
                    ctx.fillStyle = '#FFFF00'; ctx.translate(this.x, this.y); ctx.rotate(this.life*5);
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                } else if (this.type === 'smoke') { // í­íƒ„ ì—°ê¸°
                    ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Hole {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.state = 'idle'; 
                this.type = 'mole'; // 'mole' or 'bomb'
                this.moleY = 0;
            }

            pop() {
                if (this.state !== 'idle') return;
                this.state = 'rising';
                this.moleY = config.holeSize;
                
                // ë ˆë²¨ì´ ë†’ì„ìˆ˜ë¡ í­íƒ„ í™•ë¥  ì¦ê°€ (ìµœëŒ€ 30%)
                // ë ˆë²¨ 1: 0%, ë ˆë²¨ 2: 10%, ë ˆë²¨ 3: 15% ...
                const bombChance = Math.min(0.3, (gameState.level - 1) * 0.1); 
                this.type = Math.random() < bombChance ? 'bomb' : 'mole';

                // ë ˆë²¨ì´ ë†’ì„ìˆ˜ë¡ ë” ë¹¨ë¦¬ ë“¤ì–´ê°
                const baseTime = 1000;
                const minTime = 400;
                const speedFactor = (gameState.level - 1) * 100; 
                const stayTime = Math.max(minTime, Math.random() * (baseTime - speedFactor) + minTime);

                setTimeout(() => {
                    if (this.state === 'rising') this.state = 'idle';
                }, stayTime);
            }

            hit(hitX, hitY) {
                if (this.state === 'rising') {
                    this.state = 'hit'; // ì¦‰ì‹œ ìƒíƒœ ë³€ê²½

                    if (this.type === 'mole') {
                        // ë‘ë”ì§€: ì ìˆ˜ íšë“
                        updateScore(10); // ê¸°ë³¸ 10ì 
                        effects.push(new Effect(hitX, hitY, 'hit'));
                        for(let i=0; i<5; i++) effects.push(new Effect(hitX, hitY, 'star'));
                    } else {
                        // í­íƒ„: ê°ì 
                        updateScore(-config.bombPenalty);
                        effects.push(new Effect(hitX, hitY, 'bomb_hit'));
                        for(let i=0; i<8; i++) effects.push(new Effect(hitX, hitY, 'smoke'));
                        // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ (ê°„ë‹¨ êµ¬í˜„)
                        canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                        setTimeout(()=>canvas.style.transform='none', 200);
                    }

                    setTimeout(() => { this.state = 'idle'; }, 500);
                    return true;
                }
                return false;
            }

            draw() {
                const cx = this.x + config.holeSize/2;
                const cy = this.y + config.holeSize/2;

                // 1. êµ¬ë©
                ctx.fillStyle = '#3e2723';
                ctx.beginPath();
                ctx.ellipse(cx, cy + config.holeSize*0.15, config.holeSize/2, config.holeSize/3, 0, 0, Math.PI * 2);
                ctx.fill();

                // 2. ë‚´ìš©ë¬¼ (ë§ˆìŠ¤í‚¹)
                ctx.save();
                ctx.beginPath();
                ctx.rect(this.x, this.y - config.holeSize, config.holeSize, config.holeSize * 2); 
                ctx.clip();

                // ì• ë‹ˆë©”ì´ì…˜ ì†ë„ë„ ë ˆë²¨ì— ë”°ë¼ ë¹¨ë¼ì§
                let moveSpeed = (config.holeSize * 0.1) + (gameState.level * 0.5); 
                
                if (this.state !== 'idle') {
                    this.moleY = Math.max(0, this.moleY - (this.state === 'rising' ? moveSpeed : -moveSpeed/2));
                } else {
                    this.moleY = Math.min(config.holeSize, this.moleY + moveSpeed);
                }

                const drawY = cy + this.moleY;

                if (this.moleY < config.holeSize) {
                    if (this.type === 'mole') {
                        this.drawMole(cx, drawY);
                    } else {
                        this.drawBomb(cx, drawY);
                    }
                }
                ctx.restore();

                // 3. êµ¬ë© ì• í„±
                ctx.fillStyle = '#5d4037'; ctx.beginPath(); 
                ctx.ellipse(cx, cy + config.holeSize*0.2, config.holeSize/2, config.holeSize/6, 0, 0, Math.PI); ctx.fill();
            }

            drawMole(x, y) {
                // ëª¸í†µ
                ctx.fillStyle = '#8d6e63'; 
                ctx.beginPath(); ctx.ellipse(x, y, config.moleSize/2, config.moleSize/1.8, 0, Math.PI, 0); ctx.fill(); ctx.stroke();
                
                // í‘œì •
                const eyeOffX = config.moleSize*0.2; const eyeOffY = config.moleSize*0.4;
                ctx.fillStyle = 'black';
                if (this.state === 'hit') {
                    // ì•„ì•¼! X_X
                    ctx.lineWidth=3;
                    ctx.beginPath(); ctx.moveTo(x-eyeOffX-5, y-eyeOffY-5); ctx.lineTo(x-eyeOffX+5, y-eyeOffY+5); ctx.moveTo(x-eyeOffX+5, y-eyeOffY-5); ctx.lineTo(x-eyeOffX-5, y-eyeOffY+5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(x+eyeOffX-5, y-eyeOffY-5); ctx.lineTo(x+eyeOffX+5, y-eyeOffY+5); ctx.moveTo(x+eyeOffX+5, y-eyeOffY-5); ctx.lineTo(x+eyeOffX-5, y-eyeOffY+5); ctx.stroke();
                    ctx.lineWidth=1;
                    ctx.fillStyle = 'red'; ctx.font = `bold ${config.moleSize*0.3}px Jua`; 
                    ctx.fillText('ì•„ì•¼!', x-config.moleSize*0.4, y-config.moleSize*0.6);
                } else {
                    // ê¸°ë³¸ O_O
                    ctx.beginPath(); ctx.arc(x-eyeOffX, y-eyeOffY, 3, 0, Math.PI*2); ctx.arc(x+eyeOffX, y-eyeOffY, 3, 0, Math.PI*2); ctx.fill();
                }
                // ì½”
                ctx.fillStyle = '#ffab91'; ctx.beginPath(); ctx.ellipse(x, y-eyeOffY+15, 8, 5, 0, 0, Math.PI*2); ctx.fill();
            }

            drawBomb(x, y) {
                // í­íƒ„ ë³¸ì²´ (ê²€ì€ ì›)
                ctx.fillStyle = '#222'; 
                ctx.beginPath(); ctx.arc(x, y-config.moleSize*0.2, config.moleSize/2.2, 0, Math.PI*2); ctx.fill(); 
                // ê´‘íƒ
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(x-10, y-config.moleSize*0.4, 5, 0, Math.PI*2); ctx.fill();
                
                // ì‹¬ì§€
                ctx.strokeStyle = '#d4a017'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(x, y-config.moleSize*0.6); ctx.quadraticCurveTo(x+10, y-config.moleSize*0.8, x+15, y-config.moleSize*0.7); ctx.stroke();
                
                // ì‹¬ì§€ ë¶ˆê½ƒ
                if (this.state !== 'hit') {
                    ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(x+15, y-config.moleSize*0.7, Math.random()*4+2, 0, Math.PI*2); ctx.fill();
                }

                // í•´ê³¨ ë§ˆí¬ or ìœ„í—˜ í‘œì‹œ
                ctx.fillStyle = 'red'; ctx.font = `bold ${config.moleSize*0.4}px sans-serif`; 
                ctx.fillText("!", x-4, y-config.moleSize*0.1);
            }
        }

        function drawHammer(ctx, x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            const scale = config.holeSize / 120;
            // ë¿…ë§ì¹˜
            ctx.fillStyle = '#8B4513'; ctx.fillRect(-10*scale, -20*scale, 20*scale, 100*scale);
            ctx.fillStyle = '#FF6347'; ctx.beginPath(); ctx.roundRect(-40*scale, -50*scale, 80*scale, 40*scale, 10*scale); ctx.fill();
            ctx.strokeStyle = '#B22222'; ctx.lineWidth = 3*scale; ctx.stroke();
            // ì£¼ë¦„
            ctx.fillStyle = '#ff8a65'; 
            ctx.beginPath(); ctx.arc(-20*scale, -30*scale, 5*scale, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(20*scale, -30*scale, 5*scale, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // ==========================================
        // ë©”ì¸ ê²Œì„ ë£¨í”„
        // ==========================================
        function initHoles() {
            holes = [];
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    holes.push(new Hole(0,0)); // resizeCanvasì—ì„œ ìœ„ì¹˜ ì¡ìŒ
                }
            }
        }

        function randomHole() {
            const idx = Math.floor(Math.random() * holes.length);
            const hole = holes[idx];
            if (hole === gameState.lastHole) return randomHole();
            gameState.lastHole = hole;
            return hole;
        }

        function peep() {
            if (!gameState.isPlaying) return;
            
            // ë ˆë²¨ì— ë”°ë¼ íŠ€ì–´ë‚˜ì˜¤ëŠ” ë¹ˆë„ ì¦ê°€
            let freq = Math.max(300, 1000 - (gameState.level * 100));
            let variance = Math.max(100, 500 - (gameState.level * 50));
            
            const time = Math.random() * variance + freq;
            randomHole().pop();
            setTimeout(peep, time);
        }

        function updateScore(points) {
            gameState.score += points;
            scoreDisplay.textContent = gameState.score;
            if (points > 0) checkLevel();
        }

        function startGame() {
            gameState.score = 0;
            gameState.level = 1;
            gameState.timeLeft = config.baseTime;
            gameState.isPlaying = true;
            effects = [];
            
            scoreDisplay.textContent = "0";
            levelDisplay.textContent = "1";
            timeDisplay.textContent = gameState.timeLeft;
            newRecordMsg.style.display = 'none';
            
            switchScreen(null); // ëª¨ë“  ìŠ¤í¬ë¦° ë‹«ê¸°
            
            resizeCanvas();
            peep();
            
            // íƒ€ì´ë¨¸
            if (timerId) clearInterval(timerId);
            timerId = setInterval(() => {
                gameState.timeLeft--;
                timeDisplay.textContent = gameState.timeLeft;
                if (gameState.timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            if (!gameLoopId) animate();
        }

        function endGame() {
            gameState.isPlaying = false;
            clearInterval(timerId);
            
            finalScoreSpan.textContent = gameState.score;
            
            const isNewRecord = saveHighScore(gameState.score);
            if(isNewRecord && gameState.score > 0) newRecordMsg.style.display = 'block';
            
            switchScreen(gameOverScreen);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            holes.forEach(hole => hole.draw());

            effects = effects.filter(e => e.life > 0);
            effects.forEach(e => { e.update(); e.draw(ctx); });

            if (gameState.isPlaying) {
                // ë§ì¹˜ ìœ„ì¹˜ ë³´ì • (ëª¨ë°”ì¼/PC)
                drawHammer(ctx, gameState.mouseX, gameState.mouseY, gameState.hammer.angle);
            }

            gameLoopId = requestAnimationFrame(animate);
        }

        // ==========================================
        // ì…ë ¥ í•¸ë“¤ëŸ¬
        // ==========================================
        function handleInput(x, y) {
            if (!gameState.isPlaying) return;

            gameState.mouseX = x; gameState.mouseY = y;
            gameState.hammer.isHitting = true;
            gameState.hammer.angle = -Math.PI / 4;

            let hitSomething = false;

            holes.forEach(hole => {
                const cx = hole.x + config.holeSize / 2;
                const cy = hole.y + config.holeSize / 2;
                const dist = Math.hypot(x - cx, y - cy);
                
                if (dist < config.holeSize / 1.5 && hole.state === 'rising') {
                    hole.hit(x, y);
                    hitSomething = true;
                }
            });

            if (!hitSomething) {
                updateScore(-config.missPenalty);
                effects.push(new Effect(x, y, 'miss'));
            }

            setTimeout(() => { 
                gameState.hammer.isHitting = false; 
                gameState.hammer.angle = 0; 
            }, 100);
        }

        // Mouse & Touch Events
        canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => { gameState.mouseX = e.clientX; gameState.mouseY = e.clientY; });
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        canvas.addEventListener('touchmove', e => {
             e.preventDefault(); 
             gameState.mouseX = e.touches[0].clientX; gameState.mouseY = e.touches[0].clientY; 
        }, {passive: false});

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

        // ì´ˆê¸°í™”
        initHoles();
        resizeCanvas();

    </script>
</body>
</html>
