<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš´ë¹¨ ì†”ë¡œ ë””íœìŠ¤ v8.8 (ë¹„ìš© ë°¸ëŸ°ìŠ¤ ì¡°ì •)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        * { box-sizing: border-box; touch-action: none; }

        body {
            margin: 0; padding: 0;
            background-color: #0f0f0f;
            display: flex; align-items: center; justify-content: center;
            height: 100vh;
            height: 100dvh; 
            color: white; font-family: 'Jua', sans-serif;
            overflow: hidden; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 100%; height: 100%;
            max-width: 600px;
            background-color: #4CAF50;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }

        /* --- ìƒë‹¨ UI --- */
        #top-ui {
            flex: 0 0 145px;
            background: rgba(0,0,0,0.85);
            padding: 5px 15px; z-index: 10;
            display: flex; flex-direction: column; justify-content: center;
            border-bottom: 2px solid #333;
            transition: flex-basis 0.3s;
        }

        .utility-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        
        .timer-box {
            font-size: 1.1rem; color: #FFF; 
            background: #333; padding: 4px 10px; border-radius: 8px;
            border: 1px solid #777; display: flex; align-items: center; gap: 5px; width: 110px; justify-content: center;
        }
        .timer-box.urgent { color: #FF5252; border-color: #FF5252; animation: blink 1s infinite; }
        .timer-box.prep { color: #00E676; border-color: #00E676; }

        .util-right { display: flex; gap: 5px; }
        .util-btn {
            background: #424242; border: 1px solid #757575; color: white;
            padding: 6px 12px; border-radius: 12px; font-family: 'Jua'; cursor: pointer;
            font-size: 0.9rem; transition: background 0.2s; min-width: 40px;
        }
        .util-btn.active { background: #FFC107; color: black; border-color: #FF6F00; }
        .util-btn.active-x3 { background: #FF5252; color: white; border-color: #D50000; }
        .util-btn.paused { background: #2196F3; border-color: #64B5F6; }
        .util-btn.artifact { background: #9C27B0; border-color: #E1BEE7; }
        .util-btn.shop { background: #009688; border-color: #80CBC4; }
        .util-btn.fx-off { background: #616161; color: #aaa; border-color: #424242; }

        /* ìŠ¤í‚µ ë²„íŠ¼ */
        .btn-skip {
            background: linear-gradient(to bottom, #29B6F6, #0288D1);
            border: 2px solid #B3E5FC; color: white;
            padding: 5px 15px; border-radius: 20px;
            font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            animation: pulse-blue 2s infinite;
        }
        .btn-skip.prep-mode {
            background: linear-gradient(to bottom, #66BB6A, #2E7D32);
            border-color: #A5D6A7;
            animation: none;
        }
        .btn-skip:active { transform: scale(0.95); }

        .top-info-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 4px; }
        .info-group { text-align: center; }
        .info-label { font-size: 11px; color: #bbb; }
        .info-value { font-size: 1.2rem; color: #FFD700; text-shadow: 1px 1px 2px #000; }
        
        .mythic-stone {
            display: flex; align-items: center; gap: 5px;
            background: rgba(100, 0, 255, 0.2); padding: 2px 8px; border-radius: 12px; border: 1px solid #7C4DFF;
            font-size: 0.9rem; color: #E040FB;
        }

        .class-upgrade-bar { display: flex; gap: 5px; justify-content: space-between; margin-top: 4px; }
        .class-btn {
            flex: 1; border: 1px solid #555; border-radius: 8px;
            background: rgba(255,255,255,0.1); color: #ddd;
            font-family: 'Jua'; cursor: pointer; padding: 4px 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.8rem; transition: background 0.1s;
        }
        .class-btn:active { transform: scale(0.95); }
        .cb-phy { border-color: #EF5350; }
        .cb-mag { border-color: #AB47BC; }
        .cb-sup { border-color: #26A69A; }

        #canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; background-color: #66BB6A; }
        canvas { display: block; width: 100%; height: 100%; }

        /* ì¼ì‹œì •ì§€ ì˜¤ë²„ë ˆì´ */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); pointer-events: none; display: none;
            justify-content: center; align-items: center; font-size: 3rem; 
            color: white; font-weight: bold; text-shadow: 0 0 10px black; z-index: 50;
        }

        /* --- í•˜ë‹¨ UI --- */
        #bottom-ui {
            flex: 0 0 160px;
            background-color: #3E2723;
            padding: 10px;
            display: flex; flex-direction: column; justify-content: space-between;
            border-top: 4px solid #281A16; z-index: 10;
            transition: flex-basis 0.3s;
        }

        #resources { display: flex; justify-content: space-between; padding: 0 5px; margin-bottom: 5px; font-size: 1.1rem; color: #FFD700; }
        #buttons { display: flex; justify-content: space-between; align-items: flex-end; height: 100%; gap: 6px; }

        .game-btn {
            border: none; border-radius: 14px; color: white;
            font-family: 'Jua', sans-serif; cursor: pointer;
            position: relative; box-shadow: 0 5px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s; padding: 0; overflow: hidden;
        }
        .game-btn:active { transform: translateY(5px); box-shadow: none; }

        .btn-upgrade { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #673AB7, #512DA8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #9575CD; }
        .btn-summon { flex: 1; height: 100%; max-height: 95px; background: linear-gradient(135deg, #FFC107, #FF8F00); font-size: 1.6rem; color: #3E2723; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 1px solid #FFE082; }
        .btn-combine { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #009688, #00695C); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #4DB6AC; }
        .btn-gamble { width: 18%; height: 100%; max-height: 70px; background: linear-gradient(135deg, #2196F3, #1565C0); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; border: 1px solid #64B5F6; margin-bottom: 5px;}

        @media (max-height: 800px) {
            #top-ui { flex: 0 0 125px; padding: 3px 10px; }
            #bottom-ui { flex: 0 0 140px; padding: 5px; }
            .info-value { font-size: 1rem; }
            .timer-box { font-size: 0.9rem; width: 90px; }
            .util-btn { padding: 4px 8px; font-size: 0.8rem; }
            .game-btn { border-radius: 10px; box-shadow: 0 3px 0 rgba(0,0,0,0.5); }
            .btn-summon { font-size: 1.3rem; }
            .btn-upgrade, .btn-combine { font-size: 0.8rem; }
            .btn-gamble { font-size: 0.7rem; }
            #resources { font-size: 0.9rem; margin-bottom: 2px; }
        }

        @media (max-height: 600px) {
            #top-ui { flex: 0 0 110px; }
            #bottom-ui { flex: 0 0 120px; }
            .class-btn { font-size: 0.7rem; padding: 2px 0; }
        }

        @keyframes pulse-blue { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(41, 182, 246, 0.7); } 70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(41, 182, 246, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(41, 182, 246, 0); } }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* ëª¨ë‹¬ & íˆ´íŒ */
        .game-modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; height: 85%; background: rgba(30, 30, 30, 0.98); border: 2px solid #FFD700; border-radius: 15px; z-index: 100; flex-direction: column; padding: 15px; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.9); }
        .game-modal.open { display: flex; }
        .modal-header { font-size: 1.4rem; text-align: center; margin-bottom: 10px; color: #FFD700; }
        
        .recipe-list { 
            overflow-y: auto; 
            flex: 1; 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 8px; 
            /* ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤ ìˆ˜ì •: ì „ì—­ touch-action:noneì„ ë®ì–´ì”€ */
            touch-action: pan-y; 
            -webkit-overflow-scrolling: touch;
        }

        .recipe-card { background: rgba(255, 255, 255, 0.08); padding: 8px; border-radius: 6px; display: flex; flex-direction: column; gap: 3px; border: 1px solid #555; position: relative; }
        .recipe-name { font-size: 1rem; font-weight: bold; color: #E040FB; display: flex; justify-content: space-between;}
        .recipe-desc { font-size: 0.75rem; color: #bbb; margin-bottom: 5px; height: 30px; overflow: hidden; }
        .recipe-req { display: flex; gap: 5px; font-size: 0.75rem; color: #ddd; align-items: center; flex-wrap: wrap; }
        
        .artifact-card { background: rgba(0, 0, 0, 0.4); border: 1px solid #7B1FA2; padding: 10px; border-radius: 8px; display: flex; align-items: center; gap: 10px; }
        .artifact-icon { font-size: 2rem; background: rgba(255,255,255,0.1); border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; }
        .artifact-info { flex: 1; }
        .artifact-name { font-weight: bold; color: #E1BEE7; }
        .artifact-stat { font-size: 0.85rem; color: #9E9E9E; }
        .artifact-count { font-size: 1.2rem; font-weight: bold; color: #FFD700; }

        .shop-card { background: rgba(0, 50, 50, 0.4); border: 1px solid #009688; padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 5px; align-items: center; text-align: center; }
        .shop-name { font-weight: bold; color: #80CBC4; font-size: 1.1rem; }
        .shop-desc { font-size: 0.8rem; color: #B2DFDB; margin-bottom: 5px; }
        .shop-cost { color: #E040FB; font-weight: bold; font-size: 0.9rem; }

        .btn-buy-recipe { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #6200EA; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #00C853; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine:disabled { background: #444; color: #888; cursor: not-allowed; }
        .btn-close { margin-top: 10px; padding: 10px; background: #D32F2F; color: white; border: none; border-radius: 8px; font-family: 'Jua'; cursor: pointer; }

        /* ë©”ì‹œì§€ ì˜ì—­ ìˆ˜ì •: ì¤‘ì²© ê°€ëŠ¥í•˜ë„ë¡ */
        #message-area { 
            position: absolute; top: 25%; left: 50%; transform: translateX(-50%); 
            pointer-events: none; display: flex; flex-direction: column-reverse; 
            align-items: center; width: 100%; height: 0; overflow: visible; z-index: 999; 
        }
        
        .pop-text { 
            font-size: 2rem; font-weight: bold; color: #fff; 
            text-shadow: 2px 2px 0 #000, 0 0 10px gold; 
            opacity: 0; margin-bottom: 5px; animation: popupFloat 1.5s forwards; 
            flex-shrink: 0; white-space: nowrap;
        }

        @keyframes popupFloat {
            0% { opacity: 0; transform: translateY(20px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1.1); }
            20% { transform: translateY(0) scale(1); }
            80% { opacity: 1; transform: translateY(-30px); }
            100% { opacity: 0; transform: translateY(-60px); }
        }
        
        .tooltip { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); background: rgba(20,20,20,0.95); padding: 15px; border-radius: 8px; font-size: 0.95rem; display: none; width: 90%; text-align: center; z-index: 200; border: 2px solid #FFD700; pointer-events: none; white-space: pre-line; box-shadow: 0 5px 20px rgba(0,0,0,0.8); }
        .luck-tooltip { position: absolute; bottom: 100px; left: 10px; background: rgba(0,0,0,0.95); padding: 12px; border-radius: 8px; border: 1px solid #7E57C2; color: white; font-size: 0.85rem; z-index: 200; display: none; pointer-events: none; text-align: left; line-height: 1.6; }

        .c-rare { color: #42A5F5; } .c-hero { color: #BA68C8; } .c-legend { color: #FF9800; } .c-myth { color: #FF5252; } .c-immortal { color: #E040FB; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="top-ui">
            <div class="utility-bar">
                <div id="timer-box" class="timer-box">
                    <span id="timer-icon">â³</span> <span id="wave-timer">40</span>s
                </div>
                <button id="btn-skip" class="btn-skip" onclick="skipWave()">
                    <span id="skip-text">â© ìŠ¤í‚µ</span>
                    <span id="skip-reward-box" style="font-size:0.8em;">(+<span id="skip-reward">0</span>G)</span>
                </button>
                <div class="util-right">
                    <button id="btn-fx" class="util-btn active" onclick="toggleFx()">âœ¨ FX On</button>
                    <button class="util-btn shop" onclick="openShopModal()">ğŸª</button>
                    <button class="util-btn artifact" onclick="openArtifactModal()">ğŸ“¦</button>
                    <button id="btn-pause" class="util-btn" onclick="togglePause()">â¸ï¸</button>
                    <button id="btn-auto-merge" class="util-btn" onclick="toggleAutoMerge()">ğŸ¤– Auto Off</button>
                    <button id="btn-speed" class="util-btn" onclick="toggleSpeed()">â© x1</button>
                </div>
            </div>

            <div class="top-info-row">
                <div class="info-group">
                    <div class="info-label">WAVE</div>
                    <div class="info-value" id="wave-display">1</div>
                </div>
                <div class="mythic-stone">
                    ğŸ’ <span id="stone-display">0</span>
                </div>
                <div class="info-group">
                    <div class="info-label">ì¸êµ¬ìˆ˜ (ìµœëŒ€ <span id="max-pop-display">200</span>)</div>
                    <div class="info-value" style="color:#FF5252"><span id="enemy-count">0</span> / <span id="max-pop-val">200</span></div>
                </div>
            </div>
            
            <div class="class-upgrade-bar">
                <button class="class-btn cb-phy" onclick="upgradeClass('phy')">
                    âš”ï¸ ë¬¼ë¦¬ Lv.<span id="lv-phy">1</span>
                    <span id="cost-phy" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
                <button class="class-btn cb-mag" onclick="upgradeClass('mag')">
                    ğŸ”® ë§ˆë²• Lv.<span id="lv-mag">1</span>
                    <span id="cost-mag" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
                <button class="class-btn cb-sup" onclick="upgradeClass('sup')">
                    âš—ï¸ ë³´ì¡° Lv.<span id="lv-sup">1</span>
                    <span id="cost-sup" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="pause-overlay">PAUSED</div>
            <!-- ë©”ì‹œì§€ê°€ ë™ì ìœ¼ë¡œ ì¶”ê°€ë  ì˜ì—­ -->
            <div id="message-area"></div>
            <div id="unit-tooltip" class="tooltip"></div>
            <div id="luck-tooltip" class="luck-tooltip"></div>
        </div>

        <div id="bottom-ui">
            <div id="resources">
                <span style="color:#ccc;">í–‰ìš´ Lv.<span id="summon-level">1</span></span>
                <span>ğŸ’° <span id="gold-display">200</span></span>
            </div>
            <div id="buttons">
                <button class="game-btn btn-upgrade" onclick="upgradeSummon()" 
                    onmousedown="showLuckInfo()" onmouseup="hideLuckInfo()"
                    ontouchstart="showLuckInfo()" ontouchend="hideLuckInfo()">
                    â˜˜ï¸ê°•í™”
                    <span style="font-size:0.75em; color:#FFEB3B; margin-top:2px;" id="upgrade-cost">50G</span>
                </button>
                
                <button class="game-btn btn-summon" onclick="summonUnit()">
                    ğŸ² ì†Œí™˜
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;" id="summon-cost-display">10 G</span>
                </button>
                
                <button class="game-btn btn-combine" onclick="openCombineModal()">
                    ğŸ° ì¡°í•©
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">New!</span>
                </button>

                <button class="game-btn btn-gamble" onclick="gamble()">
                    ğŸ°ë„ë°•<br><span id="gamble-cost-display">50G</span>
                </button>
            </div>
        </div>

        <!-- ì¡°í•© ëª¨ë‹¬ -->
        <div id="combine-modal" class="game-modal">
            <div class="modal-header">ğŸ° íˆë“  ì˜ì›… ì¡°í•©ì†Œ</div>
            <div class="recipe-list" id="recipe-list"></div>
            <button class="btn-close" onclick="closeModal('combine-modal')">ë‹«ê¸°</button>
        </div>

        <!-- ìœ ë¬¼ ëª¨ë‹¬ -->
        <div id="artifact-modal" class="game-modal">
            <div class="modal-header">ğŸ“¦ ë³´ìœ  ìœ ë¬¼</div>
            <div class="recipe-list" id="artifact-list"></div>
            <button class="btn-close" onclick="closeModal('artifact-modal')">ë‹«ê¸°</button>
        </div>

        <!-- ìƒì  ëª¨ë‹¬ -->
        <div id="shop-modal" class="game-modal">
            <div class="modal-header">ğŸª ê³ ëŒ€ ìƒì </div>
            <div class="recipe-list" style="grid-template-columns: 1fr; gap: 10px;">
                <div class="shop-card">
                    <div class="shop-name">ğŸ˜ï¸ ì˜í†  í™•ì¥</div>
                    <div class="shop-desc">ìµœëŒ€ ì¸êµ¬ìˆ˜ +10 ì¦ê°€ (ì˜êµ¬)</div>
                    <div class="shop-cost">ê°€ê²©: ğŸ’3</div>
                    <button class="btn-do-combine" onclick="buyShopItem('maxPop')">êµ¬ë§¤í•˜ê¸° (í˜„ì¬ Lv.<span id="shop-lv-maxPop">0</span>)</button>
                </div>
                <div class="shop-card">
                    <div class="shop-name">ğŸ’° ë¶€ì˜ ì¶•ì </div>
                    <div class="shop-desc">ì‹œì‘ ê³¨ë“œ +50 ì¦ê°€ (ì˜êµ¬)</div>
                    <div class="shop-cost">ê°€ê²©: ğŸ’2</div>
                    <button class="btn-do-combine" onclick="buyShopItem('startGold')">êµ¬ë§¤í•˜ê¸° (í˜„ì¬ Lv.<span id="shop-lv-startGold">0</span>)</button>
                </div>
                <div class="shop-card">
                    <div class="shop-name">âš”ï¸ ì „ì‚¬ì˜ í˜</div>
                    <div class="shop-desc">ëª¨ë“  ê³µê²©ë ¥ +5% (ì˜êµ¬)</div>
                    <div class="shop-cost">ê°€ê²©: ğŸ’5</div>
                    <button class="btn-do-combine" onclick="buyShopItem('dmgUp')">êµ¬ë§¤í•˜ê¸° (í˜„ì¬ Lv.<span id="shop-lv-dmgUp">0</span>)</button>
                </div>
                <div class="shop-card">
                    <div class="shop-name">ğŸ’° í™©ê¸ˆ ì†</div>
                    <div class="shop-desc">ê³¨ë“œ íšë“ +5% (ì˜êµ¬)</div>
                    <div class="shop-cost">ê°€ê²©: ğŸ’4</div>
                    <button class="btn-do-combine" onclick="buyShopItem('goldUp')">êµ¬ë§¤í•˜ê¸° (í˜„ì¬ Lv.<span id="shop-lv-goldUp">0</span>)</button>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px; color: #E040FB;">ë³´ìœ  ì‹ í™”ì„: ğŸ’<span id="shop-stone-display">0</span></div>
            <button class="btn-close" onclick="closeModal('shop-modal')">ë‹«ê¸°</button>
        </div>

        <!-- ê²Œì„ ì˜¤ë²„ ëª¨ë‹¬ -->
        <div id="game-over-modal" class="game-modal" style="border-color: #D50000; text-align: center;">
            <div class="modal-header" style="color: #FF5252; font-size: 2rem;">â˜ ï¸ GAME OVER â˜ ï¸</div>
            <div style="margin: 20px 0; font-size: 1.2rem; color: #ddd;">
                <div>ìµœì¢… ì›¨ì´ë¸Œ: <span id="go-wave" style="color: #FFD700; font-weight: bold;"></span></div>
                <div style="font-size: 0.9rem; margin-top: 5px;">ì¸êµ¬ìˆ˜ ì´ˆê³¼!</div>
            </div>
            <button class="btn-do-combine" onclick="retryGame()" style="background: #D32F2F; width: 60%; margin: 0 auto; display: block;">ë‹¤ì‹œ ë„ì „</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        const GRID_COLS = 6; const GRID_ROWS = 5;
        let TILE_SIZE = 0, GRID_OFFSET_X = 0, GRID_OFFSET_Y = 0;
        let PATH_POINTS = [];
        let TRASH_ZONE = { x: 0, y: 0, r: 0 };

        const UNIT_DATA = {
            'ì•¼ë§Œì¸': { color: '#BCAAA4', icon: 'ğŸª“', desc: '10% í™•ë¥ ë¡œ ê¸°ì ˆ (ë“±ê¸‰â†‘)', type: 'phy' },
            'ê¶ìˆ˜': { color: '#81D4FA', icon: 'ğŸ¹', desc: 'ì¹˜ëª…íƒ€ 2.5ë°° (ë“±ê¸‰â†‘)', type: 'phy' },
            'ì–¼ìŒë²•ì‚¬': { color: '#90CAF9', icon: 'ğŸ§Š', desc: 'ê³µê²© ì‹œ ìŠ¬ë¡œìš° 40% (ë“±ê¸‰â†‘)', type: 'mag' },
            'ì‚°ì ': { color: '#A1887F', icon: 'ğŸ’°', desc: '5% í™•ë¥ ë¡œ 10ê³¨ë“œ (ë“±ê¸‰â†‘)', type: 'sup' },
            'ì „ê¸°ë¡œë´‡': { color: '#FFF59D', icon: 'âš¡', desc: '3ì¸ ë™ì‹œ ê³µê²© (ë“±ê¸‰â†‘)', type: 'mag' },
            'ë‹Œì': { color: '#424242', icon: 'ğŸ¥·', desc: 'ì²´ë ¥ 30%ì´í•˜ 3ë°° í”¼í•´ (ë“±ê¸‰â†‘)', type: 'phy' }
        };
        const UNIT_TYPES = Object.keys(UNIT_DATA);
        
        const HIDDEN_DATA = {
            'ê°œêµ¬ë¦¬ì™•ì': { color: '#69F0AE', icon: 'ğŸ¸', desc: 'ì´ˆê³ ì† ê³µì† (5ë°°)', type: 'phy' },
            'ë§ˆì‹ ': { color: '#D50000', icon: 'ğŸ‘¿', desc: 'ì „ì²´ í™”ë©´ ê´‘ì—­ í”¼í•´', type: 'mag' },
            'ë“œë˜ê³¤': { color: '#FFAB00', icon: 'ğŸ²', desc: 'ê°•ë ¥í•œ í•œë°© & ìŠ¤í„´ (ë“±ê¸‰â†‘)', type: 'phy' },
            'ì„±ê¸°ì‚¬': { color: '#FFD54F', icon: 'ğŸ›¡ï¸', desc: 'ë²”ìœ„ ìŠ¤í„´ & ë†’ì€ ê¹¡ë”œ', type: 'phy' },
            'ì €ê²©ìˆ˜': { color: '#81C784', icon: 'ğŸ”«', desc: 'ì‚¬ê±°ë¦¬ ë¬´í•œ & ë‹¨ì¼ ê·¹ë”œ', type: 'phy' },
            'ëŒ€ë§ˆë²•ì‚¬': { color: '#7E57C2', icon: 'ğŸ§™â€â™‚ï¸', desc: 'ê´‘ì—­ ìŠ¬ë¡œìš° & ì§€ì†ë”œ', type: 'mag' },
            'ì—°ê¸ˆìˆ ì‚¬': { color: '#F4511E', icon: 'âš—ï¸', desc: 'ê³¨ë“œ ë³µì‚¬ í™•ë¥  ì¦ê°€ (ë“±ê¸‰â†‘)', type: 'sup' },
            'ê°•ë ¹ìˆ ì‚¬': { color: '#4A148C', icon: 'ğŸ’€', desc: 'ë¶€ì‹ ë°ë¯¸ì§€ ë¶€ì—¬', type: 'mag' },
            'ë¬´ì‚¬': { color: '#E0E0E0', icon: 'âš”ï¸', desc: '50% í™•ë¥ ë¡œ ì¹˜ëª…íƒ€', type: 'phy' },
            'ì œìš°ìŠ¤': { color: '#FFFF00', icon: 'ğŸŒ©ï¸', desc: '5ëª… ì—°ì‡„ ë²ˆê°œ ê³µê²©', type: 'mag' },
            'ê³¨ë ˜': { color: '#795548', icon: 'ğŸ—¿', desc: 'ê´‘ì—­ ìŠ¤í”Œë˜ì‹œ ê³µê²©', type: 'phy' },
            'ë±€íŒŒì´ì–´': { color: '#B71C1C', icon: 'ğŸ§›', desc: 'ê³µì† ë¹ ë¦„ & ì  ì²˜ì¹˜ì‹œ ê³µì†ë²„í”„', type: 'mag' },
            'ê³µí•™ì': { color: '#607D8B', icon: 'ğŸ”§', desc: 'ì£¼ë³€ ì•„êµ° ê³µì† +20%', type: 'sup' },
            'ë„ë°•ì‚¬': { color: '#3F51B5', icon: 'ğŸƒ', desc: 'ëœë¤ ë°ë¯¸ì§€ (1~10ë°°)', type: 'sup' },
            'ë©”ë‘ì‚¬': { color: '#004D40', icon: 'ğŸ', desc: '3ì´ˆê°„ ì  ì„í™”(ì •ì§€)', type: 'mag' },
            'í”¼ë‹‰ìŠ¤': { color: '#FF5722', icon: 'ğŸ¦…', desc: 'ë¼ì¸ ì „ì²´ í™”ìƒ ê³µê²©', type: 'mag' }
        };

        const ARTIFACT_DATA = {
            'sword': { name: 'ìš©ê¸°ì˜ ê²€', icon: 'âš”ï¸', desc: 'ë¬¼ë¦¬ ê³µê²©ë ¥ +10%', type: 'phyDmg', val: 0.1 },
            'crystal': { name: 'ë§ˆë‚˜ ìˆ˜ì •', icon: 'ğŸ”®', desc: 'ë§ˆë²• ê³µê²©ë ¥ +10%', type: 'magDmg', val: 0.1 },
            'coin': { name: 'í–‰ìš´ì˜ ë™ì „', icon: 'ğŸ’°', desc: 'ê³¨ë“œ íšë“ëŸ‰ +10%', type: 'gold', val: 0.1 },
            'feather': { name: 'ë°”ëŒì˜ ê¹ƒí„¸', icon: 'ğŸ¹', desc: 'ê³µê²© ì†ë„ +5%', type: 'spd', val: 0.05 },
            'skull': { name: 'ê±°ì¸ í•™ì‚´ì', icon: 'ğŸ’€', desc: 'ë³´ìŠ¤ í”¼í•´ëŸ‰ +20%', type: 'bossDmg', val: 0.2 },
            'hourglass': { name: 'ì‹œê°„ì˜ ëª¨ë˜', icon: 'â³', desc: 'ì¿¨íƒ€ì„ ê°ì†Œ +5%', type: 'cdr', val: 0.05 },
            'dice': { name: 'ë„ë°•ì‚¬ì˜ ì£¼ì‚¬ìœ„', icon: 'ğŸ²', desc: 'ì¹˜ëª…íƒ€ í™•ë¥  +5%', type: 'crit', val: 0.05 },
            'relic': { name: 'ê³ ëŒ€ ìœ ë¬¼', icon: 'ğŸ’', desc: 'ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ +30G', type: 'startGold', val: 30 }
        };
        const ARTIFACT_KEYS = Object.keys(ARTIFACT_DATA);

        const TIERS = ['ì¼ë°˜', 'í¬ê·€', 'ì˜ì›…', 'ì „ì„¤', 'ì‹ í™”', 'ë¶ˆë©¸'];
        const TIER_COLORS = ['#B0BEC5', '#29B6F6', '#AB47BC', '#FF7043', '#FF1744', '#D500F9'];

        const RECIPES = [
            { id: 'frog', name: 'ê°œêµ¬ë¦¬ì™•ì', cost: 3, result: 'ê°œêµ¬ë¦¬ì™•ì', req: [{type:'ì•¼ë§Œì¸',tier:3}, {type:'ê¶ìˆ˜',tier:3}] },
            { id: 'demon', name: 'ë§ˆì‹ ', cost: 5, result: 'ë§ˆì‹ ', req: [{type:'ë‹Œì',tier:3}, {type:'ì „ê¸°ë¡œë´‡',tier:3}] },
            { id: 'dragon', name: 'ë“œë˜ê³¤', cost: 5, result: 'ë“œë˜ê³¤', req: [{type:'ì–¼ìŒë²•ì‚¬',tier:3}, {type:'ì•¼ë§Œì¸',tier:3}] },
            { id: 'pala', name: 'ì„±ê¸°ì‚¬', cost: 3, result: 'ì„±ê¸°ì‚¬', req: [{type:'ì•¼ë§Œì¸',tier:3}, {type:'ì‚°ì ',tier:3}] },
            { id: 'sniper', name: 'ì €ê²©ìˆ˜', cost: 3, result: 'ì €ê²©ìˆ˜', req: [{type:'ê¶ìˆ˜',tier:3}, {type:'ë‹Œì',tier:3}] },
            { id: 'arch', name: 'ëŒ€ë§ˆë²•ì‚¬', cost: 3, result: 'ëŒ€ë§ˆë²•ì‚¬', req: [{type:'ì–¼ìŒë²•ì‚¬',tier:3}, {type:'ì „ê¸°ë¡œë´‡',tier:3}] },
            { id: 'alch', name: 'ì—°ê¸ˆìˆ ì‚¬', cost: 3, result: 'ì—°ê¸ˆìˆ ì‚¬', req: [{type:'ì‚°ì ',tier:3}, {type:'ì–¼ìŒë²•ì‚¬',tier:3}] },
            { id: 'necro', name: 'ê°•ë ¹ìˆ ì‚¬', cost: 3, result: 'ê°•ë ¹ìˆ ì‚¬', req: [{type:'ì „ê¸°ë¡œë´‡',tier:3}, {type:'ë‹Œì',tier:3}] },
            { id: 'samu', name: 'ë¬´ì‚¬', cost: 3, result: 'ë¬´ì‚¬', req: [{type:'ë‹Œì',tier:3}, {type:'ì•¼ë§Œì¸',tier:3}] },
            { id: 'zeus', name: 'ì œìš°ìŠ¤', cost: 4, result: 'ì œìš°ìŠ¤', req: [{type:'ì „ê¸°ë¡œë´‡',tier:3}, {type:'ì‚°ì ',tier:3}] },
            { id: 'golem', name: 'ê³¨ë ˜', cost: 3, result: 'ê³¨ë ˜', req: [{type:'ì•¼ë§Œì¸',tier:3}, {type:'ì–¼ìŒë²•ì‚¬',tier:3}] },
            { id: 'vamp', name: 'ë±€íŒŒì´ì–´', cost: 3, result: 'ë±€íŒŒì´ì–´', req: [{type:'ë‹Œì',tier:3}, {type:'ê¶ìˆ˜',tier:3}] },
            { id: 'engi', name: 'ê³µí•™ì', cost: 4, result: 'ê³µí•™ì', req: [{type:'ì‚°ì ',tier:3}, {type:'ì „ê¸°ë¡œë´‡',tier:3}] },
            { id: 'gamb', name: 'ë„ë°•ì‚¬', cost: 3, result: 'ë„ë°•ì‚¬', req: [{type:'ì‚°ì ',tier:3}, {type:'ê¶ìˆ˜',tier:3}] },
            { id: 'medu', name: 'ë©”ë‘ì‚¬', cost: 4, result: 'ë©”ë‘ì‚¬', req: [{type:'ì–¼ìŒë²•ì‚¬',tier:3}, {type:'ê¶ìˆ˜',tier:3}] },
            { id: 'phoe', name: 'í”¼ë‹‰ìŠ¤', cost: 5, result: 'í”¼ë‹‰ìŠ¤', req: [{type:'ì „ê¸°ë¡œë´‡',tier:3}, {type:'ì•¼ë§Œì¸',tier:3}] }
        ];
        RECIPES.forEach(r => r.unlocked = false);

        const SUMMON_RATES = [];
        for(let i=1; i<=20; i++) {
            let rate = {}; let cost = 0;
            let baseR = 1 + (i*1.5); 
            let baseE = 0.1 + (i*0.5); 
            let baseL = 0.05 + (i*0.25); 
            let baseM = 0.01 + (i*0.1); 

            if(i <= 5) { baseR = (i-1)*10 + 1; }
            else if(i <= 10) { baseR = 40 + (i-5)*2; baseE = (i-5)*3 + 1; }
            else if(i <= 15) { baseR = 50; baseE = 20 + (i-10)*2; baseL = (i-10)*2 + 1; }
            else { baseE = 30 + (i-15); baseL = 10 + (i-15)*3; baseM = (i-15)*0.5 + 0.1; }

            rate = { r: Math.min(baseR, 90), e: Math.min(baseE, 50), l: Math.min(baseL, 20), m: Math.min(baseM, 5) };
            let totalSpecial = rate.r + rate.e + rate.l + rate.m;
            if(totalSpecial > 99) {
                let factor = 99 / totalSpecial;
                rate.r *= factor; rate.e *= factor; rate.l *= factor; rate.m *= factor;
                totalSpecial = 99;
            }
            rate.c = 100 - totalSpecial;

            if(i <= 5) cost = 50 * i;
            else if(i <= 10) cost = 150 * (i-3);
            else if(i <= 15) cost = 1000 + (i-10)*500;
            else cost = 3000 + (i-15)*1500;
            if(i===20) cost = 'MAX';
            
            rate.c = parseFloat(rate.c.toFixed(2));
            rate.r = parseFloat(rate.r.toFixed(2));
            rate.e = parseFloat(rate.e.toFixed(2));
            rate.l = parseFloat(rate.l.toFixed(2));
            rate.m = parseFloat(rate.m.toFixed(2));
            SUMMON_RATES.push({ ...rate, cost: cost });
        }

        const BASE_SUMMON_COST = 10;
        const BASE_GAMBLE_COST = 50;
        const WAVE_DURATION = 40; 
        const MAX_ENEMIES_LIMIT = 200; 

        let gold = 200;
        let stones = 0; 
        let wave = 0; // 0ë¶€í„° ì‹œì‘í•˜ì—¬ startNextWave()í˜¸ì¶œì‹œ 1ì´ ë¨
        let units = [];
        let enemies = [];
        let projectiles = [];
        let effects = []; 
        let summonLevel = 1;
        let classLv = { phy: 1, mag: 1, sup: 1 };
        let artifacts = {}; // { sword: 2, coin: 5 ... }
        ARTIFACT_KEYS.forEach(k => artifacts[k] = 0);
        let upgrades = { maxPop: 0, startGold: 0, dmgUp: 0, goldUp: 0 }; // ìƒì  ì—…ê·¸ë ˆì´ë“œ
        let currentMaxPop = 200;

        let lastTime = 0;
        let enemySpawnTimer = 0;
        let enemiesToSpawn = 0;
        let waveTimer = 0;
        let isPrep = false; // ì¤€ë¹„ ì‹œê°„ ì—¬ë¶€
        let isFxOn = true; // ì´í™íŠ¸ On/Off
        
        let draggingUnit = null;
        let frameCount = 0;

        let timeScale = 1;
        let isAutoMerge = false;
        let autoMergeTimer = 0;
        let isPaused = false;
        
        let shakeAmount = 0; // í™”ë©´ í”ë“¤ë¦¼ ê°•ë„

        const SAVE_KEY = 'lucky_defense_solo_v5_art';

        function saveGame() {
            const data = {
                stones: stones,
                unlockedRecipes: RECIPES.filter(r => r.unlocked).map(r => r.id),
                artifacts: artifacts,
                upgrades: upgrades
            };
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        }

        function loadGame() {
            const json = localStorage.getItem(SAVE_KEY);
            if (json) {
                try {
                    const data = JSON.parse(json);
                    if(data.stones !== undefined) stones = data.stones;
                    if(data.unlockedRecipes) {
                        data.unlockedRecipes.forEach(id => {
                            const r = RECIPES.find(recipe => recipe.id === id);
                            if(r) r.unlocked = true;
                        });
                    }
                    if(data.artifacts) artifacts = { ...artifacts, ...data.artifacts };
                    if(data.upgrades) upgrades = { ...upgrades, ...data.upgrades };
                } catch(e) {}
            }
            updateMaxPop();
        }

        function updateMaxPop() {
            currentMaxPop = 200 + (upgrades.maxPop * 10);
        }

        function getSummonCost() { return BASE_SUMMON_COST + Math.max(0, (wave - 1) * 2); } // 0.5 -> 2 (4ë°°)
        function getGambleCost() { return BASE_GAMBLE_COST + Math.max(0, (wave - 1) * 4); } // 1 -> 4 (4ë°°)
        function getArtifactVal(type) {
            let total = 0;
            for(let k in artifacts) {
                if(ARTIFACT_DATA[k].type === type) total += ARTIFACT_DATA[k].val * artifacts[k];
            }
            return total;
        }

        function resizeGame() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            
            const maxTileW = canvas.width / (GRID_COLS + 2.5);
            const maxTileH = canvas.height / (GRID_ROWS + 4.0);
            
            TILE_SIZE = Math.floor(Math.min(maxTileW, maxTileH));
            GRID_OFFSET_X = (canvas.width - GRID_COLS * TILE_SIZE) / 2;
            GRID_OFFSET_Y = (canvas.height - GRID_ROWS * TILE_SIZE) / 2;

            const margin = TILE_SIZE * 0.7; 
            
            PATH_POINTS = [
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin }, 
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin } 
            ];

            TRASH_ZONE = { x: canvas.width - TILE_SIZE * 0.9, y: canvas.height - TILE_SIZE * 0.9, r: TILE_SIZE * 0.6 };
            units.forEach(u => { u.x = GRID_OFFSET_X + u.col * TILE_SIZE; u.y = GRID_OFFSET_Y + u.row * TILE_SIZE; });
        }

        function init() {
            loadGame();
            window.addEventListener('resize', resizeGame);
            resizeGame();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('touchstart', (e) => { if(e.touches.length>1) return; e.preventDefault(); onMouseDown({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchend', (e) => { onMouseUp({clientX: e.changedTouches?e.changedTouches[0].clientX : 0, clientY: e.changedTouches?e.changedTouches[0].clientY : 0}); });
            
            startNextWave(); 
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if(!isPaused) { frameCount++; update(deltaTime); }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            const scaledDelta = deltaTime * timeScale; 
            if (shakeAmount > 0) { shakeAmount -= (scaledDelta / 1000) * 20; if (shakeAmount < 0) shakeAmount = 0; }

            if (waveTimer > 0) {
                waveTimer -= scaledDelta / 1000;
                if (waveTimer <= 0) {
                    waveTimer = 0;
                    if(isPrep) startBattle(); else startNextWave();
                }
            }

            if (!isPrep && enemiesToSpawn > 0) {
                let spawnInterval = Math.max(150, 700 - (wave * 20)); 
                enemySpawnTimer += scaledDelta;
                if (enemySpawnTimer > spawnInterval) { spawnEnemy(); enemySpawnTimer = 0; enemiesToSpawn--; }
            }

            if(isAutoMerge) {
                autoMergeTimer += deltaTime; 
                if(autoMergeTimer > 500) { performAutoMerge(); autoMergeTimer = 0; }
            }

            for(let i=effects.length-1; i>=0; i--) {
                let fx = effects[i]; fx.life -= deltaTime;
                if(fx.type === 'text') fx.y -= (0.05 * deltaTime);
                else if(fx.type === 'particle') { fx.x += fx.vx * (deltaTime/16); fx.y += fx.vy * (deltaTime/16); }
                if(fx.life <= 0) effects.splice(i, 1);
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.stunTimer > 0) enemy.stunTimer -= scaledDelta;
                if (enemy.slowTimer > 0) enemy.slowTimer -= scaledDelta;
                if (enemy.dotTimer > 0) { enemy.dotTimer -= scaledDelta; enemy.hp -= (enemy.maxHp * 0.001); }
                
                moveEnemy(enemy, scaledDelta);
                
                if (enemy.hp <= 0) { 
                    let bonusGold = (2 + Math.floor(wave * 0.2)) * (1 + getArtifactVal('gold') + (upgrades.goldUp * 0.05));
                    gold += Math.floor(bonusGold); 
                    
                    if (isFxOn) {
                        let pColor = '#CFD8DC';
                        if(enemy.type === 'fast') pColor = '#FFF176';
                        else if(enemy.type === 'tank') pColor = '#8D6E63';
                        else if(enemy.type === 'boss') pColor = '#E91E63';
                        createExplosion(enemy.x, enemy.y, pColor, enemy.type === 'boss' ? 30 : 8);
                    }
                    
                    if(enemy.type === 'boss') { addShake(10); spawnFloatingText(enemy.x, enemy.y, "BOSS KILL!", "#FF1744"); }
                    enemies.splice(i, 1); updateUI(); 
                }
            }

            if (enemies.length > currentMaxPop) {
                showGameOver();
                return;
            }

            units.forEach(unit => {
                if (unit === draggingUnit) return;
                unit.cooldown -= scaledDelta;
                if (unit.cooldown <= 0) {
                    if(unit.type === 'ì „ê¸°ë¡œë´‡' || unit.type === 'ì œìš°ìŠ¤') {
                        let cnt = unit.type==='ì œìš°ìŠ¤' ? 5 : 3;
                        const targets = findTargets(unit, cnt);
                        if(targets.length > 0) { targets.forEach(t => fireProjectile(unit, t)); resetCooldown(unit); }
                    } else if(unit.type === 'ë§ˆì‹ ' || unit.type === 'í”¼ë‹‰ìŠ¤') {
                        fireGlobalAttack(unit); resetCooldown(unit);
                    } else if(unit.type === 'ê³µí•™ì') {
                         const target = findTarget(unit); if(target) { fireProjectile(unit, target); resetCooldown(unit); }
                    } else {
                        const target = findTarget(unit); if (target) { fireProjectile(unit, target); resetCooldown(unit); }
                    }
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i]; moveProjectile(p, scaledDelta);
                if (p.hit) { 
                    if(isFxOn) createExplosion(p.x, p.y, p.color, 3); 
                    projectiles.splice(i, 1); 
                }
            }
            updateUI(); 
        }

        // --- ì´í™íŠ¸ ê´€ë ¨ í•¨ìˆ˜ (ìµœì í™” ì ìš©) ---
        function toggleFx() {
            isFxOn = !isFxOn;
            const btn = document.getElementById('btn-fx');
            if(isFxOn) {
                btn.innerText = "âœ¨ FX On";
                btn.classList.remove('fx-off');
                btn.classList.add('active');
            } else {
                btn.innerText = "ğŸŒ‘ FX Off";
                btn.classList.remove('active');
                btn.classList.add('fx-off');
            }
        }

        function addShake(amount) { if(isFxOn) shakeAmount = amount; }
        
        function createExplosion(x, y, color, count) {
            if(!isFxOn) return;
            let currentCount = effects.length;
            if(currentCount > 400) return; 
            if(currentCount > 200) count = Math.ceil(count / 4); 
            else if(currentCount > 100) count = Math.ceil(count / 2); 
            if(count < 1) count = 1; 

            for(let i=0; i<count; i++) {
                let angle = Math.random() * Math.PI * 2; 
                let speed = Math.random() * 3 + 1;
                effects.push({ 
                    type: 'particle', 
                    x: x, y: y, 
                    vx: Math.cos(angle) * speed, 
                    vy: Math.sin(angle) * speed, 
                    color: color, 
                    life: 400 + Math.random() * 200, 
                    size: Math.random() * 3 + 2 
                });
            }
        }
        
        function createSparkle(x, y, color) {
            if(!isFxOn) return;
            let count = 10;
            if(effects.length > 300) count = 2;
            else if(effects.length > 150) count = 5;

            for(let i=0; i<count; i++) {
                effects.push({ 
                    type: 'particle', 
                    x: x + (Math.random() - 0.5) * TILE_SIZE, 
                    y: y + (Math.random() - 0.5) * TILE_SIZE, 
                    vx: (Math.random() - 0.5) * 0.5, 
                    vy: -Math.random() * 2 - 1, 
                    color: color, 
                    life: 600 + Math.random() * 300, 
                    size: Math.random() * 2 + 1 
                });
            }
        }
        // -------------------------

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none';
            document.getElementById('btn-pause').classList.toggle('paused', isPaused);
            document.getElementById('btn-pause').innerText = isPaused ? 'â–¶ï¸' : 'â¸ï¸';
        }
        function toggleSpeed() {
            if(timeScale === 1) timeScale = 2; else if(timeScale === 2) timeScale = 3; else timeScale = 1;
            const btn = document.getElementById('btn-speed');
            btn.innerText = `â© x${timeScale}`;
            btn.className = `util-btn ${timeScale >= 2 ? 'active' : ''} ${timeScale === 3 ? 'active-x3' : ''}`;
        }
        function toggleAutoMerge() {
            isAutoMerge = !isAutoMerge;
            const btn = document.getElementById('btn-auto-merge');
            btn.innerText = isAutoMerge ? 'ğŸ¤– On' : 'ğŸ¤– Off';
            btn.classList.toggle('active', isAutoMerge);
        }
        function performAutoMerge() {
            for(let i=0; i<units.length; i++) {
                let u1 = units[i];
                if(u1 === draggingUnit) continue;
                if(u1.tier >= 5) continue; 
                for(let j=i+1; j<units.length; j++) {
                    let u2 = units[j];
                    if(u2 === draggingUnit) continue;
                    if(u1.type === u2.type && u1.tier === u2.tier) { processMerge(u1, u2); return; }
                }
            }
        }
        function processMerge(u1, u2) {
            let newTier = u1.tier + 1; let newType = u1.type; let c = u2.col; let r = u2.row; 
            units = units.filter(u => u !== u1 && u !== u2);
            createUnit(c, r, newType, newTier);
            createSparkle(GRID_OFFSET_X + c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + r*TILE_SIZE + TILE_SIZE/2, TIER_COLORS[newTier]);
            if(newTier === 5) showPopup(`ğŸ”¥ë¶ˆë©¸ [${newType}] ê°•ë¦¼!ğŸ”¥`);
            else if(!isAutoMerge) showPopup(`í•©ì„±! [${TIERS[newTier]}] ì„±ê³µ âœ¨`); 
        }
        function spawnFloatingText(x, y, text, color='#FFD700') { effects.push({ type: 'text', x: x, y: y, text: text, color: color, life: 800 }); }

        function resetCooldown(unit) {
            let baseSpeed = 1000 / (1 + unit.tier * 0.25);
            let classSpdMult = 1 + (classLv.sup - 1) * 0.05 + getArtifactVal('spd');
            if(unit.type === 'ê°œêµ¬ë¦¬ì™•ì') baseSpeed = 200;
            if(unit.type === 'ë±€íŒŒì´ì–´') baseSpeed = 400;
            if(unit.type === 'ë§ˆì‹ ') baseSpeed = 1500;
            if(unit.type === 'ì €ê²©ìˆ˜') baseSpeed = 2000;
            
            // ì¿¨íƒ€ì„ ê°ì†Œ ìœ ë¬¼ ì ìš©
            let cdr = Math.min(0.5, getArtifactVal('cdr'));
            baseSpeed *= (1 - cdr);

            unit.cooldown = baseSpeed / classSpdMult;
        }

        function draw() {
            ctx.save();
            if (isFxOn && shakeAmount > 0) { let dx = (Math.random() - 0.5) * shakeAmount; let dy = (Math.random() - 0.5) * shakeAmount; ctx.translate(dx, dy); }
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5, GRID_COLS*TILE_SIZE + 10, GRID_ROWS*TILE_SIZE + 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            for(let c=0; c<GRID_COLS; c++) { for(let r=0; r<GRID_ROWS; r++) { ctx.strokeRect(GRID_OFFSET_X + c*TILE_SIZE, GRID_OFFSET_Y + r*TILE_SIZE, TILE_SIZE, TILE_SIZE); } }

            if(PATH_POINTS.length > 0) {
                ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = TILE_SIZE * 0.45; ctx.lineJoin = 'round';
                ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y);
                for(let i=1; i<PATH_POINTS.length; i++) ctx.lineTo(PATH_POINTS[i].x, PATH_POINTS[i].y);
                ctx.closePath(); ctx.stroke();
            }

            enemies.forEach(e => {
                let color = '#CFD8DC';
                if(e.type === 'fast') color = '#FFF176'; else if(e.type === 'tank') color = '#8D6E63'; else if(e.type === 'boss') color = '#E91E63';
                if(e.stunTimer > 0) color = '#FFEB3B'; else if(e.slowTimer > 0) color = '#42A5F5'; else if(e.dotTimer > 0) color = '#7B1FA2';
                
                let r = TILE_SIZE * 0.22; if(e.type === 'boss') r *= 1.5;
                ctx.fillStyle = color; ctx.beginPath(); 
                if(e.type === 'fast') { ctx.moveTo(e.x, e.y - r); ctx.lineTo(e.x + r, e.y + r); ctx.lineTo(e.x - r, e.y + r); } 
                else if(e.type === 'tank') { ctx.rect(e.x - r, e.y - r, r*2, r*2); } 
                else if(e.type === 'boss') { drawStar(ctx, e.x, e.y, 5, r, r/2); } 
                else { ctx.arc(e.x, e.y, r, 0, Math.PI*2); }
                ctx.fill(); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.stroke();

                let pct = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#263238'; ctx.fillRect(e.x - r, e.y - r - 8, r*2, 5);
                ctx.fillStyle = pct > 0.5 ? '#76FF03' : '#FF1744'; ctx.fillRect(e.x - r, e.y - r - 8, r*2*pct, 5);
            });

            units.forEach(u => { if(u !== draggingUnit) drawUnit(u, u.x, u.y); });

            projectiles.forEach(p => {
                ctx.fillStyle = p.color; ctx.beginPath(); 
                if(p.shape === 'arrow') ctx.ellipse(p.x, p.y, p.size*1.5, p.size*0.5, Math.atan2(p.target.y - p.y, p.target.x - p.x), 0, Math.PI*2);
                else if(p.shape === 'star') drawStar(ctx, p.x, p.y, 4, p.size, p.size/2);
                else ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); 
                ctx.fill();
            });

            effects.forEach(fx => {
                if(fx.type === 'text') {
                    ctx.globalAlpha = Math.max(0, fx.life / 800); ctx.fillStyle = fx.color; ctx.font = `bold ${TILE_SIZE*0.35}px Jua`;
                    ctx.textAlign = 'center'; ctx.lineWidth = 3; ctx.strokeText(fx.text, fx.x, fx.y); ctx.fillText(fx.text, fx.x, fx.y); ctx.globalAlpha = 1.0;
                } else if (isFxOn && fx.type === 'particle') {
                    ctx.globalAlpha = Math.max(0, fx.life / 600); ctx.fillStyle = fx.color; ctx.beginPath(); ctx.arc(fx.x, fx.y, fx.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
                }
            });

            if(draggingUnit) {
                if(draggingUnit.type !== 'ì €ê²©ìˆ˜') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    let rangePx = draggingUnit.range * (TILE_SIZE/55);
                    ctx.arc(draggingUnit.dragX, draggingUnit.dragY, rangePx, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
                let isHover = dist < TRASH_ZONE.r * 1.5;
                ctx.fillStyle = isHover ? '#D32F2F' : 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(TRASH_ZONE.x, TRASH_ZONE.y, isHover ? TRASH_ZONE.r*1.1 : TRASH_ZONE.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${TILE_SIZE*0.4}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText('ğŸ—‘ï¸', TRASH_ZONE.x, TRASH_ZONE.y);
                drawUnit(draggingUnit, draggingUnit.dragX, draggingUnit.dragY);
            }
            ctx.restore();
        }

        function drawUnit(unit, x, y) {
            const cx = x + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const cy = y + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const size = TILE_SIZE * 0.85;
            let data = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            ctx.fillStyle = data.color; ctx.lineWidth = 3;
            if(isFxOn && unit.tier >= 4) { let hue = (frameCount * 3) % 360; ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`; ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle; } 
            else { ctx.strokeStyle = TIER_COLORS[unit.tier]; ctx.shadowBlur = 0; }

            ctx.beginPath();
            if(unit.tier === 0) ctx.arc(cx, cy, size/2, 0, Math.PI*2);
            else if(unit.tier === 1) ctx.rect(cx - size/2, cy - size/2, size, size);
            else if(unit.tier === 2) drawPolygon(ctx, cx, cy, size/2, 6);
            else if(unit.tier === 3) drawPolygon(ctx, cx, cy, size/2, 4, Math.PI/4);
            else drawStar(ctx, cx, cy, 5, size/2, size/4); 
            ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

            ctx.fillStyle = 'white'; ctx.font = `${size*0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(data.icon, cx, cy);
            ctx.font = `${size*0.25}px sans-serif`; ctx.fillStyle = '#fff';
            let typeIcon = data.type === 'phy' ? 'âš”ï¸' : (data.type==='mag' ? 'ğŸ”®' : 'âš—ï¸');
            ctx.fillText(typeIcon, cx + size/3, cy + size/3);
        }

        function drawPolygon(ctx, x, y, radius, sides, rotateAngle = 0) {
            if (sides < 3) return; var a = (Math.PI * 2)/sides;
            ctx.moveTo(x + radius*Math.cos(rotateAngle), y + radius*Math.sin(rotateAngle));
            for (var i = 1; i < sides; i++) ctx.lineTo(x + radius*Math.cos(a*i + rotateAngle), y + radius*Math.sin(a*i + rotateAngle)); ctx.closePath();
        }
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI/2*3; let x=cx; let y=cy; let step=Math.PI/spikes;
            ctx.moveTo(cx, cy-outerRadius);
            for(let i=0; i<spikes; i++){ x=cx+Math.cos(rot)*outerRadius; y=cy+Math.sin(rot)*outerRadius; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*innerRadius; y=cy+Math.sin(rot)*innerRadius; ctx.lineTo(x,y); rot+=step; }
            ctx.lineTo(cx, cy-outerRadius); ctx.closePath();
        }

        function upgradeSummon() {
            if(summonLevel >= 20) { showPopup("ìµœê³  ë ˆë²¨ì…ë‹ˆë‹¤!"); return; }
            let cost = SUMMON_RATES[summonLevel-1].cost;
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            gold -= cost; summonLevel++; showPopup(`í–‰ìš´ ê°•í™” Lv.${summonLevel} ì„±ê³µ!`); updateUI();
            if(document.getElementById('luck-tooltip').style.display === 'block') showLuckInfo();
        }

        function upgradeClass(type) {
            let cost = classLv[type] * 100;
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            gold -= cost; classLv[type]++;
            let name = type==='phy'?'ë¬¼ë¦¬':(type==='mag'?'ë§ˆë²•':'ë³´ì¡°');
            showPopup(`${name} ê³„ì—´ Lv.${classLv[type]} ê°•í™”!`);
            updateUI();
        }

        function summonUnit() {
            let cost = getSummonCost();
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            let emptySlots = getEmptySlots();
            if(emptySlots.length === 0) { showPopup("ìë¦¬ê°€ ê½‰ ì°¼ìŠµë‹ˆë‹¤!"); return; }
            
            gold -= cost;
            
            let rates = SUMMON_RATES[summonLevel-1];
            let rand = Math.random() * 100;
            let tier = 0;
            
            if(rand < rates.c) tier = 0;
            else if(rand < rates.c + rates.r) { tier = 1; showPopup("í¬ê·€ ì†Œí™˜! ğŸ’™"); }
            else if(rand < rates.c + rates.r + rates.e) { tier = 2; showPopup("ì˜ì›… ì†Œí™˜! ğŸ’œ"); }
            else if(rand < rates.c + rates.r + rates.e + rates.l) { tier = 3; showPopup("ì „ì„¤ ì†Œí™˜! ğŸ§¡"); }
            else { tier = 4; showPopup("âš¡ì‹ í™” ì†Œí™˜!âš¡"); addShake(5); } // ì‹ í™” ì†Œí™˜ì‹œ í”ë“¤ë¦¼ ì¶”ê°€

            let slot = emptySlots[Math.floor(Math.random()*emptySlots.length)];
            let type = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
            createUnit(slot.c, slot.r, type, tier);
            
            // ì†Œí™˜ ì´í™íŠ¸
            createSparkle(GRID_OFFSET_X + slot.c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + slot.r*TILE_SIZE + TILE_SIZE/2, '#FFFFFF');

            updateUI();
        }

        function createUnit(col, row, type, tier) {
            const x = GRID_OFFSET_X + col * TILE_SIZE;
            const y = GRID_OFFSET_Y + row * TILE_SIZE;
            
            let mult = Math.pow(2.2, tier);
            if(tier >= 4) mult *= 2; 
            if(HIDDEN_DATA[type]) mult *= 3;

            let rng = 160 + (tier * 15);
            if(type === 'ì €ê²©ìˆ˜') rng = 9999;

            units.push({
                col, row, x, y, type, tier,
                damage: 10 * mult,
                range: rng,
                cooldown: 0
            });
        }

        function gamble() {
            let cost = getGambleCost();
            if(gold < cost) { showPopup("ë¹„ìš© ë¶€ì¡±!"); return; }
            gold -= cost;
            
            // í™•ë¥ : ê½ 35, ê³¨ë“œ 25, ìœ ë‹› 25, ìœ ë¬¼ 10, ì‹ í™”ì„ 5
            let rand = Math.random() * 100;
            
            if(rand < 35) {
                showPopup("ê½... ğŸ’¸");
            } else if(rand < 60) {
                // ê³¨ë“œ
                let gain = 150 + (summonLevel * 5) + (wave * 2); 
                gold += gain; showPopup(`+${gain}G ëŒ€ë°•! ğŸ‰`); 
            } else if(rand < 85) {
                // ìœ ë‹›
                let emptySlots = getEmptySlots();
                if(emptySlots.length > 0) {
                    let rates = SUMMON_RATES[summonLevel-1];
                    let r2 = Math.random() * 100;
                    let t = 0;
                    if(r2 < rates.c) t = 0; else if(r2 < rates.c+rates.r) t=1; else if(r2 < rates.c+rates.r+rates.e) t=2; else t=3; 
                    let s = emptySlots[Math.floor(Math.random()*emptySlots.length)];
                    let ty = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
                    createUnit(s.c, s.r, ty, t);
                    showPopup("ìœ ë‹› íšë“! ğŸ²");
                } else {
                    gold += cost; showPopup("ìë¦¬ ì—†ìŒ");
                }
            } else if(rand < 95) {
                // ìœ ë¬¼
                let key = ARTIFACT_KEYS[Math.floor(Math.random() * ARTIFACT_KEYS.length)];
                artifacts[key]++;
                let art = ARTIFACT_DATA[key];
                showPopup(`${art.icon} ${art.name} íšë“!`);
                saveGame();
            } else {
                // ì‹ í™”ì„
                stones += 1; showPopup("ğŸ’ ì‹ í™”ì„ íšë“! ğŸ’");
                saveGame();
            }
            updateUI();
        }

        function openCombineModal() {
            const list = document.getElementById('recipe-list');
            list.innerHTML = '';
            
            RECIPES.forEach(r => {
                const canUnlock = !r.unlocked && stones >= r.cost;
                const canCombine = r.unlocked && checkIngredients(r.req);
                let info = HIDDEN_DATA[r.result];
                let typeIcon = info.type === 'phy' ? 'âš”ï¸' : (info.type==='mag' ? 'ğŸ”®' : 'âš—ï¸');
                
                let btnHtml = !r.unlocked ? 
                    `<button class="btn-buy-recipe" onclick="unlockRecipe('${r.id}')" ${canUnlock?'':'disabled'}>í•´ê¸ˆ (ğŸ’${r.cost})</button>` :
                    `<button class="btn-do-combine" onclick="combineHero('${r.id}')" ${canCombine?'':'disabled'}>${canCombine?'ì¡°í•© ê°€ëŠ¥!':'ì¬ë£Œ ë¶€ì¡±'}</button>`;

                let reqHtml = r.req.map(req => {
                    let has = units.some(u => u.type === req.type && u.tier === req.tier);
                    return `<span style="color:${has?'#69F0AE':'#FF5252'}">[ì „ì„¤]${req.type}</span>`;
                }).join('+');

                let item = document.createElement('div');
                item.className = 'recipe-card';
                item.innerHTML = `
                    <div class="recipe-name"><span>${typeIcon} ${r.name}</span> <span style="font-size:0.8rem">${info.type.toUpperCase()}</span></div>
                    <div class="recipe-desc">${info.desc}</div>
                    <div class="recipe-req">${reqHtml}</div>
                    ${btnHtml}
                `;
                list.appendChild(item);
            });
            document.getElementById('combine-modal').classList.add('open');
        }

        function openArtifactModal() {
            const list = document.getElementById('artifact-list');
            list.innerHTML = '';
            ARTIFACT_KEYS.forEach(key => {
                let art = ARTIFACT_DATA[key];
                let count = artifacts[key];
                let item = document.createElement('div');
                item.className = 'artifact-card';
                item.innerHTML = `
                    <div class="artifact-icon">${art.icon}</div>
                    <div class="artifact-info">
                        <div class="artifact-name">${art.name}</div>
                        <div class="artifact-stat">${art.desc}</div>
                    </div>
                    <div class="artifact-count">x${count}</div>
                `;
                list.appendChild(item);
            });
            document.getElementById('artifact-modal').classList.add('open');
        }

        function openShopModal() {
            document.getElementById('shop-lv-maxPop').innerText = upgrades.maxPop;
            document.getElementById('shop-lv-startGold').innerText = upgrades.startGold;
            document.getElementById('shop-lv-dmgUp').innerText = upgrades.dmgUp;
            document.getElementById('shop-lv-goldUp').innerText = upgrades.goldUp;
            document.getElementById('shop-stone-display').innerText = stones;
            document.getElementById('shop-modal').classList.add('open');
        }

        function buyShopItem(type) {
            let cost = 0;
            if(type === 'maxPop') cost = 3;
            if(type === 'startGold') cost = 2;
            if(type === 'dmgUp') cost = 5;
            if(type === 'goldUp') cost = 4;

            if(stones >= cost) {
                stones -= cost;
                upgrades[type]++;
                saveGame();
                if(type === 'maxPop') updateMaxPop();
                showPopup("êµ¬ë§¤ ì™„ë£Œ!");
                openShopModal(); // UI ê°±ì‹ 
                updateUI();
            } else {
                showPopup("ì‹ í™”ì„ ë¶€ì¡±!");
            }
        }

        function closeModal(id) { document.getElementById(id).classList.remove('open'); }
        function unlockRecipe(id) {
            let r = RECIPES.find(x => x.id === id);
            if(r && stones >= r.cost) { stones -= r.cost; r.unlocked = true; showPopup(`${r.name} í•´ê¸ˆ ì™„ë£Œ!`); saveGame(); updateUI(); openCombineModal(); }
        }
        function checkIngredients(reqs) {
            let tempUnits = [...units];
            for(let req of reqs) {
                let idx = tempUnits.findIndex(u => u.type === req.type && u.tier === req.tier);
                if(idx === -1) return false; tempUnits.splice(idx, 1);
            }
            return true;
        }
        function combineHero(id) {
            let r = RECIPES.find(x => x.id === id); if(!r) return;
            let ingredients = []; let tempUnits = [...units];
            for(let req of r.req) {
                let u = units.find(unit => unit.type === req.type && unit.tier === req.tier && !ingredients.includes(unit));
                if(u) ingredients.push(u); else { showPopup("ì¬ë£Œê°€ ë¶€ì¡±."); return; }
            }
            units = units.filter(u => !ingredients.includes(u));
            let pos = { c: ingredients[0].col, r: ingredients[0].row };
            createUnit(pos.c, pos.r, r.result, 4); 
            
            // ì¡°í•© ì´í™íŠ¸
            createSparkle(GRID_OFFSET_X + pos.c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + pos.r*TILE_SIZE + TILE_SIZE/2, '#E040FB');
            addShake(10); showPopup(`âœ¨${r.name} ì†Œí™˜ ì„±ê³µ!âœ¨`); closeModal('combine-modal');
        }

        function startNextWave() {
            wave++;
            
            // 1ì›¨ì´ë¸Œë§Œ ì¤€ë¹„ ì‹œê°„(20ì´ˆ) ê°€ì§
            if (wave === 1) {
                isPrep = true; 
                waveTimer = 20;
                showPopup("ì „íˆ¬ ì¤€ë¹„ ë‹¨ê³„!");
                updateUI();
            } else {
                // 2ì›¨ì´ë¸Œë¶€í„°ëŠ” 10ì´ˆ ëŒ€ê¸° ì—†ì´ ë°”ë¡œ ì‹œì‘
                gold += (50 + wave * 5) + (getArtifactVal('startGold')); 
                if(wave % 10 === 0) { stones++; showPopup(`Wave ${wave} ëŒì…!<br>ğŸ’ì‹ í™”ì„ íšë“!`); saveGame(); }
                else showPopup(`Wave ${wave} ëŒì…!`);
                
                startBattle();
            }
        }

        function startBattle() {
            isPrep = false; // ì „íˆ¬ ì‹œì‘
            waveTimer = WAVE_DURATION; 
            enemiesToSpawn = 12 + Math.floor(wave * 2.5);
            showPopup(`âš”ï¸ Wave ${wave} ì „íˆ¬ ì‹œì‘! âš”ï¸`);
            
            if(wave % 10 === 0) {
                addShake(15); // ë³´ìŠ¤ ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ê°•í•œ í”ë“¤ë¦¼
                spawnFloatingText(canvas.width/2, canvas.height/2, "WARNING: BOSS", "#FF0000");
            }
            updateUI();
        }

        function skipWave() {
            if(isPrep) {
                // ì¤€ë¹„ ì‹œê°„ ìŠ¤í‚µ (ì¦‰ì‹œ ì „íˆ¬ ì‹œì‘)
                let bonus = 0;
                // 1ì›¨ì´ë¸Œê°€ ì•„ë‹ˆë©´ ë³´ë„ˆìŠ¤ ì§€ê¸‰
                if(wave > 1 && waveTimer > 0) {
                    bonus = Math.floor(waveTimer) * 5; // ì¤€ë¹„ ì‹œê°„ ìŠ¤í‚µ ë³´ë„ˆìŠ¤
                    gold += bonus;
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Start! +${bonus}G`, '#4CAF50');
                } else {
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Start!`, '#FFF');
                }
                startBattle();
            } else {
                // ì „íˆ¬ ìŠ¤í‚µ (ê¸°ì¡´ ë¡œì§: ë‚¨ì€ ì‹œê°„ë§Œí¼ ë³´ìƒë°›ê³  ë‹¤ìŒ ì›¨ì´ë¸Œ ì¤€ë¹„ë¡œ)
                if(waveTimer > 0) {
                    let bonus = Math.floor(waveTimer) * 2; 
                    gold += bonus;
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Skip! +${bonus}G`, '#FFD700');
                }
                startNextWave();
            }
        }

        function spawnEnemy() {
            let start = PATH_POINTS[0];
            let hp = 120 * Math.pow(1.3, wave-1);
            let spd = 60 + (wave * 2); // ì†ë„ ê°ì†Œ ì ìš© (100 -> 60)
            let type = 'normal';
            
            if(wave % 10 === 0) { type = 'boss'; hp *= 10; spd *= 0.7; }
            else if(wave % 5 === 0) { type = 'tank'; hp *= 3; spd *= 0.8; }
            else if(wave % 3 === 0) { type = 'fast'; hp *= 0.7; spd *= 1.5; }

            enemies.push({ x: start.x, y: start.y, pathIndex: 0, hp, maxHp: hp, speed: spd, reachedEnd: false, stunTimer: 0, slowTimer: 0, dotTimer: 0, type: type });
            updateUI();
        }

        function moveEnemy(enemy, deltaTime) {
            if(enemy.stunTimer > 0) return;
            
            let currentPt = PATH_POINTS[enemy.pathIndex];
            let nextIdx = (enemy.pathIndex + 1) % PATH_POINTS.length;
            let target = PATH_POINTS[nextIdx];
            
            let dx = target.x - enemy.x; let dy = target.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            let spd = enemy.speed;
            if(enemy.slowTimer > 0) spd *= 0.6;
            let move = (spd * deltaTime) / 1000;
            
            if(dist < move) { 
                enemy.x = target.x; enemy.y = target.y; 
                enemy.pathIndex = nextIdx; 
            } else { 
                enemy.x += (dx/dist)*move; enemy.y += (dy/dist)*move; 
            }
        }

        function findTarget(unit) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let closest = null; let minD = 9999;
            for(let e of enemies) {
                let d = Math.hypot(e.x - cx, e.y - cy);
                if(d <= rangePx && d < minD) { minD = d; closest = e; }
            }
            return closest;
        }
        function findTargets(unit, count) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let targets = [];
            for(let e of enemies) {
                if(Math.hypot(e.x - cx, e.y - cy) <= rangePx) { targets.push(e); if(targets.length>=count) break; }
            }
            return targets;
        }
        function fireGlobalAttack(unit) {
            addShake(5); // ì „ì²´ ê³µê²©ì‹œ í”ë“¤ë¦¼
            enemies.forEach(e => {
                let dmg = unit.damage * (1 + (classLv.mag - 1) * 0.1 + getArtifactVal('magDmg')); 
                let globalDmgMult = 1 + (upgrades.dmgUp * 0.05); // ì „ì‚¬ì˜ í˜ ì ìš©
                dmg *= globalDmgMult;

                e.hp -= dmg;
                projectiles.push({ x: e.x, y: e.y - 20, target: null, damage: 0, speed: 0, hit: true, color: '#D50000', size: 10, timer: 10 });
                // ì´í™íŠ¸ ì¶”ê°€
                createExplosion(e.x, e.y, '#D50000', 5);
            });
        }
        function fireProjectile(unit, target) {
            let color = '#FFFF00'; let effect = null; let pSize = 5; let shape = 'circle';
            let info = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            let dmg = unit.damage;
            let globalDmgMult = 1 + (upgrades.dmgUp * 0.05); // ì „ì‚¬ì˜ í˜ ì ìš©

            if(info.type === 'phy') { dmg *= (1 + (classLv.phy - 1) * 0.1 + getArtifactVal('phyDmg')); shape = 'arrow'; }
            else if(info.type === 'mag') { dmg *= (1 + (classLv.mag - 1) * 0.1 + getArtifactVal('magDmg')); shape = 'star'; }
            
            dmg *= globalDmgMult;

            let critRate = 0;
            if(unit.type === 'ê¶ìˆ˜') critRate += 0.2;
            if(unit.type === 'ë¬´ì‚¬') critRate += 0.5;
            critRate += getArtifactVal('crit');

            if(Math.random() < critRate) {
                let critDmg = (unit.type==='ê¶ìˆ˜') ? (2.5 + unit.tier * 0.5) : 2.0;
                dmg *= critDmg; color='#F44336'; spawnFloatingText(target.x, target.y - 20, "CRIT!", "#F44336");
            }

            if(unit.type === 'ì•¼ë§Œì¸' && Math.random() < (0.1 + unit.tier*0.02)) { effect='stun'; color='#FFF'; }
            if(unit.type === 'ì–¼ìŒë²•ì‚¬' || unit.type === 'ëŒ€ë§ˆë²•ì‚¬') { effect='slow'; color='#29B6F6'; }
            if(unit.type === 'ì‚°ì ' && Math.random() < (0.05 + unit.tier*0.01) * (classLv.sup*0.5)) { 
                gold += 10; updateUI(); spawnFloatingText(unit.x+TILE_SIZE/2, unit.y, "+10G");
            }
            if(unit.type === 'ë‹Œì' && target.hp/target.maxHp <= (0.3 + unit.tier*0.05)) { dmg *= 3; color='#D32F2F'; }
            if(unit.type === 'ì—°ê¸ˆìˆ ì‚¬' && Math.random() < (0.1 + unit.tier*0.02)) { 
                gold += 50; updateUI(); spawnFloatingText(unit.x+TILE_SIZE/2, unit.y, "+50G", "#00E676");
            }
            if(unit.type === 'ë“œë˜ê³¤' && Math.random() < (0.3 + unit.tier*0.05)) { effect='stun'; color='#FFAB00'; pSize=8; }
            if(unit.type === 'ê°•ë ¹ìˆ ì‚¬') { effect='dot'; color='#7B1FA2'; }
            if(unit.type === 'ë©”ë‘ì‚¬') { effect='stun'; color='#004D40'; }
            if(unit.type === 'ë„ë°•ì‚¬') { dmg *= (Math.random()*9 + 1); color='#3F51B5'; }

            if(getArtifactVal('bossDmg') > 0 && target.type === 'boss') dmg *= (1 + getArtifactVal('bossDmg'));

            if(unit.tier === 5) { pSize += 3; color = '#E040FB'; }
            projectiles.push({ x: unit.x+TILE_SIZE/2, y: unit.y+TILE_SIZE/2, target: target, damage: dmg, speed: 700, hit: false, effect: effect, color: color, size: pSize, shape: shape });
        }

        function moveProjectile(p, deltaTime) {
            if(p.timer) { p.timer--; if(p.timer<=0) p.hit=true; return; }
            if(!p.target || !enemies.includes(p.target)) { p.hit = true; return; }
            let dx = p.target.x - p.x; let dy = p.target.y - p.y;
            let dist = Math.hypot(dx, dy);
            let move = (p.speed * deltaTime) / 1000;
            if(dist < move) {
                p.x = p.target.x; p.y = p.target.y; p.hit = true;
                p.target.hp -= p.damage;
                if(p.effect === 'stun') p.target.stunTimer = 1500;
                if(p.effect === 'slow') p.target.slowTimer = 2000;
                if(p.effect === 'dot') p.target.dotTimer = 3000;
            } else { p.x += (dx/dist)*move; p.y += (dy/dist)*move; }
        }

        function getGridPos(cx, cy) {
            let rect = canvas.getBoundingClientRect();
            let x = cx - rect.left; let y = cy - rect.top;
            if(x > GRID_OFFSET_X && x < GRID_OFFSET_X + GRID_COLS*TILE_SIZE && y > GRID_OFFSET_Y && y < GRID_OFFSET_Y + GRID_ROWS*TILE_SIZE) {
                   return { c: Math.floor((x-GRID_OFFSET_X)/TILE_SIZE), r: Math.floor((y-GRID_OFFSET_Y)/TILE_SIZE) };
            }
            return null;
        }
        function onMouseDown(e) {
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let u = getUnitAt(pos.c, pos.r);
                if(u) {
                    draggingUnit = u;
                    let rect = canvas.getBoundingClientRect();
                    u.dragX = e.clientX - rect.left; u.dragY = e.clientY - rect.top;
                    let info = UNIT_DATA[u.type] || HIDDEN_DATA[u.type];
                    let statText = "";
                    if(u.type==='ì•¼ë§Œì¸') statText = `ê¸°ì ˆ: ${Math.round((0.1+u.tier*0.02)*100)}%`;
                    else if(u.type==='ê¶ìˆ˜') statText = `ì¹˜ëª…íƒ€: ${2.5 + u.tier*0.5}ë°°`;
                    else if(u.type==='ë‹Œì') statText = `ì²˜í˜•: ${Math.round((0.3+u.tier*0.05)*100)}%ì´í•˜`;
                    else if(u.type==='ì‚°ì ') statText = `ê°•íƒˆ: ${Math.round((0.05+u.tier*0.01)*100)}%`;
                    else if(u.type==='ë“œë˜ê³¤') statText = `ìŠ¤í„´: ${Math.round((0.3+u.tier*0.05)*100)}%`;
                    showTooltip(`<span style="color:${info.color}; font-size:1.1em; font-weight:bold;">${u.type}</span> <span style="color:${TIER_COLORS[u.tier]}">[${TIERS[u.tier]}]</span><br>${info.desc}<br><span style="color:#FFEB3B">${statText}</span>`);
                }
            }
        }
        function onMouseMove(e) { if(draggingUnit) { let rect = canvas.getBoundingClientRect(); draggingUnit.dragX = e.clientX - rect.left; draggingUnit.dragY = e.clientY - rect.top; } }
        function onMouseUp(e) {
            hideTooltip();
            if(!draggingUnit) return;
            let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
            if(dist < TRASH_ZONE.r * 1.5) { units = units.filter(u => u !== draggingUnit); gold += Math.floor(getSummonCost()/2); showPopup("íŒë§¤ ì™„ë£Œ"); updateUI(); draggingUnit = null; return; }
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let target = getUnitAt(pos.c, pos.r);
                if(target && target !== draggingUnit) {
                    if(target.type === draggingUnit.type && target.tier === draggingUnit.tier) {
                        if(target.tier < 5) { processMerge(draggingUnit, target); } else { showPopup("ìµœê³  ë“±ê¸‰ì…ë‹ˆë‹¤!"); returnUnit(); }
                    } else { let tmpC = draggingUnit.col; let tmpR = draggingUnit.row; draggingUnit.col = target.col; draggingUnit.row = target.row; target.col = tmpC; target.row = tmpR; updateUnitPos(draggingUnit); updateUnitPos(target); }
                } else { draggingUnit.col = pos.c; draggingUnit.row = pos.r; updateUnitPos(draggingUnit); }
            } else returnUnit();
            draggingUnit = null;
        }

        function getUnitAt(c, r) { return units.find(u => u.col === c && u.row === r); }
        function getEmptySlots() { let slots = []; for(let c=0; c<GRID_COLS; c++) for(let r=0; r<GRID_ROWS; r++) if(!getUnitAt(c,r)) slots.push({c,r}); return slots; }
        function updateUnitPos(u) { u.x = GRID_OFFSET_X + u.col*TILE_SIZE; u.y = GRID_OFFSET_Y + u.row*TILE_SIZE; }
        function returnUnit() { updateUnitPos(draggingUnit); }
        
        function resetGame() {
            gold = 200 + (upgrades.startGold * 50); // ì´ˆê¸° ìê¸ˆ ë°˜ì˜
            wave = 0; units = []; enemies = []; projectiles = []; summonLevel = 1; stones = stones; 
            classLv = { phy: 1, mag: 1, sup: 1 };
            waveTimer = 0;
            isPaused = false;
            startNextWave();
            updateUI();
        }

        function showGameOver() {
            isPaused = true;
            document.getElementById('go-wave').innerText = wave;
            document.getElementById('game-over-modal').classList.add('open');
        }

        function retryGame() {
            closeModal('game-over-modal');
            resetGame();
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('stone-display').innerText = stones;
            document.getElementById('wave-display').innerText = wave;
            let ec = document.getElementById('enemy-count');
            ec.innerText = enemies.length;
            if(enemies.length > currentMaxPop * 0.8) ec.style.color = '#FF1744'; else ec.style.color = '#fff';
            
            document.getElementById('max-pop-display').innerText = currentMaxPop;
            document.getElementById('max-pop-val').innerText = currentMaxPop;

            document.getElementById('summon-level').innerText = summonLevel;
            let rate = SUMMON_RATES[summonLevel-1];
            document.getElementById('upgrade-cost').innerText = rate.cost;
            document.getElementById('summon-cost-display').innerText = getSummonCost() + " G";
            document.getElementById('gamble-cost-display').innerText = getGambleCost() + "G";

            document.getElementById('lv-phy').innerText = classLv.phy;
            document.getElementById('cost-phy').innerText = (classLv.phy * 100) + 'G';
            document.getElementById('lv-mag').innerText = classLv.mag;
            document.getElementById('cost-mag').innerText = (classLv.mag * 100) + 'G';
            document.getElementById('lv-sup').innerText = classLv.sup;
            document.getElementById('cost-sup').innerText = (classLv.sup * 100) + 'G';

            let tBox = document.getElementById('timer-box');
            let tIcon = document.getElementById('timer-icon');
            let skipBtn = document.getElementById('btn-skip');
            let skipTxt = document.getElementById('skip-text');
            let skipRewardBox = document.getElementById('skip-reward-box');
            let skipReward = document.getElementById('skip-reward');
            
            document.getElementById('wave-timer').innerText = Math.ceil(waveTimer);
            skipTxt.innerText = "â© ìŠ¤í‚µ";

            if (isPrep) {
                tBox.classList.remove('urgent'); tBox.classList.add('prep'); tIcon.innerText = "â³";
                skipBtn.classList.add('prep-mode');
                skipRewardBox.style.display = "inline";
                if (wave === 1) skipReward.innerText = "0"; else skipReward.innerText = Math.floor(waveTimer) * 5;
            } else {
                tBox.classList.remove('prep');
                if(waveTimer < 10) tBox.classList.add('urgent'); else tBox.classList.remove('urgent');
                tIcon.innerText = "ğŸ”¥";
                skipBtn.classList.remove('prep-mode');
                skipRewardBox.style.display = "inline";
                skipReward.innerText = Math.floor(waveTimer) * 2;
            }
        }

        // ë©”ì‹œì§€ê°€ ìŒ“ì´ë„ë¡ ìˆ˜ì •ëœ í•¨ìˆ˜
        function showPopup(txt) { 
            const area = document.getElementById('message-area');
            const el = document.createElement('div'); el.className = 'pop-text'; el.innerHTML = txt;
            area.appendChild(el); setTimeout(() => { if(el.parentElement) el.parentElement.removeChild(el); }, 1500);
        }

        function showLuckInfo() {
            let cur = SUMMON_RATES[summonLevel-1];
            let next = (summonLevel < 20) ? SUMMON_RATES[summonLevel] : cur;
            let el = document.getElementById('luck-tooltip');
            let mText = cur.m > 0 ? `<div class="c-myth">ì‹ í™”: ${cur.m}%</div>` : '';
            let nextM = next.m > 0 ? `<div class="c-myth">ì‹ í™”: ${next.m}%</div>` : '';
            el.innerHTML = `<div style="margin-bottom:5px; font-weight:bold; color:#FFD700;">í˜„ì¬ (Lv.${summonLevel})</div><div class="c-rare">í¬ê·€: ${cur.r}%</div><div class="c-hero">ì˜ì›…: ${cur.e}%</div><div class="c-legend">ì „ì„¤: ${cur.l}%</div>${mText}<hr style="border-color:#555; margin:5px 0;"><div style="margin-bottom:5px; font-weight:bold; color:#AAA;">ë‹¤ìŒ (Lv.${summonLevel < 20 ? summonLevel+1 : 'MAX'})</div><div class="c-rare">í¬ê·€: ${next.r}%</div><div class="c-hero">ì˜ì›…: ${next.e}%</div><div class="c-legend">ì „ì„¤: ${next.l}%</div>${nextM}`;
            el.style.display = 'block';
        }
        function hideLuckInfo() { document.getElementById('luck-tooltip').style.display = 'none'; }
        function showTooltip(txt) { let el = document.getElementById('unit-tooltip'); el.innerHTML = txt; el.style.display = 'block'; }
        function hideTooltip() { document.getElementById('unit-tooltip').style.display = 'none'; }

        // --- ì´í™íŠ¸ ê´€ë ¨ í•¨ìˆ˜ (ìµœì í™” ì ìš©) ---
        function toggleFx() {
            isFxOn = !isFxOn;
            const btn = document.getElementById('btn-fx');
            if(isFxOn) {
                btn.innerText = "âœ¨ FX On";
                btn.classList.remove('fx-off');
                btn.classList.add('active');
            } else {
                btn.innerText = "ğŸŒ‘ FX Off";
                btn.classList.remove('active');
                btn.classList.add('fx-off');
            }
        }

        function addShake(amount) { if(isFxOn) shakeAmount = amount; }
        
        function createExplosion(x, y, color, count) {
            if(!isFxOn) return;
            let currentCount = effects.length;
            if(currentCount > 400) return; 
            if(currentCount > 200) count = Math.ceil(count / 4); 
            else if(currentCount > 100) count = Math.ceil(count / 2); 
            if(count < 1) count = 1; 

            for(let i=0; i<count; i++) {
                let angle = Math.random() * Math.PI * 2; 
                let speed = Math.random() * 3 + 1;
                effects.push({ 
                    type: 'particle', 
                    x: x, y: y, 
                    vx: Math.cos(angle) * speed, 
                    vy: Math.sin(angle) * speed, 
                    color: color, 
                    life: 400 + Math.random() * 200, 
                    size: Math.random() * 3 + 2 
                });
            }
        }
        
        function createSparkle(x, y, color) {
            if(!isFxOn) return;
            let count = 10;
            if(effects.length > 300) count = 2;
            else if(effects.length > 150) count = 5;

            for(let i=0; i<count; i++) {
                effects.push({ 
                    type: 'particle', 
                    x: x + (Math.random() - 0.5) * TILE_SIZE, 
                    y: y + (Math.random() - 0.5) * TILE_SIZE, 
                    vx: (Math.random() - 0.5) * 0.5, 
                    vy: -Math.random() * 2 - 1, 
                    color: color, 
                    life: 600 + Math.random() * 300, 
                    size: Math.random() * 2 + 1 
                });
            }
        }

        init();
    </script>
</body>
</html>
