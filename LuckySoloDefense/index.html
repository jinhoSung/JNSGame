<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš´ë¹¨ ì†”ë¡œ ë””íœìŠ¤ v4.5</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        * { box-sizing: border-box; touch-action: none; }

        body {
            margin: 0; padding: 0;
            background-color: #0f0f0f;
            display: flex; align-items: center; justify-content: center;
            height: 100vh;
            color: white; font-family: 'Jua', sans-serif;
            overflow: hidden; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 100%; height: 100%;
            max-width: 600px;
            background-color: #4CAF50;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }

        /* --- ìƒë‹¨ UI --- */
        #top-ui {
            flex: 0 0 110px;
            background: rgba(0,0,0,0.85);
            padding: 5px 15px; z-index: 10;
            display: flex; flex-direction: column; justify-content: center;
            border-bottom: 2px solid #333;
        }

        .top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 4px; }
        .info-label { font-size: 12px; color: #bbb; }
        .info-value { font-size: 1.3rem; color: #FFD700; text-shadow: 1px 1px 2px #000; }
        
        /* ê³„ì—´ ê°•í™” ë°” */
        .class-upgrade-bar {
            display: flex; gap: 5px; justify-content: space-between; margin-top: 5px;
        }
        .class-btn {
            flex: 1; border: 1px solid #555; border-radius: 8px;
            background: rgba(255,255,255,0.1); color: #ddd;
            font-family: 'Jua'; cursor: pointer; padding: 4px 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.8rem; transition: background 0.1s;
        }
        .class-btn:active { transform: scale(0.95); }
        .class-btn span { font-size: 0.7rem; color: #FFEB3B; }
        .cb-phy { border-color: #EF5350; }
        .cb-mag { border-color: #AB47BC; }
        .cb-sup { border-color: #26A69A; }

        .mythic-stone {
            display: flex; align-items: center; gap: 5px;
            background: rgba(100, 0, 255, 0.2); padding: 2px 8px; border-radius: 12px; border: 1px solid #7C4DFF;
            font-size: 0.9rem;
        }

        #canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; background-color: #66BB6A; }
        canvas { display: block; width: 100%; height: 100%; }

        /* --- í•˜ë‹¨ UI --- */
        #bottom-ui {
            flex: 0 0 160px;
            background-color: #3E2723;
            padding: 10px;
            display: flex; flex-direction: column; justify-content: space-between;
            border-top: 4px solid #281A16; z-index: 10;
        }

        #resources { display: flex; justify-content: space-between; padding: 0 5px; margin-bottom: 5px; font-size: 1.1rem; color: #FFD700; }
        #buttons { display: flex; justify-content: space-between; align-items: flex-end; height: 100%; gap: 6px; }

        .game-btn {
            border: none; border-radius: 14px; color: white;
            font-family: 'Jua', sans-serif; cursor: pointer;
            position: relative; box-shadow: 0 5px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s; padding: 0; overflow: hidden;
        }
        .game-btn:active { transform: translateY(5px); box-shadow: none; }

        .btn-upgrade { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #673AB7, #512DA8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #9575CD; }
        .btn-summon { flex: 1; height: 100%; max-height: 95px; background: linear-gradient(135deg, #FFC107, #FF8F00); font-size: 1.6rem; color: #3E2723; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 1px solid #FFE082; }
        .btn-combine { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #009688, #00695C); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.95rem; border: 1px solid #4DB6AC; }
        .btn-gamble { width: 18%; height: 100%; max-height: 70px; background: linear-gradient(135deg, #2196F3, #1565C0); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; border: 1px solid #64B5F6; margin-bottom: 5px;}

        .btn-wave {
            position: absolute; top: 20px; right: 20px;
            background: #D32F2F; padding: 10px 20px; border-radius: 30px;
            border: 3px solid white; font-weight: bold; font-size: 1.1rem;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4); z-index: 20;
            animation: pulse 2s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* ì¡°í•©ì†Œ ëª¨ë‹¬ */
        #combine-modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 95%; height: 85%; background: rgba(30, 30, 30, 0.98);
            border: 2px solid #FFD700; border-radius: 15px; z-index: 100;
            flex-direction: column; padding: 15px; color: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
        }
        #combine-modal.open { display: flex; }
        .modal-header { font-size: 1.4rem; text-align: center; margin-bottom: 10px; color: #FFD700; }
        .recipe-list { overflow-y: auto; flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .recipe-card {
            background: rgba(255, 255, 255, 0.08); padding: 8px; border-radius: 6px;
            display: flex; flex-direction: column; gap: 3px; border: 1px solid #555;
            position: relative;
        }
        .recipe-name { font-size: 1rem; font-weight: bold; color: #E040FB; display: flex; justify-content: space-between;}
        .recipe-desc { font-size: 0.75rem; color: #bbb; margin-bottom: 5px; height: 30px; overflow: hidden; }
        .recipe-req { display: flex; gap: 5px; font-size: 0.75rem; color: #ddd; align-items: center; flex-wrap: wrap; }
        .btn-buy-recipe { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #6200EA; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #00C853; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine:disabled { background: #444; color: #888; cursor: not-allowed; }
        .btn-close { margin-top: 10px; padding: 10px; background: #D32F2F; color: white; border: none; border-radius: 8px; font-family: 'Jua'; cursor: pointer; }

        /* ë©”ì‹œì§€ & íˆ´íŒ */
        #message-area { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; text-align: center; width: 100%; z-index: 50; }
        .pop-text { font-size: 2rem; font-weight: bold; color: #fff; text-shadow: 3px 3px 0 #000, 0 0 15px gold; opacity: 0; transition: opacity 0.3s, transform 0.3s; }
        .pop-text.show { opacity: 1; transform: translateY(-40px); }
        
        .tooltip {
            position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%);
            background: rgba(20,20,20,0.95); padding: 12px; border-radius: 8px;
            font-size: 0.9rem; display: none; width: 85%; text-align: center; z-index: 200;
            border: 2px solid #FFD700; pointer-events: none; white-space: pre-line;
            box-shadow: 0 5px 20px rgba(0,0,0,0.8);
        }

        .luck-tooltip {
            position: absolute; bottom: 100px; left: 10px;
            background: rgba(0,0,0,0.9); padding: 10px; border-radius: 8px;
            border: 1px solid #7E57C2; color: white; font-size: 0.8rem;
            z-index: 200; display: none; pointer-events: none; text-align: left;
        }

        /* ë“±ê¸‰ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
        .c-rare { color: #42A5F5; } .c-hero { color: #BA68C8; } .c-legend { color: #FF9800; } .c-myth { color: #FF5252; } .c-immortal { color: #E040FB; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="top-ui">
            <div class="top-row">
                <div class="info-group">
                    <div class="info-label">WAVE</div>
                    <div class="info-value" id="wave-display">1</div>
                </div>
                <div class="mythic-stone">
                    ğŸ’ <span id="stone-display">0</span>
                </div>
                <div class="info-group">
                    <div class="info-label">ì  ìˆ«ì</div>
                    <div class="info-value" style="color:#FF5252"><span id="enemy-count">0</span> / 60</div>
                </div>
            </div>
            
            <!-- ê³„ì—´ ê°•í™” UI -->
            <div class="class-upgrade-bar">
                <button class="class-btn cb-phy" onclick="upgradeClass('phy')">
                    âš”ï¸ ë¬¼ë¦¬ Lv.<span id="lv-phy">1</span>
                    <span id="cost-phy">100G</span>
                </button>
                <button class="class-btn cb-mag" onclick="upgradeClass('mag')">
                    ğŸ”® ë§ˆë²• Lv.<span id="lv-mag">1</span>
                    <span id="cost-mag">100G</span>
                </button>
                <button class="class-btn cb-sup" onclick="upgradeClass('sup')">
                    âš—ï¸ ë³´ì¡° Lv.<span id="lv-sup">1</span>
                    <span id="cost-sup">100G</span>
                </button>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <button id="start-wave-btn" class="btn-wave" onclick="startNextWave()">ğŸ”¥ ì „íˆ¬ ì‹œì‘</button>
            <div id="message-area"><div id="popup-msg" class="pop-text"></div></div>
            <div id="unit-tooltip" class="tooltip"></div>
            <div id="luck-tooltip" class="luck-tooltip"></div>
        </div>

        <div id="bottom-ui">
            <div id="resources">
                <span style="color:#ccc;">í–‰ìš´ Lv.<span id="summon-level">1</span></span>
                <span>ğŸ’° <span id="gold-display">200</span></span>
            </div>
            <div id="buttons">
                <button class="game-btn btn-upgrade" onclick="upgradeSummon()" 
                    onmousedown="showLuckInfo()" onmouseup="hideLuckInfo()"
                    ontouchstart="showLuckInfo()" ontouchend="hideLuckInfo()">
                    â˜˜ï¸ê°•í™”
                    <span style="font-size:0.75em; color:#FFEB3B; margin-top:2px;" id="upgrade-cost">50G</span>
                </button>
                
                <button class="game-btn btn-summon" onclick="summonUnit()">
                    ğŸ² ì†Œí™˜
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">10 G</span>
                </button>
                
                <button class="game-btn btn-combine" onclick="openCombineModal()">
                    ğŸ° ì¡°í•©
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">New!</span>
                </button>

                <button class="game-btn btn-gamble" onclick="gamble()">
                    ğŸ°ë„ë°•<br>50G
                </button>
            </div>
        </div>

        <!-- ì¡°í•©ì†Œ ëª¨ë‹¬ -->
        <div id="combine-modal">
            <div class="modal-header">ğŸ° íˆë“  ì˜ì›… ì¡°í•©ì†Œ</div>
            <div class="recipe-list" id="recipe-list">
                <!-- JS ìƒì„± -->
            </div>
            <button class="btn-close" onclick="closeCombineModal()">ë‹«ê¸°</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        // --- ê·¸ë¦¬ë“œ ---
        const GRID_COLS = 6; const GRID_ROWS = 5;
        let TILE_SIZE = 0, GRID_OFFSET_X = 0, GRID_OFFSET_Y = 0;
        let PATH_POINTS = [];
        let TRASH_ZONE = { x: 0, y: 0, r: 0 };

        // --- ìœ ë‹› ë°ì´í„° ---
        // type: phy(ë¬¼ë¦¬), mag(ë§ˆë²•), sup(ë³´ì¡°)
        const UNIT_DATA = {
            'ì•¼ë§Œì¸': { color: '#BCAAA4', icon: 'ğŸª“', desc: '10% í™•ë¥ ë¡œ 1.5ì´ˆ ê¸°ì ˆ', type: 'phy' },
            'ê¶ìˆ˜': { color: '#81D4FA', icon: 'ğŸ¹', desc: 'ì¹˜ëª…íƒ€ 2.5ë°° (20%)', type: 'phy' },
            'ì–¼ìŒë²•ì‚¬': { color: '#90CAF9', icon: 'ğŸ§Š', desc: 'ê³µê²© ì‹œ ìŠ¬ë¡œìš° 40%', type: 'mag' },
            'ì‚°ì ': { color: '#A1887F', icon: 'ğŸ’°', desc: 'ê³µê²© ì‹œ 5% í™•ë¥ ë¡œ 10ê³¨ë“œ', type: 'sup' },
            'ì „ê¸°ë¡œë´‡': { color: '#FFF59D', icon: 'âš¡', desc: '3ì¸ ë™ì‹œ ê³µê²©', type: 'mag' },
            'ë‹Œì': { color: '#424242', icon: 'ğŸ¥·', desc: 'ì²´ë ¥ 30%ì´í•˜ 3ë°° í”¼í•´', type: 'phy' }
        };
        const UNIT_TYPES = Object.keys(UNIT_DATA);
        
        // --- íˆë“  ì˜ì›… ë°ì´í„° (16ì¢…) ---
        const HIDDEN_DATA = {
            'ê°œêµ¬ë¦¬ì™•ì': { color: '#69F0AE', icon: 'ğŸ¸', desc: 'ì´ˆê³ ì† ê³µì† (5ë°°)', type: 'phy' },
            'ë§ˆì‹ ': { color: '#D50000', icon: 'ğŸ‘¿', desc: 'ì „ì²´ í™”ë©´ ê´‘ì—­ í”¼í•´', type: 'mag' },
            'ë“œë˜ê³¤': { color: '#FFAB00', icon: 'ğŸ²', desc: 'ê°•ë ¥í•œ í•œë°© & ìŠ¤í„´', type: 'phy' },
            'ì„±ê¸°ì‚¬': { color: '#FFD54F', icon: 'ğŸ›¡ï¸', desc: 'ë²”ìœ„ ìŠ¤í„´ & ë†’ì€ ê¹¡ë”œ', type: 'phy' },
            'ì €ê²©ìˆ˜': { color: '#81C784', icon: 'ğŸ”«', desc: 'ì‚¬ê±°ë¦¬ ë¬´í•œ & ë‹¨ì¼ ê·¹ë”œ', type: 'phy' },
            'ëŒ€ë§ˆë²•ì‚¬': { color: '#7E57C2', icon: 'ğŸ§™â€â™‚ï¸', desc: 'ê´‘ì—­ ìŠ¬ë¡œìš° & ì§€ì†ë”œ', type: 'mag' },
            'ì—°ê¸ˆìˆ ì‚¬': { color: '#F4511E', icon: 'âš—ï¸', desc: '10% í™•ë¥ ë¡œ ê³¨ë“œ ë³µì‚¬', type: 'sup' },
            'ê°•ë ¹ìˆ ì‚¬': { color: '#4A148C', icon: 'ğŸ’€', desc: 'ì ì—ê²Œ ë¶€ì‹(ë„íŠ¸ë€) ë¶€ì—¬', type: 'mag' },
            'ë¬´ì‚¬': { color: '#E0E0E0', icon: 'âš”ï¸', desc: '50% í™•ë¥ ë¡œ ì¹˜ëª…íƒ€', type: 'phy' },
            'ì œìš°ìŠ¤': { color: '#FFFF00', icon: 'ğŸŒ©ï¸', desc: '5ëª… ì—°ì‡„ ë²ˆê°œ ê³µê²©', type: 'mag' },
            'ê³¨ë ˜': { color: '#795548', icon: 'ğŸ—¿', desc: 'ê´‘ì—­ ìŠ¤í”Œë˜ì‹œ ê³µê²©', type: 'phy' },
            'ë±€íŒŒì´ì–´': { color: '#B71C1C', icon: 'ğŸ§›', desc: 'ê³µì† ë¹ ë¦„ & ì  ì²˜ì¹˜ì‹œ ê³µì†ë²„í”„', type: 'mag' },
            'ê³µí•™ì': { color: '#607D8B', icon: 'ğŸ”§', desc: 'ì£¼ë³€ ì•„êµ° ê³µì† +20% (ì˜¤ë¼)', type: 'sup' },
            'ë„ë°•ì‚¬': { color: '#3F51B5', icon: 'ğŸƒ', desc: 'ëœë¤ ë°ë¯¸ì§€ (1~10ë°°)', type: 'sup' },
            'ë©”ë‘ì‚¬': { color: '#004D40', icon: 'ğŸ', desc: '3ì´ˆê°„ ì  ì„í™”(ì •ì§€)', type: 'mag' },
            'í”¼ë‹‰ìŠ¤': { color: '#FF5722', icon: 'ğŸ¦…', desc: 'ë¼ì¸ ì „ì²´ í™”ìƒ ê³µê²©', type: 'mag' }
        };

        const TIERS = ['ì¼ë°˜', 'í¬ê·€', 'ì˜ì›…', 'ì „ì„¤', 'ì‹ í™”', 'ë¶ˆë©¸'];
        const TIER_COLORS = ['#B0BEC5', '#29B6F6', '#AB47BC', '#FF7043', '#FF1744', '#D500F9'];

        // --- ë ˆì‹œí”¼ (ì¡°í•©ì‹) ---
        // ëª¨ë“  ì¬ë£ŒëŠ” ì „ì„¤(3í‹°ì–´) ê¸°ì¤€
        const RECIPES = [
            { id: 'frog', name: 'ê°œêµ¬ë¦¬ì™•ì', cost: 3, result: 'ê°œêµ¬ë¦¬ì™•ì', req: [{type:'ì•¼ë§Œì¸',t:3}, {type:'ê¶ìˆ˜',t:3}] },
            { id: 'demon', name: 'ë§ˆì‹ ', cost: 5, result: 'ë§ˆì‹ ', req: [{type:'ë‹Œì',t:3}, {type:'ì „ê¸°ë¡œë´‡',t:3}] },
            { id: 'dragon', name: 'ë“œë˜ê³¤', cost: 5, result: 'ë“œë˜ê³¤', req: [{type:'ì–¼ìŒë²•ì‚¬',t:3}, {type:'ì•¼ë§Œì¸',t:3}] },
            { id: 'pala', name: 'ì„±ê¸°ì‚¬', cost: 3, result: 'ì„±ê¸°ì‚¬', req: [{type:'ì•¼ë§Œì¸',t:3}, {type:'ì‚°ì ',t:3}] },
            { id: 'sniper', name: 'ì €ê²©ìˆ˜', cost: 3, result: 'ì €ê²©ìˆ˜', req: [{type:'ê¶ìˆ˜',t:3}, {type:'ë‹Œì',t:3}] },
            { id: 'arch', name: 'ëŒ€ë§ˆë²•ì‚¬', cost: 3, result: 'ëŒ€ë§ˆë²•ì‚¬', req: [{type:'ì–¼ìŒë²•ì‚¬',t:3}, {type:'ì „ê¸°ë¡œë´‡',t:3}] },
            { id: 'alch', name: 'ì—°ê¸ˆìˆ ì‚¬', cost: 3, result: 'ì—°ê¸ˆìˆ ì‚¬', req: [{type:'ì‚°ì ',t:3}, {type:'ì–¼ìŒë²•ì‚¬',t:3}] },
            { id: 'necro', name: 'ê°•ë ¹ìˆ ì‚¬', cost: 3, result: 'ê°•ë ¹ìˆ ì‚¬', req: [{type:'ì „ê¸°ë¡œë´‡',t:3}, {type:'ë‹Œì',t:3}] },
            { id: 'samu', name: 'ë¬´ì‚¬', cost: 3, result: 'ë¬´ì‚¬', req: [{type:'ë‹Œì',t:3}, {type:'ì•¼ë§Œì¸',t:3}] },
            { id: 'zeus', name: 'ì œìš°ìŠ¤', cost: 4, result: 'ì œìš°ìŠ¤', req: [{type:'ì „ê¸°ë¡œë´‡',t:3}, {type:'ì‚°ì ',t:3}] },
            { id: 'golem', name: 'ê³¨ë ˜', cost: 3, result: 'ê³¨ë ˜', req: [{type:'ì•¼ë§Œì¸',t:3}, {type:'ì–¼ìŒë²•ì‚¬',t:3}] },
            { id: 'vamp', name: 'ë±€íŒŒì´ì–´', cost: 3, result: 'ë±€íŒŒì´ì–´', req: [{type:'ë‹Œì',t:3}, {type:'ê¶ìˆ˜',t:3}] },
            { id: 'engi', name: 'ê³µí•™ì', cost: 4, result: 'ê³µí•™ì', req: [{type:'ì‚°ì ',t:3}, {type:'ì „ê¸°ë¡œë´‡',t:3}] },
            { id: 'gamb', name: 'ë„ë°•ì‚¬', cost: 3, result: 'ë„ë°•ì‚¬', req: [{type:'ì‚°ì ',t:3}, {type:'ê¶ìˆ˜',t:3}] },
            { id: 'medu', name: 'ë©”ë‘ì‚¬', cost: 4, result: 'ë©”ë‘ì‚¬', req: [{type:'ì–¼ìŒë²•ì‚¬',t:3}, {type:'ê¶ìˆ˜',t:3}] },
            { id: 'phoe', name: 'í”¼ë‹‰ìŠ¤', cost: 5, result: 'í”¼ë‹‰ìŠ¤', req: [{type:'ì „ê¸°ë¡œë´‡',t:3}, {type:'ì•¼ë§Œì¸',t:3}] }
        ];
        // ì´ˆê¸°í™”: unlocked ìƒíƒœ ì¶”ê°€
        RECIPES.forEach(r => r.unlocked = false);

        // --- í™•ë¥  í…Œì´ë¸” ìƒì„± (20ë‹¨ê³„) ---
        const SUMMON_RATES = [];
        for(let i=1; i<=20; i++) {
            let rate = {}; let cost = 0;
            if(i <= 5) { rate = { c: 100 - (i-1)*10, r: (i-1)*10, e: 0, l: 0, m: 0 }; cost = 50 * i; }
            else if(i <= 10) { rate = { c: 60 - (i-5)*6, r: 40 - (i-5)*2, e: (i-5)*8, l: 0, m: 0 }; cost = 150 * (i-3); }
            else if(i <= 15) { rate = { c: 30 - (i-10)*4, r: 30 - (i-10)*2, e: 40 - (i-10)*2, l: (i-10)*8, m: 0 }; cost = 1000 + (i-10)*500; }
            else { 
                let myth = (i-15) * 0.5; // ìµœëŒ€ 2.5%
                let leg = 40 - (i-15)*2; 
                let epic = 30 - (i-15)*2;
                rate = { c: 5, r: 10, e: epic, l: leg, m: myth };
                let total = rate.c + rate.r + rate.e + rate.l + rate.m;
                if(total < 100) rate.c += (100 - total);
                cost = 3000 + (i-15)*1500; 
            }
            if(i===20) cost = 'MAX';
            SUMMON_RATES.push({ ...rate, cost: cost });
        }

        const SUMMON_COST = 10;
        const GAMBLE_COST = 50;

        // --- ê²Œì„ ìƒíƒœ ---
        let gold = 200;
        let stones = 0; 
        let wave = 1;
        let units = [];
        let enemies = [];
        let projectiles = [];
        let summonLevel = 1;
        
        // ê³„ì—´ ë ˆë²¨
        let classLv = { phy: 1, mag: 1, sup: 1 };
        
        let lastTime = 0;
        let enemySpawnTimer = 0;
        let enemiesToSpawn = 0;
        let isWaveActive = false;
        let maxEnemies = 60;
        let draggingUnit = null;
        let frameCount = 0;

        // --- ë¦¬ì‚¬ì´ì§• ---
        function resizeGame() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            const maxTileW = canvas.width / (GRID_COLS + 1.2);
            const maxTileH = canvas.height / (GRID_ROWS + 2.5);
            TILE_SIZE = Math.floor(Math.min(maxTileW, maxTileH));
            GRID_OFFSET_X = (canvas.width - GRID_COLS * TILE_SIZE) / 2;
            GRID_OFFSET_Y = (canvas.height - GRID_ROWS * TILE_SIZE) / 2;

            const margin = TILE_SIZE * 0.6;
            PATH_POINTS = [
                { x: -50, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y - margin },
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin },
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin },
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y - margin },
                { x: canvas.width + 50, y: GRID_OFFSET_Y - margin }
            ];
            TRASH_ZONE = { x: canvas.width - TILE_SIZE * 0.9, y: canvas.height - TILE_SIZE * 0.9, r: TILE_SIZE * 0.6 };
            units.forEach(u => { u.x = GRID_OFFSET_X + u.col * TILE_SIZE; u.y = GRID_OFFSET_Y + u.row * TILE_SIZE; });
        }

        function init() {
            window.addEventListener('resize', resizeGame);
            resizeGame();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('touchstart', (e) => { if(e.touches.length>1) return; e.preventDefault(); onMouseDown({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchend', (e) => { onMouseUp({clientX: e.changedTouches?e.changedTouches[0].clientX : 0, clientY: e.changedTouches?e.changedTouches[0].clientY : 0}); });
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            frameCount++;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            if (isWaveActive && enemiesToSpawn > 0) {
                let spawnInterval = Math.max(150, 700 - (wave * 20)); 
                enemySpawnTimer += deltaTime;
                if (enemySpawnTimer > spawnInterval) { spawnEnemy(); enemySpawnTimer = 0; enemiesToSpawn--; }
            } else if (isWaveActive && enemiesToSpawn === 0 && enemies.length === 0) {
                endWave();
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.stunTimer > 0) enemy.stunTimer -= deltaTime;
                if (enemy.slowTimer > 0) enemy.slowTimer -= deltaTime;
                if (enemy.dotTimer > 0) { // ë¶€ì‹(ê°•ë ¹ìˆ ì‚¬) ë°ë¯¸ì§€
                    enemy.dotTimer -= deltaTime;
                    enemy.hp -= (enemy.maxHp * 0.001); // ì´ˆë‹¹ ì¼ì • ì²´ë ¥ ë¹„ë¡€ë€
                }
                
                moveEnemy(enemy, deltaTime);
                if (enemy.reachedEnd) { enemies.splice(i, 1); }
                else if (enemy.hp <= 0) { gold += (2 + Math.floor(wave * 0.2)); enemies.splice(i, 1); updateUI(); }
            }

            if (enemies.length >= maxEnemies) { alert(`ê²Œì„ ì˜¤ë²„! ${wave} ì›¨ì´ë¸Œ ê¸°ë¡.`); resetGame(); return; }

            // ìœ ë‹› ì¿¨íƒ€ì„ ë° ê³µê²©
            units.forEach(unit => {
                if (unit === draggingUnit) return;
                unit.cooldown -= deltaTime;
                if (unit.cooldown <= 0) {
                    // íŠ¹ìˆ˜ ë¡œì§
                    if(unit.type === 'ì „ê¸°ë¡œë´‡' || unit.type === 'ì œìš°ìŠ¤') {
                        let cnt = unit.type==='ì œìš°ìŠ¤' ? 5 : 3;
                        const targets = findTargets(unit, cnt);
                        if(targets.length > 0) { targets.forEach(t => fireProjectile(unit, t)); resetCooldown(unit); }
                    } else if(unit.type === 'ë§ˆì‹ ' || unit.type === 'í”¼ë‹‰ìŠ¤') {
                        fireGlobalAttack(unit);
                        resetCooldown(unit);
                    } else if(unit.type === 'ê³µí•™ì') {
                         // ì˜¤ë¼í˜•ì´ë¼ ê³µê²© ì•ˆí•¨ (êµ¬í˜„ ìƒëµí•˜ê±°ë‚˜ ì•½í•œ í‰íƒ€)
                         const target = findTarget(unit);
                         if(target) { fireProjectile(unit, target); resetCooldown(unit); }
                    } else {
                        const target = findTarget(unit);
                        if (target) { fireProjectile(unit, target); resetCooldown(unit); }
                    }
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                moveProjectile(p, deltaTime);
                if (p.hit) projectiles.splice(i, 1);
            }
        }

        function resetCooldown(unit) {
            let baseSpeed = 1000 / (1 + unit.tier * 0.25);
            let info = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            
            // ë³´ì¡° ê³„ì—´ ì—…ê·¸ë ˆì´ë“œ íš¨ê³¼ (ê³µì† ì¦ê°€)
            // 1ë ™: 100%, 2ë ™: 105%, ...
            let classSpdMult = 1 + (classLv.sup - 1) * 0.05;

            // íˆë“  ìœ ë‹› íŠ¹ìˆ˜ ê³µì†
            if(unit.type === 'ê°œêµ¬ë¦¬ì™•ì') baseSpeed = 200;
            if(unit.type === 'ë±€íŒŒì´ì–´') baseSpeed = 400;
            if(unit.type === 'ë§ˆì‹ ') baseSpeed = 1500;
            if(unit.type === 'ì €ê²©ìˆ˜') baseSpeed = 2000;

            unit.cooldown = baseSpeed / classSpdMult;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5, GRID_COLS*TILE_SIZE + 10, GRID_ROWS*TILE_SIZE + 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            for(let c=0; c<GRID_COLS; c++) {
                for(let r=0; r<GRID_ROWS; r++) {
                    ctx.strokeRect(GRID_OFFSET_X + c*TILE_SIZE, GRID_OFFSET_Y + r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // ê²½ë¡œ
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = TILE_SIZE * 0.45; ctx.lineJoin = 'round';
            ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y);
            for(let i=1; i<PATH_POINTS.length; i++) ctx.lineTo(PATH_POINTS[i].x, PATH_POINTS[i].y);
            ctx.stroke();

            // ì 
            enemies.forEach(e => {
                if(e.stunTimer > 0) ctx.fillStyle = '#FFEB3B';
                else if(e.slowTimer > 0) ctx.fillStyle = '#42A5F5';
                else if(e.dotTimer > 0) ctx.fillStyle = '#7B1FA2';
                else ctx.fillStyle = '#CFD8DC';
                
                let r = TILE_SIZE * 0.22;
                ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.stroke();
                let pct = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#263238'; ctx.fillRect(e.x - r, e.y - r - 8, r*2, 5);
                ctx.fillStyle = pct > 0.5 ? '#76FF03' : '#FF1744'; ctx.fillRect(e.x - r, e.y - r - 8, r*2*pct, 5);
            });

            // ìœ ë‹›
            units.forEach(u => { if(u !== draggingUnit) drawUnit(u, u.x, u.y); });

            // íˆ¬ì‚¬ì²´
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });

            // ë“œë˜ê·¸
            if(draggingUnit) {
                // ì‚¬ê±°ë¦¬ (ì €ê²©ìˆ˜ ì˜ˆì™¸)
                if(draggingUnit.type !== 'ì €ê²©ìˆ˜') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    let rangePx = draggingUnit.range * (TILE_SIZE/55);
                    ctx.arc(draggingUnit.dragX, draggingUnit.dragY, rangePx, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
                let isHover = dist < TRASH_ZONE.r * 1.5;
                ctx.fillStyle = isHover ? '#D32F2F' : 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(TRASH_ZONE.x, TRASH_ZONE.y, isHover ? TRASH_ZONE.r*1.1 : TRASH_ZONE.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${TILE_SIZE*0.4}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText('ğŸ—‘ï¸', TRASH_ZONE.x, TRASH_ZONE.y);
                drawUnit(draggingUnit, draggingUnit.dragX, draggingUnit.dragY);
            }
        }

        function drawUnit(unit, x, y) {
            const cx = x + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const cy = y + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const size = TILE_SIZE * 0.85;

            let data = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            ctx.fillStyle = data.color;
            ctx.lineWidth = 3;

            if(unit.tier >= 4) {
                let hue = (frameCount * 3) % 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
            } else {
                ctx.strokeStyle = TIER_COLORS[unit.tier];
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            if(unit.tier === 0) ctx.arc(cx, cy, size/2, 0, Math.PI*2);
            else if(unit.tier === 1) ctx.rect(cx - size/2, cy - size/2, size, size);
            else if(unit.tier === 2) drawPolygon(ctx, cx, cy, size/2, 6);
            else if(unit.tier === 3) drawPolygon(ctx, cx, cy, size/2, 4, Math.PI/4);
            else drawStar(ctx, cx, cy, 5, size/2, size/4); 
            ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

            ctx.fillStyle = 'white'; ctx.font = `${size*0.5}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(data.icon, cx, cy);
            
            // ê³„ì—´ í‘œì‹œ (ì‘ê²Œ)
            ctx.font = `${size*0.25}px sans-serif`;
            ctx.fillStyle = '#fff';
            let typeIcon = data.type === 'phy' ? 'âš”ï¸' : (data.type==='mag' ? 'ğŸ”®' : 'âš—ï¸');
            ctx.fillText(typeIcon, cx + size/3, cy + size/3);
        }

        function drawPolygon(ctx, x, y, radius, sides, rotateAngle = 0) {
            if (sides < 3) return; var a = (Math.PI * 2)/sides;
            ctx.moveTo(x + radius*Math.cos(rotateAngle), y + radius*Math.sin(rotateAngle));
            for (var i = 1; i < sides; i++) ctx.lineTo(x + radius*Math.cos(a*i + rotateAngle), y + radius*Math.sin(a*i + rotateAngle)); ctx.closePath();
        }
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI/2*3; let x=cx; let y=cy; let step=Math.PI/spikes;
            ctx.moveTo(cx, cy-outerRadius);
            for(let i=0; i<spikes; i++){ x=cx+Math.cos(rot)*outerRadius; y=cy+Math.sin(rot)*outerRadius; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*innerRadius; y=cy+Math.sin(rot)*innerRadius; ctx.lineTo(x,y); rot+=step; }
            ctx.lineTo(cx, cy-outerRadius); ctx.closePath();
        }

        // --- ë¡œì§: ê°•í™” ---
        function upgradeSummon() {
            if(summonLevel >= 20) { showPopup("ìµœê³  ë ˆë²¨ì…ë‹ˆë‹¤!"); return; }
            let cost = SUMMON_RATES[summonLevel-1].cost;
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            gold -= cost; summonLevel++; showPopup(`í–‰ìš´ ê°•í™” Lv.${summonLevel} ì„±ê³µ!`); updateUI();
            
            // íˆ´íŒ ê°±ì‹ 
            if(document.getElementById('luck-tooltip').style.display === 'block') showLuckInfo();
        }

        function upgradeClass(type) {
            // ë¹„ìš©: 100 * ë ˆë²¨
            let cost = classLv[type] * 100;
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            gold -= cost;
            classLv[type]++;
            let name = type==='phy'?'ë¬¼ë¦¬':(type==='mag'?'ë§ˆë²•':'ë³´ì¡°');
            showPopup(`${name} ê³„ì—´ Lv.${classLv[type]} ê°•í™”!`);
            updateUI();
        }

        function summonUnit() {
            if(gold < SUMMON_COST) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            let emptySlots = getEmptySlots();
            if(emptySlots.length === 0) { showPopup("ìë¦¬ê°€ ê½‰ ì°¼ìŠµë‹ˆë‹¤!"); return; }
            gold -= SUMMON_COST;
            
            let rates = SUMMON_RATES[summonLevel-1];
            let rand = Math.random() * 100;
            let tier = 0;
            
            if(rand < rates.c) tier = 0;
            else if(rand < rates.c + rates.r) { tier = 1; showPopup("í¬ê·€ ì†Œí™˜! ğŸ’™"); }
            else if(rand < rates.c + rates.r + rates.e) { tier = 2; showPopup("ì˜ì›… ì†Œí™˜! ğŸ’œ"); }
            else if(rand < rates.c + rates.r + rates.e + rates.l) { tier = 3; showPopup("ì „ì„¤ ì†Œí™˜! ğŸ§¡"); }
            else { tier = 4; showPopup("âš¡ì‹ í™” ì†Œí™˜!âš¡"); }

            let slot = emptySlots[Math.floor(Math.random()*emptySlots.length)];
            let type = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
            createUnit(slot.c, slot.r, type, tier);
            updateUI();
        }

        function createUnit(col, row, type, tier) {
            const x = GRID_OFFSET_X + col * TILE_SIZE;
            const y = GRID_OFFSET_Y + row * TILE_SIZE;
            
            let mult = Math.pow(2.2, tier);
            if(tier >= 4) mult *= 2; 
            
            let info = UNIT_DATA[type] || HIDDEN_DATA[type];
            // íˆë“  ìœ ë‹› ìŠ¤íƒ¯ ë³´ì •
            if(HIDDEN_DATA[type]) mult *= 3;

            let rng = 160 + (tier * 15);
            if(type === 'ì €ê²©ìˆ˜') rng = 9999;

            units.push({
                col, row, x, y, type, tier,
                damage: 10 * mult,
                range: rng,
                cooldown: 0
            });
        }

        function gamble() {
            if(gold < GAMBLE_COST) { showPopup("ë¹„ìš© ë¶€ì¡±!"); return; }
            gold -= GAMBLE_COST;
            let rand = Math.random();
            if(rand < 0.45) showPopup("ê½... ğŸ’¸");
            else if(rand < 0.70) { 
                let gain = 150 + (summonLevel * 5); 
                gold += gain; showPopup(`+${gain}G ëŒ€ë°•! ğŸ‰`); 
            }
            else if(rand < 0.95) { 
                summonUnit(); gold += SUMMON_COST; showPopup("ìœ ë‹› íšë“! ğŸ²"); 
            } else {
                stones += 1; showPopup("ğŸ’ ì‹ í™”ì„ íšë“! ğŸ’");
            }
            updateUI();
        }

        // --- ì¡°í•© ---
        function openCombineModal() {
            const list = document.getElementById('recipe-list');
            list.innerHTML = '';
            
            RECIPES.forEach(r => {
                const canUnlock = !r.unlocked && stones >= r.cost;
                const canCombine = r.unlocked && checkIngredients(r.req);
                let info = HIDDEN_DATA[r.result];
                let typeIcon = info.type === 'phy' ? 'âš”ï¸' : (info.type==='mag' ? 'ğŸ”®' : 'âš—ï¸');
                
                let btnHtml = !r.unlocked ? 
                    `<button class="btn-buy-recipe" onclick="unlockRecipe('${r.id}')" ${canUnlock?'':'disabled'}>í•´ê¸ˆ (ğŸ’${r.cost})</button>` :
                    `<button class="btn-do-combine" onclick="combineHero('${r.id}')" ${canCombine?'':'disabled'}>${canCombine?'ì¡°í•© ê°€ëŠ¥!':'ì¬ë£Œ ë¶€ì¡±'}</button>`;

                let reqHtml = r.req.map(req => {
                    let has = units.some(u => u.type === req.type && u.tier === req.tier);
                    return `<span style="color:${has?'#69F0AE':'#FF5252'}">[ì „ì„¤]${req.type}</span>`;
                }).join('+');

                let item = document.createElement('div');
                item.className = 'recipe-card';
                item.innerHTML = `
                    <div class="recipe-name"><span>${typeIcon} ${r.name}</span> <span style="font-size:0.8rem">${info.type.toUpperCase()}</span></div>
                    <div class="recipe-desc">${info.desc}</div>
                    <div class="recipe-req">${reqHtml}</div>
                    ${btnHtml}
                `;
                list.appendChild(item);
            });
            document.getElementById('combine-modal').classList.add('open');
        }

        function closeCombineModal() { document.getElementById('combine-modal').classList.remove('open'); }
        function unlockRecipe(id) {
            let r = RECIPES.find(x => x.id === id);
            if(r && stones >= r.cost) {
                stones -= r.cost; r.unlocked = true;
                showPopup(`${r.name} í•´ê¸ˆ ì™„ë£Œ!`); updateUI(); openCombineModal();
            }
        }
        function checkIngredients(reqs) {
            let tempUnits = [...units];
            for(let req of reqs) {
                let idx = tempUnits.findIndex(u => u.type === req.type && u.tier === req.tier);
                if(idx === -1) return false;
                tempUnits.splice(idx, 1);
            }
            return true;
        }
        function combineHero(id) {
            let r = RECIPES.find(x => x.id === id);
            if(!r) return;
            let ingredients = [];
            let tempUnits = [...units];
            for(let req of r.req) {
                let u = units.find(unit => unit.type === req.type && unit.tier === req.tier && !ingredients.includes(unit));
                if(u) ingredients.push(u);
                else { showPopup("ì¬ë£Œê°€ ë¶€ì¡±."); return; }
            }
            units = units.filter(u => !ingredients.includes(u));
            let pos = { c: ingredients[0].col, r: ingredients[0].row };
            createUnit(pos.c, pos.r, r.result, 4); // ì¡°í•©ì€ ì‹ í™”(Tier 4) ë“±ê¸‰ ì·¨ê¸‰ (ìŠ¤íƒ¯ì€ ë³„ë„)
            showPopup(`âœ¨${r.name} ì†Œí™˜ ì„±ê³µ!âœ¨`);
            closeCombineModal();
        }

        // --- ì „íˆ¬ ---
        function startNextWave() {
            if(isWaveActive) return;
            wave++;
            enemiesToSpawn = 12 + Math.floor(wave * 2.5);
            isWaveActive = true;
            document.getElementById('start-wave-btn').style.display = 'none';
            updateUI();
        }
        function spawnEnemy() {
            let start = PATH_POINTS[0];
            let hp = 120 * Math.pow(1.3, wave-1);
            let spd = 100 + (wave * 2.5);
            enemies.push({ x: start.x, y: start.y, pathIndex: 0, hp, maxHp: hp, speed: spd, reachedEnd: false, stunTimer: 0, slowTimer: 0, dotTimer: 0 });
            updateUI();
        }
        function moveEnemy(enemy, deltaTime) {
            if(enemy.stunTimer > 0) return;
            let target = PATH_POINTS[enemy.pathIndex+1];
            if(!target) { enemy.reachedEnd = true; return; }
            let dx = target.x - enemy.x; let dy = target.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            let spd = enemy.speed;
            if(enemy.slowTimer > 0) spd *= 0.6;
            let move = (spd * deltaTime) / 1000;
            if(dist < move) { enemy.x = target.x; enemy.y = target.y; enemy.pathIndex++; }
            else { enemy.x += (dx/dist)*move; enemy.y += (dy/dist)*move; }
        }
        function findTarget(unit) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let closest = null; let minD = 9999;
            for(let e of enemies) {
                let d = Math.hypot(e.x - cx, e.y - cy);
                if(d <= rangePx && d < minD) { minD = d; closest = e; }
            }
            return closest;
        }
        function findTargets(unit, count) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let targets = [];
            for(let e of enemies) {
                if(Math.hypot(e.x - cx, e.y - cy) <= rangePx) { targets.push(e); if(targets.length>=count) break; }
            }
            return targets;
        }
        function fireGlobalAttack(unit) {
            enemies.forEach(e => {
                let dmg = unit.damage * (1 + (classLv.mag - 1) * 0.1); // ë§ˆë²• ê³„ì—´ ì ìš©
                e.hp -= dmg;
                projectiles.push({ x: e.x, y: e.y - 20, target: null, damage: 0, speed: 0, hit: true, color: '#D50000', size: 10, timer: 10 });
            });
        }
        function fireProjectile(unit, target) {
            let color = '#FFFF00'; let effect = null; let pSize = 5;
            let info = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            let dmg = unit.damage;

            // ê³„ì—´ ê°•í™” ì ìš© (ë ˆë²¨ë‹¹ 10% ì¦ë€)
            if(info.type === 'phy') dmg *= (1 + (classLv.phy - 1) * 0.1);
            else if(info.type === 'mag') dmg *= (1 + (classLv.mag - 1) * 0.1);
            
            // íŠ¹ì„±
            if(unit.type === 'ì•¼ë§Œì¸' && Math.random()<0.1) { effect='stun'; color='#FFF'; }
            if(unit.type === 'ê¶ìˆ˜' && Math.random()<0.2) { dmg*=2.5; color='#F44336'; }
            if(unit.type === 'ì–¼ìŒë²•ì‚¬' || unit.type === 'ëŒ€ë§ˆë²•ì‚¬') { effect='slow'; color='#29B6F6'; }
            if(unit.type === 'ì‚°ì ' && Math.random() < 0.05 * (classLv.sup*0.5)) { // ë³´ì¡°ë ™ ë†’ìœ¼ë©´ í™•ë¥ ì¦ê°€
                gold += 10; updateUI(); 
            }
            if(unit.type === 'ì—°ê¸ˆìˆ ì‚¬' && Math.random() < 0.1) { gold += 50; updateUI(); }
            if(unit.type === 'ë‹Œì' && target.hp/target.maxHp<=0.3) { dmg*=3; color='#D32F2F'; }
            if(unit.type === 'ë“œë˜ê³¤' && Math.random()<0.3) { effect='stun'; color='#FFAB00'; pSize=8; }
            if(unit.type === 'ê°•ë ¹ìˆ ì‚¬') { effect='dot'; color='#7B1FA2'; }
            if(unit.type === 'ë¬´ì‚¬' && Math.random()<0.5) { dmg*=2; color='#E0E0E0'; }
            if(unit.type === 'ë©”ë‘ì‚¬') { effect='stun'; color='#004D40'; }
            if(unit.type === 'ë„ë°•ì‚¬') { dmg *= (Math.random()*9 + 1); color='#3F51B5'; }

            if(unit.tier === 5) { pSize += 3; color = '#E040FB'; }
            projectiles.push({ x: unit.x+TILE_SIZE/2, y: unit.y+TILE_SIZE/2, target: target, damage: dmg, speed: 700, hit: false, effect: effect, color: color, size: pSize });
        }

        function moveProjectile(p, deltaTime) {
            if(p.timer) { p.timer--; if(p.timer<=0) p.hit=true; return; }
            if(!p.target || !enemies.includes(p.target)) { p.hit = true; return; }
            let dx = p.target.x - p.x; let dy = p.target.y - p.y;
            let dist = Math.hypot(dx, dy);
            let move = (p.speed * deltaTime) / 1000;
            if(dist < move) {
                p.x = p.target.x; p.y = p.target.y; p.hit = true;
                p.target.hp -= p.damage;
                if(p.effect === 'stun') p.target.stunTimer = 1500;
                if(p.effect === 'slow') p.target.slowTimer = 2000;
                if(p.effect === 'dot') p.target.dotTimer = 3000;
            } else { p.x += (dx/dist)*move; p.y += (dy/dist)*move; }
        }

        // --- ì…ë ¥ ---
        function getGridPos(cx, cy) {
            let rect = canvas.getBoundingClientRect();
            let x = cx - rect.left; let y = cy - rect.top;
            if(x > GRID_OFFSET_X && x < GRID_OFFSET_X + GRID_COLS*TILE_SIZE && y > GRID_OFFSET_Y && y < GRID_OFFSET_Y + GRID_ROWS*TILE_SIZE) {
                   return { c: Math.floor((x-GRID_OFFSET_X)/TILE_SIZE), r: Math.floor((y-GRID_OFFSET_Y)/TILE_SIZE) };
            }
            return null;
        }
        function onMouseDown(e) {
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let u = getUnitAt(pos.c, pos.r);
                if(u) {
                    draggingUnit = u;
                    let rect = canvas.getBoundingClientRect();
                    u.dragX = e.clientX - rect.left; u.dragY = e.clientY - rect.top;
                    let info = UNIT_DATA[u.type] || HIDDEN_DATA[u.type];
                    showTooltip(`<span style="color:${info.color}; font-size:1.1em; font-weight:bold;">${u.type}</span> <span style="color:${TIER_COLORS[u.tier]}">[${TIERS[u.tier]}]</span><br>${info.desc}<br>íƒ€ì…: ${info.type.toUpperCase()}`);
                }
            }
        }
        function onMouseMove(e) { if(draggingUnit) { let rect = canvas.getBoundingClientRect(); draggingUnit.dragX = e.clientX - rect.left; draggingUnit.dragY = e.clientY - rect.top; } }
        function onMouseUp(e) {
            hideTooltip();
            if(!draggingUnit) return;
            let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
            if(dist < TRASH_ZONE.r * 1.5) { units = units.filter(u => u !== draggingUnit); gold += Math.floor(SUMMON_COST/2); showPopup("íŒë§¤ ì™„ë£Œ (+5G)"); updateUI(); draggingUnit = null; return; }
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let target = getUnitAt(pos.c, pos.r);
                if(target && target !== draggingUnit) {
                    if(target.type === draggingUnit.type && target.tier === draggingUnit.tier) {
                        if(target.tier < 5) { 
                            let newTier = target.tier + 1; let newType = target.type; 
                            units = units.filter(u => u !== draggingUnit && u !== target);
                            createUnit(pos.c, pos.r, newType, newTier);
                            if(newTier===5) showPopup(`ğŸ”¥ë¶ˆë©¸ [${newType}] ê°•ë¦¼!ğŸ”¥`); else showPopup(`í•©ì„±! [${TIERS[newTier]}] ì„±ê³µ âœ¨`);
                        } else { showPopup("ìµœê³  ë“±ê¸‰ì…ë‹ˆë‹¤!"); returnUnit(); }
                    } else { let tmpC = draggingUnit.col; let tmpR = draggingUnit.row; draggingUnit.col = target.col; draggingUnit.row = target.row; target.col = tmpC; target.row = tmpR; updateUnitPos(draggingUnit); updateUnitPos(target); }
                } else { draggingUnit.col = pos.c; draggingUnit.row = pos.r; updateUnitPos(draggingUnit); }
            } else returnUnit();
            draggingUnit = null;
        }

        function getUnitAt(c, r) { return units.find(u => u.col === c && u.row === r); }
        function getEmptySlots() { let slots = []; for(let c=0; c<GRID_COLS; c++) for(let r=0; r<GRID_ROWS; r++) if(!getUnitAt(c,r)) slots.push({c,r}); return slots; }
        function updateUnitPos(u) { u.x = GRID_OFFSET_X + u.col*TILE_SIZE; u.y = GRID_OFFSET_Y + u.row*TILE_SIZE; }
        function returnUnit() { updateUnitPos(draggingUnit); }
        function endWave() { 
            isWaveActive = false; document.getElementById('start-wave-btn').style.display = 'block'; 
            gold += (50 + wave * 5); 
            if(wave % 10 === 0) { stones++; showPopup(`Wave ${wave} í´ë¦¬ì–´!<br>ğŸ’ì‹ í™”ì„ íšë“!`); } else showPopup(`Wave ${wave} í´ë¦¬ì–´!`); 
            updateUI(); 
        }
        function resetGame() {
            gold = 200; wave = 1; units = []; enemies = []; projectiles = []; summonLevel = 1; stones = 0;
            classLv = { phy: 1, mag: 1, sup: 1 };
            isWaveActive = false; document.getElementById('start-wave-btn').style.display = 'block';
            updateUI();
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('stone-display').innerText = stones;
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('enemy-count').innerText = enemies.length;
            document.getElementById('summon-level').innerText = summonLevel;
            
            let rate = SUMMON_RATES[summonLevel-1];
            document.getElementById('upgrade-cost').innerText = rate.cost;

            // ê³„ì—´ ê°•í™” UI
            document.getElementById('lv-phy').innerText = classLv.phy;
            document.getElementById('cost-phy').innerText = (classLv.phy * 100) + 'G';
            document.getElementById('lv-mag').innerText = classLv.mag;
            document.getElementById('cost-mag').innerText = (classLv.mag * 100) + 'G';
            document.getElementById('lv-sup').innerText = classLv.sup;
            document.getElementById('cost-sup').innerText = (classLv.sup * 100) + 'G';
        }

        // íˆ´íŒ ê´€ë ¨
        function showLuckInfo() {
            let cur = SUMMON_RATES[summonLevel-1];
            let next = (summonLevel < 20) ? SUMMON_RATES[summonLevel] : cur;
            let el = document.getElementById('luck-tooltip');
            let mText = cur.m > 0 ? `<div class="c-myth">ì‹ í™”: ${cur.m}%</div>` : '';
            let nextM = next.m > 0 ? `<div class="c-myth">ì‹ í™”: ${next.m}%</div>` : '';

            el.innerHTML = `
                <div style="margin-bottom:5px; font-weight:bold; color:#FFD700;">í˜„ì¬ (Lv.${summonLevel})</div>
                <div class="c-rare">í¬ê·€: ${cur.r}%</div>
                <div class="c-hero">ì˜ì›…: ${cur.e}%</div>
                <div class="c-legend">ì „ì„¤: ${cur.l}%</div>
                ${mText}
                <hr style="border-color:#555; margin:5px 0;">
                <div style="margin-bottom:5px; font-weight:bold; color:#AAA;">ë‹¤ìŒ (Lv.${summonLevel < 20 ? summonLevel+1 : 'MAX'})</div>
                <div class="c-rare">í¬ê·€: ${next.r}%</div>
                <div class="c-hero">ì˜ì›…: ${next.e}%</div>
                <div class="c-legend">ì „ì„¤: ${next.l}%</div>
                ${nextM}
            `;
            el.style.display = 'block';
        }
        function hideLuckInfo() { document.getElementById('luck-tooltip').style.display = 'none'; }
        
        function showPopup(txt) { let el = document.getElementById('popup-msg'); el.innerHTML = txt; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), 1500); }
        function showTooltip(txt) { let el = document.getElementById('unit-tooltip'); el.innerHTML = txt; el.style.display = 'block'; }
        function hideTooltip() { document.getElementById('unit-tooltip').style.display = 'none'; }

        init();
    </script>
</body>
</html>
