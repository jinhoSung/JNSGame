<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš´ë¹¨ ì†”ë¡œ ë””íœìŠ¤ v4 (ì¡°í•© ì—…ë°ì´íŠ¸)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        * { box-sizing: border-box; touch-action: none; }

        body {
            margin: 0; padding: 0;
            background-color: #0f0f0f;
            display: flex; align-items: center; justify-content: center;
            height: 100vh;
            color: white; font-family: 'Jua', sans-serif;
            overflow: hidden; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 100%; height: 100%;
            max-width: 600px;
            background-color: #4CAF50;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }

        /* --- UI --- */
        #top-ui {
            flex: 0 0 115px;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px; z-index: 10;
            display: flex; flex-direction: column; justify-content: center;
            border-bottom: 2px solid #333;
        }

        .top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 6px; }
        .info-label { font-size: 13px; color: #bbb; }
        .info-value { font-size: 1.4rem; color: #FFD700; text-shadow: 1px 1px 2px #000; }
        
        /* íŠ¹ìˆ˜ ì¬í™” í‘œì‹œ */
        .mythic-stone {
            display: flex; align-items: center; gap: 5px;
            background: rgba(100, 0, 255, 0.3); padding: 5px 10px; border-radius: 15px; border: 1px solid #7C4DFF;
        }
        .mythic-stone span { font-size: 1.2rem; color: #E040FB; text-shadow: 0 0 5px #E040FB; }

        #canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; background-color: #66BB6A; }
        canvas { display: block; width: 100%; height: 100%; }

        #bottom-ui {
            flex: 0 0 160px;
            background-color: #3E2723;
            padding: 10px;
            display: flex; flex-direction: column; justify-content: space-between;
            border-top: 4px solid #281A16; z-index: 10;
        }

        #resources { display: flex; justify-content: space-between; padding: 0 5px; margin-bottom: 5px; font-size: 1.1rem; color: #FFD700; }
        #buttons { display: flex; justify-content: space-between; align-items: flex-end; height: 100%; gap: 6px; }

        .game-btn {
            border: none; border-radius: 14px; color: white;
            font-family: 'Jua', sans-serif; cursor: pointer;
            position: relative; box-shadow: 0 5px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s; padding: 0; overflow: hidden;
        }
        .game-btn:active { transform: translateY(5px); box-shadow: none; }

        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn-upgrade { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #673AB7, #512DA8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #9575CD; }
        .btn-summon { flex: 1; height: 100%; max-height: 95px; background: linear-gradient(135deg, #FFC107, #FF8F00); font-size: 1.6rem; color: #3E2723; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 1px solid #FFE082; }
        .btn-combine { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #009688, #00695C); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.95rem; border: 1px solid #4DB6AC; }
        .btn-gamble { width: 18%; height: 100%; max-height: 70px; background: linear-gradient(135deg, #2196F3, #1565C0); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; border: 1px solid #64B5F6; margin-bottom: 5px;}

        .btn-wave {
            position: absolute; top: 20px; right: 20px;
            background: #D32F2F; padding: 10px 20px; border-radius: 30px;
            border: 3px solid white; font-weight: bold; font-size: 1.1rem;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4); z-index: 20;
            animation: pulse 2s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* ì¡°í•©ì†Œ ëª¨ë‹¬ */
        #combine-modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-height: 80%; background: rgba(30, 30, 30, 0.95);
            border: 2px solid #FFD700; border-radius: 15px; z-index: 100;
            flex-direction: column; padding: 20px; color: white;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #combine-modal.open { display: flex; }
        .modal-header { font-size: 1.5rem; text-align: center; margin-bottom: 15px; color: #FFD700; }
        .recipe-list { overflow-y: auto; flex: 1; }
        .recipe-card {
            background: rgba(255, 255, 255, 0.1); margin-bottom: 10px; padding: 10px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 5px; border: 1px solid #555;
        }
        .recipe-header { display: flex; justify-content: space-between; align-items: center; }
        .recipe-name { font-size: 1.2rem; font-weight: bold; color: #E040FB; }
        .recipe-cost { font-size: 0.9rem; color: #aaa; }
        .recipe-req { display: flex; gap: 10px; font-size: 0.9rem; color: #ddd; align-items: center; margin-top: 5px;}
        .req-item { display: flex; align-items: center; gap: 3px; }
        .btn-buy-recipe {
            padding: 8px; border: none; border-radius: 5px; background: #6200EA; color: white; font-family: 'Jua'; cursor: pointer;
        }
        .btn-do-combine {
            padding: 8px; border: none; border-radius: 5px; background: #00C853; color: white; font-family: 'Jua'; cursor: pointer;
        }
        .btn-do-combine:disabled { background: #555; color: #aaa; cursor: not-allowed; }
        .btn-close { margin-top: 10px; padding: 10px; background: #D32F2F; color: white; border: none; border-radius: 8px; font-family: 'Jua'; cursor: pointer; }

        /* ë©”ì‹œì§€ & íˆ´íŒ */
        #message-area { position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; text-align: center; width: 100%; z-index: 50; }
        .pop-text { font-size: 2.2rem; font-weight: bold; color: #fff; text-shadow: 3px 3px 0 #000, 0 0 15px gold; opacity: 0; transition: opacity 0.3s, transform 0.3s; }
        .pop-text.show { opacity: 1; transform: translateY(-40px); }
        .tooltip { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); background: rgba(20,20,20,0.95); padding: 15px; border-radius: 12px; font-size: 0.95rem; display: none; width: 90%; text-align: center; z-index: 100; border: 2px solid #555; pointer-events: none; }

        /* ë“±ê¸‰ ìƒ‰ìƒ í´ë˜ìŠ¤ */
        .c-legend { color: #FF7043; }
        .c-myth { color: #FF5252; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="top-ui">
            <div class="top-row">
                <div class="info-group">
                    <div class="info-label">WAVE</div>
                    <div class="info-value" id="wave-display">1</div>
                </div>
                <div class="mythic-stone">
                    ğŸ’ <span id="stone-display">0</span>
                </div>
                <div class="info-group">
                    <div class="info-label">ì  ìˆ«ì</div>
                    <div class="info-value" style="color:#FF5252"><span id="enemy-count">0</span> / 60</div>
                </div>
            </div>
            <div style="text-align:center; font-size:0.8rem; color:#aaa;" id="chance-text">ì¼ë°˜ ì†Œí™˜ í™•ë¥ : ì‹ í™” 0%</div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <button id="start-wave-btn" class="btn-wave" onclick="startNextWave()">ğŸ”¥ ì „íˆ¬ ì‹œì‘</button>
            <div id="message-area"><div id="popup-msg" class="pop-text"></div></div>
            <div id="unit-tooltip" class="tooltip"></div>
        </div>

        <div id="bottom-ui">
            <div id="resources">
                <span style="color:#ccc;">í–‰ìš´ Lv.<span id="summon-level">1</span></span>
                <span>ğŸ’° <span id="gold-display">200</span></span>
            </div>
            <div id="buttons">
                <button class="game-btn btn-upgrade" onclick="upgradeSummon()">
                    â˜˜ï¸í–‰ìš´
                    <span style="font-size:0.75em; color:#FFEB3B; margin-top:2px;" id="upgrade-cost">50G</span>
                </button>
                
                <button class="game-btn btn-summon" onclick="summonUnit()">
                    ğŸ² ì†Œí™˜
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">10 G</span>
                </button>
                
                <button class="game-btn btn-combine" onclick="openCombineModal()">
                    ğŸ° ì¡°í•©
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">Special</span>
                </button>

                <button class="game-btn btn-gamble" onclick="gamble()">
                    ğŸ°ë„ë°•<br>50G
                </button>
            </div>
        </div>

        <!-- ì¡°í•©ì†Œ ëª¨ë‹¬ -->
        <div id="combine-modal">
            <div class="modal-header">ğŸ° ì˜ì›… ì¡°í•©ì†Œ</div>
            <div class="recipe-list" id="recipe-list">
                <!-- JSë¡œ ìƒì„±ë¨ -->
            </div>
            <button class="btn-close" onclick="closeCombineModal()">ë‹«ê¸°</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        // --- ê·¸ë¦¬ë“œ ---
        const GRID_COLS = 6; const GRID_ROWS = 5;
        let TILE_SIZE = 0, GRID_OFFSET_X = 0, GRID_OFFSET_Y = 0;
        let PATH_POINTS = [];
        let TRASH_ZONE = { x: 0, y: 0, r: 0 };

        // --- ìœ ë‹› ë°ì´í„° ---
        // ì¼ë°˜ ìœ ë‹› (ëœë¤ ì†Œí™˜ìš©)
        const UNIT_DATA = {
            'ì•¼ë§Œì¸': { color: '#BCAAA4', icon: 'ğŸª“', desc: '1.5ì´ˆ ê¸°ì ˆ (10%)', type: 'phy' },
            'ê¶ìˆ˜': { color: '#81D4FA', icon: 'ğŸ¹', desc: 'ì¹˜ëª…íƒ€ 2.5ë°° (20%)', type: 'phy' },
            'ì–¼ìŒë²•ì‚¬': { color: '#90CAF9', icon: 'ğŸ§Š', desc: 'ìŠ¬ë¡œìš° 40%', type: 'mag' },
            'ì‚°ì ': { color: '#A1887F', icon: 'ğŸ’°', desc: 'ê³µê²© ì‹œ 10ê³¨ë“œ (5%)', type: 'phy' },
            'ì „ê¸°ë¡œë´‡': { color: '#FFF59D', icon: 'âš¡', desc: '3ì¸ ë™ì‹œ ê³µê²©', type: 'mag' },
            'ë‹Œì': { color: '#424242', icon: 'ğŸ¥·', desc: 'ì²´ë ¥ 30%ì´í•˜ 3ë°° í”¼í•´', type: 'phy' }
        };
        const UNIT_TYPES = Object.keys(UNIT_DATA);
        
        // --- íˆë“ /ì¡°í•© ì˜ì›… ë°ì´í„° ---
        // ì´ë“¤ì€ ì†Œí™˜ìœ¼ë¡œ ë‚˜ì˜¤ì§€ ì•Šê³  ì¡°í•©ìœ¼ë¡œë§Œ ë“±ì¥ (Tier 5 ì·¨ê¸‰)
        const HIDDEN_DATA = {
            'ê°œêµ¬ë¦¬ì™•ì': { color: '#69F0AE', icon: 'ğŸ¸', desc: 'ê³µì†ì´ ë¯¸ì¹œë“¯ì´ ë¹ ë¦„ (5ë°°)', type: 'phy' },
            'ë§ˆì‹ ': { color: '#D50000', icon: 'ğŸ‘¿', desc: 'ì „ì²´ í™”ë©´ ê´‘ì—­ ë”œ', type: 'mag' },
            'ë“œë˜ê³¤': { color: '#FFAB00', icon: 'ğŸ²', desc: 'ê°•ë ¥í•œ í•œë°© & ìŠ¤í„´', type: 'phy' }
        };

        const TIERS = ['ì¼ë°˜', 'í¬ê·€', 'ì˜ì›…', 'ì „ì„¤', 'ì‹ í™”', 'ë¶ˆë©¸'];
        const TIER_COLORS = ['#B0BEC5', '#29B6F6', '#AB47BC', '#FF7043', '#FF1744', '#D500F9'];

        // --- ë ˆì‹œí”¼ ë°ì´í„° ---
        // ingredients: í•„ìš”í•œ ì¬ë£Œ (ì „ì„¤ ë“±ê¸‰, Tier=3)
        const RECIPES = [
            { 
                id: 'frog', name: 'ê°œêµ¬ë¦¬ì™•ì', unlocked: false, cost: 5, 
                result: 'ê°œêµ¬ë¦¬ì™•ì', 
                req: [ {type:'ì•¼ë§Œì¸', tier:3}, {type:'ê¶ìˆ˜', tier:3} ] 
            },
            { 
                id: 'demon', name: 'ë§ˆì‹ ', unlocked: false, cost: 10, 
                result: 'ë§ˆì‹ ', 
                req: [ {type:'ë‹Œì', tier:3}, {type:'ì‚°ì ', tier:3} ] 
            },
            { 
                id: 'dragon', name: 'ë“œë˜ê³¤', unlocked: false, cost: 15, 
                result: 'ë“œë˜ê³¤', 
                req: [ {type:'ì „ê¸°ë¡œë´‡', tier:3}, {type:'ì–¼ìŒë²•ì‚¬', tier:3} ] 
            }
        ];

        // --- ì†Œí™˜ í™•ë¥  (20ë‹¨ê³„) ---
        const SUMMON_RATES = [];
        for(let i=1; i<=20; i++) {
            let rate = {}; let cost = 0;
            if(i <= 5) { rate = { c: 100 - (i-1)*10, r: (i-1)*10, e: 0, l: 0, m: 0 }; cost = 50 * i; }
            else if(i <= 10) { rate = { c: 60 - (i-5)*6, r: 40 - (i-5)*2, e: (i-5)*8, l: 0, m: 0 }; cost = 150 * (i-3); }
            else if(i <= 15) { rate = { c: 30 - (i-10)*4, r: 30 - (i-10)*2, e: 40 - (i-10)*2, l: (i-10)*8, m: 0 }; cost = 1000 + (i-10)*500; }
            else { 
                let myth = (i-15) * 0.5; // ìµœëŒ€ 2.5%
                let leg = 40 - (i-15)*2; 
                let epic = 30 - (i-15)*2;
                rate = { c: 5, r: 10, e: epic, l: leg, m: myth };
                let total = rate.c + rate.r + rate.e + rate.l + rate.m;
                if(total < 100) rate.c += (100 - total);
                cost = 3000 + (i-15)*1500; 
            }
            if(i===20) cost = 'MAX';
            SUMMON_RATES.push({ ...rate, cost: cost });
        }

        const SUMMON_COST = 10;
        const GAMBLE_COST = 50;

        // --- ê²Œì„ ìƒíƒœ ---
        let gold = 200;
        let stones = 0; // ì‹ í™”ì„
        let wave = 1;
        let units = [];
        let enemies = [];
        let projectiles = [];
        let summonLevel = 1;
        
        let lastTime = 0;
        let enemySpawnTimer = 0;
        let enemiesToSpawn = 0;
        let isWaveActive = false;
        let maxEnemies = 60;
        let draggingUnit = null;
        let frameCount = 0;

        // --- ë¦¬ì‚¬ì´ì§• ---
        function resizeGame() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            const maxTileW = canvas.width / (GRID_COLS + 1.2);
            const maxTileH = canvas.height / (GRID_ROWS + 2.5);
            TILE_SIZE = Math.floor(Math.min(maxTileW, maxTileH));
            GRID_OFFSET_X = (canvas.width - GRID_COLS * TILE_SIZE) / 2;
            GRID_OFFSET_Y = (canvas.height - GRID_ROWS * TILE_SIZE) / 2;

            const margin = TILE_SIZE * 0.6;
            PATH_POINTS = [
                { x: -50, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y - margin },
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin },
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin },
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y - margin },
                { x: canvas.width + 50, y: GRID_OFFSET_Y - margin }
            ];
            TRASH_ZONE = { x: canvas.width - TILE_SIZE * 0.9, y: canvas.height - TILE_SIZE * 0.9, r: TILE_SIZE * 0.6 };
            units.forEach(u => { u.x = GRID_OFFSET_X + u.col * TILE_SIZE; u.y = GRID_OFFSET_Y + u.row * TILE_SIZE; });
        }

        function init() {
            window.addEventListener('resize', resizeGame);
            resizeGame();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('touchstart', (e) => { if(e.touches.length>1) return; e.preventDefault(); onMouseDown({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchend', (e) => { onMouseUp({clientX: e.changedTouches?e.changedTouches[0].clientX : 0, clientY: e.changedTouches?e.changedTouches[0].clientY : 0}); });
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            frameCount++;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            if (isWaveActive && enemiesToSpawn > 0) {
                let spawnInterval = Math.max(150, 700 - (wave * 20)); 
                enemySpawnTimer += deltaTime;
                if (enemySpawnTimer > spawnInterval) { spawnEnemy(); enemySpawnTimer = 0; enemiesToSpawn--; }
            } else if (isWaveActive && enemiesToSpawn === 0 && enemies.length === 0) {
                endWave();
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.stunTimer > 0) enemy.stunTimer -= deltaTime;
                if (enemy.slowTimer > 0) enemy.slowTimer -= deltaTime;
                moveEnemy(enemy, deltaTime);
                if (enemy.reachedEnd) { enemies.splice(i, 1); }
                else if (enemy.hp <= 0) { gold += (2 + Math.floor(wave * 0.2)); enemies.splice(i, 1); updateUI(); }
            }

            if (enemies.length >= maxEnemies) { alert(`ê²Œì„ ì˜¤ë²„! ${wave} ì›¨ì´ë¸Œ ê¸°ë¡.`); resetGame(); return; }

            units.forEach(unit => {
                if (unit === draggingUnit) return;
                unit.cooldown -= deltaTime;
                if (unit.cooldown <= 0) {
                    if(unit.type === 'ì „ê¸°ë¡œë´‡') {
                        const targets = findTargets(unit, 3);
                        if(targets.length > 0) { targets.forEach(t => fireProjectile(unit, t)); resetCooldown(unit); }
                    } else if(unit.type === 'ë§ˆì‹ ') {
                        fireGlobalAttack(unit);
                        resetCooldown(unit);
                    } else {
                        const target = findTarget(unit);
                        if (target) { fireProjectile(unit, target); resetCooldown(unit); }
                    }
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                moveProjectile(p, deltaTime);
                if (p.hit) projectiles.splice(i, 1);
            }
        }

        function resetCooldown(unit) {
            let baseSpeed = 1000 / (1 + unit.tier * 0.3);
            if(unit.type === 'ì‚°ì ') baseSpeed *= 1.2;
            
            // íˆë“  ìœ ë‹› íŠ¹ìˆ˜ ê³µì†
            if(unit.type === 'ê°œêµ¬ë¦¬ì™•ì') baseSpeed = 200; // ì´ˆê³ ì†
            if(unit.type === 'ë§ˆì‹ ') baseSpeed = 1500; // ëŠë¦¼ (ê´‘ì—­ì´ë‹ˆê¹Œ)
            
            unit.cooldown = baseSpeed;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5, GRID_COLS*TILE_SIZE + 10, GRID_ROWS*TILE_SIZE + 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            for(let c=0; c<GRID_COLS; c++) {
                for(let r=0; r<GRID_ROWS; r++) {
                    ctx.strokeRect(GRID_OFFSET_X + c*TILE_SIZE, GRID_OFFSET_Y + r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // ê²½ë¡œ
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = TILE_SIZE * 0.45; ctx.lineJoin = 'round';
            ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y);
            for(let i=1; i<PATH_POINTS.length; i++) ctx.lineTo(PATH_POINTS[i].x, PATH_POINTS[i].y);
            ctx.stroke();

            // ì 
            enemies.forEach(e => {
                if(e.stunTimer > 0) ctx.fillStyle = '#FFEB3B';
                else if(e.slowTimer > 0) ctx.fillStyle = '#42A5F5';
                else ctx.fillStyle = '#CFD8DC';
                let r = TILE_SIZE * 0.22;
                ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.stroke();
                let pct = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#263238'; ctx.fillRect(e.x - r, e.y - r - 8, r*2, 5);
                ctx.fillStyle = pct > 0.5 ? '#76FF03' : '#FF1744'; ctx.fillRect(e.x - r, e.y - r - 8, r*2*pct, 5);
            });

            // ìœ ë‹›
            units.forEach(u => { if(u !== draggingUnit) drawUnit(u, u.x, u.y); });

            // íˆ¬ì‚¬ì²´
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });

            // ë“œë˜ê·¸
            if(draggingUnit) {
                ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.1)';
                let rangePx = draggingUnit.range * (TILE_SIZE/55);
                ctx.arc(draggingUnit.dragX, draggingUnit.dragY, rangePx, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                
                let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
                let isHover = dist < TRASH_ZONE.r * 1.5;
                ctx.fillStyle = isHover ? '#D32F2F' : 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(TRASH_ZONE.x, TRASH_ZONE.y, isHover ? TRASH_ZONE.r*1.1 : TRASH_ZONE.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${TILE_SIZE*0.4}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText('ğŸ—‘ï¸', TRASH_ZONE.x, TRASH_ZONE.y);
                drawUnit(draggingUnit, draggingUnit.dragX, draggingUnit.dragY);
            }
        }

        function drawUnit(unit, x, y) {
            const cx = x + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const cy = y + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const size = TILE_SIZE * 0.85;

            // ë°ì´í„° ì†ŒìŠ¤ ë¶„ê¸°
            let data = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            
            ctx.fillStyle = data.color;
            ctx.lineWidth = 3;

            // ë¶ˆë©¸/íˆë“  ì´í™íŠ¸
            if(unit.tier >= 4) {
                let hue = (frameCount * 3) % 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
            } else {
                ctx.strokeStyle = TIER_COLORS[unit.tier];
                ctx.shadowBlur = 0;
            }

            // ëª¨ì–‘ ê·¸ë¦¬ê¸°
            ctx.beginPath();
            if(unit.tier === 0) ctx.arc(cx, cy, size/2, 0, Math.PI*2);
            else if(unit.tier === 1) ctx.rect(cx - size/2, cy - size/2, size, size);
            else if(unit.tier === 2) drawPolygon(ctx, cx, cy, size/2, 6);
            else if(unit.tier === 3) drawPolygon(ctx, cx, cy, size/2, 4, Math.PI/4);
            else drawStar(ctx, cx, cy, 5, size/2, size/4); // ì‹ í™” ì´ìƒ
            ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

            ctx.fillStyle = 'white'; ctx.font = `${size*0.5}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(data.icon, cx, cy);
        }

        function drawPolygon(ctx, x, y, radius, sides, rotateAngle = 0) {
            if (sides < 3) return;
            var a = (Math.PI * 2)/sides;
            ctx.moveTo(x + radius*Math.cos(rotateAngle), y + radius*Math.sin(rotateAngle));
            for (var i = 1; i < sides; i++) ctx.lineTo(x + radius*Math.cos(a*i + rotateAngle), y + radius*Math.sin(a*i + rotateAngle));
            ctx.closePath();
        }
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes;
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
                x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
        }

        // --- ë¡œì§ ---
        function upgradeSummon() {
            if(summonLevel >= 20) { showPopup("ìµœê³  ë ˆë²¨ì…ë‹ˆë‹¤!"); return; }
            let cost = SUMMON_RATES[summonLevel-1].cost;
            if(gold < cost) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            gold -= cost; summonLevel++; showPopup(`í–‰ìš´ ê°•í™” Lv.${summonLevel} ì„±ê³µ!`); updateUI();
        }

        function summonUnit() {
            if(gold < SUMMON_COST) { showPopup("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!"); return; }
            let emptySlots = getEmptySlots();
            if(emptySlots.length === 0) { showPopup("ìë¦¬ê°€ ê½‰ ì°¼ìŠµë‹ˆë‹¤!"); return; }
            gold -= SUMMON_COST;
            
            let rates = SUMMON_RATES[summonLevel-1];
            let rand = Math.random() * 100;
            let tier = 0;
            
            if(rand < rates.c) tier = 0;
            else if(rand < rates.c + rates.r) { tier = 1; showPopup("í¬ê·€ ì†Œí™˜! ğŸ’™"); }
            else if(rand < rates.c + rates.r + rates.e) { tier = 2; showPopup("ì˜ì›… ì†Œí™˜! ğŸ’œ"); }
            else if(rand < rates.c + rates.r + rates.e + rates.l) { tier = 3; showPopup("ì „ì„¤ ì†Œí™˜! ğŸ§¡"); }
            else { tier = 4; showPopup("âš¡ì‹ í™” ì†Œí™˜!âš¡"); }

            let slot = emptySlots[Math.floor(Math.random()*emptySlots.length)];
            let type = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
            createUnit(slot.c, slot.r, type, tier);
            updateUI();
        }

        function createUnit(col, row, type, tier) {
            const x = GRID_OFFSET_X + col * TILE_SIZE;
            const y = GRID_OFFSET_Y + row * TILE_SIZE;
            
            // ë°ë¯¸ì§€ ê³„ì‚°
            let mult = Math.pow(2.2, tier);
            if(tier >= 4) mult *= 2; // ì‹ í™” ì´ìƒ ë³´ë„ˆìŠ¤
            
            // íˆë“  ìœ ë‹› ìŠ¤íƒ¯ ë³´ì •
            if(HIDDEN_DATA[type]) {
                mult *= 3; // íˆë“ ì€ ë” ì…ˆ
            }

            units.push({
                col, row, x, y, type, tier,
                damage: 10 * mult,
                range: 160 + (tier * 15),
                cooldown: 0
            });
        }

        function gamble() {
            if(gold < GAMBLE_COST) { showPopup("ë¹„ìš© ë¶€ì¡±!"); return; }
            gold -= GAMBLE_COST;
            let rand = Math.random();
            if(rand < 0.45) showPopup("ê½... ğŸ’¸");
            else if(rand < 0.70) { 
                let gain = 150 + (summonLevel * 5); 
                gold += gain; showPopup(`+${gain}G ëŒ€ë°•! ğŸ‰`); 
            }
            else if(rand < 0.95) { 
                summonUnit(); gold += SUMMON_COST; showPopup("ìœ ë‹› íšë“! ğŸ²"); 
            } else {
                stones += 1; showPopup("ğŸ’ ì‹ í™”ì„ íšë“! ğŸ’");
            }
            updateUI();
        }

        // --- ì¡°í•© ì‹œìŠ¤í…œ ---
        function openCombineModal() {
            const list = document.getElementById('recipe-list');
            list.innerHTML = '';
            
            RECIPES.forEach(r => {
                const canUnlock = !r.unlocked && stones >= r.cost;
                const canCombine = r.unlocked && checkIngredients(r.req);
                
                let btnHtml = '';
                if(!r.unlocked) {
                    btnHtml = `<button class="btn-buy-recipe" onclick="unlockRecipe('${r.id}')" ${canUnlock ? '' : 'disabled'}>
                                í•´ê¸ˆ (ğŸ’${r.cost})
                               </button>`;
                } else {
                    btnHtml = `<button class="btn-do-combine" onclick="combineHero('${r.id}')" ${canCombine ? '' : 'disabled'}>
                                ${canCombine ? 'ì¡°í•© ê°€ëŠ¥!' : 'ì¬ë£Œ ë¶€ì¡±'}
                               </button>`;
                }

                let reqHtml = r.req.map(req => {
                    // ë³´ìœ  ì—¬ë¶€ ì²´í¬
                    let has = units.some(u => u.type === req.type && u.tier === req.tier);
                    let color = has ? '#69F0AE' : '#FF5252';
                    return `<div class="req-item" style="color:${color}">
                                <span>[ì „ì„¤]</span><span>${req.type}</span>
                            </div>`;
                }).join(' + ');

                let item = document.createElement('div');
                item.className = 'recipe-card';
                item.innerHTML = `
                    <div class="recipe-header">
                        <div class="recipe-name">${r.name}</div>
                        ${btnHtml}
                    </div>
                    <div style="font-size:0.8rem; color:#bbb;">${HIDDEN_DATA[r.result].desc}</div>
                    <div class="recipe-req">${reqHtml}</div>
                `;
                list.appendChild(item);
            });
            
            document.getElementById('combine-modal').classList.add('open');
        }

        function closeCombineModal() { document.getElementById('combine-modal').classList.remove('open'); }

        function unlockRecipe(id) {
            let r = RECIPES.find(x => x.id === id);
            if(r && stones >= r.cost) {
                stones -= r.cost;
                r.unlocked = true;
                showPopup(`${r.name} í•´ê¸ˆ ì™„ë£Œ!`);
                updateUI();
                openCombineModal(); // ë¦¬í”„ë ˆì‹œ
            }
        }

        function checkIngredients(reqs) {
            // ë‹¨ìˆœ ì²´í¬: ì¬ë£Œê°€ ë‹¤ ìˆëŠ”ì§€ (ì¤‘ë³µ ì¬ë£Œ ì²˜ë¦¬ í•„ìš”í•˜ì§€ë§Œ, ì—¬ê¸°ì„  ë‹¨ìˆœ 1:1 ì²´í¬)
            // ì‹¤ì œ ì†Œë¹„ë¥¼ ìœ„í•´ì„  ì •í™•í•œ ë§¤ì¹­ í•„ìš”.
            // ì—¬ê¸°ì„  í¸ì˜ìƒ íƒ€ì…/í‹°ì–´ ì¼ì¹˜í•˜ëŠ” ìœ ë‹› ê°¯ìˆ˜ë¥¼ ì…‰ë‹ˆë‹¤.
            let tempUnits = [...units];
            for(let req of reqs) {
                let idx = tempUnits.findIndex(u => u.type === req.type && u.tier === req.tier);
                if(idx === -1) return false;
                tempUnits.splice(idx, 1); // ê°€ìƒ ì†Œë¹„
            }
            return true;
        }

        function combineHero(id) {
            let r = RECIPES.find(x => x.id === id);
            if(!r) return;
            
            // ì¬ë£Œ ì†Œë¹„
            let ingredients = [];
            let tempUnits = [...units];
            
            for(let req of r.req) {
                let u = units.find(unit => unit.type === req.type && unit.tier === req.tier && !ingredients.includes(unit));
                if(u) ingredients.push(u);
                else { showPopup("ì¬ë£Œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤."); return; }
            }

            // ì¬ë£Œ ì‚­ì œ
            units = units.filter(u => !ingredients.includes(u));
            
            // ê²°ê³¼ë¬¼ ìƒì„± (ì²«ë²ˆì§¸ ì¬ë£Œ ìœ„ì¹˜ì—)
            let pos = { c: ingredients[0].col, r: ingredients[0].row };
            createUnit(pos.c, pos.r, r.result, 4); // ì‹ í™”(4) ë“±ê¸‰ë³´ë‹¤ ë†’ê²Œ ì„¤ì • ê°€ëŠ¥í•˜ì§€ë§Œ ì¼ë‹¨ 4ë¡œ
            // íˆë“  ìœ ë‹›ì€ Tier 4(ì‹ í™”)ë¡œ í‘œê¸°ë˜ì§€ë§Œ ëŠ¥ë ¥ì¹˜ëŠ” í›¨ì”¬ ë†’ìŒ
            
            showPopup(`âœ¨${r.name} ì†Œí™˜ ì„±ê³µ!âœ¨`);
            closeCombineModal();
        }

        // --- ì „íˆ¬ ---
        function startNextWave() {
            if(isWaveActive) return;
            wave++;
            enemiesToSpawn = 12 + Math.floor(wave * 2.5);
            isWaveActive = true;
            document.getElementById('start-wave-btn').style.display = 'none';
            updateUI();
        }

        function spawnEnemy() {
            let start = PATH_POINTS[0];
            let hp = 120 * Math.pow(1.3, wave-1);
            let spd = 100 + (wave * 2.5);
            enemies.push({ x: start.x, y: start.y, pathIndex: 0, hp, maxHp: hp, speed: spd, reachedEnd: false, stunTimer: 0, slowTimer: 0 });
            updateUI();
        }

        function moveEnemy(enemy, deltaTime) {
            if(enemy.stunTimer > 0) return;
            let target = PATH_POINTS[enemy.pathIndex+1];
            if(!target) { enemy.reachedEnd = true; return; }
            let dx = target.x - enemy.x; let dy = target.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            let spd = enemy.speed;
            if(enemy.slowTimer > 0) spd *= 0.6;
            let move = (spd * deltaTime) / 1000;
            if(dist < move) { enemy.x = target.x; enemy.y = target.y; enemy.pathIndex++; }
            else { enemy.x += (dx/dist)*move; enemy.y += (dy/dist)*move; }
        }

        function findTarget(unit) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let closest = null; let minD = 9999;
            for(let e of enemies) {
                let d = Math.hypot(e.x - cx, e.y - cy);
                if(d <= rangePx && d < minD) { minD = d; closest = e; }
            }
            return closest;
        }
        function findTargets(unit, count) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let targets = [];
            for(let e of enemies) {
                if(Math.hypot(e.x - cx, e.y - cy) <= rangePx) { targets.push(e); if(targets.length>=count) break; }
            }
            return targets;
        }

        function fireGlobalAttack(unit) {
            enemies.forEach(e => {
                e.hp -= unit.damage;
                // ì´í™íŠ¸ ìƒì„± (ê° ì  ìœ„ì¹˜ì—)
                projectiles.push({ x: e.x, y: e.y - 20, target: null, damage: 0, speed: 0, hit: true, color: '#D50000', size: 10, timer: 10 });
            });
        }

        function fireProjectile(unit, target) {
            let color = '#FFFF00'; let effect = null; let dmg = unit.damage; let pSize = 5;
            let data = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            
            if(unit.type === 'ì•¼ë§Œì¸') { if(Math.random()<0.1) { effect='stun'; color='#FFF'; } }
            else if(unit.type === 'ê¶ìˆ˜') { if(Math.random()<0.2) { dmg*=2.5; color='#F44336'; } }
            else if(unit.type === 'ì–¼ìŒë²•ì‚¬') { effect='slow'; color='#29B6F6'; }
            else if(unit.type === 'ì‚°ì ') { if(Math.random()<0.05) { gold+=10; updateUI(); } }
            else if(unit.type === 'ë‹Œì') { if(target.hp/target.maxHp<=0.3) { dmg*=3; color='#D32F2F'; } }
            else if(unit.type === 'ë“œë˜ê³¤') { if(Math.random()<0.3) effect='stun'; color='#FFAB00'; pSize=8; }

            projectiles.push({ x: unit.x+TILE_SIZE/2, y: unit.y+TILE_SIZE/2, target: target, damage: dmg, speed: 700, hit: false, effect: effect, color: color, size: pSize });
        }

        function moveProjectile(p, deltaTime) {
            if(p.timer) { p.timer--; if(p.timer<=0) p.hit=true; return; } // ì´í™íŠ¸ìš©
            if(!p.target || !enemies.includes(p.target)) { p.hit = true; return; }
            let dx = p.target.x - p.x; let dy = p.target.y - p.y;
            let dist = Math.hypot(dx, dy);
            let move = (p.speed * deltaTime) / 1000;
            if(dist < move) {
                p.x = p.target.x; p.y = p.target.y; p.hit = true;
                p.target.hp -= p.damage;
                if(p.effect === 'stun') p.target.stunTimer = 1500;
                if(p.effect === 'slow') p.target.slowTimer = 2000;
            } else { p.x += (dx/dist)*move; p.y += (dy/dist)*move; }
        }

        // --- ì…ë ¥ ---
        function getGridPos(cx, cy) {
            let rect = canvas.getBoundingClientRect();
            let x = cx - rect.left; let y = cy - rect.top;
            if(x > GRID_OFFSET_X && x < GRID_OFFSET_X + GRID_COLS*TILE_SIZE && y > GRID_OFFSET_Y && y < GRID_OFFSET_Y + GRID_ROWS*TILE_SIZE) {
                   return { c: Math.floor((x-GRID_OFFSET_X)/TILE_SIZE), r: Math.floor((y-GRID_OFFSET_Y)/TILE_SIZE) };
            }
            return null;
        }

        function onMouseDown(e) {
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let u = getUnitAt(pos.c, pos.r);
                if(u) {
                    draggingUnit = u;
                    let rect = canvas.getBoundingClientRect();
                    u.dragX = e.clientX - rect.left; u.dragY = e.clientY - rect.top;
                    let info = UNIT_DATA[u.type] || HIDDEN_DATA[u.type];
                    showTooltip(`<span style="color:${info.color}; font-size:1.1em; font-weight:bold;">${u.type}</span> <span style="color:${TIER_COLORS[u.tier]}">[${TIERS[u.tier]}]</span><br>${info.desc}`);
                }
            }
        }
        function onMouseMove(e) {
            if(draggingUnit) {
                let rect = canvas.getBoundingClientRect();
                draggingUnit.dragX = e.clientX - rect.left; draggingUnit.dragY = e.clientY - rect.top;
            }
        }
        function onMouseUp(e) {
            hideTooltip();
            if(!draggingUnit) return;
            
            let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
            if(dist < TRASH_ZONE.r * 1.5) {
                units = units.filter(u => u !== draggingUnit);
                gold += Math.floor(SUMMON_COST/2); showPopup("íŒë§¤ ì™„ë£Œ (+5G)");
                updateUI(); draggingUnit = null; return;
            }

            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let target = getUnitAt(pos.c, pos.r);
                if(target && target !== draggingUnit) {
                    if(target.type === draggingUnit.type && target.tier === draggingUnit.tier) {
                        if(target.tier < 5) { 
                            let newTier = target.tier + 1;
                            let newType = target.type; 
                            units = units.filter(u => u !== draggingUnit && u !== target);
                            createUnit(pos.c, pos.r, newType, newTier);
                            showPopup(`í•©ì„±! [${TIERS[newTier]}] ì„±ê³µ âœ¨`);
                        } else { showPopup("ìµœê³  ë“±ê¸‰ì…ë‹ˆë‹¤!"); returnUnit(); }
                    } else { 
                        let tmpC = draggingUnit.col; let tmpR = draggingUnit.row;
                        draggingUnit.col = target.col; draggingUnit.row = target.row;
                        target.col = tmpC; target.row = tmpR;
                        updateUnitPos(draggingUnit); updateUnitPos(target);
                    }
                } else {
                    draggingUnit.col = pos.c; draggingUnit.row = pos.r;
                    updateUnitPos(draggingUnit);
                }
            } else returnUnit();
            draggingUnit = null;
        }

        function getUnitAt(c, r) { return units.find(u => u.col === c && u.row === r); }
        function getEmptySlots() { 
            let slots = [];
            for(let c=0; c<GRID_COLS; c++) for(let r=0; r<GRID_ROWS; r++) if(!getUnitAt(c,r)) slots.push({c,r});
            return slots;
        }
        function updateUnitPos(u) { u.x = GRID_OFFSET_X + u.col*TILE_SIZE; u.y = GRID_OFFSET_Y + u.row*TILE_SIZE; }
        function returnUnit() { updateUnitPos(draggingUnit); }
        function endWave() { 
            isWaveActive = false; document.getElementById('start-wave-btn').style.display = 'block'; 
            gold += (50 + wave * 5); 
            // 10ì›¨ì´ë¸Œ ë§ˆë‹¤ ì‹ í™”ì„ í™•ì • ì§€ê¸‰
            if(wave % 10 === 0) { stones++; showPopup(`Wave ${wave} í´ë¦¬ì–´!<br>ğŸ’ì‹ í™”ì„ íšë“!`); }
            else showPopup(`Wave ${wave} í´ë¦¬ì–´!`); 
            updateUI(); 
        }
        function resetGame() {
            gold = 200; wave = 1; units = []; enemies = []; projectiles = []; summonLevel = 1; stones = 0;
            isWaveActive = false; document.getElementById('start-wave-btn').style.display = 'block';
            updateUI();
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('stone-display').innerText = stones;
            document.getElementById('wave-display').innerText = wave;
            document.getElementById('enemy-count').innerText = enemies.length;
            document.getElementById('summon-level').innerText = summonLevel;
            
            let rate = SUMMON_RATES[summonLevel-1];
            document.getElementById('upgrade-cost').innerText = rate.cost;

            let mRate = rate.m > 0 ? `<span class="c-myth"> ì‹ í™” ${rate.m}%</span>` : '';
            document.getElementById('chance-text').innerHTML = `ì†Œí™˜ í™•ë¥ : <span class="c-legend">ì „ì„¤ ${rate.l}%</span> ${mRate}`;
        }

        function showPopup(txt) { let el = document.getElementById('popup-msg'); el.innerHTML = txt; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), 1500); }
        function showTooltip(txt) { let el = document.getElementById('unit-tooltip'); el.innerHTML = txt; el.style.display = 'block'; }
        function hideTooltip() { document.getElementById('unit-tooltip').style.display = 'none'; }

        init();
    </script>
</body>
</html>
