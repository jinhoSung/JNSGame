<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ïö¥Îπ® ÏÜîÎ°ú ÎîîÌéúÏä§ v7.9 (Î©îÏãúÏßÄ Í∞úÏÑ†)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        * { box-sizing: border-box; touch-action: none; }

        body {
            margin: 0; padding: 0;
            background-color: #0f0f0f;
            display: flex; align-items: center; justify-content: center;
            height: 100vh;
            color: white; font-family: 'Jua', sans-serif;
            overflow: hidden; user-select: none;
        }

        #game-wrapper {
            position: relative; width: 100%; height: 100%;
            max-width: 600px;
            background-color: #4CAF50;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.9);
        }

        /* --- ÏÉÅÎã® UI --- */
        #top-ui {
            flex: 0 0 145px;
            background: rgba(0,0,0,0.85);
            padding: 5px 15px; z-index: 10;
            display: flex; flex-direction: column; justify-content: center;
            border-bottom: 2px solid #333;
        }

        .utility-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        
        .timer-box {
            font-size: 1.1rem; color: #FFF; 
            background: #333; padding: 4px 10px; border-radius: 8px;
            border: 1px solid #777; display: flex; align-items: center; gap: 5px; width: 110px; justify-content: center;
        }
        .timer-box.urgent { color: #FF5252; border-color: #FF5252; animation: blink 1s infinite; }
        .timer-box.prep { color: #00E676; border-color: #00E676; }

        .util-right { display: flex; gap: 5px; }
        .util-btn {
            background: #424242; border: 1px solid #757575; color: white;
            padding: 6px 12px; border-radius: 12px; font-family: 'Jua'; cursor: pointer;
            font-size: 0.9rem; transition: background 0.2s; min-width: 40px;
        }
        .util-btn.active { background: #FFC107; color: black; border-color: #FF6F00; }
        .util-btn.active-x3 { background: #FF5252; color: white; border-color: #D50000; }
        .util-btn.paused { background: #2196F3; border-color: #64B5F6; }

        /* Ïä§ÌÇµ Î≤ÑÌäº */
        .btn-skip {
            background: linear-gradient(to bottom, #29B6F6, #0288D1);
            border: 2px solid #B3E5FC; color: white;
            padding: 5px 15px; border-radius: 20px;
            font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            animation: pulse-blue 2s infinite;
        }
        .btn-skip.prep-mode {
            background: linear-gradient(to bottom, #66BB6A, #2E7D32);
            border-color: #A5D6A7;
            animation: none;
        }
        .btn-skip:active { transform: scale(0.95); }

        .top-info-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 4px; }
        .info-group { text-align: center; }
        .info-label { font-size: 11px; color: #bbb; }
        .info-value { font-size: 1.2rem; color: #FFD700; text-shadow: 1px 1px 2px #000; }
        
        .mythic-stone {
            display: flex; align-items: center; gap: 5px;
            background: rgba(100, 0, 255, 0.2); padding: 2px 8px; border-radius: 12px; border: 1px solid #7C4DFF;
            font-size: 0.9rem; color: #E040FB;
        }

        .class-upgrade-bar { display: flex; gap: 5px; justify-content: space-between; margin-top: 4px; }
        .class-btn {
            flex: 1; border: 1px solid #555; border-radius: 8px;
            background: rgba(255,255,255,0.1); color: #ddd;
            font-family: 'Jua'; cursor: pointer; padding: 4px 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.8rem; transition: background 0.1s;
        }
        .class-btn:active { transform: scale(0.95); }
        .cb-phy { border-color: #EF5350; }
        .cb-mag { border-color: #AB47BC; }
        .cb-sup { border-color: #26A69A; }

        #canvas-container { flex: 1; position: relative; width: 100%; overflow: hidden; background-color: #66BB6A; }
        canvas { display: block; width: 100%; height: 100%; }

        /* ÏùºÏãúÏ†ïÏßÄ Ïò§Î≤ÑÎ†àÏù¥ */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); pointer-events: none; display: none;
            justify-content: center; align-items: center; font-size: 3rem; 
            color: white; font-weight: bold; text-shadow: 0 0 10px black; z-index: 50;
        }

        /* --- ÌïòÎã® UI --- */
        #bottom-ui {
            flex: 0 0 160px;
            background-color: #3E2723;
            padding: 10px;
            display: flex; flex-direction: column; justify-content: space-between;
            border-top: 4px solid #281A16; z-index: 10;
        }

        #resources { display: flex; justify-content: space-between; padding: 0 5px; margin-bottom: 5px; font-size: 1.1rem; color: #FFD700; }
        #buttons { display: flex; justify-content: space-between; align-items: flex-end; height: 100%; gap: 6px; }

        .game-btn {
            border: none; border-radius: 14px; color: white;
            font-family: 'Jua', sans-serif; cursor: pointer;
            position: relative; box-shadow: 0 5px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s; padding: 0; overflow: hidden;
        }
        .game-btn:active { transform: translateY(5px); box-shadow: none; }

        .btn-upgrade { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #673AB7, #512DA8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #9575CD; }
        .btn-summon { flex: 1; height: 100%; max-height: 95px; background: linear-gradient(135deg, #FFC107, #FF8F00); font-size: 1.6rem; color: #3E2723; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 1px solid #FFE082; }
        .btn-combine { width: 22%; height: 100%; max-height: 80px; background: linear-gradient(135deg, #009688, #00695C); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.9rem; border: 1px solid #4DB6AC; }
        .btn-gamble { width: 18%; height: 100%; max-height: 70px; background: linear-gradient(135deg, #2196F3, #1565C0); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 0.8rem; border: 1px solid #64B5F6; margin-bottom: 5px;}

        @keyframes pulse-blue { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(41, 182, 246, 0.7); } 70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(41, 182, 246, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(41, 182, 246, 0); } }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* Î™®Îã¨ & Ìà¥ÌåÅ */
        #combine-modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; height: 85%; background: rgba(30, 30, 30, 0.98); border: 2px solid #FFD700; border-radius: 15px; z-index: 100; flex-direction: column; padding: 15px; color: white; box-shadow: 0 0 50px rgba(0,0,0,0.9); }
        #combine-modal.open { display: flex; }
        .modal-header { font-size: 1.4rem; text-align: center; margin-bottom: 10px; color: #FFD700; }
        .recipe-list { overflow-y: auto; flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .recipe-card { background: rgba(255, 255, 255, 0.08); padding: 8px; border-radius: 6px; display: flex; flex-direction: column; gap: 3px; border: 1px solid #555; position: relative; }
        .recipe-name { font-size: 1rem; font-weight: bold; color: #E040FB; display: flex; justify-content: space-between;}
        .recipe-desc { font-size: 0.75rem; color: #bbb; margin-bottom: 5px; height: 30px; overflow: hidden; }
        .recipe-req { display: flex; gap: 5px; font-size: 0.75rem; color: #ddd; align-items: center; flex-wrap: wrap; }
        .btn-buy-recipe { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #6200EA; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine { width: 100%; padding: 5px; margin-top: 5px; border: none; border-radius: 4px; background: #00C853; color: white; font-family: 'Jua'; cursor: pointer; font-size: 0.9rem;}
        .btn-do-combine:disabled { background: #444; color: #888; cursor: not-allowed; }
        .btn-close { margin-top: 10px; padding: 10px; background: #D32F2F; color: white; border: none; border-radius: 8px; font-family: 'Jua'; cursor: pointer; }

        /* Î©îÏãúÏßÄ ÏòÅÏó≠ ÏàòÏ†ï: Ï§ëÏ≤© Í∞ÄÎä•ÌïòÎèÑÎ°ù */
        #message-area { 
            position: absolute; 
            top: 25%; 
            left: 50%; 
            transform: translateX(-50%); 
            pointer-events: none; 
            display: flex; 
            flex-direction: column-reverse; /* ÏµúÏã† Î©îÏãúÏßÄÍ∞Ä ÏïÑÎûòÏóê ÏåìÏù¥Í±∞ÎÇò ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÍ≤å Ï°∞Ï†ï */
            align-items: center;
            width: 100%; 
            height: 0;
            overflow: visible;
            z-index: 999; 
        }
        
        .pop-text { 
            font-size: 2rem; 
            font-weight: bold; 
            color: #fff; 
            text-shadow: 2px 2px 0 #000, 0 0 10px gold; 
            opacity: 0; 
            margin-bottom: 5px;
            animation: popupFloat 1.5s forwards; 
            flex-shrink: 0;
            white-space: nowrap;
        }

        @keyframes popupFloat {
            0% { opacity: 0; transform: translateY(20px) scale(0.8); }
            10% { opacity: 1; transform: translateY(0) scale(1.1); }
            20% { transform: translateY(0) scale(1); }
            80% { opacity: 1; transform: translateY(-30px); }
            100% { opacity: 0; transform: translateY(-60px); }
        }
        
        .tooltip { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); background: rgba(20,20,20,0.95); padding: 15px; border-radius: 8px; font-size: 0.95rem; display: none; width: 90%; text-align: center; z-index: 200; border: 2px solid #FFD700; pointer-events: none; white-space: pre-line; box-shadow: 0 5px 20px rgba(0,0,0,0.8); }
        .luck-tooltip { position: absolute; bottom: 100px; left: 10px; background: rgba(0,0,0,0.95); padding: 12px; border-radius: 8px; border: 1px solid #7E57C2; color: white; font-size: 0.85rem; z-index: 200; display: none; pointer-events: none; text-align: left; line-height: 1.6; }

        .c-rare { color: #42A5F5; } .c-hero { color: #BA68C8; } .c-legend { color: #FF9800; } .c-myth { color: #FF5252; } .c-immortal { color: #E040FB; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="top-ui">
            <div class="utility-bar">
                <div id="timer-box" class="timer-box">
                    <span id="timer-icon">‚è≥</span> <span id="wave-timer">40</span>s
                </div>
                <button id="btn-skip" class="btn-skip" onclick="skipWave()">
                    <span id="skip-text">‚è© Ïä§ÌÇµ</span>
                    <span id="skip-reward-box" style="font-size:0.8em;">(+<span id="skip-reward">0</span>G)</span>
                </button>
                <div class="util-right">
                    <button id="btn-pause" class="util-btn" onclick="togglePause()">‚è∏Ô∏è</button>
                    <button id="btn-auto-merge" class="util-btn" onclick="toggleAutoMerge()">ü§ñ Auto Off</button>
                    <button id="btn-speed" class="util-btn" onclick="toggleSpeed()">‚è© x1</button>
                </div>
            </div>

            <div class="top-info-row">
                <div class="info-group">
                    <div class="info-label">WAVE</div>
                    <div class="info-value" id="wave-display">1</div>
                </div>
                <div class="mythic-stone">
                    üíé <span id="stone-display">0</span>
                </div>
                <div class="info-group">
                    <div class="info-label">Ïù∏Íµ¨Ïàò (ÏµúÎåÄ 200)</div>
                    <div class="info-value" style="color:#FF5252"><span id="enemy-count">0</span> / 200</div>
                </div>
            </div>
            
            <div class="class-upgrade-bar">
                <button class="class-btn cb-phy" onclick="upgradeClass('phy')">
                    ‚öîÔ∏è Î¨ºÎ¶¨ Lv.<span id="lv-phy">1</span>
                    <span id="cost-phy" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
                <button class="class-btn cb-mag" onclick="upgradeClass('mag')">
                    üîÆ ÎßàÎ≤ï Lv.<span id="lv-mag">1</span>
                    <span id="cost-mag" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
                <button class="class-btn cb-sup" onclick="upgradeClass('sup')">
                    ‚öóÔ∏è Î≥¥Ï°∞ Lv.<span id="lv-sup">1</span>
                    <span id="cost-sup" style="font-size:0.7rem; color:#FFEB3B">100G</span>
                </button>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="pause-overlay">PAUSED</div>
            <!-- Î©îÏãúÏßÄÍ∞Ä ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê† ÏòÅÏó≠ -->
            <div id="message-area"></div>
            <div id="unit-tooltip" class="tooltip"></div>
            <div id="luck-tooltip" class="luck-tooltip"></div>
        </div>

        <div id="bottom-ui">
            <div id="resources">
                <span style="color:#ccc;">ÌñâÏö¥ Lv.<span id="summon-level">1</span></span>
                <span>üí∞ <span id="gold-display">200</span></span>
            </div>
            <div id="buttons">
                <button class="game-btn btn-upgrade" onclick="upgradeSummon()" 
                    onmousedown="showLuckInfo()" onmouseup="hideLuckInfo()"
                    ontouchstart="showLuckInfo()" ontouchend="hideLuckInfo()">
                    ‚òòÔ∏èÍ∞ïÌôî
                    <span style="font-size:0.75em; color:#FFEB3B; margin-top:2px;" id="upgrade-cost">50G</span>
                </button>
                
                <button class="game-btn btn-summon" onclick="summonUnit()">
                    üé≤ ÏÜåÌôò
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;" id="summon-cost-display">10 G</span>
                </button>
                
                <button class="game-btn btn-combine" onclick="openCombineModal()">
                    üè∞ Ï°∞Ìï©
                    <span style="font-size:0.65em; margin-top:5px; opacity:0.8;">New!</span>
                </button>

                <button class="game-btn btn-gamble" onclick="gamble()">
                    üé∞ÎèÑÎ∞ï<br><span id="gamble-cost-display">50G</span>
                </button>
            </div>
        </div>

        <div id="combine-modal">
            <div class="modal-header">üè∞ ÌûàÎì† ÏòÅÏõÖ Ï°∞Ìï©ÏÜå</div>
            <div class="recipe-list" id="recipe-list">
            </div>
            <button class="btn-close" onclick="closeCombineModal()">Îã´Í∏∞</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        const GRID_COLS = 6; const GRID_ROWS = 5;
        let TILE_SIZE = 0, GRID_OFFSET_X = 0, GRID_OFFSET_Y = 0;
        let PATH_POINTS = [];
        let TRASH_ZONE = { x: 0, y: 0, r: 0 };

        const UNIT_DATA = {
            'ÏïºÎßåÏù∏': { color: '#BCAAA4', icon: 'ü™ì', desc: '10% ÌôïÎ•†Î°ú Í∏∞Ï†à (Îì±Í∏â‚Üë)', type: 'phy' },
            'Í∂ÅÏàò': { color: '#81D4FA', icon: 'üèπ', desc: 'ÏπòÎ™ÖÌÉÄ 2.5Î∞∞ (Îì±Í∏â‚Üë)', type: 'phy' },
            'ÏñºÏùåÎ≤ïÏÇ¨': { color: '#90CAF9', icon: 'üßä', desc: 'Í≥µÍ≤© Ïãú Ïä¨Î°úÏö∞ 40% (Îì±Í∏â‚Üë)', type: 'mag' },
            'ÏÇ∞Ï†Å': { color: '#A1887F', icon: 'üí∞', desc: '5% ÌôïÎ•†Î°ú 10Í≥®Îìú (Îì±Í∏â‚Üë)', type: 'sup' },
            'Ï†ÑÍ∏∞Î°úÎ¥á': { color: '#FFF59D', icon: '‚ö°', desc: '3Ïù∏ ÎèôÏãú Í≥µÍ≤© (Îì±Í∏â‚Üë)', type: 'mag' },
            'ÎãåÏûê': { color: '#424242', icon: 'ü•∑', desc: 'Ï≤¥Î†• 30%Ïù¥Ìïò 3Î∞∞ ÌîºÌï¥ (Îì±Í∏â‚Üë)', type: 'phy' }
        };
        const UNIT_TYPES = Object.keys(UNIT_DATA);
        
        const HIDDEN_DATA = {
            'Í∞úÍµ¨Î¶¨ÏôïÏûê': { color: '#69F0AE', icon: 'üê∏', desc: 'Ï¥àÍ≥†ÏÜç Í≥µÏÜç (5Î∞∞)', type: 'phy' },
            'ÎßàÏã†': { color: '#D50000', icon: 'üëø', desc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Í¥ëÏó≠ ÌîºÌï¥', type: 'mag' },
            'ÎìúÎûòÍ≥§': { color: '#FFAB00', icon: 'üê≤', desc: 'Í∞ïÎ†•Ìïú ÌïúÎ∞© & Ïä§ÌÑ¥ (Îì±Í∏â‚Üë)', type: 'phy' },
            'ÏÑ±Í∏∞ÏÇ¨': { color: '#FFD54F', icon: 'üõ°Ô∏è', desc: 'Î≤îÏúÑ Ïä§ÌÑ¥ & ÎÜíÏùÄ Íπ°Îîú', type: 'phy' },
            'Ï†ÄÍ≤©Ïàò': { color: '#81C784', icon: 'üî´', desc: 'ÏÇ¨Í±∞Î¶¨ Î¨¥Ìïú & Îã®Ïùº Í∑πÎîú', type: 'phy' },
            'ÎåÄÎßàÎ≤ïÏÇ¨': { color: '#7E57C2', icon: 'üßô‚Äç‚ôÇÔ∏è', desc: 'Í¥ëÏó≠ Ïä¨Î°úÏö∞ & ÏßÄÏÜçÎîú', type: 'mag' },
            'Ïó∞Í∏àÏà†ÏÇ¨': { color: '#F4511E', icon: '‚öóÔ∏è', desc: 'Í≥®Îìú Î≥µÏÇ¨ ÌôïÎ•† Ï¶ùÍ∞Ä (Îì±Í∏â‚Üë)', type: 'sup' },
            'Í∞ïÎ†πÏà†ÏÇ¨': { color: '#4A148C', icon: 'üíÄ', desc: 'Î∂ÄÏãù Îç∞ÎØ∏ÏßÄ Î∂ÄÏó¨', type: 'mag' },
            'Î¨¥ÏÇ¨': { color: '#E0E0E0', icon: '‚öîÔ∏è', desc: '50% ÌôïÎ•†Î°ú ÏπòÎ™ÖÌÉÄ', type: 'phy' },
            'Ï†úÏö∞Ïä§': { color: '#FFFF00', icon: 'üå©Ô∏è', desc: '5Î™Ö Ïó∞ÏáÑ Î≤àÍ∞ú Í≥µÍ≤©', type: 'mag' },
            'Í≥®Î†ò': { color: '#795548', icon: 'üóø', desc: 'Í¥ëÏó≠ Ïä§ÌîåÎûòÏãú Í≥µÍ≤©', type: 'phy' },
            'Î±ÄÌååÏù¥Ïñ¥': { color: '#B71C1C', icon: 'üßõ', desc: 'Í≥µÏÜç Îπ†Î¶Ñ & Ï†Å Ï≤òÏπòÏãú Í≥µÏÜçÎ≤ÑÌîÑ', type: 'mag' },
            'Í≥µÌïôÏûê': { color: '#607D8B', icon: 'üîß', desc: 'Ï£ºÎ≥Ä ÏïÑÍµ∞ Í≥µÏÜç +20%', type: 'sup' },
            'ÎèÑÎ∞ïÏÇ¨': { color: '#3F51B5', icon: 'üÉè', desc: 'ÎûúÎç§ Îç∞ÎØ∏ÏßÄ (1~10Î∞∞)', type: 'sup' },
            'Î©îÎëêÏÇ¨': { color: '#004D40', icon: 'üêç', desc: '3Ï¥àÍ∞Ñ Ï†Å ÏÑùÌôî(Ï†ïÏßÄ)', type: 'mag' },
            'ÌîºÎãâÏä§': { color: '#FF5722', icon: 'ü¶Ö', desc: 'ÎùºÏù∏ Ï†ÑÏ≤¥ ÌôîÏÉÅ Í≥µÍ≤©', type: 'mag' }
        };

        const TIERS = ['ÏùºÎ∞ò', 'Ìù¨Í∑Ä', 'ÏòÅÏõÖ', 'Ï†ÑÏÑ§', 'Ïã†Ìôî', 'Î∂àÎ©∏'];
        const TIER_COLORS = ['#B0BEC5', '#29B6F6', '#AB47BC', '#FF7043', '#FF1744', '#D500F9'];

        const RECIPES = [
            { id: 'frog', name: 'Í∞úÍµ¨Î¶¨ÏôïÏûê', cost: 3, result: 'Í∞úÍµ¨Î¶¨ÏôïÏûê', req: [{type:'ÏïºÎßåÏù∏',tier:3}, {type:'Í∂ÅÏàò',tier:3}] },
            { id: 'demon', name: 'ÎßàÏã†', cost: 5, result: 'ÎßàÏã†', req: [{type:'ÎãåÏûê',tier:3}, {type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}] },
            { id: 'dragon', name: 'ÎìúÎûòÍ≥§', cost: 5, result: 'ÎìúÎûòÍ≥§', req: [{type:'ÏñºÏùåÎ≤ïÏÇ¨',tier:3}, {type:'ÏïºÎßåÏù∏',tier:3}] },
            { id: 'pala', name: 'ÏÑ±Í∏∞ÏÇ¨', cost: 3, result: 'ÏÑ±Í∏∞ÏÇ¨', req: [{type:'ÏïºÎßåÏù∏',tier:3}, {type:'ÏÇ∞Ï†Å',tier:3}] },
            { id: 'sniper', name: 'Ï†ÄÍ≤©Ïàò', cost: 3, result: 'Ï†ÄÍ≤©Ïàò', req: [{type:'Í∂ÅÏàò',tier:3}, {type:'ÎãåÏûê',tier:3}] },
            { id: 'arch', name: 'ÎåÄÎßàÎ≤ïÏÇ¨', cost: 3, result: 'ÎåÄÎßàÎ≤ïÏÇ¨', req: [{type:'ÏñºÏùåÎ≤ïÏÇ¨',tier:3}, {type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}] },
            { id: 'alch', name: 'Ïó∞Í∏àÏà†ÏÇ¨', cost: 3, result: 'Ïó∞Í∏àÏà†ÏÇ¨', req: [{type:'ÏÇ∞Ï†Å',tier:3}, {type:'ÏñºÏùåÎ≤ïÏÇ¨',tier:3}] },
            { id: 'necro', name: 'Í∞ïÎ†πÏà†ÏÇ¨', cost: 3, result: 'Í∞ïÎ†πÏà†ÏÇ¨', req: [{type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}, {type:'ÎãåÏûê',tier:3}] },
            { id: 'samu', name: 'Î¨¥ÏÇ¨', cost: 3, result: 'Î¨¥ÏÇ¨', req: [{type:'ÎãåÏûê',tier:3}, {type:'ÏïºÎßåÏù∏',tier:3}] },
            { id: 'zeus', name: 'Ï†úÏö∞Ïä§', cost: 4, result: 'Ï†úÏö∞Ïä§', req: [{type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}, {type:'ÏÇ∞Ï†Å',tier:3}] },
            { id: 'golem', name: 'Í≥®Î†ò', cost: 3, result: 'Í≥®Î†ò', req: [{type:'ÏïºÎßåÏù∏',tier:3}, {type:'ÏñºÏùåÎ≤ïÏÇ¨',tier:3}] },
            { id: 'vamp', name: 'Î±ÄÌååÏù¥Ïñ¥', cost: 3, result: 'Î±ÄÌååÏù¥Ïñ¥', req: [{type:'ÎãåÏûê',tier:3}, {type:'Í∂ÅÏàò',tier:3}] },
            { id: 'engi', name: 'Í≥µÌïôÏûê', cost: 4, result: 'Í≥µÌïôÏûê', req: [{type:'ÏÇ∞Ï†Å',tier:3}, {type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}] },
            { id: 'gamb', name: 'ÎèÑÎ∞ïÏÇ¨', cost: 3, result: 'ÎèÑÎ∞ïÏÇ¨', req: [{type:'ÏÇ∞Ï†Å',tier:3}, {type:'Í∂ÅÏàò',tier:3}] },
            { id: 'medu', name: 'Î©îÎëêÏÇ¨', cost: 4, result: 'Î©îÎëêÏÇ¨', req: [{type:'ÏñºÏùåÎ≤ïÏÇ¨',tier:3}, {type:'Í∂ÅÏàò',tier:3}] },
            { id: 'phoe', name: 'ÌîºÎãâÏä§', cost: 5, result: 'ÌîºÎãâÏä§', req: [{type:'Ï†ÑÍ∏∞Î°úÎ¥á',tier:3}, {type:'ÏïºÎßåÏù∏',tier:3}] }
        ];
        RECIPES.forEach(r => r.unlocked = false);

        const SUMMON_RATES = [];
        for(let i=1; i<=20; i++) {
            let rate = {}; let cost = 0;
            let baseR = 1 + (i*1.5); 
            let baseE = 0.1 + (i*0.5); 
            let baseL = 0.05 + (i*0.25); 
            let baseM = 0.01 + (i*0.1); 

            if(i <= 5) { baseR = (i-1)*10 + 1; }
            else if(i <= 10) { baseR = 40 + (i-5)*2; baseE = (i-5)*3 + 1; }
            else if(i <= 15) { baseR = 50; baseE = 20 + (i-10)*2; baseL = (i-10)*2 + 1; }
            else { baseE = 30 + (i-15); baseL = 10 + (i-15)*3; baseM = (i-15)*0.5 + 0.1; }

            rate = { r: Math.min(baseR, 90), e: Math.min(baseE, 50), l: Math.min(baseL, 20), m: Math.min(baseM, 5) };
            let totalSpecial = rate.r + rate.e + rate.l + rate.m;
            if(totalSpecial > 99) {
                let factor = 99 / totalSpecial;
                rate.r *= factor; rate.e *= factor; rate.l *= factor; rate.m *= factor;
                totalSpecial = 99;
            }
            rate.c = 100 - totalSpecial;

            if(i <= 5) cost = 50 * i;
            else if(i <= 10) cost = 150 * (i-3);
            else if(i <= 15) cost = 1000 + (i-10)*500;
            else cost = 3000 + (i-15)*1500;
            if(i===20) cost = 'MAX';
            
            rate.c = parseFloat(rate.c.toFixed(2));
            rate.r = parseFloat(rate.r.toFixed(2));
            rate.e = parseFloat(rate.e.toFixed(2));
            rate.l = parseFloat(rate.l.toFixed(2));
            rate.m = parseFloat(rate.m.toFixed(2));
            SUMMON_RATES.push({ ...rate, cost: cost });
        }

        const BASE_SUMMON_COST = 10;
        const BASE_GAMBLE_COST = 50;
        const WAVE_DURATION = 40; 
        const MAX_ENEMIES_LIMIT = 200; 

        let gold = 200;
        let stones = 0; 
        let wave = 0; // 0Î∂ÄÌÑ∞ ÏãúÏûëÌïòÏó¨ startNextWave()Ìò∏Ï∂úÏãú 1Ïù¥ Îê®
        let units = [];
        let enemies = [];
        let projectiles = [];
        let effects = []; 
        let summonLevel = 1;
        let classLv = { phy: 1, mag: 1, sup: 1 };
        
        let lastTime = 0;
        let enemySpawnTimer = 0;
        let enemiesToSpawn = 0;
        let waveTimer = 0;
        let isPrep = false; // Ï§ÄÎπÑ ÏãúÍ∞Ñ Ïó¨Î∂Ä
        
        let draggingUnit = null;
        let frameCount = 0;

        let timeScale = 1;
        let isAutoMerge = false;
        let autoMergeTimer = 0;
        let isPaused = false;
        
        let shakeAmount = 0; // ÌôîÎ©¥ ÌùîÎì§Î¶º Í∞ïÎèÑ

        const SAVE_KEY = 'lucky_defense_solo_v4';

        function saveGame() {
            const data = {
                stones: stones,
                unlockedRecipes: RECIPES.filter(r => r.unlocked).map(r => r.id)
            };
            localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        }

        function loadGame() {
            const json = localStorage.getItem(SAVE_KEY);
            if (json) {
                try {
                    const data = JSON.parse(json);
                    if(data.stones !== undefined) stones = data.stones;
                    if(data.unlockedRecipes && Array.isArray(data.unlockedRecipes)) {
                        data.unlockedRecipes.forEach(id => {
                            const r = RECIPES.find(recipe => recipe.id === id);
                            if(r) r.unlocked = true;
                        });
                    }
                } catch(e) {}
            }
        }

        function getSummonCost() { return BASE_SUMMON_COST + Math.max(0, Math.floor((wave - 1) * 0.5)); }
        function getGambleCost() { return BASE_GAMBLE_COST + Math.max(0, (wave - 1)); }

        function resizeGame() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            
            // ÌôîÎ©¥ ÏûòÎ¶º Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ïó¨Î∞± Í≥ÑÏàò Ï¶ùÍ∞Ä (1.2 -> 2.5, 2.5 -> 4.0)
            const maxTileW = canvas.width / (GRID_COLS + 2.5);
            const maxTileH = canvas.height / (GRID_ROWS + 4.0);
            
            TILE_SIZE = Math.floor(Math.min(maxTileW, maxTileH));
            GRID_OFFSET_X = (canvas.width - GRID_COLS * TILE_SIZE) / 2;
            GRID_OFFSET_Y = (canvas.height - GRID_ROWS * TILE_SIZE) / 2;

            const margin = TILE_SIZE * 0.7; 
            
            PATH_POINTS = [
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y - margin }, 
                { x: GRID_OFFSET_X + GRID_COLS * TILE_SIZE + margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin }, 
                { x: GRID_OFFSET_X - margin, y: GRID_OFFSET_Y + GRID_ROWS * TILE_SIZE + margin } 
            ];

            TRASH_ZONE = { x: canvas.width - TILE_SIZE * 0.9, y: canvas.height - TILE_SIZE * 0.9, r: TILE_SIZE * 0.6 };
            units.forEach(u => { u.x = GRID_OFFSET_X + u.col * TILE_SIZE; u.y = GRID_OFFSET_Y + u.row * TILE_SIZE; });
        }

        function init() {
            loadGame();
            window.addEventListener('resize', resizeGame);
            resizeGame();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('touchstart', (e) => { if(e.touches.length>1) return; e.preventDefault(); onMouseDown({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onMouseMove({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); }, {passive: false});
            canvas.addEventListener('touchend', (e) => { onMouseUp({clientX: e.changedTouches?e.changedTouches[0].clientX : 0, clientY: e.changedTouches?e.changedTouches[0].clientY : 0}); });
            
            startNextWave(); // 1Ïõ®Ïù¥Î∏å Ï§ÄÎπÑ ÏãúÏûë
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if(!isPaused) {
                frameCount++;
                update(deltaTime); 
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            const scaledDelta = deltaTime * timeScale; 

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Í∞êÏá†
            if (shakeAmount > 0) {
                shakeAmount -= (scaledDelta / 1000) * 20; // 1Ï¥àÏóê 20 Í∞êÏÜå
                if (shakeAmount < 0) shakeAmount = 0;
            }

            if (waveTimer > 0) {
                waveTimer -= scaledDelta / 1000;
                if (waveTimer <= 0) {
                    waveTimer = 0;
                    if(isPrep) {
                        startBattle(); // Ï§ÄÎπÑ ÏãúÍ∞Ñ Ï¢ÖÎ£å -> Ï†ÑÌà¨ ÏãúÏûë
                    } else {
                        startNextWave(); // Ï†ÑÌà¨ ÏãúÍ∞Ñ Ï¢ÖÎ£å -> Îã§Ïùå Ïõ®Ïù¥Î∏å Ï§ÄÎπÑ
                    }
                }
            }

            // Ï†ÑÌà¨ Ï§ëÏóêÎßå Ï†Å Ïä§Ìè∞
            if (!isPrep && enemiesToSpawn > 0) {
                let spawnInterval = Math.max(150, 700 - (wave * 20)); 
                enemySpawnTimer += scaledDelta;
                if (enemySpawnTimer > spawnInterval) { spawnEnemy(); enemySpawnTimer = 0; enemiesToSpawn--; }
            }

            if(isAutoMerge) {
                autoMergeTimer += deltaTime; 
                if(autoMergeTimer > 500) {
                    performAutoMerge();
                    autoMergeTimer = 0;
                }
            }

            for(let i=effects.length-1; i>=0; i--) {
                let fx = effects[i];
                fx.life -= deltaTime;
                if(fx.type === 'text') {
                    fx.y -= (0.05 * deltaTime);
                } else if(fx.type === 'particle') {
                    fx.x += fx.vx * (deltaTime/16);
                    fx.y += fx.vy * (deltaTime/16);
                }
                if(fx.life <= 0) effects.splice(i, 1);
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.stunTimer > 0) enemy.stunTimer -= scaledDelta;
                if (enemy.slowTimer > 0) enemy.slowTimer -= scaledDelta;
                if (enemy.dotTimer > 0) {
                    enemy.dotTimer -= scaledDelta;
                    enemy.hp -= (enemy.maxHp * 0.001);
                }
                
                moveEnemy(enemy, scaledDelta);
                
                if (enemy.hp <= 0) { 
                    gold += (2 + Math.floor(wave * 0.2)); 
                    
                    // ÏÇ¨Îßù Ïù¥ÌéôÌä∏
                    let pColor = '#CFD8DC';
                    if(enemy.type === 'fast') pColor = '#FFF176';
                    else if(enemy.type === 'tank') pColor = '#8D6E63';
                    else if(enemy.type === 'boss') pColor = '#E91E63';
                    
                    createExplosion(enemy.x, enemy.y, pColor, enemy.type === 'boss' ? 30 : 8);
                    
                    if(enemy.type === 'boss') {
                        addShake(10); // Î≥¥Ïä§ ÏÇ¨ÎßùÏãú ÌôîÎ©¥ ÌùîÎì§Î¶º
                        spawnFloatingText(enemy.x, enemy.y, "BOSS KILL!", "#FF1744");
                    }

                    enemies.splice(i, 1); 
                    updateUI(); 
                }
            }

            if (enemies.length > MAX_ENEMIES_LIMIT) {
                alert(`Í≤åÏûÑ Ïò§Î≤Ñ! Ï†ÅÏù¥ ÎÑàÎ¨¥ ÎßéÏäµÎãàÎã§ (${enemies.length}).\n${wave} Ïõ®Ïù¥Î∏å Í∏∞Î°ù.`);
                resetGame();
                return;
            }

            units.forEach(unit => {
                if (unit === draggingUnit) return;
                unit.cooldown -= scaledDelta;
                if (unit.cooldown <= 0) {
                    if(unit.type === 'Ï†ÑÍ∏∞Î°úÎ¥á' || unit.type === 'Ï†úÏö∞Ïä§') {
                        let cnt = unit.type==='Ï†úÏö∞Ïä§' ? 5 : 3;
                        const targets = findTargets(unit, cnt);
                        if(targets.length > 0) { targets.forEach(t => fireProjectile(unit, t)); resetCooldown(unit); }
                    } else if(unit.type === 'ÎßàÏã†' || unit.type === 'ÌîºÎãâÏä§') {
                        fireGlobalAttack(unit);
                        resetCooldown(unit);
                    } else if(unit.type === 'Í≥µÌïôÏûê') {
                         const target = findTarget(unit);
                         if(target) { fireProjectile(unit, target); resetCooldown(unit); }
                    } else {
                        const target = findTarget(unit);
                        if (target) { fireProjectile(unit, target); resetCooldown(unit); }
                    }
                }
            });

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                moveProjectile(p, scaledDelta);
                if (p.hit) {
                    // ÌÉÄÍ≤© Ïù¥ÌéôÌä∏ (ÌûàÌä∏ Ïãú ÏûëÏùÄ Ïä§ÌååÌÅ¨)
                    createExplosion(p.x, p.y, p.color, 3);
                    projectiles.splice(i, 1);
                }
            }
            
            updateUI(); 
        }

        // --- Ïù¥ÌéôÌä∏ Í¥ÄÎ†® Ìï®Ïàò ---
        function addShake(amount) {
            shakeAmount = amount;
        }

        function createExplosion(x, y, color, count) {
            for(let i=0; i<count; i++) {
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * 3 + 1;
                effects.push({
                    type: 'particle',
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    life: 400 + Math.random() * 200,
                    size: Math.random() * 3 + 2
                });
            }
        }

        function createSparkle(x, y, color) {
            // ÏúÑÎ°ú Ïò¨ÎùºÍ∞ÄÎäî Î∞òÏßùÏù¥ Ìö®Í≥º
            for(let i=0; i<10; i++) {
                effects.push({
                    type: 'particle',
                    x: x + (Math.random() - 0.5) * TILE_SIZE,
                    y: y + (Math.random() - 0.5) * TILE_SIZE,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 1,
                    color: color,
                    life: 600 + Math.random() * 300,
                    size: Math.random() * 2 + 1
                });
            }
        }
        // -------------------------

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none';
            document.getElementById('btn-pause').classList.toggle('paused', isPaused);
            document.getElementById('btn-pause').innerText = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        }

        function toggleSpeed() {
            if(timeScale === 1) timeScale = 2;
            else if(timeScale === 2) timeScale = 3;
            else timeScale = 1;
            
            const btn = document.getElementById('btn-speed');
            btn.innerText = `‚è© x${timeScale}`;
            btn.className = `util-btn ${timeScale >= 2 ? 'active' : ''} ${timeScale === 3 ? 'active-x3' : ''}`;
        }

        function toggleAutoMerge() {
            isAutoMerge = !isAutoMerge;
            const btn = document.getElementById('btn-auto-merge');
            btn.innerText = isAutoMerge ? 'ü§ñ On' : 'ü§ñ Off';
            btn.classList.toggle('active', isAutoMerge);
        }

        function performAutoMerge() {
            for(let i=0; i<units.length; i++) {
                let u1 = units[i];
                if(u1 === draggingUnit) continue;
                if(u1.tier >= 5) continue; 

                for(let j=i+1; j<units.length; j++) {
                    let u2 = units[j];
                    if(u2 === draggingUnit) continue;

                    if(u1.type === u2.type && u1.tier === u2.tier) {
                        processMerge(u1, u2);
                        return; 
                    }
                }
            }
        }

        function processMerge(u1, u2) {
            let newTier = u1.tier + 1;
            let newType = u1.type;
            let c = u2.col; let r = u2.row; 

            units = units.filter(u => u !== u1 && u !== u2);
            createUnit(c, r, newType, newTier);
            
            // Ìï©ÏÑ± Ïù¥ÌéôÌä∏
            createSparkle(GRID_OFFSET_X + c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + r*TILE_SIZE + TILE_SIZE/2, TIER_COLORS[newTier]);
            
            if(newTier === 5) showPopup(`üî•Î∂àÎ©∏ [${newType}] Í∞ïÎ¶º!üî•`);
            else if(!isAutoMerge) showPopup(`Ìï©ÏÑ±! [${TIERS[newTier]}] ÏÑ±Í≥µ ‚ú®`); 
        }

        function spawnFloatingText(x, y, text, color='#FFD700') {
            effects.push({ type: 'text', x: x, y: y, text: text, color: color, life: 800 });
        }

        function resetCooldown(unit) {
            let baseSpeed = 1000 / (1 + unit.tier * 0.25);
            let classSpdMult = 1 + (classLv.sup - 1) * 0.05;

            if(unit.type === 'Í∞úÍµ¨Î¶¨ÏôïÏûê') baseSpeed = 200;
            if(unit.type === 'Î±ÄÌååÏù¥Ïñ¥') baseSpeed = 400;
            if(unit.type === 'ÎßàÏã†') baseSpeed = 1500;
            if(unit.type === 'Ï†ÄÍ≤©Ïàò') baseSpeed = 2000;

            unit.cooldown = baseSpeed / classSpdMult;
        }

        function draw() {
            ctx.save(); // ÌôîÎ©¥ ÌùîÎì§Î¶º Ï†ÅÏö© Ï†Ñ ÏÉÅÌÉú Ï†ÄÏû•

            // ÌôîÎ©¥ ÌùîÎì§Î¶º Ï†ÅÏö©
            if (shakeAmount > 0) {
                let dx = (Math.random() - 0.5) * shakeAmount;
                let dy = (Math.random() - 0.5) * shakeAmount;
                ctx.translate(dx, dy);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height); // ÌùîÎì§Î¶º Í≥†Î†§ÌïòÏó¨ ÌÅ¥Î¶¨Ïñ¥Îäî transform ÏòÅÌñ• ÏïàÎ∞õÍ≤å Ìï†ÏàòÎèÑ ÏûàÏßÄÎßå, Ï†ÑÏ≤¥ ÏßÄÏö∞Í≥† Îã§Ïãú Í∑∏Î¶¨ÎäîÍ≤å ÍπîÎÅî

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(GRID_OFFSET_X - 5, GRID_OFFSET_Y - 5, GRID_COLS*TILE_SIZE + 10, GRID_ROWS*TILE_SIZE + 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
            for(let c=0; c<GRID_COLS; c++) {
                for(let r=0; r<GRID_ROWS; r++) {
                    ctx.strokeRect(GRID_OFFSET_X + c*TILE_SIZE, GRID_OFFSET_Y + r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Í≤ΩÎ°ú Í∑∏Î¶¨Í∏∞ (ÌèêÏáÑ Î£®ÌîÑ - ÏßÅÏÇ¨Í∞ÅÌòï)
            if(PATH_POINTS.length > 0) {
                ctx.beginPath(); 
                ctx.strokeStyle = 'rgba(255,255,255,0.2)'; 
                ctx.lineWidth = TILE_SIZE * 0.45; 
                ctx.lineJoin = 'round';
                ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y);
                for(let i=1; i<PATH_POINTS.length; i++) ctx.lineTo(PATH_POINTS[i].x, PATH_POINTS[i].y);
                ctx.closePath(); // ÏãúÏûëÏ†êÍ≥º Ïó∞Í≤∞
                ctx.stroke();
            }

            // Ï†Å Í∑∏Î¶¨Í∏∞
            enemies.forEach(e => {
                let color = '#CFD8DC';
                if(e.type === 'fast') color = '#FFF176';
                if(e.type === 'tank') color = '#8D6E63';
                if(e.type === 'boss') color = '#E91E63';

                if(e.stunTimer > 0) color = '#FFEB3B';
                else if(e.slowTimer > 0) color = '#42A5F5';
                else if(e.dotTimer > 0) color = '#7B1FA2';
                
                let r = TILE_SIZE * 0.22;
                if(e.type === 'boss') r *= 1.5;

                ctx.fillStyle = color;
                ctx.beginPath(); 
                if(e.type === 'fast') { ctx.moveTo(e.x, e.y - r); ctx.lineTo(e.x + r, e.y + r); ctx.lineTo(e.x - r, e.y + r); } 
                else if(e.type === 'tank') { ctx.rect(e.x - r, e.y - r, r*2, r*2); } 
                else if(e.type === 'boss') { drawStar(ctx, e.x, e.y, 5, r, r/2); } 
                else { ctx.arc(e.x, e.y, r, 0, Math.PI*2); }
                ctx.fill();
                ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.stroke();

                let pct = Math.max(0, e.hp / e.maxHp);
                ctx.fillStyle = '#263238'; ctx.fillRect(e.x - r, e.y - r - 8, r*2, 5);
                ctx.fillStyle = pct > 0.5 ? '#76FF03' : '#FF1744'; ctx.fillRect(e.x - r, e.y - r - 8, r*2*pct, 5);
            });

            units.forEach(u => { if(u !== draggingUnit) drawUnit(u, u.x, u.y); });

            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); 
                if(p.shape === 'arrow') ctx.ellipse(p.x, p.y, p.size*1.5, p.size*0.5, Math.atan2(p.target.y - p.y, p.target.x - p.x), 0, Math.PI*2);
                else if(p.shape === 'star') drawStar(ctx, p.x, p.y, 4, p.size, p.size/2);
                else ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); 
                ctx.fill();
            });

            effects.forEach(fx => {
                if(fx.type === 'text') {
                    ctx.globalAlpha = Math.max(0, fx.life / 800);
                    ctx.fillStyle = fx.color;
                    ctx.font = `bold ${TILE_SIZE*0.35}px Jua`;
                    ctx.textAlign = 'center';
                    ctx.lineWidth = 3;
                    ctx.strokeText(fx.text, fx.x, fx.y);
                    ctx.fillText(fx.text, fx.x, fx.y);
                    ctx.globalAlpha = 1.0;
                } else if (fx.type === 'particle') {
                    ctx.globalAlpha = Math.max(0, fx.life / 600);
                    ctx.fillStyle = fx.color;
                    ctx.beginPath();
                    ctx.arc(fx.x, fx.y, fx.size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            });

            if(draggingUnit) {
                if(draggingUnit.type !== 'Ï†ÄÍ≤©Ïàò') {
                    ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    let rangePx = draggingUnit.range * (TILE_SIZE/55);
                    ctx.arc(draggingUnit.dragX, draggingUnit.dragY, rangePx, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                }
                
                let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
                let isHover = dist < TRASH_ZONE.r * 1.5;
                ctx.fillStyle = isHover ? '#D32F2F' : 'rgba(0,0,0,0.6)';
                ctx.beginPath(); ctx.arc(TRASH_ZONE.x, TRASH_ZONE.y, isHover ? TRASH_ZONE.r*1.1 : TRASH_ZONE.r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = `${TILE_SIZE*0.4}px sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText('üóëÔ∏è', TRASH_ZONE.x, TRASH_ZONE.y);
                drawUnit(draggingUnit, draggingUnit.dragX, draggingUnit.dragY);
            }
            
            ctx.restore(); // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìï¥Ï†ú
        }

        function drawUnit(unit, x, y) {
            const cx = x + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const cy = y + (unit === draggingUnit ? 0 : TILE_SIZE/2);
            const size = TILE_SIZE * 0.85;

            let data = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            ctx.fillStyle = data.color;
            ctx.lineWidth = 3;

            if(unit.tier >= 4) {
                let hue = (frameCount * 3) % 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
            } else {
                ctx.strokeStyle = TIER_COLORS[unit.tier];
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            if(unit.tier === 0) ctx.arc(cx, cy, size/2, 0, Math.PI*2);
            else if(unit.tier === 1) ctx.rect(cx - size/2, cy - size/2, size, size);
            else if(unit.tier === 2) drawPolygon(ctx, cx, cy, size/2, 6);
            else if(unit.tier === 3) drawPolygon(ctx, cx, cy, size/2, 4, Math.PI/4);
            else drawStar(ctx, cx, cy, 5, size/2, size/4); 
            ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;

            ctx.fillStyle = 'white'; ctx.font = `${size*0.5}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(data.icon, cx, cy);
            
            ctx.font = `${size*0.25}px sans-serif`;
            ctx.fillStyle = '#fff';
            let typeIcon = data.type === 'phy' ? '‚öîÔ∏è' : (data.type==='mag' ? 'üîÆ' : '‚öóÔ∏è');
            ctx.fillText(typeIcon, cx + size/3, cy + size/3);
        }

        function drawPolygon(ctx, x, y, radius, sides, rotateAngle = 0) {
            if (sides < 3) return; var a = (Math.PI * 2)/sides;
            ctx.moveTo(x + radius*Math.cos(rotateAngle), y + radius*Math.sin(rotateAngle));
            for (var i = 1; i < sides; i++) ctx.lineTo(x + radius*Math.cos(a*i + rotateAngle), y + radius*Math.sin(a*i + rotateAngle)); ctx.closePath();
        }
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI/2*3; let x=cx; let y=cy; let step=Math.PI/spikes;
            ctx.moveTo(cx, cy-outerRadius);
            for(let i=0; i<spikes; i++){ x=cx+Math.cos(rot)*outerRadius; y=cy+Math.sin(rot)*outerRadius; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*innerRadius; y=cy+Math.sin(rot)*innerRadius; ctx.lineTo(x,y); rot+=step; }
            ctx.lineTo(cx, cy-outerRadius); ctx.closePath();
        }

        function upgradeSummon() {
            if(summonLevel >= 20) { showPopup("ÏµúÍ≥† Î†àÎ≤®ÏûÖÎãàÎã§!"); return; }
            let cost = SUMMON_RATES[summonLevel-1].cost;
            if(gold < cost) { showPopup("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; }
            gold -= cost; summonLevel++; showPopup(`ÌñâÏö¥ Í∞ïÌôî Lv.${summonLevel} ÏÑ±Í≥µ!`); updateUI();
            if(document.getElementById('luck-tooltip').style.display === 'block') showLuckInfo();
        }

        function upgradeClass(type) {
            let cost = classLv[type] * 100;
            if(gold < cost) { showPopup("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; }
            gold -= cost; classLv[type]++;
            let name = type==='phy'?'Î¨ºÎ¶¨':(type==='mag'?'ÎßàÎ≤ï':'Î≥¥Ï°∞');
            showPopup(`${name} Í≥ÑÏó¥ Lv.${classLv[type]} Í∞ïÌôî!`);
            updateUI();
        }

        function summonUnit() {
            let cost = getSummonCost();
            if(gold < cost) { showPopup("Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!"); return; }
            let emptySlots = getEmptySlots();
            if(emptySlots.length === 0) { showPopup("ÏûêÎ¶¨Í∞Ä ÍΩâ Ï∞ºÏäµÎãàÎã§!"); return; }
            
            gold -= cost;
            
            let rates = SUMMON_RATES[summonLevel-1];
            let rand = Math.random() * 100;
            let tier = 0;
            
            if(rand < rates.c) tier = 0;
            else if(rand < rates.c + rates.r) { tier = 1; showPopup("Ìù¨Í∑Ä ÏÜåÌôò! üíô"); }
            else if(rand < rates.c + rates.r + rates.e) { tier = 2; showPopup("ÏòÅÏõÖ ÏÜåÌôò! üíú"); }
            else if(rand < rates.c + rates.r + rates.e + rates.l) { tier = 3; showPopup("Ï†ÑÏÑ§ ÏÜåÌôò! üß°"); }
            else { tier = 4; showPopup("‚ö°Ïã†Ìôî ÏÜåÌôò!‚ö°"); addShake(5); } // Ïã†Ìôî ÏÜåÌôòÏãú ÌùîÎì§Î¶º Ï∂îÍ∞Ä

            let slot = emptySlots[Math.floor(Math.random()*emptySlots.length)];
            let type = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
            createUnit(slot.c, slot.r, type, tier);
            
            // ÏÜåÌôò Ïù¥ÌéôÌä∏
            createSparkle(GRID_OFFSET_X + slot.c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + slot.r*TILE_SIZE + TILE_SIZE/2, '#FFFFFF');

            updateUI();
        }

        function createUnit(col, row, type, tier) {
            const x = GRID_OFFSET_X + col * TILE_SIZE;
            const y = GRID_OFFSET_Y + row * TILE_SIZE;
            
            let mult = Math.pow(2.2, tier);
            if(tier >= 4) mult *= 2; 
            if(HIDDEN_DATA[type]) mult *= 3;

            let rng = 160 + (tier * 15);
            if(type === 'Ï†ÄÍ≤©Ïàò') rng = 9999;

            units.push({
                col, row, x, y, type, tier,
                damage: 10 * mult,
                range: rng,
                cooldown: 0
            });
        }

        function gamble() {
            let cost = getGambleCost();
            if(gold < cost) { showPopup("ÎπÑÏö© Î∂ÄÏ°±!"); return; }
            gold -= cost;
            let rand = Math.random();
            if(rand < 0.45) showPopup("ÍΩù... üí∏");
            else if(rand < 0.70) { 
                let gain = 150 + (summonLevel * 5) + (wave * 2); 
                gold += gain; showPopup(`+${gain}G ÎåÄÎ∞ï! üéâ`); 
            }
            else if(rand < 0.95) { 
                let emptySlots = getEmptySlots();
                if(emptySlots.length > 0) {
                    let rates = SUMMON_RATES[summonLevel-1];
                    let r2 = Math.random() * 100;
                    let t = 0;
                    if(r2 < rates.c) t = 0;
                    else if(r2 < rates.c+rates.r) t=1;
                    else if(r2 < rates.c+rates.r+rates.e) t=2;
                    else t=3; 
                    
                    let s = emptySlots[Math.floor(Math.random()*emptySlots.length)];
                    let ty = UNIT_TYPES[Math.floor(Math.random()*UNIT_TYPES.length)];
                    createUnit(s.c, s.r, ty, t);
                    showPopup("Ïú†Îãõ ÌöçÎìù! üé≤");
                } else {
                    gold += cost; 
                    showPopup("ÏûêÎ¶¨ ÏóÜÏùå");
                }
            } else {
                stones += 1; showPopup("üíé Ïã†ÌôîÏÑù ÌöçÎìù! üíé");
                saveGame();
            }
            updateUI();
        }

        function openCombineModal() {
            const list = document.getElementById('recipe-list');
            list.innerHTML = '';
            
            RECIPES.forEach(r => {
                const canUnlock = !r.unlocked && stones >= r.cost;
                const canCombine = r.unlocked && checkIngredients(r.req);
                let info = HIDDEN_DATA[r.result];
                let typeIcon = info.type === 'phy' ? '‚öîÔ∏è' : (info.type==='mag' ? 'üîÆ' : '‚öóÔ∏è');
                
                let btnHtml = !r.unlocked ? 
                    `<button class="btn-buy-recipe" onclick="unlockRecipe('${r.id}')" ${canUnlock?'':'disabled'}>Ìï¥Í∏à (üíé${r.cost})</button>` :
                    `<button class="btn-do-combine" onclick="combineHero('${r.id}')" ${canCombine?'':'disabled'}>${canCombine?'Ï°∞Ìï© Í∞ÄÎä•!':'Ïû¨Î£å Î∂ÄÏ°±'}</button>`;

                let reqHtml = r.req.map(req => {
                    let has = units.some(u => u.type === req.type && u.tier === req.tier);
                    return `<span style="color:${has?'#69F0AE':'#FF5252'}">[Ï†ÑÏÑ§]${req.type}</span>`;
                }).join('+');

                let item = document.createElement('div');
                item.className = 'recipe-card';
                item.innerHTML = `
                    <div class="recipe-name"><span>${typeIcon} ${r.name}</span> <span style="font-size:0.8rem">${info.type.toUpperCase()}</span></div>
                    <div class="recipe-desc">${info.desc}</div>
                    <div class="recipe-req">${reqHtml}</div>
                    ${btnHtml}
                `;
                list.appendChild(item);
            });
            document.getElementById('combine-modal').classList.add('open');
        }

        function closeCombineModal() { document.getElementById('combine-modal').classList.remove('open'); }
        function unlockRecipe(id) {
            let r = RECIPES.find(x => x.id === id);
            if(r && stones >= r.cost) {
                stones -= r.cost; r.unlocked = true;
                showPopup(`${r.name} Ìï¥Í∏à ÏôÑÎ£å!`); 
                saveGame(); 
                updateUI(); openCombineModal();
            }
        }
        function checkIngredients(reqs) {
            let tempUnits = [...units];
            for(let req of reqs) {
                let idx = tempUnits.findIndex(u => u.type === req.type && u.tier === req.tier);
                if(idx === -1) return false;
                tempUnits.splice(idx, 1);
            }
            return true;
        }
        function combineHero(id) {
            let r = RECIPES.find(x => x.id === id);
            if(!r) return;
            let ingredients = [];
            let tempUnits = [...units];
            for(let req of r.req) {
                let u = units.find(unit => unit.type === req.type && unit.tier === req.tier && !ingredients.includes(unit));
                if(u) ingredients.push(u);
                else { showPopup("Ïû¨Î£åÍ∞Ä Î∂ÄÏ°±."); return; }
            }
            units = units.filter(u => !ingredients.includes(u));
            let pos = { c: ingredients[0].col, r: ingredients[0].row };
            createUnit(pos.c, pos.r, r.result, 4); 
            
            // Ï°∞Ìï© Ïù¥ÌéôÌä∏
            createSparkle(GRID_OFFSET_X + pos.c*TILE_SIZE + TILE_SIZE/2, GRID_OFFSET_Y + pos.r*TILE_SIZE + TILE_SIZE/2, '#E040FB');
            addShake(10); // Ï°∞Ìï©Ïãú ÌôîÎ©¥ ÌùîÎì§Î¶º

            showPopup(`‚ú®${r.name} ÏÜåÌôò ÏÑ±Í≥µ!‚ú®`);
            closeCombineModal();
        }

        function startNextWave() {
            wave++;
            isPrep = true; // Ï§ÄÎπÑ Î™®Îìú ÏßÑÏûÖ
            // Ï≤´ Ïõ®Ïù¥Î∏åÎäî 20Ï¥à, ÎÇòÎ®∏ÏßÄÎäî 10Ï¥à ÎåÄÍ∏∞
            waveTimer = (wave === 1) ? 20 : 10;
            
            // Ïõ®Ïù¥Î∏å ÏãúÏûë Î≥¥ÏÉÅ (Ï§ÄÎπÑ Îã®Í≥Ñ ÏãúÏûë Ïãú ÏßÄÍ∏â)
            if(wave > 1) { 
                gold += (50 + wave * 5); 
                if(wave % 10 === 0) { stones++; showPopup(`Wave ${wave} Ï§ÄÎπÑ!<br>üíéÏã†ÌôîÏÑù ÌöçÎìù!`); saveGame(); }
                else showPopup(`Wave ${wave} Ï§ÄÎπÑ!`);
            } else {
                showPopup("Ï†ÑÌà¨ Ï§ÄÎπÑ Îã®Í≥Ñ!");
            }
            updateUI();
        }

        function startBattle() {
            isPrep = false; // Ï†ÑÌà¨ ÏãúÏûë
            waveTimer = WAVE_DURATION; 
            enemiesToSpawn = 12 + Math.floor(wave * 2.5);
            showPopup(`‚öîÔ∏è Wave ${wave} Ï†ÑÌà¨ ÏãúÏûë! ‚öîÔ∏è`);
            
            if(wave % 10 === 0) {
                addShake(15); // Î≥¥Ïä§ Ïõ®Ïù¥Î∏å ÏãúÏûë Ïãú Í∞ïÌïú ÌùîÎì§Î¶º
                spawnFloatingText(canvas.width/2, canvas.height/2, "WARNING: BOSS", "#FF0000");
            }
            updateUI();
        }

        function skipWave() {
            if(isPrep) {
                // Ï§ÄÎπÑ ÏãúÍ∞Ñ Ïä§ÌÇµ (Ï¶âÏãú Ï†ÑÌà¨ ÏãúÏûë)
                let bonus = 0;
                // 1Ïõ®Ïù¥Î∏åÍ∞Ä ÏïÑÎãàÎ©¥ Î≥¥ÎÑàÏä§ ÏßÄÍ∏â
                if(wave > 1 && waveTimer > 0) {
                    bonus = Math.floor(waveTimer) * 5; // Ï§ÄÎπÑ ÏãúÍ∞Ñ Ïä§ÌÇµ Î≥¥ÎÑàÏä§
                    gold += bonus;
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Start! +${bonus}G`, '#4CAF50');
                } else {
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Start!`, '#FFF');
                }
                startBattle();
            } else {
                // Ï†ÑÌà¨ Ïä§ÌÇµ (Í∏∞Ï°¥ Î°úÏßÅ: ÎÇ®ÏùÄ ÏãúÍ∞ÑÎßåÌÅº Î≥¥ÏÉÅÎ∞õÍ≥† Îã§Ïùå Ïõ®Ïù¥Î∏å Ï§ÄÎπÑÎ°ú)
                if(waveTimer > 0) {
                    let bonus = Math.floor(waveTimer) * 2; 
                    gold += bonus;
                    spawnFloatingText(canvas.width/2, canvas.height/2, `Skip! +${bonus}G`, '#FFD700');
                }
                startNextWave();
            }
        }

        function spawnEnemy() {
            let start = PATH_POINTS[0];
            let hp = 120 * Math.pow(1.3, wave-1);
            let spd = 60 + (wave * 2); // ÏÜçÎèÑ Í∞êÏÜå Ï†ÅÏö© (100 -> 60)
            let type = 'normal';
            
            if(wave % 10 === 0) { type = 'boss'; hp *= 10; spd *= 0.7; }
            else if(wave % 5 === 0) { type = 'tank'; hp *= 3; spd *= 0.8; }
            else if(wave % 3 === 0) { type = 'fast'; hp *= 0.7; spd *= 1.5; }

            enemies.push({ x: start.x, y: start.y, pathIndex: 0, hp, maxHp: hp, speed: spd, reachedEnd: false, stunTimer: 0, slowTimer: 0, dotTimer: 0, type: type });
            updateUI();
        }

        function moveEnemy(enemy, deltaTime) {
            if(enemy.stunTimer > 0) return;
            
            let currentPt = PATH_POINTS[enemy.pathIndex];
            let nextIdx = (enemy.pathIndex + 1) % PATH_POINTS.length;
            let target = PATH_POINTS[nextIdx];
            
            let dx = target.x - enemy.x; let dy = target.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            let spd = enemy.speed;
            if(enemy.slowTimer > 0) spd *= 0.6;
            let move = (spd * deltaTime) / 1000;
            
            if(dist < move) { 
                enemy.x = target.x; enemy.y = target.y; 
                enemy.pathIndex = nextIdx; 
            } else { 
                enemy.x += (dx/dist)*move; enemy.y += (dy/dist)*move; 
            }
        }

        function findTarget(unit) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let closest = null; let minD = 9999;
            for(let e of enemies) {
                let d = Math.hypot(e.x - cx, e.y - cy);
                if(d <= rangePx && d < minD) { minD = d; closest = e; }
            }
            return closest;
        }
        function findTargets(unit, count) {
            let rangePx = unit.range * (TILE_SIZE/55);
            let cx = unit.x + TILE_SIZE/2; let cy = unit.y + TILE_SIZE/2;
            let targets = [];
            for(let e of enemies) {
                if(Math.hypot(e.x - cx, e.y - cy) <= rangePx) { targets.push(e); if(targets.length>=count) break; }
            }
            return targets;
        }
        function fireGlobalAttack(unit) {
            addShake(5); // Ï†ÑÏ≤¥ Í≥µÍ≤©Ïãú ÌùîÎì§Î¶º
            enemies.forEach(e => {
                let dmg = unit.damage * (1 + (classLv.mag - 1) * 0.1); 
                e.hp -= dmg;
                projectiles.push({ x: e.x, y: e.y - 20, target: null, damage: 0, speed: 0, hit: true, color: '#D50000', size: 10, timer: 10 });
                // Ïù¥ÌéôÌä∏ Ï∂îÍ∞Ä
                createExplosion(e.x, e.y, '#D50000', 5);
            });
        }
        function fireProjectile(unit, target) {
            let color = '#FFFF00'; let effect = null; let pSize = 5; let shape = 'circle';
            let info = UNIT_DATA[unit.type] || HIDDEN_DATA[unit.type];
            let dmg = unit.damage;

            if(info.type === 'phy') { dmg *= (1 + (classLv.phy - 1) * 0.1); shape = 'arrow'; }
            else if(info.type === 'mag') { dmg *= (1 + (classLv.mag - 1) * 0.1); shape = 'star'; }
            
            if(unit.type === 'ÏïºÎßåÏù∏' && Math.random() < (0.1 + unit.tier*0.02)) { effect='stun'; color='#FFF'; }
            if(unit.type === 'Í∂ÅÏàò' && Math.random() < 0.2) { 
                dmg *= (2.5 + unit.tier * 0.5); color='#F44336'; 
                spawnFloatingText(target.x, target.y - 20, "CRIT!", "#F44336");
            }
            if(unit.type === 'ÏñºÏùåÎ≤ïÏÇ¨' || unit.type === 'ÎåÄÎßàÎ≤ïÏÇ¨') { effect='slow'; color='#29B6F6'; }
            if(unit.type === 'ÏÇ∞Ï†Å' && Math.random() < (0.05 + unit.tier*0.01) * (classLv.sup*0.5)) { 
                gold += 10; updateUI(); 
                spawnFloatingText(unit.x+TILE_SIZE/2, unit.y, "+10G");
            }
            if(unit.type === 'ÎãåÏûê' && target.hp/target.maxHp <= (0.3 + unit.tier*0.05)) { dmg *= 3; color='#D32F2F'; }
            if(unit.type === 'Ïó∞Í∏àÏà†ÏÇ¨' && Math.random() < (0.1 + unit.tier*0.02)) { 
                gold += 50; updateUI(); 
                spawnFloatingText(unit.x+TILE_SIZE/2, unit.y, "+50G", "#00E676");
            }
            if(unit.type === 'ÎìúÎûòÍ≥§' && Math.random() < (0.3 + unit.tier*0.05)) { effect='stun'; color='#FFAB00'; pSize=8; }
            if(unit.type === 'Í∞ïÎ†πÏà†ÏÇ¨') { effect='dot'; color='#7B1FA2'; }
            if(unit.type === 'Î¨¥ÏÇ¨' && Math.random()<0.5) { dmg*=2; color='#E0E0E0'; }
            if(unit.type === 'Î©îÎëêÏÇ¨') { effect='stun'; color='#004D40'; }
            if(unit.type === 'ÎèÑÎ∞ïÏÇ¨') { dmg *= (Math.random()*9 + 1); color='#3F51B5'; }

            if(unit.tier === 5) { pSize += 3; color = '#E040FB'; }
            projectiles.push({ x: unit.x+TILE_SIZE/2, y: unit.y+TILE_SIZE/2, target: target, damage: dmg, speed: 700, hit: false, effect: effect, color: color, size: pSize, shape: shape });
        }

        function moveProjectile(p, deltaTime) {
            if(p.timer) { p.timer--; if(p.timer<=0) p.hit=true; return; }
            if(!p.target || !enemies.includes(p.target)) { p.hit = true; return; }
            let dx = p.target.x - p.x; let dy = p.target.y - p.y;
            let dist = Math.hypot(dx, dy);
            let move = (p.speed * deltaTime) / 1000;
            if(dist < move) {
                p.x = p.target.x; p.y = p.target.y; p.hit = true;
                p.target.hp -= p.damage;
                if(p.effect === 'stun') p.target.stunTimer = 1500;
                if(p.effect === 'slow') p.target.slowTimer = 2000;
                if(p.effect === 'dot') p.target.dotTimer = 3000;
            } else { p.x += (dx/dist)*move; p.y += (dy/dist)*move; }
        }

        function getGridPos(cx, cy) {
            let rect = canvas.getBoundingClientRect();
            let x = cx - rect.left; let y = cy - rect.top;
            if(x > GRID_OFFSET_X && x < GRID_OFFSET_X + GRID_COLS*TILE_SIZE && y > GRID_OFFSET_Y && y < GRID_OFFSET_Y + GRID_ROWS*TILE_SIZE) {
                   return { c: Math.floor((x-GRID_OFFSET_X)/TILE_SIZE), r: Math.floor((y-GRID_OFFSET_Y)/TILE_SIZE) };
            }
            return null;
        }
        function onMouseDown(e) {
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let u = getUnitAt(pos.c, pos.r);
                if(u) {
                    draggingUnit = u;
                    let rect = canvas.getBoundingClientRect();
                    u.dragX = e.clientX - rect.left; u.dragY = e.clientY - rect.top;
                    let info = UNIT_DATA[u.type] || HIDDEN_DATA[u.type];
                    
                    let statText = "";
                    if(u.type==='ÏïºÎßåÏù∏') statText = `Í∏∞Ï†à: ${Math.round((0.1+u.tier*0.02)*100)}%`;
                    else if(u.type==='Í∂ÅÏàò') statText = `ÏπòÎ™ÖÌÉÄ: ${2.5 + u.tier*0.5}Î∞∞`;
                    else if(u.type==='ÎãåÏûê') statText = `Ï≤òÌòï: ${Math.round((0.3+u.tier*0.05)*100)}%Ïù¥Ìïò`;
                    else if(u.type==='ÏÇ∞Ï†Å') statText = `Í∞ïÌÉà: ${Math.round((0.05+u.tier*0.01)*100)}%`;
                    else if(u.type==='ÎìúÎûòÍ≥§') statText = `Ïä§ÌÑ¥: ${Math.round((0.3+u.tier*0.05)*100)}%`;
                    
                    showTooltip(`<span style="color:${info.color}; font-size:1.1em; font-weight:bold;">${u.type}</span> <span style="color:${TIER_COLORS[u.tier]}">[${TIERS[u.tier]}]</span><br>${info.desc}<br><span style="color:#FFEB3B">${statText}</span>`);
                }
            }
        }
        function onMouseMove(e) { if(draggingUnit) { let rect = canvas.getBoundingClientRect(); draggingUnit.dragX = e.clientX - rect.left; draggingUnit.dragY = e.clientY - rect.top; } }
        function onMouseUp(e) {
            hideTooltip();
            if(!draggingUnit) return;
            let dist = Math.hypot(draggingUnit.dragX - TRASH_ZONE.x, draggingUnit.dragY - TRASH_ZONE.y);
            if(dist < TRASH_ZONE.r * 1.5) { units = units.filter(u => u !== draggingUnit); gold += Math.floor(getSummonCost()/2); showPopup("ÌåêÎß§ ÏôÑÎ£å"); updateUI(); draggingUnit = null; return; }
            let pos = getGridPos(e.clientX, e.clientY);
            if(pos) {
                let target = getUnitAt(pos.c, pos.r);
                if(target && target !== draggingUnit) {
                    if(target.type === draggingUnit.type && target.tier === draggingUnit.tier) {
                        if(target.tier < 5) { 
                            processMerge(draggingUnit, target);
                        } else { showPopup("ÏµúÍ≥† Îì±Í∏âÏûÖÎãàÎã§!"); returnUnit(); }
                    } else { let tmpC = draggingUnit.col; let tmpR = draggingUnit.row; draggingUnit.col = target.col; draggingUnit.row = target.row; target.col = tmpC; target.row = tmpR; updateUnitPos(draggingUnit); updateUnitPos(target); }
                } else { draggingUnit.col = pos.c; draggingUnit.row = pos.r; updateUnitPos(draggingUnit); }
            } else returnUnit();
            draggingUnit = null;
        }

        function getUnitAt(c, r) { return units.find(u => u.col === c && u.row === r); }
        function getEmptySlots() { let slots = []; for(let c=0; c<GRID_COLS; c++) for(let r=0; r<GRID_ROWS; r++) if(!getUnitAt(c,r)) slots.push({c,r}); return slots; }
        function updateUnitPos(u) { u.x = GRID_OFFSET_X + u.col*TILE_SIZE; u.y = GRID_OFFSET_Y + u.row*TILE_SIZE; }
        function returnUnit() { updateUnitPos(draggingUnit); }
        
        function resetGame() {
            gold = 200; wave = 0; units = []; enemies = []; projectiles = []; summonLevel = 1; stones = stones; 
            classLv = { phy: 1, mag: 1, sup: 1 };
            waveTimer = 0;
            
            startNextWave();
            updateUI();
        }

        function updateUI() {
            document.getElementById('gold-display').innerText = gold;
            document.getElementById('stone-display').innerText = stones;
            document.getElementById('wave-display').innerText = wave;
            
            let ec = document.getElementById('enemy-count');
            ec.innerText = enemies.length;
            if(enemies.length > MAX_ENEMIES_LIMIT * 0.8) ec.style.color = '#FF1744';
            else ec.style.color = '#fff';

            document.getElementById('summon-level').innerText = summonLevel;
            
            let rate = SUMMON_RATES[summonLevel-1];
            document.getElementById('upgrade-cost').innerText = rate.cost;

            document.getElementById('summon-cost-display').innerText = getSummonCost() + " G";
            document.getElementById('gamble-cost-display').innerText = getGambleCost() + "G";

            document.getElementById('lv-phy').innerText = classLv.phy;
            document.getElementById('cost-phy').innerText = (classLv.phy * 100) + 'G';
            document.getElementById('lv-mag').innerText = classLv.mag;
            document.getElementById('cost-mag').innerText = (classLv.mag * 100) + 'G';
            document.getElementById('lv-sup').innerText = classLv.sup;
            document.getElementById('cost-sup').innerText = (classLv.sup * 100) + 'G';

            let tBox = document.getElementById('timer-box');
            let tIcon = document.getElementById('timer-icon');
            let skipBtn = document.getElementById('btn-skip');
            let skipTxt = document.getElementById('skip-text');
            let skipRewardBox = document.getElementById('skip-reward-box');
            let skipReward = document.getElementById('skip-reward');
            
            document.getElementById('wave-timer').innerText = Math.ceil(waveTimer);

            // Ìï≠ÏÉÅ 'Ïä§ÌÇµ'ÏúºÎ°ú ÌëúÏãú
            skipTxt.innerText = "‚è© Ïä§ÌÇµ";

            if (isPrep) {
                // Ï§ÄÎπÑ ÏÉÅÌÉú UI
                tBox.classList.remove('urgent');
                tBox.classList.add('prep');
                tIcon.innerText = "‚è≥";
                skipBtn.classList.add('prep-mode');
                
                // Î≥¥ÏÉÅ Î∞ïÏä§ ÌëúÏãú
                skipRewardBox.style.display = "inline";
                
                if (wave === 1) {
                    skipReward.innerText = "0"; // 1Ïõ®Ïù¥Î∏å Î≥¥ÏÉÅ 0
                } else {
                    skipReward.innerText = Math.floor(waveTimer) * 5;
                }
            } else {
                // Ï†ÑÌà¨ ÏÉÅÌÉú UI
                tBox.classList.remove('prep');
                if(waveTimer < 10) tBox.classList.add('urgent');
                else tBox.classList.remove('urgent');
                tIcon.innerText = "üî•";
                
                skipBtn.classList.remove('prep-mode');
                skipRewardBox.style.display = "inline";
                skipReward.innerText = Math.floor(waveTimer) * 2;
            }
        }

        // Î©îÏãúÏßÄÍ∞Ä ÏåìÏù¥ÎèÑÎ°ù ÏàòÏ†ïÎêú Ìï®Ïàò
        function showPopup(txt) { 
            const area = document.getElementById('message-area');
            const el = document.createElement('div');
            el.className = 'pop-text';
            el.innerHTML = txt;
            area.appendChild(el); 
            // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¢ÖÎ£å ÌõÑ Ï†úÍ±∞ (ÏïΩ 1.5Ï¥à)
            setTimeout(() => {
                if(el.parentElement) el.parentElement.removeChild(el);
            }, 1500);
        }

        function showLuckInfo() {
            let cur = SUMMON_RATES[summonLevel-1];
            let next = (summonLevel < 20) ? SUMMON_RATES[summonLevel] : cur;
            let el = document.getElementById('luck-tooltip');
            let mText = cur.m > 0 ? `<div class="c-myth">Ïã†Ìôî: ${cur.m}%</div>` : '';
            let nextM = next.m > 0 ? `<div class="c-myth">Ïã†Ìôî: ${next.m}%</div>` : '';

            el.innerHTML = `
                <div style="margin-bottom:5px; font-weight:bold; color:#FFD700;">ÌòÑÏû¨ (Lv.${summonLevel})</div>
                <div class="c-rare">Ìù¨Í∑Ä: ${cur.r}%</div>
                <div class="c-hero">ÏòÅÏõÖ: ${cur.e}%</div>
                <div class="c-legend">Ï†ÑÏÑ§: ${cur.l}%</div>
                ${mText}
                <hr style="border-color:#555; margin:5px 0;">
                <div style="margin-bottom:5px; font-weight:bold; color:#AAA;">Îã§Ïùå (Lv.${summonLevel < 20 ? summonLevel+1 : 'MAX'})</div>
                <div class="c-rare">Ìù¨Í∑Ä: ${next.r}%</div>
                <div class="c-hero">ÏòÅÏõÖ: ${next.e}%</div>
                <div class="c-legend">Ï†ÑÏÑ§: ${next.l}%</div>
                ${nextM}
            `;
            el.style.display = 'block';
        }
        function hideLuckInfo() { document.getElementById('luck-tooltip').style.display = 'none'; }
        
        function showTooltip(txt) { let el = document.getElementById('unit-tooltip'); el.innerHTML = txt; el.style.display = 'block'; }
        function hideTooltip() { document.getElementById('unit-tooltip').style.display = 'none'; }

        init();
    </script>
</body>
</html>
